The SourceLight definition language uses a bracket syntax to prototype
what's expected in source code.  All keywords are enclosed in brackets
directly.  Anything that's a variable is enclosed in brackets, but is
prefixed with an @ for the member name, and then (algorithm) indicating
which algorithm is used to extract and store the name.

----------
	Example:
		#define xyz 123
	-----
	In order to process this, it would be setup like this:
		if ([#]["define"])
		{
			remove whitespaces;
			if ([alpha] or [alphanumeric])
			{
				if ([{{])
				{
					define_double_bracket();

				} else {
					define();
				}

			} else {
				error;
			}
		}
----------

In this example, the SourceLight compiler would see [#define] as the
"#define" keyword, which, because of the symbols in use, is recognized
as being processed in two steps from source code, to fundamental symbols,
into a combined keyword, which is [#][define] translated later into a
single [#define] keyword.

After that it sees the next component must be alphanumeric



[(]--[p]--[p]--[p]--[)]
      |    |    |

x = ((a + b) * 3)

	[=]
   /   \
 [x]   [t2]
         |
        [*]
       /   \
    [t1]   [3]
      |
     [+]
    /   \
  [a]   [b]