//////////
//
// /libsf/source/vjr/source/compiler/rdc/rdc_specs.txt
//
//////
// Version 0.54
// Copyright (c) 2014 by Rick C. Hodgin
//////
// Last update:
//     Nov.02.2014
//////
// Change log:
//     Jan.09.2015 - Added function purposes
//     Nov.02.2014 - Initial creation
//////
//
// This document is released as Liberty Software under a Repeat License, as governed
// by the Public Benefit License v1.0 or later (PBL).
//
// The PBL is a public domain license with a caveat:  self accountability unto God.
// You are free to use, copy, modify and share this software for any purpose, however,
// it is the desire of those working on this project that the software remain open.
// It is our request that you maintain it that way.  This is not a legal request unto
// our court systems, but rather a personal matter between you and God.  Our talents
// were received from God, and given to you through this forum.  And it is our wish
// that those talents reach out to as many as possible in a form allowing them to wield
// this content for their own betterment, as you are now considering doing.  And whereas
// we could've forced the issue through something like a copyleft-protected release, the
// truth is we are all giving an account of our lives unto God continually by the daily
// choices we make.  And here again is another case where you get to demonstrate your
// character unto God, and unto your fellow man.
//
// Jesus came to this Earth to set the captives free, to save men's eternal souls from
// the punishment demanded by our sin.  Each one of us is given the opportunity to
// receive Him in this world and be saved.  Whether we choose to receive Him, and follow
// Him, and purpose our lives on the goals He has for each of us (all of which are
// beneficial for all involved), is one way we reveal our character continually.  God
// sees straight through to the heart, bypassing all of the words, all of the facades.
// He is our Creator, and He knows who we are truly.
//
// Jesus is called "Christ" because He saves men from the eternal flames of Hell, the
// just punishment of rebellion against God (rebellion against truth) by eternal beings,
// which each of us are.
//
// Do not let His free gift escape you because of some desire to shortcut what is right
// in your life. Instead, do what is right, and do it because He is who He is, and what
// He has done to save us from such a fate.  Demonstrate to Him, to me, and to all of
// mankind, and to all of the Heavenly hosts, exactly who you are on the inside.  Receive
// Jesus Christ into your heart, learn of Him, of how He came here to guide us into that
// which is of His Kingdom and will be forever hereafter we leave this world.  Do this,
// and live.
//
// Every project released by Liberty Software Foundation will include a copy of the
// pbl.txt document, which can be found at http://www.libsf.org/licenses/.
//
// For additional information about this project, or to view the license, see:
//
//     http://www.libsf.org/
//     http://www.libsf.org/licenses/
//     http://www.visual-freepro.org/vjr/indexmain.html
//     http://www.visual-freepro.org/wiki/index.php/PBL
//
// Thank you.  And may The Lord bless you richly as you lift up your life, your
// talents, your gifts, your praise, unto Him.  In Jesus' name I pray.  Amen.
//
//




Nov.03.2014 -- Early draft.  Incomplete.  Inconsistent.

RDC Specifications Document
---------------------------

1.0 - Reserved Keywords
-----------------------

	void		-- An unspecified type
	bool		-- 8-bit boolean quantity which explicitly tests 0 for false, all others true
	char		-- 8-bit signed quantity
	short		-- 16-bit signed quantity
	int			-- 32-bit signed quantity
	long		-- 64-bit signed quantity
	float		-- 32-bit floating point
	double		-- 64-bit floating point

	const,ro	-- Augments a type to indicate it is read-only
	rw			-- Augments a type to explicitly indicate it is read-write
	volatile	-- Augments a type to indicate it is to be coded as conveyed
	hide		-- Augments a type to indicate it should not be visible in SourceLight (typically used for unused / reserved members)
	unsigned	-- Augments char, short, int, long to make it unsigned
	static		-- Augments a definition to make it a singleton
	extern		-- Augments a type to indicate its body is populated elsewhere
	sizeof		-- Returns the size of a type
	offsetof	-- Returns the offset of a type

	s8,u8		-- Signed and unsigned 8-bit quantities
	s16,u16		-- Signed and unsigned 16-bit quantities
	s32,u32		-- Signed and unsigned 32-bit quantities
	s64,u64		-- Signed and unsigned 64-bit quantities
	f32,f64		-- 32-bit and 64-bit floating points

	bi			-- Arbitrary precision big integer, defaults to 128 bits
	bfp			-- Arbitrary precision floating point, defaults to 256 bits
	datum		-- An explicitly allocated piece of data with a pointer and length
	date		-- A date with year, month, day
	datetime	-- A datetime with year, month, day, hour, minute, second, millisecond
	thread		-- A thread variable

	NULL		-- A constant pointer to 0
	null		-- A constant integer value of 0
	true		-- Sets a bool to 0xff
	false		-- Sets a bool to 0x00

	and			-- A verbose form of &&
	or			-- A verbose form of ||
	not			-- A verbose form of !

	#define		-- Pragma definition of a token or macro
	#undefine	-- Pragma un-definition of a token
	#if			-- Pragma logic test for conditionally compiled code
	#ifdef		-- Pragma logic test for the existence of a token
	#ifndef		-- Pragma logic test for the non-existence of a token
	#else		-- Pragma logic test for conditionally compiled code
	#elseif		-- Pragma logic test for conditionally compiled code
	#endif		-- Pragma termination of a conditional test block
	#align		-- An alignment directive
	#push		-- Pushes a token value onto the stack
	#pop		-- Pops a token value from the stack
	typedef		-- Typedefs one type to another name

	struct		-- A structure definition
	class		-- A class definition
	operator	-- An operator override definition
	extends		-- A class extends another class (can extend multiple simultaneously)
	parent		-- A reference to the immediate parent in an inheritance chain
	child		-- A reference to the immediate child in an inheritance chain
	union		-- A merging of two or more types
	enum		-- An enumeration of items
	new			-- Creates an instance of a class
	delete		-- Deltes an instance of a class

	adhoc		-- Declares an adhoc
	function	-- Declares a function
	purpose		-- Declares a purpose within a function
	params		-- Declares input parameters
	returns		-- Declares return values
	inline		-- Provides an optimization hint
	optimize	-- Provides an optimization level hint (0=none)
	nodebug		-- Declares that a function should not be entered on single-step debugging
	breakpoint	-- Code will trap to the debugger if connected and engaged, ignored otherwise

	do			-- Loop which always enters once, requires trailing while test
	while		-- Conditionally tests loop logic and continues in the loop if true
	until		-- Conditionally tests loop logic and continues in the loop if false
	iterate		-- Repeat a task a specified number of times
	for			-- A for loop
	unless		-- A conditional test on false
	roll		-- Executes as many of the conditionals as possible (until one evaluates to false)
	if			-- A conditional test on true
	else		-- An else clause on an if or unless
	elseif		-- An elseif clause on an
	lif			-- A line conditional test on true which
	lelseif		-- A line elseif clause on an if or unless
	fif			-- A full conditional test on true which executes one line, no braces
	felseif		-- A full elseif clause on an if or unless
	switch		-- A switch statement
	case		-- A member test of a switch statement
	mefa,meta	-- Called on logic test results, mefa=false, meta=true
	quit		-- Quits the application explicitly (calls OS's endProcess() function)

	in			-- Create a new thread
	andin		-- Create an additional new thread
	out			-- Leave a thread
	join		-- Joins the current thread to one or more other threads before continuing
	timeout		-- Called for each join-attempted thread that did not out before timeout
	success		-- Called if threads join successfully before the timeout

	engage		-- Launches another process
	unengage	-- Explicitly ends a running process launched with engage

	default		-- In a switch statement, specifies the unspecified operation
	break		-- Breaks the current loop
	breakto		-- Breaks to the indicated level
	continue	-- Continues to the current level
	continueto	-- Continues to the indicated level
	exit		-- A pseudonym for break
	exitto		-- A pseudonym for breakto
	loop		-- A pseudonym for continue
	loopto		-- A pseudonym for continueto
	goto		-- Goes to the indicated label or named block
	return		-- Returns from a called function and optionally explicitly returns
				   one or more of the following:  a value or values, a meia, and mema.

	flow		-- A structured flow control block
	flowout		-- Exit a structured flow control block 
	flowoutto	-- Exit a structured flow control block to an indicated level
	flowto		-- Flow to a member of a structured flow control block
	subflow		-- Defines a subflow member of a strutured flow control block
	meia		-- Called on an inquiry
	mema		-- Called on receipt of a particular message

	flowof		-- Defines a function to be a flow of another function
	super		-- Executes commands from the parent's point of view (as in "super return;")

2.0 - Program Engagement
------------------------

	RDC defines engage and unengage as the start and ending concepts for running a program.
	In order to run, startup code is called to engage the application.  When flow brings the
	program to a close, it is goes through unengaging steps until it is fully unengaged.

	main() is the top level user-function for creating a console-based application.
	main() is defined as int main(int argc, char* argv[]);.

	dllmain() is the top level user-function for creating a DLL.
	dllmain() is defined as bool dllmain(u32 instance, u32 callType);

	guimain() is the top level user-function for creating a gui-based application.
	guimain() is defined in various forms depending on the operating system in use, and is
	analgous to WinMain() on Windows.

	For backward compatibility other definitions of dllmain() may also exist.

	At startup, an application compiled with RDC will go through these stages:
		(1) Engaging steps of self-initialization, global/static memory to default values.
		(2) Link to all required DLLs.
		(3) Call dllmain() in sequence for each loaded DLL.
		(3) Call main(), dllmain(), or guimain() for user app.

	Upon closing, an application compiled with RDC will go through these stages:
		(1) Unengaging steps of releasing OS handles and allocated memory blocks.
		(2) Saving any machine-state information (depending on what platform the
			RDC-compiled code was running on).
		(3) Signal its unengage() to the OS, which ends the program.


2.1 - Function and Adhoc Definitions
------------------------------------

	RDC provides for functions, adhocs, and flowof functions (which are a special type of
	function designed to abstract logic from a parent function).  In addition, RDC allows
	for multiple return parameters.
	
	The general C/C++ syntax form is allowable.  RDC adds an additional syntax form
	allowance:
	
		function nameOfFunction
		| returns int x, int y, int z;
		| params int a, int b, int c;
		{
			// Code goes here
			
			// Instead of issuing return(1,2,3), you can use:
			x = 1;
			y = 2;
			z = 3;
			
			// An implicit return here will not result in an error
		}
	
	Adhocs are special functions which can be declared near to some location which needs
	to have its logic extracted.  They reference the local variable environment of where
	they are defined, and also prvide for their own discreet additions.  As with flow {...}
	blocks, issuing super return; will exit out of the parent function, and not out of
	itself.  The general C/C++ syntax form is allowable here as well.  RDC adds an
	additional syntax form allowance:
	
		function nameOfFunction
		| returns int x;
		| params int a, int b, int c;
		{
			// Some code can go here
		
			// Normal flow does not enter an adhoc
			adhoc myAdhoc
			| returns int x;	// x here hides nameofFunction's x return parameter
			| params int a;		// a here hides nameOfFunction's a parameter
			{
				int b, c;		// b here hides nameOfFunction's b parameter
								// c remains accessible
				
				b = (super.b + a + super.a) * c;
				x = b * b;
			}
			
			// An implicit return here will not result in an error
			x = myAdhoc(a + b + c);
		}

2.2 - Flow Control
------------------

	RDC provides standard flow control mechanisms:
	
		do {
				// Code always enters this loop at least once
			} while (condition};	// Repeats while true
			
		do {
				// Code here
			} until (condition);	// Repeats while false
			
		while (condition) {
				// Code only enters the loop if condition is initially true
			}
			
		until (condition) {
				// Code only enters the loop if condition is initially false
			}
			
		int n = 10;
		iterate (n) {
				// Repeats the indicated number of times
			}
			
		for (init; condition; incrementer) {
				// Repeats until condition is false
			}
			
		// If and unless can operate together
		if (condition) {
				// Flows here if condition is true
			} else if (condition2) {
				// Flows here if condition2 is true
			} elseif (condition3) {
				// Flows here if condition3 is true
			} else unless (condition4) {
				// Flows here if  condition4 is false
			} else {
				// If condition and condition2 were false, flows here
			}
			
		unless (condition) {
				// Flows here if condition is false
			} else unless (condition2) {
				// Flows here if condition2 is false
			} else if (condition3) {
				// Flows here if condition3 is true
			} elseif (condition4) {
				// Flows here if condition4 is true
			} else  {
				// Flows here otherwise
			}
			
			// A line-if, does not require braces, executes each item on line
				lif (condition)			command1; command2; command3;
			lelseif (condition2)		command4; command5;
			lelse						command6; command7; command8;
			
		switch (variable) {
				case constant_test:
					break;
				case constant_test2:
					break;
				case constant..range:
					break;
				default:
					// If nothing above matched, flows here
					break;
			}
			
		// A switch form based on logic tests
		switch {
				case condition:		// Perform a non-constant test
					break;
				case condition2:	// Perform a logic test
					break;
				default:
					break;
			}
	
3.0 - Assignment Operations
---------------------------

	All values descending in size are sign-saturated to the lesser size.
	All values ascending in size are sign-extended to the greater size.
	All global variables are initialized to their explicit value, or 0s, before main() is called.
	All signed and unsigned values becoming a float or double will convert as closely as possible.
	All float or double values becoming a signed or unsigned value will round.
	All assignments will be done with = or :=.

4.0 - Comparison Operations
---------------------------

	All signed compares of equal size will be compared as signed values.
	All unsigned compares of equal size will be compared as unsigned values.

	All signed/unsigned compares will be compared thusly:
		(1) Signed is bigger, unsigned is upsized to signed's size, and compared.
		(2) Unsigned is bigger, unsigned and signed are both upsized to unsigned's
		    larger, and compared.

	All float and signed or unsigned compares will be converted to float and compared.
	All double and signed or unsigned compares will be converted to double and compared.
	All non-bool values used for logic tests will be explicitly compared to 0 for false.

	Comparison operators:
		(1) ==, tests for equal
		(2) >=, tests for greater than or equal to
		(3) <=, tests for less than or equal to
		(4) >, tests for greater than
		(5) <, tests for less than
		(6) !=, tests for not equal
		(7) !>=, tests for not greater than or equal to
		(8) !<=, tests for not less than or equal to
		(9) !>, tests for not greater than
		(10) !<, tests for not less than
		(11) $, found in (comparing one datum to another)
		(12) !$, not found in (comparing one datum to another)

5.0 - Thread Operations
-----------------------

	RDC will use OS services to create threads using the in {...} andin {...} syntax.
	Example:

		s64 lnMilliseconds;
		s32 sum1, sum2, sum3;
		thread t1, t2, t3;


		//////////
		// Launch three threads running sumPiDigits()
		//////
			in t1 {
				sum1 = sumPiDigits();

			} andin t2 {
				sum2 = sumPiDigits();

			} andin t3 {
				sum3 = sumPiDigits();

			} meia(thread* t) {
				// Called on inquiry if t1, t2, or t3 are already engaged
			}
			printf("Threads launched:\nT1: %u\nT2: %u\nT3: %u\n", t1.id, t2.id, t3.id);


		//////////
		// Create two adhoc functions for our join results
		//////
			adhoc myTimeout
			| params thread* t, void* data;
			{
				allThreadsCompleted = true;
				printf("Thread %u timed out!\n", t->id);
			}

			adhoc allGood
			| params void;
			{
				printf("All threads completed okay.\n")
			}


		//////////
		// Join with those threads before continuing
		//////
			lnMilliseconds = join(t1, t2, t3)::success(allGood)::timeout(10, myTimeout, NULL);


	Each thread will execute the code within, which can call other functions, etc.
	Thread unengage will automatically signal when its closing brace is reached.
	To explicitly exit a thread at any point, use the [out] keyword.

6.0 - Unions and Anonymous Unions
---------------------------------

	Unions and anonymous unions can be declared at any point a variable is declared in RDC.
	This includes function parameter declarations.  The keyword union is not required.

		function printEncoding
		| returns u32 r1;
		| params union {u32 iValue, f32 fValue}, bool* equal;
		{
			printf("The value %f in hex %x\n", fValue, iValue);
			*equal = ((int)fValue == iValue);
			return(iValue);
		}

		// The above would be the same as without the union keyword:

		function printEncoding
		| returns u32 r1;
		| params {u32 iValue, f32 fValue}, bool* equal;
		{
			printf("The value %f in hex %x\n", fValue, iValue);
			*equal = ((int)fValue == iValue);
			r1 = iValue;
		}

7.0 - Multiple Return Parameters
--------------------------------

	Functions can return multiple parameters.  As with input parameters being
	comma-delimited, so are return parameters.

		int r1, r2;

		r1, r2 = myFunction(int a, int b);

		function myFunction
		| returns int r1, int r2;
		| params int a, int b;
		{
			// Code for the function goes here
		}

8.0 - Flow Blocks
-----------------

	Flow blocks allow program logic to be removed from its deeply nested location, and
	moved to a documented location, allowing the mechanics of the underlying logic to be
	hidden from the overall big-picture view of the algorithm.  This is useful in
	maintenance and debugging.

	Flow blocks also allow for structured programming to exist in logic cases where
	spaghetti code would otherwise only be possible without complexity in navigating
	through the various levels.

		flow name
		| int ret1;
		{
			// Code for the normal operation goes here
			flowto sampleCallAndExit;
			ret1 = sampleCallAndReturnValue(1,2);

			// To explicitly flow out of the flow block at any time:
			flowout;


		} always before {
			// Code to execute always before the flow


		} always after {
			// Code to execute always after the flow


		} subflow sampleCallAndReturnValue
			| returns int r;
			| params int a, int b;
			{
				// Code for the subflow goes here
				// Control will automatically return when it reaches the closing brace
				// To explicitly return:
				return;

				// To explicitly return completely out of the flow block:
				super return;

				// To explicitly flow out of the flow block:
				flowout;


		} subflow sampleCallAndExit {
			// Code for the subflow goes here
			// Control will automatically exit when it reaches the closing brace


		} meia name {
			// Code for meia goes here (inquiry, a type of exception)


		} mema name {
			// Code for mema goes here
		}

9.0 - Flowof Functions
----------------------

	Flowof functions are functions which take code from another function and move it
	into a new location, but one which completely inherits the parameter, local, and
	variable environment of its parent.

	Like flow blocks, flowof functions are designed to remove complex logic from an
	otherwise nested flow, and place it in a manageable location leaving only a useful
	name "stub" at its previous location, yet without changing the environment of its
	symbols and defined parameters and variables.

		function xyz
		| returns int r1, int r2;
		| params int x, int y;
		{
			int a, b;

			abc();
			def();

			printf("a=%d, b=%d\n", a, b);
			// Implicit return, but abc() have already set r1, r2
		}

		function abc flowof xyz
		{
			// Declare our own local variables
			int a, j;	// a's definition here hides a above

			// Able to access the variables from xyz
			a       = 5 * x;  // Local assignment
			super.a = a;      // Parent's a is still accessible as super.a

            j       = a * 4;
			b       = 9 * y;
			r1      = 3 * j;
			r2      = 14 * j;
		}

		function def flowof xyz
		{
			int t;		// Declare our own local variables

			t = a;		// Store a to t temporarily
			a = b;		// Set a to b from above
			b = t;		// Set b to t
		}

10.0 - Casks
------------

	Casks allow injection of code at locations which are otherwise syntactically correct.
	Casks can also define things, and act conditionally based upon logic tests.  In their
	text-based form they are somewhat difficult to wield.  When presented within an RDC
	graphical editor, however they become a graphical construct conveying additional
	meaning and isolation unto to the eye.

		(|reference|)			-- Refers to something which already exists
		[|definition|]			-- Defines a new thing
		<|logic|>				-- Acts based on a logic test
		~|utility|~				-- Injects arbitary code

	Casks can also have return and input parameters.

		(||return|cask|)		-- An example of where return parameters go
		(|cask|input||)			-- An example of where input parameters go
		(||return|cask|input||)	-- An example with both return and input parameters

	Definition casks define their thing in cask form:

		[||int r1, int r2|function xyz|int a, int b||]
		{
			// Code goes here
		}

		same as:
		function xzy
		| returns int r1, int r2;
		| params int a, int b;
		{
			// Code goes here
		}

	Logic test casks perform tests for logic flow and engagement:
		<||test|if true|if false||>		&& Equivalent to ((test) ? if true : if false);

	Utility casks allow arbitary code injection:
		~|code goes here|~

	Executing multiple bits of code:
		~|code goes here; more code; more code;|~

	Executing intermixed code and called functions:
		~|code here; someFunction(); more code; etc...|~

11.0 - The Class
----------------

	RDC defines the class with multiple-inheritance, constructors, destructors,
	operator overrides, and member overloading.  All members are public, and the
	keywords new and delete are used to create a class instance, and delete the
	same.

		class name extends class1, class2, class3, ... classN
		{
		}

	Parent or inherited class member functions which are overridden by child members
	can be referenced from within member class functions using the syntax:

		class1->member();		// Accesses explicitly named member function
		super->member();		// Accesses immediate parent member function

	The order in the above example will be name, class1, class2, class3, ... classN.

12.0 - Function Overloading and Name Attributifying
---------------------------------------------------

	RDC allows for function overloading and wil not use mangled names, but instead will
	attach attributes of the function form to the name as a postfix adjustment to the
	normal function or adhoc name.

	The format will be the types in order from left-most return to right-most parameter,
	with pointers appending the suffix p and pointer-to-pointers appending the suffix pp:

		function name
		| returns int r1, float r2
		| params char p1, int* p2, double** p3
		{
			// Code goes here
		}

	The attributified name would be name__int_float_char_intp_doublepp().  If custom
	structs or classes are referenced, they are included by name as well.  If a typedef
	is in effect, the typdef name is included as is.

		function name
		| returns CAbc* abc
		| params SMyStruct* ms, SBgra bgra
		{
			// Code goes here
		}

	The attributified name would be name__cabsp_smystructp_sbgra().  In this way,
	external applications can link directly to the function knowing exactly the input
	types, and there is never any ambiguity as to the expected input parameters.

13.0 - LiveCode ABI
-------------------

	RDC employs a new ABI that's designed around two central concepts:
	
		(1)  Every compilation is for a target machine architecture, not an OS flavor.
		(2)  Every compilation is targeted for LiveCode support.
	
	The code generated operates on a particular instruction set.  To provide OS
	facilities, a thin OS-specific wrapper is required to launch the ABI.  This
	will allow direct hookup to any required facilities, provide translation between
	RDC requirements and those services natively available on the OS.  However, a
	single generated output file can be run on any machine that is for the targeted
	architecture, and has a wrapper to support it.

14.0 - Function Purpose
-----------------------

	RDC employs groupings within a single function which allow for self-documenting
	code and multi-targeted operations all under the same "function umbrella."
	This exists outside of the general class structure and is designed to further
	align source code with its true purpose per context.  Each one is called a
	"purpose".
	
	Functions can have multiple entry points based on their purposes.  Each purpose
	is a self-contained entity that acts as a separate function being referenced in
	source code using "name().help();" syntax, as in the example below.  The normal
	function content is accessed using "name();" or "name().main();".
	
		function name
		| returns CAbc* abc
		| params SMyStruct* ms, SBgra bgra
		{
			// Explicitly named purpose accessed in source code as "name().help();"
			purpose help {
				// Code for this purpose goes here
			}
			
			// Normal code is the default purpose when not named, or the "main" purpose.
		}
	
	Each purpose can override function parameter blocks using its own parameter block.
	
		function name
		| returns CAbc* abc
		| params SMyStruct* ms, SBgra bgra
		{
			// Explicitly named purpose with its own parameter block
			purpose help
			| returns s8* helpText
			| params void
			{
				// Code for this purpose goes here
			}
			
			// Normal code is the default purpose when not named, or the "main" purpose.
		}
	
	To access this function, you would use "labc = name(lms, color);" for the main purpose,
	and for the help purpose it could be accessed as "printf("%s\n", name().help());".
	
	The purpose of the "purpose" ability in functions is to allow a single function to more
	fully encapsulate the various qualities that would typically be required for related
	functionality within a class as separate and discrete entities within its implementation
	in a system.  Purposes can be created for different variable types, for example, or to
	include self-documenting code, test suites, and more.  And if the function itself must
	not contain a main() body, but instead must explicitly require named purposes throughout,
	it can use the "purpose" keyword in its parameter block to indicate that it is a purpose-
	only function.
	
	For example:

		function convert
		| purpose	// Only purposes are allowed below
		{
			//////////
			// Explicitly named int-to-char purpose
			//////
				purpose toChar
				| returns s8* output
				| params int input
				{
					// Code to convert the integer input to a string here
				}
			
			
			//////////
			// Explicitly named char-to-int purpose
			//////
				purpose toInt
				| returns int output
				| params s8* input
				{
					// Code to convert the string to integer goes here
				}

			// Normal code is not allowed here because it was declared above "| purpose"
			// in the "function convert" parameter block.
		}
	
	To use these functions it would be:
	
		lcNumber = convert().toChar(20);
		lnValue  = convert().toInt("123");
	
	Were these to be added to a class or struct, then it would have the following syntax:
	
		CSample sample = new CSample();

		lcNumber = sample.convert().toChar(20);
		lnValue  = sample.convert().toInt("123");
		
		
--------------
New:

Nov.24.2014
Prefix/postfix combination operators for modulo, and, or, xor.
The same for ++ and --:

		++%i.4;    //        i = ((i + 1) % 4); use i
		i++%.4;    // t = i; i = ((i + 1) % 4); use t

		++&i.4;    //        i = ((i + 1) & 4); use i
		i++&.4;    // t = i; i = ((i + 1) & 4); use t

		++|i.4;    //        i = ((i + 1) | 4); use i
		i++|.4;    // t = i; i = ((i + 1) | 4); use t

		++^i.4;    //        i = ((i + 1) ^ 4); use i
		i++^.4;    // t = i; i = ((i + 1) ^ 4); use t


Dec.27.2014
The ability to obtain the address of literals will be provided.

	int sample(int* value)
	{
		return(*value + 3);
	}
	
	int main(int argc, char* argv[])
	{
	    int i = 5;
		printf("%d\n", sample(&i));
		printf("%d\n", sample(&5));
		return 0;
	}


Dec.27.2014
A new instruction called roll() executes as many as possible though the conditionals
in a type of logic test, but there need not be a block for entry based on the results
of the logic test.  Instead, roll() can simply execute and continue on.

In order to enter the block, roll() must be explicitly followed by braces, and there
is no single-line form as with if().

roll() was created to allow rolling processing through each logical item until one
fails, and then it will, based on its form, either stop processing, assign NULLs,
or assign a count, or all three.

roll() is used when a variable number of components exist, and each one in succession
is dependent upon the prior result, which causes it to roll through the calculation.

roll() exists with three components (like a for()):

	roll(assignment; conditional; count);

These forms take on specific meaning when present. The assignment is an auto-
assignment given for all values which exist in the x=y form after the first failure
is encountered. The conditional is the actual conditional logic, which can be
anything in a normal if() statement. And the count will be used to indicated how
many were processed through the conditionals (including non-assignments) before
the first failure was encountered.

roll() provides a stand-alone syntax in which no semicolons are present. If any
semicolons are used, all three must be present.

-----
Example operation using INVALID_PTR assignment, and storing a count:

	lnCount	= 0;
    c1		= f(cRoot);
	if (c1)
	{
		++lnCount;
	    c2 = f(c1);
		if (c2)
		{
			++lnCount;
			c3 = f(c2);
			if (c3)
			{
				++lnCount;
				some_operation();
			
			} else {
				c3 = INVALID_PTR;
			}
		
		} else {
			c2 = INVALID_PTR;
			c3 = INVALID_PTR;
		}
	
	} else {
		c1 = INVALID_PTR;
		c2 = INVALID_PTR;
		c3 = INVALID_PTR;
	}

-----
Using roll():

	roll (INVALID_PTR; (c1 = f(cRoot)) && (c2 = f(c1)) && (c3 = f(c2)); lnCount)
	{
		// Only entered if the logic all passed
		some_operation();
	}

-----
Using roll() as a stand-alone without some_operation() being required:

	roll (INVALID_PTR; (c1 = f(cRoot)) && (c2 = f(c1)) && (c3 = f(c2)); lnCount);
