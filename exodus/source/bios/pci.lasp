// pci.asp
//
// Exodus Peripheral Controller Interconnect routines
//
//   iPCI_read_dword()                       - Reads a value from a particular bus, device, function and doubleword
//   iPCI_write_dword()                      - Writes a value to a particular bus, device, function and doubleword
//   iPCI_verbalize_device_type()            - Looks at aspects of a PCI device and returns structured verbose description of it
//   iPCI_verbalize_device_manufacturer()    - Looks in the database of known PCI devices to return information about it
//
//   invPCI_parse_CSM_register()             - Builds the CSM register (Configuration Space Mapping)
//   invPCI_read_dword()                     - Reads a dword from the PCI bus based on the CSM value in eax
//   invPCI_write_dword()                    - Reads a dword from the PCI bus based on the CSM value in eax
//
// * Note:  These are all local routines (there are no CALL GATES to these functions)
// * Note:  Refer to INF\PCI.INF for more information
//



function iPCI_read_dword
{
// This routine reads a doubleword value from a particular bus, device, function and doubleword
//
// Upon entry:   dh - bus
//               dl - function
//               bh - device
//               bl - doubleword
//
// Upon exit:    eax - value
//
    push    edx
    push    ebx

    invPCI_parse_CSM_register()
    invPCI_read_dword()

    pop     ebx
    pop     edx
    ret
}




function iPCI_write_dword
{
// This routine writes a doubleword value from a particular bus, device, function and doubleword
//
// Upon entry:   dh - bus
//               dl - function
//               bh - device
//               bl - doubleword
//              eax - value
//
// Upon exit:    Nothing
//
    push    edx
    push    ebx

    push    eax
    invPCI_parse_CSM_register()
    pop     ebx
    invPCI_write_dword()

    pop     ebx
    pop     edx
    ret
}




function iPCI_verbalize_device_type
{
// This routine writes a doubleword value from a particular bus, device, function and doubleword
//
// Upon entry:   al - Prog I/F
//               ah - sub-class code
//              eal - class code
//
// Upon exit:    ds:[esi] - far ptr to NULL-terminated string representing device classification
//               ds:[edi] - far ptr to NULL-termianted string representing device sub-classification
//
// * For information about these class_codes and sub_class_codes, look to data.asp.  Contained within is a fixed structure which
//   is what these little .WHILE ... .ENDW loops are parsing.
//
    push    eax
    push    ebx
    push    ecx

    mov     bl,al
    shr     eax,8
  // Right now, ah - class code
  //            al - sub-class code
  //            bl - Prog I/F
    mov     esi,offset class_codes
    xor     ecx,ecx
    while (byte ptr [esi] != 0ffh)
    {
        cmp     u8 ptr [esi],ah
        jz      @F
        mov     cl,u8 ptr [esi+1]
        add     ecx,3
        add     esi,ecx
    }
  // It is unknown, which means it goes to the "undetermined" category on the list
  @@:
    add     esi,2

    mov     edi,offset sub_class_codes
    xor     ecx,ecx
    while (byte ptr [edi] != 0ffh)
    {
        cmp     u8 ptr [edi],ah
        jnz     skip_it
        cmp     u8 ptr [edi+1],al
        jnz     skip_it
        cmp     u8 ptr [edi+2],bl
        jz      @F
      skip_it:
        mov     cl,u8 ptr [edi+3]
        add     ecx,5
        add     edi,ecx
    }
  // It is unknown, which means it goes to "other"
  @@:
    add     edi,4

    pop     ecx
    pop     ebx
    pop     eax
    ret
}




function iPCI_verbalize_device_manufacturer
{
// This routine determines the device manufacturer/model based on the Vendor ID and Device ID
//
// Upon entry:   ax - Vendor ID
//               upper 16-bits of eax - Device ID
//               * Note, this is the 0-doubleword returned from the iPCI_read_dword
//
// Upon exit:    es:[edi] - far ptr to NULL-terminated string of the manufacturer/model
//
     // REMEMBER
    push    eax

    mov     ax,_sDATA
    mov     es,ax
    mov     edi,offset feature_not_finished

    pop     eax
    ret
}




function invPCI_parse_CSM_register
{
// This routine is only used internally.  It parses the entry information into the output information
//
// Upon entry:   dh - bus
//               dl - function
//               bh - device
//               bl - doubleword
//
// Upon exit:    eax - Configuration Space Mapping register in a format to send to port 03C8h
//
    and     dl,111b                                                 // Only 0-7 allowed
    and     bh,11111b                                               // Only 0-31 allowed
    and     bl,111111b                                              // Only 0-63 allowed
    mov     eax,80000000h                                           // Enable bit=1
    and     ebx,0ffffh
    ror     ebx,16                                                  // Swap ebx words
    mov     bl,dh
    ror     ebx,16
    shl     bh,3                                                    // Move device to bits [15..11]
    or      bh,dl
    shl     bl,2
    or      eax,ebx
    ret
}




function invPCI_read_dword
{
// This routine is only used internally.  It parses the entry information into the output information
//
// Upon entry:   eax - CSM register
//
// Upon exit:    eax - value
//
    push    edx

    mov     dx,_PCI_INDEX
    out     dx,eax                                                  // Set the index
    jmp     $+2
    mov     dx,_PCI_DATA
    in      eax,dx                                                  // Read the value

    pop     edx
    ret
}




function invPCI_write_dword
{
// This routine is only used internally.  It parses the entry information into the output information
//
// Upon entry:   eax - CSM register
//               ebx - value to write
//
// Upon exit:    Nothing
//
    push    edx

    mov     dx,_PCI_INDEX
    out     dx,eax                                                  // Set the index
    jmp     $+2
    mov     dx,_PCI_DATA
    mov     eax,ebx                                                 // Restored as eax
    in      eax,dx                                                  // Write the value

    pop     edx
    ret
}



function initialize_pci
{
// This routine gathers information from the PCI bus and stores it for later use
    pushad
    push    fs
    enter   8,0
  // [ebp-01] - byte, --nuserved
  // [ebp-02] - byte, device
  // [ebp-03] - byte, count of devices found
  // [ebp-04] - byte, bus
  // [ebp-08] - dword, ptr into _sPCI_DEVICES

    mov     esi,offset initializing_pci
    iVT_display_string_nr_vga()

    mov     ax,_sPCI_DEVICES
    mov     fs,ax

;; Now, scan for PCI devices
    xor     eax,eax
    mov     u32 ptr [ebp-04],eax
    mov     u32 ptr [ebp-08],eax
  @@:
    mov     dh,u8 ptr [ebp-04]                                 // bus
    mov     bh,u8 ptr [ebp-02]                                 // device
    xor     dl,dl                                                   // function
    xor     bl,bl                                                   // doubleword
    iPCI_read_dword()
    if (eax != 0ffffffffh)
    {
      // This is a valid item.  Let's determine what it is
      // Save the vendor id/device id
        mov     esi,u32 ptr [ebp-08]
        mov     u32 ptr fs:[esi],eax
        add     u32 ptr [ebp-08],4

      // Now, get the classification information.. heh heh
        mov     bl,2
        iPCI_read_dword()
        shr     eax,8

      // Save the classification information
        mov     esi,u32 ptr [ebp-08]
        mov     u32 ptr fs:[esi],eax
        add     u32 ptr [ebp-08],4

      // Right now, eax contains the class code data
        iPCI_verbalize_device_type()
      // Right now, ds:[esi] - far ptr to classification
      //            ds:[edi] - far ptr to sub-classification
        push    edi

        push    esi
        mov     esi,offset option_blank
        iVT_display_string_vga()
        pop     esi
        iVT_display_string_vga()

        mov     esi,offset comma_space
        iVT_display_string_vga()

        pop     esi
        iVT_display_string_nr_vga()
        inc     u8 ptr [ebp-03]
    }
    inc     u8 ptr [ebp-02]
    if (byte ptr [ebp-02] <= 31)
    {
        jmp     @B
    }
    mov     u8 ptr [ebp-02],0
    inc     u8 ptr [ebp-04]
    if (byte ptr [ebp-04] <= 7)
    {
        jmp     @B
    }
  // We've scanned all the PCI devices

;; Terminate our structure
    mov     esi,u32 ptr [ebp-08]
    mov     u32 ptr fs:[esi+00],0ffffffffh
    mov     u32 ptr fs:[esi+04],0ffffffffh

;; Update the display
    if (byte ptr [ebp-03] != 0)
    {
        iVT_get_cursor_vga()
        dec     dh
        iVT_position_cursor_vga()
        mov     esi,offset option_last
        IVT_display_string_nr_vga()
    }

;; We're finished
    leave
    pop     fs
    popad
    ret
}

    #include "pci.asp"
