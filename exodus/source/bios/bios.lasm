// bios.lasm
//
// +---------------+
// | standard BIOS |
// +---------------+
//
// Exodus native primative BIOS functions
//

// standard BIOS Driver

    
    
include "\libsf\exodus\source\common\equates.lasp"
include "\libsf\exodus\source\common\macros.lasp"
include "\libsf\exodus\source\common\errors.lasp"
include "\libsf\exodus\source\common\objects.lasp"
include "bios_eq.lasp"
include "task_eq.lasp"
include "obj_eq.lasp"


code text32
| org 0
{
    
// These are required to be the first 2 dwords in the file
dd  offset main
dd  offset requestor




    function requestor
    {
    // This routine is called by Exodus.  When this function is called multi-tasking is not installed.  This is a linear function.
    //
    // Upon entry:   eax - requested function
    //                ds - temporary ORG 0h data segment for use with these requestor() functions
    //
    // Upon exit:    results vary based on value of eax
    //
        if (eax == 'info')
        {
          // Program information
            mov     eax,'nati'                              // Identifying this program as a native primative
            mov     ecx,offset end_of_required_data         // The maximum number of bytes to retain after loading

            mov     esi,offset this_drivers_primatives      // Offset to the native primatives structure
            mov     edi,offset driver_name
            mov     ebx,offset version
            mov     edx,offset copyright
            mov     ebp,offset author
            clc
        
        } else if (eax == 'prim') {
          // Native primatives this program will use
            mov     ds:data_segment,ds
            mov     esi,offset required_primatives                  // This primative requires these external influence
            mov     edi,offset primative_call_gates
            clc
        
        } else if (eax == 'id  ') {
            mov     esi,offset driver_name
            call    u48 ptr cs:_VID_display_string_nr_vga
            clc
        
        } else if (eax == 'note') {
            mov     eax,'stop'
            mov     ebx,'load'
            mov     esi,offset driver_name
            call    u48 ptr cs:_EXODUS_requestor
        
        } else {
            stc
        }
        retf
    }




    function main
    {
    // This routine is called once by Exodus once initialization is complete (all calls to requestor() are finished)
    // It is used by Exodus to allow this driver to properly initialize itself.
    // When this function is called multi-tasking is not installed.  This is a linear function.
    //
    // Upon entry:   Nothing
    //
    // Upon exit:    A "continued status of execution" is expected by Exodus.  This indicates whether or not everything
    //               initialized ok or is available.  If everything is OK the carry? flag is CLEAR.  If there is an error
    //               and this driver cannot continue then the carry? should be SET.
    //               carry? - CLEAR=Ok to continue
    //                          SET=Error initializing
    //
        mov     ds,cs:data_segment
        mov     ds:bootup,0
        initialize_driver()
      // Right now, carry? is SET or CLEAR indicating status of driver
        retf
    }




    function initialize_driver
    {
    // This routine is used to initialize the driver
    //
    // Upon entry:   Nothing
    //
    // Upon exit:    The BIOS logo is displayed
    //
        initialize_TASKING()
        initialize_PIC()
        initialize_TIMER()

       // Display the BIOS logo
        mov     esi,offset bios_logo
        call    u48 ptr cs:_VID_draw_logo

        clc
        ret
    }




    function initialize_PIC
    {
    // This routine initializes the PIC to the bootup state Exodus expects/relies upon
    //
    // Upon entry:   Nothing
    //
    // Upon exit:    Nothing
    //
        pushad

       // Redirect master IRQs to INT 70h-77h
        mov     ah,0
        mov     bl,70h
        BIOS_iPIC_redirect_irq()
       // Unmask all IRQ's on master
        mov     ah,0
        BIOS_iPIC_unmask_all_irqs()

       // Redirect slave IRQs to INT 78h-7fh
        mov     ah,1
        mov     bl,78h
        BIOS_iPIC_redirect_irq()
       // Unmask all IRQ's on slave
        mov     ah,1
        BIOS_iPIC_unmask_all_irqs()

       // Enable NMI interrupts
        xor     al,al                                               // High bit is the only one that matters, 0-enables, 1-masks
        out     _PIC_70h,al

        popad
        ret
    }




    function initialize_TIMER
    {
    // This routine initializes the timer to ensure it's setup correctly
    //
    // Upon entry:   Nothing
    //
    // Upon exit:    Nothing
    //
    // Initialize the timer memory to have one event which goes to the system event (for task switching and clock maintenance)
    //
    // * Note:  The manner in which we reprent the 182 ticks per second is not exact.  This is due to the fact that the minimum
    //          firing time the timer can execute is when it contains a count value of 0xffff, which represents 18.2064971924 ticks
    //          per second.  However, when we multiply that frequency by 10, to get our ~182 times per second, we lose some ability
    //          to store the exact value in the timer.  This is due to the fact that ~18.2 ticks = 0xffff, and ~182 ticks = 1999h
    //          with .6 (in base 10) remaining, or approximately 9.6 (in base 16).  So the actual value we need for the timer is
    //          1999.96h, but since we can't load decimals we are forced to round.  This creates a problem of the timer not truly
    //          firing at the rate of 182.064971924 (as it should).  So, to compensave for this, we take the actual value and
    //          divide it by the calculated value, that yields a result of 0.999923710711 (6553.6 / 6554), which we then multiply
    //          by our timer constant (119318100000) to obtain our actual add frequency of 119308997307 (which is slightly less
    //          then our actual value).  This will cause the timer to not fire exactly as often, thereby compensating for the
    //          difference.  119308997307 = 1bc75ed2bah
    //
        pushad

       // Set the timer to interrupt 182Hz
        mov     eax,1999h
        invTIMER_set_interrupt_interval()

       // Setup the TASK GATE in the IDT (point IRQ0 to the timer ISR)
        mov     eax,'bint'
        mov     bl,70h                                              // INT 70h
        mov     ecx,1
        mov     edx,offset TIMER_handler
        call    u48 ptr ds:_EXODUS_requestor

        popad
        ret
    }




    function BIOS_iPIC_redirect_irq
    {
    // This routine re-maps the IRQ interrupts to the desired range
    //
    // Upon entry:   ah = 0 or 1             (0-Master PIC, 1-Slave PIC)
    //               bl = New Interrupt      (00h, 10h, 20h, 30h, etc.)
    //
        pushad
     // Setup the appropriate port values for the requested PIC
        if (ah == 0)
        {
            mov     edx,_PIC_21h                                    // 8259-1 (master)
            mov     ecx,_PIC_20h
        
        } else {
            mov     edx,_PIC_A1h                                    // 8259-2 (slave)
            mov     ecx,_PIC_A0h
        }

     // Read interrupt mask
        in      al,dx                                               // Read the current mask (we restore this below)
        mov     ah,al
        @IO_pause

     // Disable interrupts
        cli

     // Command 1
        xchg    edx,ecx
        mov     al,11h                                              // Cascade, require 4th init byte in this sequence
        out     dx,al
        @IO_pause

     // Command 2
        xchg    edx,ecx
        mov     al,bl                                               // User defined interrupt redirect value
        and     al,11111000b                                        // Mask off lower 3 bits (they're not used here)
        out     dx,al
        @IO_pause

     // Command 3
        if (edx >= _PIC_A0h)
        {
          // slave controller receives value 2 here
            mov     al,010b                                         // Slave controller ID (value of 2 indicates IRQ2)
        
        } else {
          // master controller receives value 4 here
            mov     al,0100b                                        // Slave controller on IRQ 2
        }
        out     dx,al
        @IO_pause

     // Command 4
        mov     al,1                                                // Normal EOI, nonbuffered, 80x86
        out     dx,al
        @IO_pause

     // Restore original interrupt mask register
        mov     al,ah
        out     dx,al

     // Enable interrupts
        sti

     // Finished
        popad
        retf
    }




    function BIOS_iPIC_mask_irq
    {
    // This routine masks a specific IRQ
    //
    // Upon entry:   ah = IRQ # to mask
    //
        if (ah <= 15)
        {
            pushad
           // Setup the appropriate port values
            mov     edx,_PIC_21h                                    // Default to 8259-1 (master)
            if (ah >= 8)
            {
                mov     edx,_PIC_A1h                                // Nope, it's 8259-2 (slave)
                sub     ah,8                                        // Subtract 8 (makes IRQ #'s 8-15 appear as 0-7, used below)
            }
           // Get current mask values
            in      al,dx
            if (ah == 0)
            {
                or      al,1b                                       // Mask IRQ 0/8
            
            } else if (ah == 1) {
                or      al,10b                                      // Mask IRQ 1/9
            
            } else if (ah == 2) {
                or      al,100b                                     // Mask IRQ 2/10
            
            } else if (ah == 3) {
                or      al,1000b                                    // Mask IRQ 3/11
            
            } else if (ah == 4) {
                or      al,10000b                                   // Mask IRQ 4/12
            
            } else if (ah == 5) {
                or      al,100000b                                  // Mask IRQ 5/13
            
            } else if (ah == 6) {
                or      al,1000000b                                 // Mask IRQ 6/14
            
            } else {
                or      al,10000000b                                // Mask IRQ 7/15
            }
           // Set the new mask values
            out     dx,al

           // Finished
            popad
        }
        retf
    }




    function BIOS_iPIC_unmask_irq
    {
    // This routine un-masks a specific IRQ
    //
    // Upon entry:   ah = IRQ # to unmask
    //
        if (ah <= 15)
        {
            pushad
           // Setup the appropriate port values
            mov     edx,_PIC_21h                                    // Default to 8259-1 (master)
            if (ah >= 8)
            {
                mov     edx,_PIC_A1h                                // Nope, it's 8259-2 (slave)
                sub     ah,8                                        // Subtract 8 (makes IRQ #'s 8-15 appear as 0-7, used below)
            }
           // Get current mask values
            in      al,dx
            if (ah == 0)
            {
                and     al,not 1b                                   // Unmask IRQ 0/8
            
            } else if (ah == 1) {
                and     al,not 10b                                  // Unmask IRQ 1/9
            
            } else if (ah == 2) {
                and     al,not 100b                                 // Unmask IRQ 2/10
            
            } else if (ah == 3) {
                and     al,not 1000b                                // Unmask IRQ 3/11
            
            } else if (ah == 4) {
                and     al,not 10000b                               // Unmask IRQ 4/12
            
            } else if (ah == 5) {
                and     al,not 100000b                              // Unmask IRQ 5/13
            
            } else if (ah == 6) {
                and     al,not 1000000b                             // Unmask IRQ 6/14
            
            } else {
                and     al,not 10000000b                            // Unmask IRQ 7/15
            }
           // Set the new mask values
            out     dx,al

           // Finished
            popad
        }
        retf
    }




    function BIOS_iPIC_mask_all_irqs
    {
    // This routine masks all IRQs (disables them)
    //
    // Upon entry:   ah = 0 or 1             (0-Master PIC, 1-Slave PIC)
    //
        push    eax
        push    edx

       // Setup the appropriate port values
        if (ah == 0)
        {
            mov     dx,_PIC_21h                                     // 8259-1 (master)
        
        } else {
            mov     dx,_PIC_A1h                                     // 8259-2 (slave)
        }

       // Set the new mask values
        mov     al,0ffh                                             // Disable all
        out     dx,al

       // Finished
        pop     edx
        pop     eax
        retf
    }




    function BIOS_iPIC_unmask_all_irqs
    {
    // This routine unmasks all IRQs (enables them)
    //
    // Upon entry:   ah = 0 or 1             (0-Master PIC, 1-Slave PIC)
    //
        push    eax
        push    edx

       // Setup the appropriate port values
        if (ah == 0)
        {
            mov     dx,_PIC_21h                                     // 8259-1 (master)
        
        } else {
            mov     dx,_PIC_A1h                                     // 8259-2 (slave)
        }

       // Set the new mask values
        xor     al,al                                               // Enable all
        out     dx,al

       // Finished
        pop     edx
        pop     eax
        retf
    }




    function iBIOS_read_8042_64h
    {
    // This routine reads one byte from port 60h into al
        in      al,064h
        TIMER_wait_full_tick()
        retf
    }




    function iBIOS_read_8042_60h
    {
    // This routine reads the byte in from port 60h to al
        push    ecx
        xor     ecx,ecx
      @@:
        iBIOS_read_8042_64h()                                 // Wait for bit 0 of port (64h) to become zero before reading
        shr     al,1
        jc      @F
        loope   @B
      @@:
        TIMER_wait_full_tick()
        in      al,060h
        pop     ecx
        retf
    }




    function iBIOS_write_8042_64h
    {
    // This routine writes a byte to port 64h
        TIMER_wait_full_tick()
        mov     al,ah
        out     064h,al
        retf
    }




    function iBIOS_write_8042_60h
    {
    // This routine writes the byte in ah to port 60h
        push    ecx
        xor     ecx,ecx
      @@:
        iBIOS_read_8042_64h()                                 // Wait for bit 1 of port (64h) to become zero before writing
        shr     al,2
        jnc     @F
        loope   @B
      @@:
        TIMER_wait_full_tick()
        mov     al,ah                                               // Write it
        out     060h,al
        TIMER_wait_full_tick()
        pop     ecx
        retf
    }




    function iBIOS_read_8042_64h_fast
    {
    // This routine reads one byte from port 60h into al
        in      al,064h
        jmp     $+2
        retf
    }




    function iBIOS_read_8042_60h_fast
    {
    // This routine reads the byte in from port 60h to al
        push    ecx
        xor     ecx,ecx
      @@:
        iBIOS_read_8042_64h_fast()                            // Wait for bit 0 of port (64h) to become zero before reading
        shr     al,1
        jc      @F
        loope   @B
      @@:
        in      al,060h
        jmp     $+2
        pop     ecx
        retf
    }




    function iBIOS_write_8042_64h_fast
    {
    // This routine writes a byte to port 64h
        mov     al,ah
        out     064h,al
        retf
    }




    function iBIOS_write_8042_60h_fast
    {
    // This routine writes the byte in ah to port 60h
        mov     al,ah                                               // Write it
        out     060h,al
        retf
    }




    function BIOS_requestor
    {
    // This routine is used to answer queries by other applications
    // * Refer to source\inf\requestr.inf for more information
    //
    // Upon entry:   eax = request number
    //               stack is appropriately setup based on request
    //
    // Upon exit:    various registers might be updated
    //
        retf
    }




    include "timer.lasp"
    include "tasks.lasp"
    include "objects.lasp"





// DATA
    driver_name                             u8  "Motherboard BIOS Driver",0
    version                                 u8  "10.10.2010",0
    copyright                               u8  "(c) Copyright Beatleworks, Inc.",0
    author                                  u8  "Rick C. Hodgin",0
    bootup                                  u8  1                   // Indicates bootup status, changes to 0 after initialization
    data_segment                            u16 0

// CALL GATES
    _EXODUS_requestor                       u16 0
  primative_call_gates:
    _VID_draw_logo                          u16 0
    _VID_display_string_nr_vga              u16 _sEXODUS_REQUESTOR
    _iDEBI_timer_interface                  u16 0f000h
    _VID_g_derive_color                     u16 0f000h
    _VID_g_fill_rectangle                   u16 0f000h
    _VID_g_draw_text                        u16 0f000h
    _VID_g_display_radix_in_edx_mono        u16 0f000h
    _VID_g_mouse_pointer                    u16 0f000h
                                            u16 0f000h
                                            u16 0f000h

// DATA only used at load time (released thereafter)
    required_primatives                     u8  13, "VID_draw_logo"
                                            u8  25, "VID_display_string_nr_vga"
                                            u8  21, "iDEBI_timer_interface"
                                            u8  18, "VID_g_derive_color"
                                            u8  20, "VID_g_fill_rectangle"
                                            u8  15, "VID_g_draw_text"
                                            u8  31, "VID_g_display_radix_in_edx_mono"
                                            u8  19, "VID_g_mouse_pointer"
                                            u8  0ffh

    bios_logo                               u8  1       // how many extra 18x16 pictures wide?
                                            u8  00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  07h,07h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,07h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,07h,07h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,00h
                                            u8  00h,07h,07h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,0ah,0ah,0ah,0ah,0ah,0ah,0ah,0ah,0ah,0ah,02h,02h,02h,02h,07h,07h,07h,07h,02h,00h
                                            u8  00h,07h,00h,02h,02h,07h,07h,07h,07h,07h,07h,07h,02h,02h,07h,07h,07h,07h,07h,07h,07h,07h,02h,02h,02h,02h,02h,0ah,0ah,0ah,0ah,0ah,07h,08h,08h,07h,02h,00h
                                            u8  00h,07h,00h,02h,02h,07h,00h,00h,00h,00h,00h,07h,0ah,0ah,07h,00h,00h,00h,00h,00h,00h,07h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,07h,07h,07h,07h,02h,00h
                                            u8  00h,07h,00h,02h,02h,07h,00h,08h,08h,08h,00h,07h,02h,02h,07h,00h,08h,08h,08h,08h,00h,07h,02h,02h,02h,02h,07h,07h,07h,07h,07h,02h,02h,02h,0ah,02h,02h,00h
                                            u8  00h,07h,00h,02h,02h,07h,00h,08h,08h,08h,00h,07h,0ah,0ah,07h,00h,08h,08h,08h,08h,00h,07h,0ah,0ah,0ah,0ah,07h,08h,08h,00h,07h,0ah,0ah,0ah,0ah,02h,02h,00h
                                            u8  00h,07h,00h,02h,02h,07h,00h,00h,00h,00h,00h,07h,02h,02h,07h,00h,08h,08h,08h,08h,00h,07h,02h,02h,02h,02h,07h,00h,08h,08h,07h,02h,02h,02h,02h,02h,02h,00h
                                            u8  00h,07h,00h,02h,02h,07h,07h,07h,07h,07h,07h,07h,02h,02h,07h,07h,07h,07h,07h,07h,07h,07h,0ah,0ah,0ah,0ah,07h,07h,07h,07h,07h,02h,02h,02h,02h,02h,02h,00h
                                            u8  00h,07h,00h,02h,02h,02h,0ah,02h,02h,02h,02h,0ah,02h,02h,02h,02h,0ah,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,00h
                                            u8  00h,07h,07h,02h,02h,02h,0ah,02h,02h,02h,02h,02h,0ah,02h,02h,02h,02h,0ah,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,00h
                                            u8  00h,07h,07h,02h,0eh,02h,0eh,02h,0eh,02h,0eh,02h,0eh,02h,0eh,02h,0eh,02h,02h,0eh,02h,0eh,02h,0eh,02h,0eh,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,00h
                                            u8  00h,07h,00h,02h,0eh,06h,0eh,06h,0eh,06h,0eh,06h,0eh,06h,0eh,06h,0eh,02h,02h,0eh,06h,0eh,06h,0eh,06h,0eh,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,02h,00h
                                            u8  00h,07h,00h,00h,0eh,06h,0eh,06h,0eh,06h,0eh,06h,0eh,06h,0eh,06h,0eh,00h,00h,0eh,06h,0eh,06h,0eh,06h,0eh,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h

 end_of_required_data:
    this_drivers_primatives                 u8  14, "BIOS_requestor"
                                            u32 offset BIOS_requestor
                                            u16 0

                                            u8  22, "BIOS_iPIC_redirect_irq"
                                            u32 offset BIOS_iPIC_redirect_irq
                                            u16 0

                                            u8  18, "BIOS_iPIC_mask_irq"
                                            u32 offset BIOS_iPIC_mask_irq
                                            u16 0

                                            u8  20, "BIOS_iPIC_unmask_irq"
                                            u32 offset BIOS_iPIC_unmask_irq
                                            u16 0

                                            u8  23, "BIOS_iPIC_mask_all_irqs"
                                            u32 offset BIOS_iPIC_mask_all_irqs
                                            u16 0

                                            u8  25, "BIOS_iPIC_unmask_all_irqs"
                                            u32 offset BIOS_iPIC_unmask_all_irqs
                                            u16 0

                                            u8  19, "iBIOS_read_8042_64h"
                                            u32 offset iBIOS_read_8042_64h
                                            u16 0

                                            u8  19, "iBIOS_read_8042_60h"
                                            u32 offset iBIOS_read_8042_60h
                                            u16 0

                                            u8  20, "iBIOS_write_8042_64h"
                                            u32 offset iBIOS_write_8042_64h
                                            u16 0

                                            u8  20, "iBIOS_write_8042_60h"
                                            u32 offset iBIOS_write_8042_60h
                                            u16 0

                                            u8  24, "iBIOS_read_8042_64h_fast"
                                            u32 offset iBIOS_read_8042_64h_fast
                                            u16 0

                                            u8  24, "iBIOS_read_8042_60h_fast"
                                            u32 offset iBIOS_read_8042_60h_fast
                                            u16 0

                                            u8  25, "iBIOS_write_8042_64h_fast"
                                            u32 offset iBIOS_write_8042_64h_fast
                                            u16 0

                                            u8  25, "iBIOS_write_8042_60h_fast"
                                            u32 offset iBIOS_write_8042_60h_fast
                                            u16 0

                                            u8  20, "TIMER_wait_next_tick"
                                            u32 offset TIMER_wait_next_tick
                                            u16 0

                                            u8  20, "TIMER_wait_full_tick"
                                            u32 offset TIMER_wait_full_tick
                                            u16 0

                                            u8  18, "TIMER_wait_x_ticks"
                                            u32 offset TIMER_wait_x_ticks
                                            u16 0

                                            u8  31, "iTIMER_activate_debi_timer_feed"
                                            u32 offset iTIMER_activate_debi_timer_feed
                                            u16 0

                                            u8  33, "iTIMER_deactivate_debi_timer_feed"
                                            u32 offset iTIMER_deactivate_debi_timer_feed
                                            u16 0

                                            u8  14, "TASK_set_focus"
                                            u32 offset TASK_set_focus
                                            u16 0

                                            u8  16, "TASK_read_events"
                                            u32 offset TASK_read_events
                                            u16 0

                                            u8  22, "TASK_release_timeslice"
                                            u32 offset TASK_release_timeslice
                                            u16 0

                                            u8  19, "iTASK_kbd_interface"
                                            u32 offset iTASK_kbd_interface
                                            u16 0

                                            u8  25, "OBJECT_create_base_object"
                                            u32 offset OBJECT_create_base_object
                                            u16 0

                                            u8  20, "OBJECT_create_object"
                                            u32 offset OBJECT_create_object
                                            u16 0

                                            u8  29, "Exodus_TASK_release_timeslice"
                                            u32 offset Exodus_TASK_release_timeslice
                                            u16 0

                                            u8  25, "iTASK_prevent_task_switch"
                                            u32 offset iTASK_prevent_task_switch
                                            u16 0

                                            u8  23, "iTASK_allow_task_switch"
                                            u32 offset iTASK_allow_task_switch
                                            u16 0

                                            u8  21, "iTASK_mouse_interface"
                                            u32 offset iTASK_mouse_interface
                                            u16 0

                                            u16 0ffffh              // Teriminator

}
// text32

END
