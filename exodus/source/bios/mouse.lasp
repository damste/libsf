// mouse.asp
//
// Exodus TASK Mouse Handler
//          +------------------------------+
// * Note * | This is not a mouse driver!! |
//          +------------------------------+
//          It just handles information sent from the mouse driver.
//




// Status
mouse_status                    u32  0                               // Is mouse displayed?  1-Yes, 0-No
mouse_pointer_type              u32  0                               // Refer to INF\MOUSE.INF or VGA\MOUSE.FNT
mouse_processing                u32  0                               // Is this program processing?  1-Yes, 0-No
dragging_something              u32  0                               // Dragging something?  1-Yes, 0-No

// Mouse coordinates
mouse_current_x                 u32  160
mouse_current_y                 u32  100
mouse_hovering_x                u32  0ffffffffh
mouse_hovering_y                u32  0ffffffffh
mouse_pointer_save_area         u8   16*20 dup(0)

// Dragging activity
dragging_x                      u32  0
dragging_y                      u32  0
dragging_height                 u32  0
dragging_width                  u32  0
dragging_offset_x               u32  0
dragging_offset_y               u32  0
dragging_snap_x                 u32  0
dragging_snap_y                 u32  0
dragging_last_x                 u32  0
dragging_last_y                 u32  0
dragging_skipped                u32  0

// Counts used to activate various things
mouse_hovering_count_start      u32  91
mouse_hovering_count            u32  0ffffffffh
mouse_clicking_count_start      u32  30
mouse_clicking_count            u32  0ffffffffh
mouse_immediate_count_start     u32  2
mouse_immediate_count           u32  0ffffffffh

// Relating to click activity
mouse_last_event                u8   0                               // Relates to clicking or dragging
mouse_right_click_x_start       u32  0
mouse_right_click_y_start       u32  0
mouse_left_click_x_start        u32  0
mouse_left_click_y_start        u32  0
mouse_right_click_x_stop        u32  0
mouse_right_click_y_stop        u32  0
mouse_left_click_x_stop         u32  0
mouse_left_click_y_stop         u32  0
mouse_right_click               u32  0
mouse_left_click                u32  0
mouse_both_click                u32  0
mouse_left_dragging             u32  0
mouse_right_dragging            u32  0

// Relating to button activity
mouse_last_buttons              u32  0                               // Button status from previous mouse packet
mouse_last_button_left          u32  0
mouse_last_button_right         u32  0
mouse_button_left               u32  0
mouse_button_right              u32  0

// Relating to screen saver
screen_saver_active             u32  0                               // 1-Yes, 0-No
screen_saver_count              u32  18200                           // 100 seconds
screen_saver_count_start        u32  18200





    function iTASK_mouse_interface
    {
    // This routine is called when there is mouse information for Exodus
    //
    // Upon entry:   eax = X delta
    //               edx = Y delta
    //               ebx = button status
    //
    // Upon exit:    The mouse information is updated
    //
        push    ds
        pushad
        mov     ds,cs:data_segment


       // Cancel screen saver (if it's active)
        if (ds:screen_saver_active == 1)
        {
            invTASK_cancel_screen_saver()
            mov     ecx,ds:screen_saver_count_start
            mov     ds:screen_saver_count,ecx
        }


       // Remove the mouse pointer that's already displayed
        if (ds:mouse_processing == 0 && ds:mouse_status == 1)
        {
            mov     ds:mouse_processing,1
            invTASK_hide_mouse_pointer()
            mov     ds:mouse_processing,0
        }


       // Update to new mouse coordinates
        invTASK_adjust_mouse_coordinates()


       // Process the data
        if (ds:mouse_processing == 0)
        {
            mov     ds:mouse_processing,1
            if (ebx != 0 || ebx != ds:mouse_last_buttons)
            {
              // There is button activity
              // This process might take a bit of time to complete so we indicate we're processing thereby removing
              // the possibility of attempted processing in the future until such time as all the processing we're about
              // to start gets completed.
                invTASK_mouse_button_activity()
            
            } else {
              // No button activity
              // We still have to see if we're over anything that needs to be updated because we also display information about
              // certain things in the Quick Watch window.  Isn't it great? :)
                mov     edx,ds:mouse_current_x
                mov     ds:mouse_hovering_x,edx
                mov     edx,ds:mouse_current_y
                mov     ds:mouse_hovering_y,edx
                mov     ecx,ds:mouse_hovering_count_start
                mov     ds:mouse_hovering_count,ecx
                mov     ds:mouse_last_event,_HOVER
                mov     ecx,ds:mouse_immediate_count_start
                mov     ds:mouse_immediate_count,ecx
                invTASK_show_mouse_pointer()
            }
            mov     ds:mouse_processing,0
        }

        popad
        pop     ds
        retf
    }




    function invTASK_adjust_mouse_coordinates
    {
    // This routine is called to adjust the mouse coordinates
    //
    // Upon entry:   eax - X delta
    //               edx - Y delta
    //               ebx - buton status
    //
    // Upon exit:    mouse_current_x - updated
    //               mouse_current_y - updated
    //
        push    es
        mov     ecx,_sSYSTEM
        mov     es,ecx

      // Adjust the mouse based on the distance it's moved
        add     ds:mouse_current_x,eax
        add     ds:mouse_current_y,edx

      // Find the maximum coordinates
        movzx   eax,<u16> es:[_SYSTEM_VGA_HORIZONTAL]
        dec     eax                                                 // Change base-1 to base-0
        movzx   edx,<u16> es:[_SYSTEM_VGA_VERTICAL]
        dec     edx                                                 // Change base-1 to base-0
      // Right now, eax - maximum horizontal
      //            edx - maximum vertical

        if (ds:dragging_something == 0)
        {
          // Verify X
            if (ds:mouse_current_x > 7fffffffh)
            {
              // It's negative (it's off the left of the screen or it's at the very left of the screen)
                mov     ds:mouse_current_x,0
            
            } else if (ds:mouse_current_x > eax) {
              // It's heading off the right side of the screen
                mov     ds:mouse_current_x,eax
            }

          // Verify Y
            if (ds:mouse_current_y > 7fffffffh)
            {
              // It's negative (it's above the top of the screen or it's at the very top of the screen)
                mov     ds:mouse_current_y,0
            
            } else if (ds:mouse_current_y > edx) {
              // It's heading off the bottom of the screen
                mov     ds:mouse_current_y,edx
            }
        
        } else {
          // The mouse is only allowed to move in certain areas when something is being dragged
          // This logic is a little more complex than the above no-drag logic

          // Make sure they're not negative
            if (ds:mouse_current_x > 7fffffffh)
            {
                neg     ds:mouse_current_x
            }
            if (ds:mouse_current_y > 7fffffffh)
            {
                neg     ds:mouse_current_y
            }

          // Verify X
            mov     ecx,ds:mouse_current_x
            sub     ecx,ds:dragging_offset_x
            if (carry?)
            {
              // We're less than zero
                neg     ecx
                add     ds:mouse_current_x,ecx
            
            } else {
              // We're good on the left-side.  Now, how about the right?
                mov     ecx,ds:mouse_current_x
                sub     ecx,ds:dragging_offset_x
                add     ecx,ds:dragging_width
                if (ecx > eax)
                {
                  // We're to far
                    sub     ecx,eax
                    sub     ds:mouse_current_x,ecx
                }
            }

          // Verify Y
            mov     ecx,ds:mouse_current_y
            sub     ecx,ds:dragging_offset_y
            if (carry?)
            {
              // We're less than zero
                neg     ecx
                add     ds:mouse_current_y,ecx
            
            } else {
              // We're good on the top.  Now, how about the bottom?
                mov     ecx,ds:mouse_current_y
                sub     ecx,ds:dragging_offset_y
                add     ecx,ds:dragging_height
                if (ecx > edx)
                {
                  // We're to far
                    sub     ecx,edx
                    sub     ds:mouse_current_y,ecx
                }
            }
        }

        pop     es
        ret
    }




    function invTASK_hide_mouse_pointer
    {
    // This routine is called when they want to hide the mouse pointer
    //
    // Upon entry:   Nothing
    //
    // Upon exit:    The mouse pointer is displayed
    //
        pushfd
        push    <u32> ds:mouse_current_x
        push    <u32> ds:mouse_current_y
        push    0                                                   // 0-hide, 1-show
        push    <u32> ds:mouse_pointer_type                     // mouse pointer type
        push    <u32> offset mouse_pointer_save_area
        cli
        call    <u48> ds:_VID_g_mouse_pointer
        mov     ds:mouse_status,0
        popfd
        ret
    }




    function invTASK_show_mouse_pointer
    {
    // This routine is called when they want to show the mouse pointer
    //
    // Upon entry:   Nothing
    //
    // Upon exit:    The mouse pointer is displayed
    //
if (ds:mouse_current_x > 320 || ds:mouse_current_y > 200)
{
    int 3
}
        pushfd
        push    <u32> ds:mouse_current_x
        push    <u32> ds:mouse_current_y
        push    1
        push    <u32> ds:mouse_pointer_type                     // mouse pointer type
        push    <u32> offset mouse_pointer_save_area
        cli
        call    <u48> ds:_VID_g_mouse_pointer
        mov     ds:mouse_status,1
        popfd
        ret
    }




    function invTASK_mouse_button_activity
    {
    // This routine is called to process button activity
    //
    // Upon entry:   Nothing
    //
    // Upon exit:    Any change in button activity is appropriately handled
    //
        ret
    }




    function invTASK_activate_screen_saver
    {
    // This routine is used to cancel a previously activated screen saver
    //
    // Upon entry:   Nothing
    //
    // Upon exit:    The screen is saved if it's not already in a saved screen state
    //
        ret
    }




    function invTASK_cancel_screen_saver
    {
    // This routine is used to cancel a previously activated screen saver
    //
    // Upon entry:   Nothing
    //
    // Upon exit:    The screen is restored if it was previously in a saved screen state
    //
        ret
    }
