Microsoft (R) Macro Assembler Version 6.11a		    03/07/09 22:34:58
Bootup							     Page 1 - 1


				; bootup.asm
				;
				; Exodus BOOTUP.COM
				;

				TITLE Bootup

				    .MODEL tiny

				    .386P
				;_DEBI   EQU 0

				INCLUDE \exodus\source\common\macros.asp                            ; Macros used throughout Exodus
			      C ; macros.asp
			      C ;
			      C ; Exodus macros, used various places
			      C ;
			      C 
			      C 
			      C 
			      C callfp     MACRO   _seg:REQ, _offset:REQ
			      C ; This macro:   callfp  _code_seg, _offset
			      C ;
			      C     db  9ah
			      C     dd  _offset
			      C     dw  _seg
			      C ENDM
			      C 
			      C 
			      C 
			      C 
			      C callg      MACRO   _seg:REQ
			      C ; This macro:   callg   _call_gate
			      C     db  9ah
			      C     dd  0
			      C     dw  _seg
			      C ENDM
			      C 
			      C 
			      C 
			      C 
			      C jmpg       MACRO   _seg:REQ
			      C ; This macro:   jmpg    _call_gate
			      C     db  0eah
			      C     dd  0
			      C     dw  _seg
			      C ENDM
			      C 
			      C 
			      C 
			      C 
			      C callf      MACRO   _func:REQ
			      C ; This macro:   callf   function_name
			      C     push    cs
			      C     call    _func
			      C ENDM
			      C 
			      C 
			      C 
			      C 
			      C @IO_pause   MACRO
			      C     jmp     $+2
			      C ENDM
			      C 
				INCLUDE \exodus\source\common\equates.asp                           ; Constants used to access memory variables, etc
			      C ; equates.asp
			      C ;
			      C ; Exodus constants.  These are used at various places.
			      C ; This file provides a common area to modify constant values, rather than sifting through programs, etc.
			      C ;
			      C 
			      C 
			      C 
			      C INCLUDE x86_eq.asp
			      C ; x86_eq.asp
			      C ;
			      C ; Constants specific to the Intel architecture
			      C ;
			      C 
			      C 
			      C 
 = 0000			      C _TSS_BACK_LINK              EQU 0
 = 0004			      C _TSS_ESP0                   EQU 4
 = 0008			      C _TSS_SS0                    EQU 8
 = 000C			      C _TSS_ESP1                   EQU 12
 = 0010			      C _TSS_SS1                    EQU 16
 = 0014			      C _TSS_ESP2                   EQU 20
 = 0018			      C _TSS_SS2                    EQU 24
 = 001C			      C _TSS_CR3                    EQU 28
 = 0020			      C _TSS_EIP                    EQU 32
 = 0024			      C _TSS_EFLAGS                 EQU 36
 = 0028			      C _TSS_EAX                    EQU 40
 = 002C			      C _TSS_ECX                    EQU 44
 = 0030			      C _TSS_EDX                    EQU 48
 = 0034			      C _TSS_EBX                    EQU 52
 = 0038			      C _TSS_ESP                    EQU 56
 = 003C			      C _TSS_EBP                    EQU 60
 = 0040			      C _TSS_ESI                    EQU 64
 = 0044			      C _TSS_EDI                    EQU 68
 = 0048			      C _TSS_ES                     EQU 72
 = 004C			      C _TSS_CS                     EQU 76
 = 0050			      C _TSS_SS                     EQU 80
 = 0054			      C _TSS_DS                     EQU 84
 = 0058			      C _TSS_FS                     EQU 88
 = 005C			      C _TSS_GS                     EQU 92
 = 0060			      C _TSS_LDT                    EQU 96
 = 0064			      C _TSS_TRAP_BIT               EQU 100
 = 0001			      C _TSS_TRAP_BIT_MASK          EQU 1b
 = 0066			      C _TSS_IO_MAP                 EQU 102
			      C ; The following area is used by Exodus.  It appears immediate after the TSS in memory
 = 0068			      C _TSS_FPU_SAVE_AREA          EQU 104
			      C 
			      C 
			      C ; EFLAGS register constants to access individual flags
 = 0000			      C _EFLAGS_CF                  EQU 0
 = 0002			      C _EFLAGS_PF                  EQU 2
 = 0004			      C _EFLAGS_ACF                 EQU 4
 = 0006			      C _EFLAGS_ZF                  EQU 6
 = 0007			      C _EFLAGS_SF                  EQU 7
 = 0008			      C _EFLAGS_TF                  EQU 8
 = 0009			      C _EFLAGS_IF                  EQU 9
 = 000A			      C _EFLAGS_DF                  EQU 10
 = 000B			      C _EFLAGS_OF                  EQU 11
 = 000C			      C _EFLAGS_IOPL                EQU 12
 = 000E			      C _EFLAGS_NT                  EQU 14
 = 0010			      C _EFLAGS_RF                  EQU 16
 = 0011			      C _EFLAGS_VM                  EQU 17
			      C ; Masks to access specific bits
 = 0001			      C _EFLAGS_CF_MASK             EQU  1b SHL _EFLAGS_CF
 = 0004			      C _EFLAGS_PF_MASK             EQU  1b SHL _EFLAGS_PF
 = 0010			      C _EFLAGS_ACF_MASK            EQU  1b SHL _EFLAGS_ACF
 = 0040			      C _EFLAGS_ZF_MASK             EQU  1b SHL _EFLAGS_ZF
 = 0080			      C _EFLAGS_SF_MASK             EQU  1b SHL _EFLAGS_SF
 = 0100			      C _EFLAGS_TF_MASK             EQU  1b SHL _EFLAGS_TF
 = 0200			      C _EFLAGS_IF_MASK             EQU  1b SHL _EFLAGS_IF
 = 0400			      C _EFLAGS_DF_MASK             EQU  1b SHL _EFLAGS_DF
 = 0800			      C _EFLAGS_OF_MASK             EQU  1b SHL _EFLAGS_OF
 = 3000			      C _EFLAGS_IOPL_MASK           EQU 11b SHL _EFLAGS_IOPL
 = 4000			      C _EFLAGS_NT_MASK             EQU  1b SHL _EFLAGS_NT
 = 00010000		      C _EFLAGS_RF_MASK             EQU  1b SHL _EFLAGS_RF
 = 00020000		      C _EFLAGS_VM_MASK             EQU  1b SHL _EFLAGS_VM
			      C 
 = 1000			      C _CW_INFINITY                EQU 1000000000000b
 = 0C00			      C _CW_ROUNDING                EQU  110000000000b
 = 0000			      C _CW_ROUNDING_00             EQU  000000000000b
 = 0400			      C _CW_ROUNDING_01             EQU  010000000000b
 = 0800			      C _CW_ROUNDING_10             EQU  100000000000b
 = 0C00			      C _CW_ROUNDING_11             EQU  110000000000b
 = 0300			      C _CW_PRECISION               EQU    1100000000b
 = 0000			      C _CW_PRECISION_00            EQU    0000000000b
 = 0100			      C _CW_PRECISION_01            EQU    0100000000b
 = 0200			      C _CW_PRECISION_10            EQU    1000000000b
 = 0300			      C _CW_PRECISION_11            EQU    1100000000b
 = 0020			      C _CW_PM                      EQU        100000b
 = 0010			      C _CW_UM                      EQU         10000b
 = 0008			      C _CW_OM                      EQU          1000b
 = 0004			      C _CW_ZM                      EQU           100b
 = 0002			      C _CW_DM                      EQU            10b
 = 0001			      C _CW_IM                      EQU             1b
			      C 
 = 8000			      C _SW_BUSY                    EQU 1000000000000000b
 = 4000			      C _SW_C3                      EQU  100000000000000b
 = 3800			      C _SW_TOS                     EQU   11100000000000b
 = 0400			      C _SW_C2                      EQU      10000000000b
 = 0200			      C _SW_C1                      EQU       1000000000b
 = 0100			      C _SW_C0                      EQU        100000000b
 = 0080			      C _SW_ERROR_SUMMARY           EQU         10000000b
 = 0040			      C _SW_STACK_FAULT             EQU          1000000b
 = 0020			      C _SW_PE                      EQU           100000b
 = 0010			      C _SW_UE                      EQU            10000b
 = 0008			      C _SW_OE                      EQU             1000b
 = 0004			      C _SW_ZE                      EQU              100b
 = 0002			      C _SW_DE                      EQU               10b
 = 0001			      C _SW_IE                      EQU                1b
			      C 
			      C 
			      C 
			      C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			      C ; ³ GDT ENTRIES ³
			      C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 = 0008			      C     _sIDT                       EQU 1 * 8       ; IDT
 = 0010			      C     _sGDT                       EQU 2 * 8       ; GDT
 = 0018			      C     _sSTACK                     EQU 3 * 8       ; STACK
 = 0020			      C     _sCODE                      EQU 4 * 8       ; kernel CODE for kernel code
 = 0048			      C     _sDATA                      EQU 9 * 8       ; kernel DATA selector for kernel data
 = 0028			      C     _sGRAPHICS                  EQU 5 * 8       ; Graphics video (0a0000h)
 = 0030			      C     _sMONO                      EQU 6 * 8       ; Mono video (0b0000h)
 = 0038			      C     _sVGA                       EQU 7 * 8       ; VGA video (0b8000h)
 = 0040			      C     _sALL_MEM                   EQU 8 * 8       ; All memory (for debugging)
			      C     ; 9 is above, _sDATA
 = 0050			      C     _sEXODUS_MEM                EQU 10 * 8      ; Exodus assigned memory
 = 0058			      C     _sEXODUS_PORTS              EQU 11 * 8      ; Exodus assigned ports
 = 0060			      C     _sEXODUS_INTS               EQU 12 * 8      ; Exodus assigned ints
			      C     ;_sNOT_USED                                 ; available
 = 0070			      C     _sEXODUS_TSS                EQU 14 * 8      ; Exodus TSS
 = 0078			      C     _sEXODUS_TASK_GATE          EQU 15 * 8      ; Exodus kernel task gate (points to _sEXODUS_TSS)
 = 0080			      C     _sEXODUS_SLAVE_TSS          EQU 16 * 8      ; Exodus Slave TSS
 = 0088			      C     _sEXODUS_SLAVE_TASK_GATE    EQU 17 * 8      ; Exodus kernel slave task gate (points to _sEXODUS_SLAVE_TSS)
			      C     ;_sNOT USED
 = 0098			      C     _sPRIMATIVES                EQU 19 * 8      ; Primative structure for natives
 = 00A0			      C     _sPRIMATIVE_LOAD_INFO       EQU 20 * 8      ; Primative load information (for reporting on each driver)
 = 00A8			      C     _sSYSTEM                    EQU 21 * 8      ; Exodus system memory
 = 00B0			      C     _sEXODUS_REQUESTOR          EQU 22 * 8      ; Call gate to Exodus's requestor() function
 = 00B8			      C     _sSYSTEM_RING1              EQU 23 * 8      ; Exodus system memory for ring-1 apps
 = 00C0			      C     _sSYSTEM_RING2              EQU 24 * 8      ; Exodus system memory for ring-2 apps
 = 00C8			      C     _sSYSTEM_RING3              EQU 25 * 8      ; Exodus system memory for ring-3 apps
 = 00D0			      C     _sDEBI_screen               EQU 26 * 8      ; low-level DEBI debugger's save screen buffer
 = 00D8			      C     _sDEBI_memory               EQU 27 * 8      ; low-level DEBI debugger's memory
 = 00E0			      C     _sFLOPPY_TRACK              EQU 28 * 8      ; Floppy disk data I/O for one full track
 = 00E8			      C     _sVGA_BACKUP                EQU 29 * 8      ; VGA video (060000h, used when in a graphics mode so writes
			      C                                                 ;  to the text screen are still valid)
 = 00F0			      C     _sDEBI_screen2              EQU 30 * 8      ; low-level DEBI debugger's save screen buffer2 (for popups and menus)
 = 00F8			      C     _sDEBI_temp                 EQU 31 * 8      ; low-level DEBI debugger's temporary selector (used for various things)
 = 0100			      C     _sEXODUS_OBJECTS            EQU 32 * 8      ; Exodus objects
 = 0108			      C     _sTASK_SWITCH_TSS           EQU 33 * 8      ; Task Manager's switch_task() function
 = 0110			      C     _sTASK_SWITCH_TASK_GATE     EQU 34 * 8      ; Task Manager's task gate (points to _sTASK_SWITCH_TSS)
 = 0118			      C     _sTASK_STACK                EQU 35 * 8      ; Task Manger task's stack
 = 0120			      C     _sSTACK0                    EQU 36 * 8      ; Exodus Stack 0
 = 0128			      C     _sSTACK1                    EQU 37 * 8      ; Exodus Stack 1
 = 0130			      C     _sSTACK2                    EQU 38 * 8      ; Exodus Stack 2
 = 0138			      C     _sDEBI_dt                   EQU 39 * 8      ; low-level DEBI debugger's DT storage
 = 0140			      C     _sDEBI_np                   EQU 40 * 8      ; low-level DEBI debugger's NP storage
 = 0148			      C     _sDEBI_rp                   EQU 41 * 8      ; low-level DEBI debugger's RP storage
			      C 
			      C   ; Variable base/limit GDT slots setup in INIT32.ASP
 = 0190			      C     _sEXODUS_INI                EQU 50 * 8      ; Holds the parsed EXODUS.INI sructure
 = 0198			      C     _sEXODUS_INI_ERRORS         EQU 51 * 8      ; Holds any errors found while parsing EXODUS.INI
 = 01A0			      C     _sTASK_SYSTEM               EQU 52 * 8      ; Holds all tasks
			      C 
 = 5DA0			      C     _cgTEMP_PRIMATIVE_MAIN      EQU 2996 * 8
 = 5DA8			      C     _cgTEMP_PRIMATIVE_REQUESTOR EQU 2997 * 8
 = 5DB0			      C     _csTEMP_PRIMATIVE           EQU 2998 * 8
 = 5DB8			      C     _dsTEMP_PRIMATIVE           EQU 2999 * 8
			      C 
			      C 
			      C 
			      C ; ÚÄÄÄÄÄÄÄÄÄÄÄ¿
			      C ; ³ CONSTANTS ³
			      C ; ÀÄÄÄÄÄÄÄÄÄÄÄÙ
 = 00C8			      C     _MIN_PRIMATIVE              EQU 200                             ; Start of the primatives
 = 0BB3			      C     _MAX_PRIMATIVE              EQU 2995                            ; End of the primatives
 = 0FFF			      C     _lastGDT                    EQU 4095                            ; Last valid GDT in the GDT
 = 0032			      C     _firstASSIGNMENT            EQU 50                              ; The first Exodus assigned GDT entry for various items
 = 00C7			      C     _lastASSIGNMENT             EQU 199                             ; The last Exodus assigned GDT entry for various items
 = 0BB8			      C     _firstUSER_ASSIGNMENT       EQU 3000
 = 0FFF			      C     _lastUSER_ASSIGNMENT        EQU 4095
 = 00C7			      C     _sGDT_init                  EQU 199                             ; Only initialize the first 199 GDT entries
			      C 
			      C 
			      C   ; Required memory structures for Exodus
			      C   ; Refer to Bootup(internal) document for definitive memory locations
 = 0008A000		      C     _sIDT_base                  EQU 8a000h
 = 0800			      C     _sIDT_limit                 EQU 800h
 = 0800			      C     _sGDT_base                  EQU 0800h
 = 8000			      C     _sGDT_limit                 EQU 8000h
 = 00098000		      C     _sSTACK_base                EQU 98000h
 = 8000			      C     _sSTACK_limit               EQU 8000h
 = 00010000		      C     _sCODE_base                 EQU 10000h
 = 00040000		      C     _sCODE_limit                EQU 40000h
 = 00010000		      C     _sDATA_base                 EQU 10000h
 = 00030000		      C     _sDATA_limit                EQU 30000h
 = 000A0000		      C     _sGRAPHICS_base             EQU 0a0000h
 = 00010000		      C     _sGRAPHICS_limit            EQU 10000h
 = 000B0000		      C     _sMONO_base                 EQU 0b0000h
 = 8000			      C     _sMONO_limit                EQU 8000h
 = 000B8000		      C     _sVGA_base                  EQU 0b8000h     ; Also, see _sVGA_BACKUP_ below
 = 8000			      C     _sVGA_limit                 EQU 8000h
 = 0000			      C     _sALL_MEM_base              EQU 0
 = FFFFFFFF		      C     _sALL_MEM_limit             EQU 0ffffffffh
 = 00070C00		      C     _sEXODUS_MEM_base           EQU 70c00h
 = 4000			      C     _sEXODUS_MEM_limit          EQU 4000h
 = 0006CC00		      C     _sEXODUS_PORTS_base         EQU 6cc00h
 = 4000			      C     _sEXODUS_PORTS_limit        EQU 4000h
 = 00097E00		      C     _sEXODUS_INTS_base          EQU 97e00h
 = 0200			      C     _sEXODUS_INTS_limit         EQU 200h
 = 00068100		      C     _sEXODUS_TSS_base           EQU 68100h
 = 0100			      C     _sEXODUS_TSS_limit          EQU 100h        ; 256 bytes
			      C    ;_sEXODUS_TASK_GATE          EQU task gate pointing to _sEXODUS_TSS
 = 00068200		      C     _sEXODUS_SLAVE_TSS_base     EQU 68200h
 = 0100			      C     _sEXODUS_SLAVE_TSS_limit    EQU 100h        ; 256 bytes
 = 0008D380		      C     _sPRIMATIVES_base           EQU 8d380h
 = 4000			      C     _sPRIMATIVES_limit          EQU 4000h       ; 16k
 = 0008C380		      C     _sPRIMATIVE_LOAD_INFO_base  EQU 8c380h
 = 1000			      C     _sPRIMATIVE_LOAD_INFO_limit EQU 1000h       ; 4k
 = 00089400		      C     _sSYSTEM_base               EQU 89400h
 = 0C00			      C     _sSYSTEM_limit              EQU 0c00h       ; 3k
 = 0800			      C     _sSYSTEM_USER_limit         EQU 0800h       ; 2k
 = 00281400		      C     _sDEBI_screen_base          EQU 281400h                         ; ; ; ; ; Added 2 MB, 02/26/2009 - RCH
 = 8000			      C     _sDEBI_screen_limit         EQU 8000h       ; 32k
 = 00279400		      C     _sDEBI_memory_base          EQU 279400h                         ; ; ; ; ; Added 2 MB, 02/26/2009 - RCH
 = 8000			      C     _sDEBI_memory_limit         EQU 8000h       ; 32k
 = 00074C00		      C     _sFLOPPY_TRACK_base         EQU 74c00h
 = 4800			      C     _sFLOPPY_TRACK_limit        EQU 4800h       ; 512 bytes per sector * 18 sectors * 2 sides = 18k
 = 00060000		      C     _sVGA_BACKUP_base           EQU 60000h      ; Note, the backup area is used when in graphics modes that use a0000h
 = 8000			      C     _sVGA_BACKUP_limit          EQU 8000h       ; so all video writes to the text window are still saved
 = 00258000		      C     _sDEBI_screen2_base         EQU 258000h
 = 00028000		      C     _sDEBI_screen2_limit        EQU 28000h       ; 32k
 = 00068000		      C     _sTASK_SWITCH_TSS_base      EQU 68000h
 = 0100			      C     _sTASK_SWITCH_TSS_limit     EQU 100h        ; 256 bytes
 = 00220000		      C     _sTASK_STACK_base           EQU 220000h                         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 8000			      C     _sTASK_STACK_limit          EQU 8000h       ; 32k
 = 00095380		      C     _sSTACK0_base               EQU 95380h
 = 2000			      C     _sSTACK0_limit              EQU 2000h       ; 8k
 = 00093380		      C     _sSTACK1_base               EQU 93380h
 = 2000			      C     _sSTACK1_limit              EQU 2000h       ; 8k
 = 00091380		      C     _sSTACK2_base               EQU 91380h
 = 2000			      C     _sSTACK2_limit              EQU 2000h       ; 8k
 = 00240000		      C     _sDEBI_dt_base              EQU 240000h                         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 8000			      C     _sDEBI_dt_limit             EQU 8000h       ; 32k
 = 00248000		      C     _sDEBI_np_base              EQU 248000h                         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 8000			      C     _sDEBI_np_limit             EQU 8000h       ; 32k
 = 00250000		      C     _sDEBI_rp_base              EQU 250000h                         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 8000			      C     _sDEBI_rp_limit             EQU 8000h       ; 32k
			      C 
 = 00050000		      C     _sEXODUS_OBJECTS_base       EQU 50000h
 = 8000			      C     _sEXODUS_OBJECTS_limit      EQU 8000h       ; 32k
 = 00200000		      C     _sEXODUS_INI_base           EQU 200000h     ; 1MB               ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 00010000		      C     _sEXODUS_INI_limit          EQU 10000h      ; 64k
 = 00210000		      C     _sEXODUS_INI_ERRORS_base    EQU 210000h     ; 1MB + 64k         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 4000			      C     _sEXODUS_INI_ERRORS_limit   EQU 4000h       ; 16k
 = 00210000		      C     _sTASK_SYSTEM_base          EQU 210000h     ; 1MB + 64k         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 00010000		      C     _sTASK_SYSTEM_limit         EQU 010000h     ; 64k
			      C 
			      C 
			      C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			      C ; ³ BOOT DT STRUCTURE ³
			      C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 = 0000			      C     _BOOT_DT_object_type        EQU 0
 = 0001			      C     _BOOT_DT_days               EQU 1
 = 0005			      C     _BOOT_DT_seconds            EQU 5
 = 0008			      C     _BOOT_DT_rp_offset          EQU 8
 = 000A			      C     _BOOT_DT_entry_type         EQU 10
 = 000B			      C     _BOOT_DT_np_offset          EQU 11
			      C 
			      C 
			      C 
			      C 
			      C 
			      C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			      C ; ³ BOOT PARAMETER BLOCK STRUCTURE ³
			      C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 = 0000			      C     _BOOT_PB_size               EQU 0
 = 0004			      C     _BOOT_PB_main               EQU 4
 = 0008			      C     _BOOT_PB_requestor          EQU 8
 = 000C			      C     _BOOT_PB_start_head         EQU 12
 = 000D			      C     _BOOT_PB_start_track        EQU 13
 = 000E			      C     _BOOT_PB_start_sector       EQU 14
 = 0010			      C     _BOOT_PB_end_head           EQU 16
 = 0011			      C     _BOOT_PB_end_track          EQU 17
 = 0012			      C     _BOOT_PB_end_sector         EQU 18
 = 0014			      C     _BOOT_PB_entry_type         EQU 20
 = 0016			      C     _BOOT_PB_linear_offset      EQU 22
 = 001A			      C     _BOOT_PB_dt_offset          EQU 26
 = 001C			      C     _BOOT_PB_crc16              EQU 28
 = 0020			      C     _BOOT_PB_structure_size     EQU 32
			      C 
			      C 
			      C 
			      C 
			      C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			      C ; ³ EXODUS.INI STRUCTURES ³
			      C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 = 0000			      C     _EXODUS_INI_FIRST_BRACKET       EQU 0
 = 0004			      C     _EXODUS_INI_TOTAL_BYTES         EQU 4
 = 0008			      C     _EXODUS_INI_TOTAL_BRACKET_GROUPS EQU 8
 = 000C			      C     _EXODUS_INI_TOTAL_PAREN_CASKS   EQU 12
 = 0010			      C     _EXODUS_INI_HEADER_LENGTH       EQU 16
			      C 
 = 0000			      C     _EXODUS_BRACKET_NEXT            EQU 0
 = 0004			      C     _EXODUS_BRACKET_PAREN_CASKS     EQU 4
 = 0008			      C     _EXODUS_BRACKET_TOTAL_PARENS    EQU 8
 = 000C			      C     _EXODUS_BRACKET_NAME            EQU 12
 = 0010			      C     _EXODUS_BRACKET_HANDLE          EQU 16
 = 0014			      C     _EXODUS_BRACKET_REQUESTOR       EQU 20
 = 0016			      C     _EXODUS_BRACKET_REQUESTOR_FUNC  EQU 22
 = 001A			      C     _EXODUS_BRACKET_SCRATCH_AREA    EQU 26
 = 001E			      C     _EXODUS_BRACKET_LENGTH          EQU 30
			      C 
 = 0000			      C     _EXODUS_PAREN_NEXT              EQU 0
 = 0004			      C     _EXODUS_PAREN_NEXT_SAME_LINE    EQU 4
 = 0008			      C     _EXODUS_PAREN_DATA_ITEMS        EQU 8
 = 000C			      C     _EXODUS_PAREN_TOTAL_DATA_ITEMS  EQU 12
 = 0010			      C     _EXODUS_PAREN_SOURCE_LINE       EQU 16
 = 0014			      C     _EXODUS_PAREN_SOURCE_LINE_LENGTH EQU 20
 = 0018			      C     _EXODUS_PAREN_HANDLE            EQU 24
 = 001A			      C     _EXODUS_PAREN_REQUESTOR         EQU 26
 = 001E			      C     _EXODUS_PAREN_REQUESTOR_FUNC    EQU 30
 = 0022			      C     _EXODUS_PAREN_SCRATCH_AREA      EQU 34
 = 0026			      C     _EXODUS_PAREN_LENGTH            EQU 38
			      C 
 = 0000			      C     _EXODUS_DATA_NEXT               EQU 0
 = 0004			      C     _EXODUS_DATA_DATA_ITEM_SOURCE   EQU 4
 = 0008			      C     _EXODUS_DATA_DATA_ITEM_LENGTH   EQU 8
 = 000C			      C     _EXODUS_DATA_LENGTH             EQU 12
			      C 
			      C 
			      C 
			      C 
			      C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			      C ; ³ EXODUS xxx STRUCTURES ³
			      C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 = 0000			      C     _EXODUS_MEM_type                EQU 0
 = 0004			      C     _EXODUS_MEM_base                EQU 4
 = 0008			      C     _EXODUS_MEM_limit               EQU 8
 = 000C			      C     _EXODUS_MEM_gdt                 EQU 12
 = 000E			      C     _EXODUS_MEM_ldt                 EQU 14
 = 0010			      C     _EXODUS_MEM_size                EQU 16
			      C 
 = 0010			      C     _EXODUS_PORTS_size              EQU 16
			      C 
 = 0002			      C     _EXODUS_INTS_size               EQU 2
			      C 
			      C 
			      C 
			      C 
			      C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			      C ; ³ EXODUS SYSTEM MEMORY ³
			      C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			      C ; Note, when updates are made here they need to be reflected in INF\SYSTEM.INF
			      C ; Note, when updates are made here and INF\SYSTEM.INF, the "Exodus Quick Reference" manual needs to be updated
 = 0000			      C     _SYSTEM_SECONDS_SINCE_BOOTUP    EQU 0                           ; dword
 = 0004			      C     _SYSTEM_SECONDS_SINCE_MIDNIGHT  EQU 4                           ; dword
 = 0008			      C     _SYSTEM_HOURS                   EQU 8                           ; byte
 = 0009			      C     _SYSTEM_MINUTES                 EQU 9                           ; byte
 = 000A			      C     _SYSTEM_SECONDS                 EQU 10                          ; byte
 = 000B			      C     _SYSTEM_182S_OF_A_SECOND        EQU 11                          ; byte
 = 000C			      C     _SYSTEM_DAY                     EQU 12                          ; byte
 = 000D			      C     _SYSTEM_MONTH                   EQU 13                          ; byte
 = 000E			      C     _SYSTEM_YEAR                    EQU 14                          ; word
 = 0010			      C     _SYSTEM_DAY_OF_YEAR             EQU 16                          ; word
 = 0012			      C     _SYSTEM_BUILD                   EQU 18                          ; 10-byte string in the format: "mm.dd.yyyy"
 = 001C			      C     _SYSTEM_TOTAL_MEMORY            EQU 28                          ; dword, total ram in bytes
 = 0020			      C     _SYSTEM_VGA_HORIZONTAL          EQU 32                          ; word (pixels-graphics, or columns-text)
 = 0022			      C     _SYSTEM_VGA_VERTICAL            EQU 34                          ; word (pixels-graphics, or rows-text)
 = 0024			      C     _SYSTEM_VGA_VIDEO_MODE          EQU 36                          ; byte (0-graphics, 1-text)
 = 0025			      C     _SYSTEM_MONO_VIDEO_MODE         EQU 37                          ; byte (0-graphics, 1-text, 0ffh-Unknown)
			      C 
			      C   ; Non-user accessible system memory areas (Exodus internal, hence the use of the _i_)
 = 0800			      C     _SYSTEM_i_FATAL                 EQU 2048                        ; dword
 = 0804			      C     _SYSTEM_i_TASKS_CREATED         EQU 2052                        ; dword
 = 0808			      C     _SYSTEM_i_TASKS_BY_USER         EQU 2056                        ; dword
 = 080C			      C     _SYSTEM_i_TASKS_BY_ERROR        EQU 2060                        ; dword
 = 0810			      C     _SYSTEM_i_IRQ6_INDICATOR        EQU 2064                        ; byte, IRQ6 indicator (changes each time an IRQ6 is signaled)
 = 0811			      C     _SYSTEM_i_IRQ6_INDICATOR_LAST   EQU 2065                        ; byte, IRQ6 indicator previous, used to see when an IRQ6 is signaled
 = 0812			      C     _SYSTEM_i_BASE                  EQU 2066                        ; dword
 = 0816			      C     _SYSTEM_i_LIMIT                 EQU 2070                        ; dword
 = 081A			      C     _SYSTEM_i_DWORD_TO_COPY         EQU 2074                        ; word
 = 081C			      C     _SYSTEM_i_LAST_GDT_REFERENCED   EQU 2076                        ; qword
 = 0824			      C     _SYSTEM_i_CODE_GDT_OFFSET       EQU 2084                        ; dword (used temporarily during native primative install)
 = 0828			      C     _SYSTEM_i_DATA_GDT_OFFSET       EQU 2088                        ; dword (used temporarily during native primative install)
 = 082C			      C     _SYSTEM_i_MAIN_GDT_OFFSET       EQU 2092                        ; dword (used temporarily during native primative install)
 = 0830			      C     _SYSTEM_i_REQUESTOR_GDT_OFFSET  EQU 2096                        ; dword (used temporarily during native primative install)
 = 0834			      C     _SYSTEM_i_GDT_TO_ASSIGN         EQU 2100                        ; word (used various places to assign GDT entries)
 = 0836			      C     _SYSTEM_i_USER_GDT_TO_ASSIGN    EQU 2102                        ; word (used various places to assign USER Program GDTs)
			      C   ; Next offset is 2104
			      C 
			      C 
			      C   ; These scratch items exist from end of memory down
 = 0BF8			      C     _SYSTEM_i_SCRATCH_DWORD2        EQU 3064                        ; dword (used various places as a scratch buffer)
 = 0BFC			      C     _SYSTEM_i_SCRATCH_DWORD1        EQU 3068                        ; dword (used various places as a scratch buffer)
			      C 
			      C 
			      C 
			      C 
			      C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			      C ; ³ BOCHS SUPPORT ³
			      C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			      C ; These equates are used to communicate via INT 0FFh
			      C ; Values here are in ecx, with edx being used for data information.
			      C ; Values in eax must be
 = 12345678		      C     _BOCHS1                         EQU 12345678h
 = 87654321		      C     _BOCHS2                         EQU 87654321h
 = 0000			      C     _BOCHS_GET_MONO_MOUSE_XY        EQU 0
 = 0001			      C     _BOCHS_GET_MONO_CURSOR          EQU 1
			      C 
				INCLUDE \exodus\source\common\errors.asp                            ; Error codes used throughout
			      C ; errors.asp
			      C 
			      C ; FDC error codes
 = 0001			      C _FDC_INVALID_PARAMETERS         EQU 1
 = 0002			      C _FDC_SEEK_FAILED                EQU 2
 = 0003			      C _FDC_TIMEOUT                    EQU 3
 = 0004			      C _FDC_INVALID_DRIVE              EQU 4
 = 0005			      C _FDC_UNKNOWN_DRIVE_TYPE         EQU 5
 = 0006			      C _FDC_INVALID_MEDIA              EQU 6
 = 0007			      C _FDC_SECTOR_NOT_FOUND           EQU 7
			      C 
			      C 
			      C ; DISK error codes
 = 0001			      C _DISK_INVALID_DRIVE             EQU 1
 = 0002			      C _DISK_INVALID_REQUEST           EQU 2
 = 0003			      C _DISK_INVALID_PARAMETERS        EQU 3
			      C 
			      C 
			      C ; Requestor error codes, general
 = 0001			      C _RQ_UNKNOWN_REQUEST             EQU 1
			      C 
			      C 
			      C ; Requestor error codes, specific
 = 03E8			      C _RQ_iDISK_DRIVE_NOT_FOUND       EQU 1000
			      C 
			      C 
			      C ; OBJECT system error codes
 = 0000			      C _TASK_NOT_FOUND                 EQU 0
 = 0001			      C _OBJECT_NOT_FOUND               EQU 1
 = 0002			      C _UNKNOWN_OBJECT_TYPE            EQU 2
 = 0003			      C _UNKNOWN_OBJECT_PROPERTY        EQU 3
 = 0004			      C _UNKNOWN_OBJECT_EVENT           EQU 4
			      C 
				INCLUDE equates.asp
			      C ; equates.asp
			      C ;
			      C ; Exodus equates used by BOOTUP
			      C ;
			      C 
 = 0000			      C _NO                     EQU 0
 = 0001			      C _YES                    EQU 1
			      C 

				;;
				;;  úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
				;;  úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
				;;  úúúÛÛúúúúúÛÛÛúúúúúúúúúúúÛÛÛúúúúúúúúÛÛúúúúúúÛúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúÛÛÛúúúúúúúúúú
				;;  úúÛÛÛúúúúÛÛúúúúúúúúúúúúúúÛÛúúúúúúúúÛÛúúúúúÛÛúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúÛÛúúúúúúúúúú
				;;  úÛÛÛÛúúúÛÛúúúúúúúúúúúúúúúÛÛúúúúúúúúúúúúúúúÛÛúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúÛÛúúúúúúúúúú
				;;  úúúÛÛúúúÛÛúúúúúúúúúúúúúúúÛÛÛÛúúúúúÛÛÛúúúÛÛÛÛÛÛúúúúúúúúúúúÛÛÛÛÛúúúÛÛÛÛÛúúúúÛÛÛÛúúúÛÛÛÛÛúú
				;;  úúúÛÛúúúÛÛÛÛÛÛúúúúúúúúúúúÛÛúÛÛúúúúúÛÛúúúúúÛÛúúúúúúúúúúúúÛÛúúúÛÛúÛÛúúúÛÛúúÛÛúÛÛúúÛÛúúúÛÛú
				;;  úúúÛÛúúúÛÛúúúÛÛúúúúúúúúúúÛÛúúÛÛúúúúÛÛúúúúúÛÛúúúúúúúúúúúúÛÛúúúúúúÛÛúúúÛÛúÛÛúúÛÛúúÛÛÛÛÛÛÛú
				;;  úúúÛÛúúúÛÛúúúÛÛúúúúúúúúúúÛÛúúÛÛúúúúÛÛúúúúúÛÛúúúúúúúúúúúúÛÛúúúúúúÛÛúúúÛÛúÛÛúúÛÛúúÛÛúúúúúú
				;;  úúúÛÛúúúÛÛúúúÛÛúúúúúúúúúúÛÛúúÛÛúúúúÛÛúúúúúÛÛúÛÛúúúúúúúúúÛÛúúúÛÛúÛÛúúúÛÛúÛÛúúÛÛúúÛÛúúúÛÛú
				;;  úÛÛÛÛÛÛúúÛÛÛÛÛúúúúúúúúúúúÛÛÛÛÛúúúúÛÛÛÛúúúúúÛÛÛúúúúúúúúúúúÛÛÛÛÛúúúÛÛÛÛÛúúúÛÛÛúÛÛúúÛÛÛÛÛúú
				;;  úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
				;;  úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
				;;  úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
				;;
 0000				_TEXT   SEGMENT PUBLIC  'CODE'  USE16
				    ORG 0h
				;;
				;; START OF EXODUS
				;;
				;; ---------------
				;;
				;; During this segment we're in real mode.
				;; All BIOS services are available
				;;
				;; Upon entry:  cx - total # of bytes in boot_parameter_block
				;;             edx - next linear address of free memory (between 010000h and 03ffffh)
				;;         cs:[si] - far ptr to start of parameter_block
				;;      cs:[si-12] - linear address of boot device's DT entry
				;;      cs:[si-08] - linear address of boot device's NP entry
				;;      cs:[si-04] - linear address of boot device's RP entry
				;;

 0000				  start:
				;; Save the parameter block information given by BOOT.COM
 0000  2E: 89 0E 0A95 R		    mov     cs:boot_parameter_count,cx                              ; Number of drivers loaded
 0005  66| 2E: 89 16 0A97 R	    mov     cs:next_linear_address,edx                              ; Next address of free memory in Exodus bootup area
 000B  66| 8B 44 F4		    mov     eax,dword ptr ds:[si-12]
 000F  66| 2E: A3 0A9B R	    mov     cs:boot_dt_linear,eax                                   ; 1st sector of DT
 0014  66| 8B 44 F8		    mov     eax,dword ptr ds:[si-8]
 0018  66| 2E: A3 0A9F R	    mov     cs:boot_np_linear,eax                                   ; 1st sector of NP
 001D  66| 8B 44 FC		    mov     eax,dword ptr ds:[si-4]
 0021  66| 2E: A3 0AA3 R	    mov     cs:boot_rp_linear,eax                                   ; 1st sector of RP
 0026  66| 33 C0		    xor     eax,eax
 0029  66| 81 E6 0000FFFF	    and     esi,0ffffh
 0030  8C D8			    mov     ax,ds
 0032  66| C1 E0 04		    shl     eax,4
 0036  66| 03 C6		    add     eax,esi
 0039  66| 2E: A3 0A91 R	    mov     cs:boot_parameter_block,eax                             ; Linear offset into memory where boot_parameter_block starts
				                                                                    ; * Refer to source\boot.asm for boot_parameter_block info

				;; Setup the data segments for this program
 003E  8C C8			    mov     ax,cs
 0040  8E D8			    mov     ds,ax
 0042  8E C0			    mov     es,ax

				;; Set video mode using BIOS
 0044  B8 0003			    mov     ax,00003h                                               ; Mode 3 = 80x25 color
 0047  CD 10			    int     10h

				;; Turn on high intensity using BIOS
 0049  B8 1003			    mov     ax,1003h                                                ; video high intensity on (instead of blinking)
 004C  32 DB			    xor     bl,bl
 004E  CD 10			    int     10h

				;; Show the bootup identification using BIOS
 0050  BB 00B9			    mov     bx,57+128                                               ; bright blue on bright cyan
 0053  33 D2			    xor     dx,dx
 0055  BD 088B R		    mov     bp,offset bootup_id1
 0058  B9 0050			    mov     cx,sizeof bootup_id1
 005B  32 FF			    xor     bh,bh
 005D  B8 1301			    mov     ax,01301h
 0060  CD 10			    int     10h

 0062  BB 00B9			    mov     bx,57+128                                               ; bright blue on bright cyan
 0065  BA 0100			    mov     dx,00100h
 0068  BD 08DB R		    mov     bp,offset bootup_id2
 006B  B9 0050			    mov     cx,sizeof bootup_id2
 006E  32 FF			    xor     bh,bh
 0070  B8 1301			    mov     ax,01301h
 0073  CD 10			    int     10h

				;; Verify the CRC-16 of the boot files
 0075  BB 0007			    mov     bx,07
 0078  BA 0300			    mov     dx,00300h
 007B  BD 092B R		    mov     bp,offset verifying_crc
 007E  B9 000F			    mov     cx,sizeof verifying_crc
 0081  32 FF			    xor     bh,bh
 0083  B8 1301			    mov     ax,01301h
 0086  CD 10			    int     10h
 0088  E8 007D			    call    verify_crc16

				;; Enable gate A20 via Exodus
 008B  BD 093A R		    mov     bp,offset enabling_gate_a20
 008E  B9 000E			    mov     cx,sizeof enabling_gate_a20
 0091  BB 0007			    mov     bx,07
 0094  BA 0400			    mov     dx,0400h
 0097  B8 1301			    mov     ax,01301h
 009A  CD 10			    int     10h
 009C  E8 018D			    call    enable_gate_a20

				;; Setup environment for protected mode via Exodus
 009F  BD 0948 R		    mov     bp,offset setup_pmode_vars
 00A2  B9 0010			    mov     cx,sizeof setup_pmode_vars
 00A5  BB 0007			    mov     bx,07
 00A8  BA 0500			    mov     dx,0500h
 00AB  B8 1301			    mov     ax,01301h
 00AE  CD 10			    int     10h
 00B0  E8 019C			    call    setup_pmode_variables

				;; Enter protected mode via Exodus
 00B3  BD 0958 R		    mov     bp,offset entering_pmode
 00B6  B9 0019			    mov     cx,sizeof entering_pmode
 00B9  BB 0007			    mov     bx,07
 00BC  BA 0600			    mov     dx,0600h
 00BF  B8 1301			    mov     ax,01301h
 00C2  CD 10			    int     10h

 00C4  FA			    cli                                                             ; Clear interrupts
 00C5  0F 20 C0			    mov     eax,cr0
 00C8  0C 01			    or      al,1
 00CA  0F 22 C0			    mov     cr0,eax
 00CD				;; Ok, we're in protected mode, still 16-bit code segment though
 00CD  EB 00			    jmp     $+2                                                     ; Clear the cache
 00CF  0F 01 1E 0AA7 R		    lidt    fword ptr IDT_ptr                                       ; Load IDT
 00D4  0F 01 16 0AAD R		    lgdt    fword ptr GDT_ptr                                       ; Load GDT
 00D9  33 C0			    xor     ax,ax
 00DB  0F 00 D0			    lldt    ax                                                      ; Load LDT with NULL
 00DE  B8 0070			    mov     ax,_sEXODUS_TSS                                         ; Load TR
 00E1  0F 00 D8			    ltr     ax
				  ; Data segment registers
 00E4  B8 0048			    mov     ax,_sDATA
 00E7  8E D8			    mov     ds,ax
 00E9  8E C0			    mov     es,ax
				  ; Extra segment registers
 00EB  B8 0038			    mov     ax,_sVGA
 00EE  8E E0			    mov     fs,ax
 00F0  B8 0030			    mov     ax,_sMONO
 00F3  8E E8			    mov     gs,ax
				  ; Stack
 00F5  B8 0018			    mov     ax,_sSTACK
 00F8  8E D0			    mov     ss,ax
 00FA  66| BC 00007FFC		    mov     esp,_sSTACK_limit - 4
 0100  FB			    sti

				;; Load the 32-bit _sCODE selector for CS and enter 32-bit code
 0101  68 0020			    push    word ptr _sCODE                                         ; Exodus CODE segment
 0104  68 0AB3 R		    push    word ptr offset end_of_16_bit_segment                   ; EIP
 0107  CB			    retf                                                            ; Execution continues below after "first_pmode_instruction"

				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;
				;; Note:  Each of these include files contains only 16-bit code and/or data.  However, some of them can create 32-bit items.
				;;
				    INCLUDE init16.asp
			      C ; init16.asp
			      C ;
			      C ; Exodus initialization routines
			      C ;
			      C ;  Functions:
			      C ;    ÀÂ verify_crc16                            ; Verify the CRC16 value stored in the bootup entries
			      C ;     Ã enable_gate_a20                         ; Enables gate A20 so we can access all memory
			      C ;     À setup_pmode_variables                   ; Sets up GDT and IDT
			      C ;       ÀÂ create_null_data_descriptor
			      C ;        Ã create_data_descriptor
			      C ;        Ã create_code_descriptor
			      C ;        Ã create_interrupt_descriptor_32_bit   ; Creates a 32-bit descriptor entry
			      C ;        Ã create_interrupt_descriptors
			      C ;        Ã create_exodus_tss_descriptor
			      C ;        Ã create_call_gate_descriptor
			      C ;        À create_task_gate_descriptor
			      C ;
			      C 
			      C 
			      C 
			      C 
 0108			      C verify_crc16    PROC    NEAR
			      C ; This routine scans all of the loaded data to ensure that the calculated CRC matches the CRC stored in the DT
			      C ;
			      C ; Upon entry:   boot_parameter_block - holds the linear address of all the files loaded in memory
			      C ;
			      C ; Upon exit:    This routine is self-terminating.  If there is a CRC error the program is terminated here.
			      C ;
 0108  C8 0002 00	      C     enter   2,0
			      C   ; [bp-2] - item
 010C  66| 60		      C     pushad
 010E  1E		      C     push    ds
 010F  06		      C     push    es
			      C 
			      C 
 0110  66| 8B 36 0A91 R	      C     mov     esi,ds:boot_parameter_block
 0115  66| 46		      C     inc     esi
 0117  66| 8B D6	      C     mov     edx,esi
 011A  66| C1 EA 04	      C     shr     edx,4
 011E  8E DA		      C     mov     ds,dx
 0120  66| 83 E6 0F	      C     and     esi,0fh
			      C   ; Right now, ds:[si] - far ptr to the boot parameter block
 0124  C7 46 FE 0000	      C     mov     word ptr [bp-2],0
			      C     .WHILE (byte ptr ds:[si+_BOOT_PB_entry_type] != 0ffh)
 0129  EB 65		   *	    jmp    @C0001
 012B			   *@C0002:
 012B  8A 44 14		      C         mov     al,byte ptr ds:[si+_BOOT_PB_entry_type]
 012E  D0 E8		      C         shr     al,1
 0130  24 07		      C         and     al,111b
			      C         .IF (al != 011b)
 0132  3C 03		   *	    cmp    al, 003h
 0134  74 54		   *	    je     @C0003
			      C           ; It's not bootup.bin (this program is bootup.bin, and whenever memory variables change the CRC will change,
			      C           ;                      so we don't do any crc calculations on bootup.bin)
 0136  66| 8B 0C	      C             mov     ecx,dword ptr ds:[si+_BOOT_PB_size]
 0139  66| 8B 7C 16	      C             mov     edi,dword ptr ds:[si+_BOOT_PB_linear_offset]
 013D  66| 8B D7	      C             mov     edx,edi
 0140  66| C1 EA 04	      C             shr     edx,4
 0144  8E C2		      C             mov     es,dx
 0146  66| 83 E7 0F	      C             and     edi,0fh
			      C 
			      C           ; Right now, es:[di] - far ptr to start of this entry
			      C           ;                 bx - used for crc16 value
 014A  33 DB		      C             xor     bx,bx
 014C			      C           @@:
 014C  68 A001		      C             push    word ptr 0a001h         ; mask
 014F  32 E4		      C             xor     ah,ah
 0151  26: 8A 05	      C             mov     al,byte ptr es:[di]
 0154  50		      C             push    ax                      ; c
 0155  53		      C             push    bx                      ; crc
			      C 
 0156  E8 009C		      C             call    update_crc16_value
 0159  8B D8		      C             mov     bx,ax
 015B  83 C4 06		      C             add     sp,6
			      C 
 015E  47		      C             inc     di
 015F  E2 EB		      C             loop    @B
			      C           ; Right now, bx is the crc16 value for this entry
 0161  39 5C 1C		      C             cmp     word ptr ds:[si+_BOOT_PB_crc16],bx
 0164  74 24		      C             jz      next_one
			      C 
			      C           ; This CRC value does not match the one on disk
			      C           ; Display a message and then lockup the system
 0166  8C CB		      C             mov     bx,cs
 0168  8E DB		      C             mov     ds,bx
 016A  8E C3		      C             mov     es,bx
			      C 
 016C  8B 46 FE		      C             mov     ax,word ptr [bp-2]
 016F  04 41		      C             add     al,'A'
 0171  A2 09A0 R	      C             mov     crc_error_code[3],al                        ; Store the error code for display
 0174  BB 0007		      C             mov     bx,07
 0177  BA 0400		      C             mov     dx,00400h
 017A  BD 097D R	      C             mov     bp,offset crc_error_start
 017D  B9 0114		      C             mov     cx,offset crc_error_end - offset crc_error_start
 0180  32 FF		      C             xor     bh,bh
 0182  B8 1301		      C             mov     ax,01301h
 0185  CD 10		      C             int     10h
			      C           ; Now that the message is displayed, lock up the system
			      C           ; They have to press reset to fix this error
 0187			      C           @@:
 0187  F4		      C             hlt
 0188  EB FD		      C             jmp     @B
			      C 
			      C         .ENDIF
			      C 
 018A			      C       next_one:
 018A			   *@C0003:
 018A  FF 46 FE		      C         inc     word ptr [bp-2]
 018D  83 C6 20		      C         add     si,_BOOT_PB_structure_size
			      C     .ENDW
 0190			   *@C0001:
 0190  80 7C 14 FF	   *	    cmp    byte ptr ds : [si + _BOOT_PB_entry_type], 0FFh
 0194  75 95		   *	    jne    @C0002
			      C 
 0196  07		      C     pop     es
 0197  1F		      C     pop     ds
 0198  66| 61		      C     popad
 019A  C9		      C     leave
 019B  C3		      C     ret
 019C			      C verify_crc16    ENDP
			      C 
			      C 
			      C 
			      C 
 019C			      C display_crc_comparitive     PROC    NEAR
 019C  32 FF		      C     xor     bh,bh
 019E  BB 0007		      C     mov     bx,07
 01A1  8A 76 FE		      C     mov     dh,byte ptr [bp-2]
 01A4  80 C6 05		      C     add     dh,5
 01A7  32 D2		      C     xor     dl,dl
 01A9  55		      C     push    bp
 01AA  BD 0971 R	      C     mov     bp,offset crc_comparitive
 01AD  B9 000C		      C     mov     cx,sizeof crc_comparitive
 01B0  B8 1301		      C     mov     ax,01301h
 01B3  CD 10		      C     int     10h
 01B5  5D		      C     pop     bp
 01B6  C3		      C     ret
 01B7			      C display_crc_comparitive     ENDP
			      C 
			      C 
			      C 
			      C 
 01B7			      C extract_word_to_ds_di       PROC    NEAR
			      C ; This routine is used to extract the dword
			      C ;
			      C ; Upon entry:   dx - word to extract
			      C ;          ds:[si] - where to store
			      C ;
			      C ; Upon exit:    4 hex characters are stored at ds:[si]
			      C ;
 01B7  57		      C     push    di
 01B8  50		      C     push    ax
			      C 
 01B9  8A C6		      C     mov     al,dh
 01BB  C0 E8 04		      C     shr     al,4
 01BE  E8 0025		      C     call    adjust_al
 01C1  88 05		      C     mov     byte ptr ds:[di],al
 01C3  47		      C     inc     di
			      C 
 01C4  8A C6		      C     mov     al,dh
 01C6  24 0F		      C     and     al,0fh
 01C8  E8 001B		      C     call    adjust_al
 01CB  88 05		      C     mov     byte ptr ds:[di],al
 01CD  47		      C     inc     di
			      C 
 01CE  8A C2		      C     mov     al,dl
 01D0  C0 E8 04		      C     shr     al,4
 01D3  E8 0010		      C     call    adjust_al
 01D6  88 05		      C     mov     byte ptr ds:[di],al
 01D8  47		      C     inc     di
			      C 
 01D9  8A C2		      C     mov     al,dl
 01DB  24 0F		      C     and     al,0fh
 01DD  E8 0006		      C     call    adjust_al
 01E0  88 05		      C     mov     byte ptr ds:[di],al
 01E2  47		      C     inc     di
			      C 
 01E3  58		      C     pop     ax
 01E4  5F		      C     pop     di
 01E5  C3		      C     ret
 01E6			      C extract_word_to_ds_di       ENDP
			      C 
			      C 
			      C 
			      C 
 01E6			      C adjust_al   proc    near
			      C     .IF (al >= 0 && al <= 9)
 01E6  3C 00		   *	    cmp    al, 000h
 01E8  72 08		   *	    jb     @C0006
 01EA  3C 09		   *	    cmp    al, 009h
 01EC  77 04		   *	    ja     @C0006
 01EE  04 30		      C         add     al,'0'
			      C     .ELSE
 01F0  EB 02		   *	    jmp    @C0009
 01F2			   *@C0006:
 01F2  04 57		      C         add     al,'a'-10
			      C     .ENDIF
 01F4			   *@C0009:
 01F4  C3		      C     ret
 01F5			      C adjust_al   endp
			      C 
			      C 
			      C 
			      C 
 01F5			      C update_crc16_value      PROC    NEAR
			      C ; This is the assembly generated by this CRC16 algorithm
			      C ;
			      C ; Upon entry:   On the stack:   mask, c, crc (each a word, in that order)
			      C ;
			      C ; [bp+8] - word, mask
			      C ; [bp+6] - word, c
			      C ; [bp+4] - word, crc
			      C ; [bp+2] - word, ip
			      C ; [bp+0] - word, bp
 01F5  C8 0002 00	      C     enter   2,0
			      C ; [bp-2] - word, i
 01F9  57		      C     push    di
 01FA  56		      C     push    si
 01FB  51		      C     push    cx
			      C 
 01FC  C7 46 FE 0008	      C     mov     word ptr [bp-2],8   ; i
 0201  8B 76 04		      C     mov     si,word ptr [bp+4]  ; crc
 0204  8B 7E 06		      C     mov     di,word ptr [bp+6]  ; c
 0207			      C   F515:
 0207  8B C6		      C     mov     ax,si
 0209  8B CF		      C     mov     cx,di
 020B  32 C1		      C     xor     al,cl
 020D  A8 01		      C     test    al,1
 020F  74 0B		      C     je      I518
 0211  8B C6		      C     mov     ax,si
 0213  D1 E8		      C     shr     ax,1
 0215  33 46 08		      C     xor     ax,word ptr [bp+8]  ; mask
 0218  8B F0		      C     mov     si,ax
 021A  EB 02		      C     jmp     I519
			      C 
 021C			      C   I518:
 021C  D1 EE		      C     shr     si,1
			      C 
 021E			      C   I519:
 021E  D1 EF		      C     shr     di,1
 0220  FF 4E FE		      C     dec     word ptr [bp-2]     ; i
 0223  75 E2		      C     jne     F515
 0225  8B C6		      C     mov     ax,si
			      C 
 0227  59		      C     pop     cx
 0228  5E		      C     pop     si
 0229  5F		      C     pop     di
 022A  C9		      C     leave
 022B  C3		      C     ret
 022C			      C update_crc16_value      ENDP
			      C 
			      C 
			      C 
			      C 
 022C			      C enable_gate_a20     PROC    NEAR
			      C   ;; Clear interrupts
 022C  FA		      C     cli
			      C 
			      C   ;; Take control of gate A20
 022D  33 C9		      C     xor     cx,cx                                                   ; Only loop 64k times
 022F			      C   eg_loop1:
 022F  E4 64		      C     in      al,64h                                                  ; Are we able to send our data yet?
 0231  A8 02		      C     test    al,2
 0233  E0 FA		      C     loopnz  eg_loop1                                                ; No if loop
			      C 
 0235  B0 D1		      C     mov     al,0d1h                                                 ; Send command "get ready to receive Output Port byte"
 0237  E6 64		      C     out     64h,al
			      C 
 0239  33 C9		      C     xor     cx,cx
 023B			      C   eg_loop2:
 023B  E4 64		      C     in      al,64h                                                  ; Are we able to send our data yet?
 023D  A8 02		      C     test    al,2
 023F  E0 FA		      C     loopnz  eg_loop2
			      C 
 0241  B0 33		      C     mov     al,00110011b                                            ; Send "Output Port" byte
 0243  E6 60		      C     out     60h,al                                                  ; Ú7Â6Â5Â4Â3Â2Â1Â0¿
			      C                                                                     ; ³x³x³1³1³x³x³1³1³
 0245  33 C9		      C     xor     cx,cx                                                   ; ÀÂÁÂÁÂÁÂÁÂÁÂÁÂÁÂÙ
 0247			      C   eg_loop3:                                                         ;  ³ ³ ³ ³ ³ ³ ³ ÀÄ system reset (0-reset)
 0247  E4 64		      C     in      al,64h                                                  ;  ³ ³ ³ ³ ³ ³ ÀÄÄÄ gate A20 (1-access above 1MB)
 0249  A8 02		      C     test    al,2                                                    ;  ³ ³ ³ ³ ³ ÀÄÄÄÄÄ mouse data clock
 024B  E0 FA		      C     loopnz  eg_loop3                                                ;  ³ ³ ³ ³ ÀÄÄÄÄÄÄÄ data to mouse
			      C                                                                     ;  ³ ³ ³ ÀÄÄÄÄÄÄÄÄÄ IRQ1 int 71h
			      C   ;; Enable interrupts                                              ;  ³ ³ ÀÄÄÄÄÄÄÄÄÄÄÄ IRQ12 int 74h
 024D  FB		      C     sti                                                             ;  ³ ÀÄÄÄÄÄÄÄÄÄÄÄÄÄ keyboard clock
 024E  C3		      C     ret                                                             ;  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ data to keyboard
 024F			      C enable_gate_a20     ENDP
			      C 
			      C 
			      C 
			      C 
 024F			      C setup_pmode_variables   PROC    NEAR
 024F  1E		      C     push    ds
			      C 
			      C ;; Setup all the IDT entries to point to an "iret"
 0250  B8 8A00		      C     mov     ax,_sIDT_base SHR 4
 0253  8E D8		      C     mov     ds,ax
 0255  66| 33 F6	      C     xor     esi,esi
 0258  E8 04A7		      C     call    create_interrupt_descriptors
			      C 
			      C ;; Setup all the GDT entries to point to a NULL data descriptor
 025B  33 C0		      C     xor     ax,ax
 025D  8E D8		      C     mov     ds,ax
 025F  66| BE 00000800	      C     mov     esi,_sGDT_base                                          ; GDT is defined in common\equates.asp
 0265  B9 00C7		      C     mov     cx,_sGDT_init                                           ; But, only the first 200 entries are initialized at bootup
 0268  66| 56		      C     push    esi
			      C     .REPEAT
 026A			   *@C000A:
 026A  E8 032B		      C         call    create_null_data_descriptor
 026D  66| 83 C6 08	      C         add     esi,8
			      C     .UNTILCXZ
 0271  E2 F7		   *	    loop   @C000A
 0273  66| 5E		      C     pop     esi
			      C 
			      C ;; Now, setup only the ones we'll need for the Exodus bootup.com requirements
			      C ;; Additional entries will be created during initialization and exodus.ini processing
			      C   ;; Slot 1, IDT ptr
 0275  66| B8 00000001	      C     mov     eax,_sIDT / 8                                           ; slot in GDT
 027B  66| BB 0008A000	      C     mov     ebx,_sIDT_base                                          ; base
 0281  66| BA 00000800	      C     mov     edx,_sIDT_limit                                         ; limit
 0287  E8 0320		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 2, GDT ptr
 028A  66| B8 00000002	      C     mov     eax,_sGDT / 8
 0290  66| BB 00000800	      C     mov     ebx,_sGDT_base
 0296  66| BA 00008000	      C     mov     edx,_sGDT_limit
 029C  E8 030B		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 3, STACK ptr
 029F  66| B8 00000003	      C     mov     eax,_sSTACK / 8
 02A5  66| BB 00098000	      C     mov     ebx,_sSTACK_base
 02AB  66| BA 00008000	      C     mov     edx,_sSTACK_limit
 02B1  E8 02F6		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 4, kernel code (this program)
 02B4  66| B8 00000004	      C     mov     eax,_sCODE / 8
 02BA  66| BB 00010000	      C     mov     ebx,_sCODE_base
 02C0  66| BA 00040000	      C     mov     edx,_sCODE_limit
 02C6  E8 03D6		      C     call    create_code_descriptor
			      C 
			      C   ;; Slot 9, kernel data (same area as code, just mapped as read/write)
 02C9  66| B8 00000009	      C     mov     eax,_sDATA / 8
 02CF  66| BB 00010000	      C     mov     ebx,_sDATA_base
 02D5  66| BA 00030000	      C     mov     edx,_sDATA_limit
 02DB  E8 02CC		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 5, data (graphics video memory)
 02DE  66| B8 00000005	      C     mov     eax,_sGRAPHICS / 8
 02E4  66| BB 000A0000	      C     mov     ebx,_sGRAPHICS_base
 02EA  66| BA 00010000	      C     mov     edx,_sGRAPHICS_limit
 02F0  E8 02B7		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 6, data (mono video memory)
 02F3  66| B8 00000006	      C     mov     eax,_sMONO / 8
 02F9  66| BB 000B0000	      C     mov     ebx,_sMONO_base
 02FF  66| BA 00008000	      C     mov     edx,_sMONO_limit
 0305  E8 02A2		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 7, data (vga video memory)
 0308  66| B8 00000007	      C     mov     eax,_sVGA / 8
 030E  66| BB 000B8000	      C     mov     ebx,_sVGA_base
 0314  66| BA 00008000	      C     mov     edx,_sVGA_limit
 031A  E8 028D		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 8, data (access to all memory)
 031D  66| B8 00000008	      C     mov     eax,_sALL_MEM / 8
 0323  66| BB 00000000	      C     mov     ebx,_sALL_MEM_base
 0329  66| BA FFFFFFFF	      C     mov     edx,_sALL_MEM_limit
 032F  E8 0278		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 10, Exodus assigned memory
 0332  66| B8 0000000A	      C     mov     eax,_sEXODUS_MEM / 8
 0338  66| BB 00070C00	      C     mov     ebx,_sEXODUS_MEM_base
 033E  66| BA 00004000	      C     mov     edx,_sEXODUS_MEM_limit
 0344  E8 0263		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 11, Exodus assigned ports
 0347  66| B8 0000000B	      C     mov     eax,_sEXODUS_PORTS / 8
 034D  66| BB 0006CC00	      C     mov     ebx,_sEXODUS_PORTS_base
 0353  66| BA 00004000	      C     mov     edx,_sEXODUS_PORTS_limit
 0359  E8 024E		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 12, Exodus assigned ints
 035C  66| B8 0000000C	      C     mov     eax,_sEXODUS_INTS / 8
 0362  66| BB 00097E00	      C     mov     ebx,_sEXODUS_INTS_base
 0368  66| BA 00000200	      C     mov     edx,_sEXODUS_INTS_limit
 036E  E8 0239		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 13, --Nuserved
			      C   ;; Slot 14, Exodus TSS
 0371  66| B8 0000000E	      C     mov     eax,_sEXODUS_TSS / 8
 0377  66| BB 00068100	      C     mov     ebx,_sEXODUS_TSS_base
 037D  66| B9 00000000 R      C     mov     ecx,offset first_pmode_instruction
 0383  66| BA 00000100	      C     mov     edx,_sEXODUS_TSS_limit
 0389  E8 039A		      C     call    create_exodus_tss_descriptor
			      C 
			      C   ;; Slot 15, Task gate to Exodus TSS
 038C  66| B8 0000000F	      C     mov     eax,_sEXODUS_TASK_GATE / 8                              ; GDT slot
 0392  66| BB 00000070	      C     mov     ebx,_sEXODUS_TSS                                        ; GDT slot of TSS this task gate points to
 0398  E8 04D7		      C     call    create_task_gate_descriptor
			      C 
			      C   ;; Slot 16, Exodus TSS
 039B  66| B8 00000010	      C     mov     eax,_sEXODUS_SLAVE_TSS / 8
 03A1  66| BB 00068200	      C     mov     ebx,_sEXODUS_SLAVE_TSS_base
 03A7  66| B9 00000000 R      C     mov     ecx,offset first_pmode_instruction
 03AD  66| BA 00000100	      C     mov     edx,_sEXODUS_SLAVE_TSS_limit
 03B3  E8 0370		      C     call    create_exodus_tss_descriptor
			      C 
			      C   ;; Slot 17, Task gate to Exodus TSS
 03B6  66| B8 00000011	      C     mov     eax,_sEXODUS_SLAVE_TASK_GATE / 8                        ; GDT slot
 03BC  66| BB 00000080	      C     mov     ebx,_sEXODUS_SLAVE_TSS                                  ; GDT slot of TSS this task gate points to
 03C2  E8 04AD		      C     call    create_task_gate_descriptor
			      C 
			      C   ;; Slot 18, --Nuserved
			      C   ;; Slot 19, PRIMATIVES
 03C5  66| B8 00000013	      C     mov     eax,_sPRIMATIVES / 8
 03CB  66| BB 0008D380	      C     mov     ebx,_sPRIMATIVES_base
 03D1  66| BA 00004000	      C     mov     edx,_sPRIMATIVES_limit
 03D7  E8 01D0		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 20, PRIMATIVES
 03DA  66| B8 00000014	      C     mov     eax,_sPRIMATIVE_LOAD_INFO / 8
 03E0  66| BB 0008C380	      C     mov     ebx,_sPRIMATIVE_LOAD_INFO_base
 03E6  66| BA 00001000	      C     mov     edx,_sPRIMATIVE_LOAD_INFO_limit
 03EC  E8 01BB		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 21, Exodus system memory
 03EF  66| B8 00000015	      C     mov     eax,_sSYSTEM / 8
 03F5  66| BB 00089400	      C     mov     ebx,_sSYSTEM_base
 03FB  66| BA 00000C00	      C     mov     edx,_sSYSTEM_limit
 0401  E8 01A6		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 22, Exodus's requestor() call gate
 0404  66| B8 00000016	      C     mov     eax,_sEXODUS_REQUESTOR / 8
 040A  66| BB 00002C59 R      C     mov     ebx,offset requestor
 0410  66| 33 C9	      C     xor     ecx,ecx
 0413  BA 0020		      C     mov     dx,_sCODE
 0416  E8 0436		      C     call    create_call_gate_descriptor
			      C 
			      C   ;; Slot 23, Exodus system memory (ring-1)
 0419  66| B8 00000017	      C     mov     eax,_sSYSTEM_RING1 / 8
 041F  66| BB 00089400	      C     mov     ebx,_sSYSTEM_base
 0425  66| BA 00000800	      C     mov     edx,_sSYSTEM_USER_limit
 042B  B1 01		      C     mov     cl,1
 042D  E8 01C9		      C     call    create_data_descriptor_pl
			      C 
			      C   ;; Slot 24, Exodus system memory (ring-2)
 0430  66| B8 00000018	      C     mov     eax,_sSYSTEM_RING2 / 8
 0436  66| BB 00089400	      C     mov     ebx,_sSYSTEM_base
 043C  66| BA 00000800	      C     mov     edx,_sSYSTEM_USER_limit
 0442  B1 02		      C     mov     cl,2
 0444  E8 01B2		      C     call    create_data_descriptor_pl
			      C 
			      C   ;; Slot 25, Exodus system memory (ring-3)
 0447  66| B8 00000019	      C     mov     eax,_sSYSTEM_RING3 / 8
 044D  66| BB 00089400	      C     mov     ebx,_sSYSTEM_base
 0453  66| BA 00000800	      C     mov     edx,_sSYSTEM_USER_limit
 0459  B1 03		      C     mov     cl,3
 045B  E8 019B		      C     call    create_data_descriptor_pl
			      C 
			      C   ;; Slot 26, low-level DEBI screen memory
 045E  66| B8 0000001A	      C     mov     eax,_sDEBI_screen / 8
 0464  66| BB 00281400	      C     mov     ebx,_sDEBI_screen_base
 046A  66| BA 00008000	      C     mov     edx,_sDEBI_screen_limit
 0470  E8 0137		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 27, low-level DEBI objects memory
 0473  66| B8 0000001B	      C     mov     eax,_sDEBI_memory / 8
 0479  66| BB 00279400	      C     mov     ebx,_sDEBI_memory_base
 047F  66| BA 00008000	      C     mov     edx,_sDEBI_memory_limit
 0485  E8 0122		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 28, low-level DEBI objects memory
 0488  66| B8 0000001C	      C     mov     eax,_sFLOPPY_TRACK / 8
 048E  66| BB 00074C00	      C     mov     ebx,_sFLOPPY_TRACK_base
 0494  66| BA 00004800	      C     mov     edx,_sFLOPPY_TRACK_limit
 049A  E8 010D		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 29, data (vga backup video memory)
 049D  66| B8 0000001D	      C     mov     eax,_sVGA_BACKUP / 8
 04A3  66| BB 00060000	      C     mov     ebx,_sVGA_BACKUP_base
 04A9  66| BA 00008000	      C     mov     edx,_sVGA_BACKUP_limit
 04AF  E8 00F8		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 30, low-level DEBI screen memory2
 04B2  66| B8 0000001E	      C     mov     eax,_sDEBI_screen2 / 8
 04B8  66| BB 00258000	      C     mov     ebx,_sDEBI_screen2_base
 04BE  66| BA 00028000	      C     mov     edx,_sDEBI_screen2_limit
 04C4  E8 00E3		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 32, Exodus objects
 04C7  66| B8 00000020	      C     mov     eax,_sEXODUS_OBJECTS / 8
 04CD  66| BB 00050000	      C     mov     ebx,_sEXODUS_OBJECTS_base
 04D3  66| BA 00008000	      C     mov     edx,_sEXODUS_OBJECTS_limit
 04D9  E8 00CE		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 33, task_switch() TSS
			      C   ;; Note, the value of ecx is filled in later by the TASK primative itself, for now we just use NULL to get it created
 04DC  66| B8 00000021	      C     mov     eax,_sTASK_SWITCH_TSS / 8
 04E2  66| BB 00068000	      C     mov     ebx,_sTASK_SWITCH_TSS_base
 04E8  66| 33 C9	      C     xor     ecx,ecx                                                 ; starting instruction
 04EB  66| BA 00000100	      C     mov     edx,_sTASK_SWITCH_TSS_limit
 04F1  E8 0232		      C     call    create_exodus_tss_descriptor
			      C 
			      C   ;; Slot 34, Task gate to task_switch()
 04F4  66| B8 00000022	      C     mov     eax,_sTASK_SWITCH_TASK_GATE / 8                         ; GDT slot
 04FA  66| BB 00000108	      C     mov     ebx,_sTASK_SWITCH_TSS                                   ; GDT slot of TSS this task gate points to
 0500  E8 036F		      C     call    create_task_gate_descriptor
			      C 
			      C   ;; Slot 35, Task manager's stack for its TSS
 0503  66| B8 00000023	      C     mov     eax,_sTASK_STACK / 8
 0509  66| BB 00220000	      C     mov     ebx,_sTASK_STACK_base
 050F  66| BA 00008000	      C     mov     edx,_sTASK_STACK_limit
 0515  E8 0092		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 50, Exodus.ini parsing area
 0518  66| B8 00000032	      C     mov     eax,_sEXODUS_INI / 8
 051E  66| BB 00200000	      C     mov     ebx,_sEXODUS_INI_base
 0524  66| BA 00010000	      C     mov     edx,_sEXODUS_INI_limit
 052A  E8 007D		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 36, STACK 0
 052D  66| B8 00000024	      C     mov     eax,_sSTACK0 / 8
 0533  66| BB 00095380	      C     mov     ebx,_sSTACK0_base
 0539  66| BA 00002000	      C     mov     edx,_sSTACK0_limit
 053F  E8 0068		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 37, STACK 1
 0542  66| B8 00000025	      C     mov     eax,_sSTACK1 / 8
 0548  66| BB 00093380	      C     mov     ebx,_sSTACK1_base
 054E  66| BA 00002000	      C     mov     edx,_sSTACK1_limit
 0554  E8 0053		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 38, STACK 2
 0557  66| B8 00000026	      C     mov     eax,_sSTACK2 / 8
 055D  66| BB 00091380	      C     mov     ebx,_sSTACK2_base
 0563  66| BA 00002000	      C     mov     edx,_sSTACK2_limit
 0569  E8 003E		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 51, Exodus.ini parsing area
 056C  66| B8 00000033	      C     mov     eax,_sEXODUS_INI_ERRORS / 8
 0572  66| BB 00210000	      C     mov     ebx,_sEXODUS_INI_ERRORS_base
 0578  66| BA 00004000	      C     mov     edx,_sEXODUS_INI_ERRORS_limit
 057E  E8 0029		      C     call    create_data_descriptor
			      C 
			      C   ;; Slot 52, TASK system
 0581  66| B8 00000034	      C     mov     eax,_sTASK_SYSTEM / 8
 0587  66| BB 00210000	      C     mov     ebx,_sTASK_SYSTEM_base
 058D  66| BA 00010000	      C     mov     edx,_sTASK_SYSTEM_limit
 0593  E8 0014		      C     call    create_data_descriptor
			      C 
 0596  1F		      C     pop     ds
 0597  C3		      C     ret
 0598			      C setup_pmode_variables   ENDP
			      C 
			      C 
			      C 
			      C 
 0598			      C create_null_data_descriptor     PROC    NEAR
			      C ; Upon entry, ds:[esi] - far ptr to memory location for null data descriptor
 0598  67& 66| C7 06	      C     mov     dword ptr [esi+0],00000000000000000000000000000000b
       00000000
 05A0  67& 66| C7 46 04	      C     mov     dword ptr [esi+4],00000000000000001001000000000000b
       00009000
 05A9  C3		      C     ret
 05AA			      C create_null_data_descriptor     ENDP
			      C 
			      C 
			      C 
			      C 
 05AA			      C create_data_descriptor      PROC    NEAR
			      C ; Upon entry, ds:[esi] - far ptr to GDT
			      C ;                  eax - slot # to insert
			      C ;                  ebx - base
			      C ;                  edx - limit
			      C ;
 05AA  66| 60		      C     pushad
			      C 
 05AC  67& 89 5C C6 02	      C     mov     word ptr [esi+eax*8+2],bx                           ; base 0:15
 05B1  66| C1 EB 10	      C     shr     ebx,16
 05B5  67& 88 5C C6 04	      C     mov     byte ptr [esi+eax*8+4],bl                           ; base 16:23
 05BA  66| C1 EB 08	      C     shr     ebx,8
 05BE  67& C6 44 C6 05 92     C     mov     byte ptr [esi+eax*8+5],10010010b                    ; Not accessed, writeable, expand=0, DPL=00
			      C     .IF (edx > 0fffffh)
 05C4  66| 81 FA 000FFFFF  *	    cmp    edx, 0000FFFFFh
 05CB  76 14		   *	    jbe    @C000B
			      C       ; This is a BIG data descriptor (so, we have to change the granularity to 1)
			      C       ; Also, setting the granularity bit makes the limit value be the number of 4k segments
 05CD  66| C1 EA 0C	      C         shr     edx,12                                          ; Divide by 4096
 05D1  67& 89 14 C6	      C         mov     word ptr [esi+eax*8+0],dx                       ; Store the new limit 0:15
 05D5  66| C1 EA 10	      C         shr     edx,16                                          ; Move over to store the next part of the limit
 05D9  80 E2 0F		      C         and     dl,0fh                                          ; Mask off the top nibble (the limit is only 20 bits)
 05DC  80 CA C0		      C         or      dl,11000000b                                    ; make granularity=1, big=1 (high bits in dl)
			      C     .ELSE
 05DF  EB 0B		   *	    jmp    @C000D
 05E1			   *@C000B:
			      C       ; It's a small data descriptor (leave the granularity at 0)
 05E1  67& 89 14 C6	      C         mov     word ptr [esi+eax*8+0],dx                       ; limit 0:15
 05E5  66| C1 EA 10	      C         shr     edx,16
 05E9  80 E2 0F		      C         and     dl,0fh
			      C     .ENDIF
 05EC			   *@C000D:
 05EC  67& 88 54 C6 06	      C     mov     byte ptr [esi+eax*8+6],dl                           ; limit 16:19, Granularity=0/1, big=0/1 (depends on size)
 05F1  67& 88 5C C6 07	      C     mov     byte ptr [esi+eax*8+7],bl                           ; base 24:31
			      C 
 05F6  66| 61		      C     popad
 05F8  C3		      C     ret
 05F9			      C create_data_descriptor      ENDP
			      C 
			      C 
			      C 
			      C 
 05F9			      C create_data_descriptor_pl       PROC    NEAR
			      C ; Upon entry, ds:[esi] - far ptr to GDT
			      C ;                  eax - slot # to insert
			      C ;                  ebx - base
			      C ;                  edx - limit
			      C ;                   cl - privledge level
			      C ;
 05F9  66| 60		      C     pushad
			      C 
 05FB  67& 89 5C C6 02	      C     mov     word ptr [esi+eax*8+2],bx                           ; base 0:15
 0600  66| C1 EB 10	      C     shr     ebx,16
 0604  67& 88 5C C6 04	      C     mov     byte ptr [esi+eax*8+4],bl                           ; base 16:23
 0609  66| C1 EB 08	      C     shr     ebx,8
 060D  C0 E1 05		      C     shl     cl,5
 0610  67& C6 44 C6 05 92     C     mov     byte ptr [esi+eax*8+5],10010010b                    ; Not accessed, writeable, expand=0, (PL=00 for now)
 0616  67& 08 4C C6 05	      C     or      byte ptr [esi+eax*8+5],cl                           ; Apply the privledge level
			      C     .IF (edx > 0fffffh)
 061B  66| 81 FA 000FFFFF  *	    cmp    edx, 0000FFFFFh
 0622  76 14		   *	    jbe    @C000E
			      C       ; This is a BIG data descriptor (so, we have to change the granularity to 1)
			      C       ; Also, setting the granularity bit makes the limit value be the number of 4k segments
 0624  66| C1 EA 0C	      C         shr     edx,12                                          ; Divide by 4096
 0628  67& 89 14 C6	      C         mov     word ptr [esi+eax*8+0],dx                       ; Store the new limit 0:15
 062C  66| C1 EA 10	      C         shr     edx,16                                          ; Move over to store the next part of the limit
 0630  80 E2 0F		      C         and     dl,0fh                                          ; Mask off the top nibble (the limit is only 20 bits)
 0633  80 CA C0		      C         or      dl,11000000b                                    ; make granularity=1, big=1 (high bits in dl)
			      C     .ELSE
 0636  EB 0B		   *	    jmp    @C0010
 0638			   *@C000E:
			      C       ; It's a small data descriptor (leave the granularity at 0)
 0638  67& 89 14 C6	      C         mov     word ptr [esi+eax*8+0],dx                       ; limit 0:15
 063C  66| C1 EA 10	      C         shr     edx,16
 0640  80 E2 0F		      C         and     dl,0fh
			      C     .ENDIF
 0643			   *@C0010:
 0643  67& 88 54 C6 06	      C     mov     byte ptr [esi+eax*8+6],dl                           ; limit 16:19, Granularity=0/1, big=0/1 (depends on size)
 0648  67& 88 5C C6 07	      C     mov     byte ptr [esi+eax*8+7],bl                           ; base 24:31
			      C 
 064D  66| 61		      C     popad
 064F  C3		      C     ret
 0650			      C create_data_descriptor_pl       ENDP
			      C 
			      C 
			      C 
			      C 
 0650			      C create_ldt_descriptor   PROC
			      C ; Upon entry, ds:[esi] - far ptr to GDT
			      C ;                  eax - slot # to insert
			      C ;                  ebx - base
			      C ;                  edx - limit
			      C ;
 0650  66| 60		      C     pushad
			      C 
 0652  67& 89 5C C6 02	      C     mov     word ptr [esi+eax*8+2],bx                           ; base 0:15
 0657  66| C1 EB 10	      C     shr     ebx,16
 065B  67& 88 5C C6 04	      C     mov     byte ptr [esi+eax*8+4],bl                           ; base 16:23
 0660  66| C1 EB 08	      C     shr     ebx,8
 0664  67& C6 44 C6 05 82     C     mov     byte ptr [esi+eax*8+5],10000010b                    ; Not accessed, writeable, expand=0, DPL=00
			      C     .IF (edx > 0fffffh)
 066A  66| 81 FA 000FFFFF  *	    cmp    edx, 0000FFFFFh
 0671  76 14		   *	    jbe    @C0011
			      C       ; This is a BIG data descriptor (so, we have to change the granularity to 1)
			      C       ; Also, setting the granularity bit makes the limit value be the number of 4k segments
 0673  66| C1 EA 0C	      C         shr     edx,12                                          ; Divide by 4096
 0677  67& 89 14 C6	      C         mov     word ptr [esi+eax*8+0],dx                       ; Store the new limit 0:15
 067B  66| C1 EA 10	      C         shr     edx,16                                          ; Move over to store the next part of the limit
 067F  80 E2 0F		      C         and     dl,0fh                                          ; Mask off the top nibble (the limit is only 20 bits)
 0682  80 CA C0		      C         or      dl,11000000b                                    ; make granularity=1, big=1 (high bits in dl)
			      C     .ELSE
 0685  EB 0B		   *	    jmp    @C0013
 0687			   *@C0011:
			      C       ; It's a small data descriptor (leave the granularity at 0)
 0687  67& 89 14 C6	      C         mov     word ptr [esi+eax*8+0],dx                       ; limit 0:15
 068B  66| C1 EA 10	      C         shr     edx,16
 068F  80 E2 0F		      C         and     dl,0fh
			      C     .ENDIF
 0692			   *@C0013:
 0692  67& 88 54 C6 06	      C     mov     byte ptr [esi+eax*8+6],dl                           ; limit 16:19, Granularity=0/1, big=0/1 (depends on size)
 0697  67& 88 5C C6 07	      C     mov     byte ptr [esi+eax*8+7],bl                           ; base 24:31
			      C 
 069C  66| 61		      C     popad
 069E  C3		      C     ret
 069F			      C create_ldt_descriptor   ENDP
			      C 
			      C 
			      C 
			      C 
 069F			      C create_code_descriptor   PROC    NEAR
			      C ; Upon entry, ds:[esi] - far ptr to GDT
			      C ;                  eax - slot # to insert
			      C ;                  ebx - base
			      C ;                  edx - limit
 069F  66| 60		      C     pushad
			      C 
 06A1  67& 89 14 C6	      C     mov     word ptr [esi+eax*8+0],dx                           ; limit 0:15
 06A5  66| C1 EA 10	      C     shr     edx,16
 06A9  67& 89 5C C6 02	      C     mov     word ptr [esi+eax*8+2],bx                           ; base 0:15
 06AE  66| C1 EB 10	      C     shr     ebx,16
 06B2  67& 88 5C C6 04	      C     mov     byte ptr [esi+eax*8+4],bl                           ; base 16:23
 06B7  66| C1 EB 08	      C     shr     ebx,8
 06BB  67& C6 44 C6 05 9A     C     mov     byte ptr [esi+eax*8+5],10011010b                    ; Not accessed, readable, conforming=0, DPL=00
 06C1  80 E2 0F		      C     and     dl,0fh
 06C4  80 CA 40		      C     or      dl,01000000b
 06C7  67& 88 54 C6 06	      C     mov     byte ptr [esi+eax*8+6],dl                           ; limit 16:19, Granularity=0, big=0
 06CC  67& 88 5C C6 07	      C     mov     byte ptr [esi+eax*8+7],bl                           ; base 24:31
			      C 
 06D1  66| 61		      C     popad
 06D3  C3		      C     ret
 06D4			      C create_code_descriptor   ENDP
			      C 
			      C 
			      C 
			      C 
 06D4			      C create_interrupt_descriptor_32_bit      PROC    NEAR
			      C ; Upon entry: eax - interrupt # to update (0-based)
			      C ;        ds:[esi] - far pointer to start of IDT
			      C ;             edx - offset in bx to routine
			      C ;             ebx - segment selector of routine
 06D4  66| 60		      C     pushad
			      C 
 06D6  66| 8B CA	      C     mov     ecx,edx                                             ; Copy 32-bit offset to ecx
 06D9  66| 81 E2 0000FFFF     C     and     edx,00000ffffh                                      ; Keep lower 16-bits in edx
 06E0  66| 81 E1 FFFF0000     C     and     ecx,0ffff0000h                                      ; Keep upper 16-bits in ecx
 06E7  B9 8E00		      C     mov     cx,1000111000000000b                                ; Add lower 16-bits in ecx, 32-bit, DPL=0, Present
 06EA  66| C1 CA 10	      C     ror     edx,16                                              ; Move edx around so we can access the high word
 06EE  8B D3		      C     mov     dx,bx                                               ; Segment selector
 06F0  66| C1 CA 10	      C     ror     edx,16                                              ; Ok, put it back the way it was
			      C 
 06F4  67& 66| 89 14 C6	      C     mov     dword ptr [esi+eax*8+0],edx                         ; Store the IDT descriptor
 06F9  67& 66| 89 4C C6	      C     mov     dword ptr [esi+eax*8+4],ecx
       04
			      C 
 06FF  66| 61		      C     popad
 0701  C3		      C     ret
 0702			      C create_interrupt_descriptor_32_bit      ENDP
			      C 
			      C 
			      C 
			      C 
 0702			      C create_interrupt_descriptors    PROC    NEAR
			      C ; Create all of the interrupt descriptors.  All 256 of them.
			      C ; Upon entry:   ds:[esi] - far ptr to start of IDT
			      C ;
 0702  66| 60		      C     pushad
			      C 
 0704  66| BB 00000020	      C     mov     ebx,_sCODE                                              ; Code segment
 070A  66| BA 00002601 R      C     mov     edx,offset default_interrupt_handler32                  ; Default interrupt handler for 32-bit code
 0710  66| B9 000000FF	      C     mov     ecx,255
 0716  66| B8 00000000	      C     mov     eax,0                                                   ; Start at int 0 in the IDT
 071C			      C   @@:
 071C  E8 FFB5		      C     call    create_interrupt_descriptor_32_bit
 071F  66| 40		      C     inc     eax
 0721  E2 F9		      C     loop    @b
			      C 
 0723  66| 61		      C     popad
 0725  C3		      C     ret
 0726			      C create_interrupt_descriptors    ENDP
			      C 
			      C 
			      C 
			      C 
 0726			      C create_exodus_tss_descriptor    PROC
			      C ; Upon entry, ds:[esi] - far ptr to memory location for the TSS descriptor
			      C ;                  eax - slot # to insert
			      C ;                  ebx - base
			      C ;                  ecx - offset of first instruction
			      C ;                  edx - limit
 0726  06		      C     push    es
 0727  66| 60		      C     pushad
 0729  66| 8B FB	      C     mov     edi,ebx
			      C 
			      C   ; Create the TSS descriptor
 072C  67& 89 14 C6	      C     mov     word ptr [esi+eax*8+0],dx                           ; limit 0:15
 0730  67& 89 5C C6 02	      C     mov     word ptr [esi+eax*8+2],bx                           ; base 0:15
 0735  66| C1 EB 10	      C     shr     ebx,16
 0739  67& 88 5C C6 04	      C     mov     byte ptr [esi+eax*8+4],bl                           ; base 16:23
 073E  66| C1 EB 08	      C     shr     ebx,8
 0742  67& C6 44 C6 05 89     C     mov     byte ptr [esi+eax*8+5],10001001b                    ; present=1:dpl=00:010:busy=1:1
 0748  66| C1 EA 10	      C     shr     edx,16
 074C  80 E2 0F		      C     and     dl,0fh                                              ; make the top nibble be all 0s
 074F  67& 88 54 C6 06	      C     mov     byte ptr [esi+eax*8+6],dl                           ; Granularity=0:0:0:Available=0:limit 16:19
 0754  67& 88 5C C6 07	      C     mov     byte ptr [esi+eax*8+7],bl                           ; base 24:31
			      C 
			      C   ; Write the Exodus variables there
 0759  66| 8B DF	      C     mov     ebx,edi
 075C  66| C1 EB 04	      C     shr     ebx,4
 0760  8E C3		      C     mov     es,bx
 0762  66| 83 E7 0F	      C     and     edi,0fh
			      C   ; Right now, es:[edi] - far ptr the memory location for Exodus
			      C   ; Code segment register
 0766  66| B8 00000020	      C     mov     eax,_sCODE
 076C  67& 66| 26: 89 47      C     mov     dword ptr es:[edi+_TSS_CS],eax                          ; cs
       4C
			      C   ; Instruction Pointer
 0772  67& 66| 26: 89 4F      C     mov     dword ptr es:[edi+_TSS_EIP],ecx                         ; eip
       20
			      C   ; Data segment registers
 0778  66| B8 00000048	      C     mov     eax,_sDATA
 077E  67& 66| 26: 89 47      C     mov     dword ptr es:[edi+_TSS_DS],eax                          ; ds
       54
 0784  67& 66| 26: 89 47      C     mov     dword ptr es:[edi+_TSS_ES],eax                          ; es
       48
			      C   ; Extra segment registers
 078A  66| B8 00000038	      C     mov     eax,_sVGA
 0790  67& 66| 26: 89 47      C     mov     dword ptr es:[edi+_TSS_FS],eax                          ; fs
       58
 0796  66| B8 00000030	      C     mov     eax,_sMONO
 079C  67& 66| 26: 89 47      C     mov     dword ptr es:[edi+_TSS_GS],eax                          ; gs
       5C
			      C   ; Stack
 07A2  66| B8 00000018	      C     mov     eax,_sSTACK
 07A8  67& 66| 26: 89 47      C     mov     dword ptr es:[edi+_TSS_SS],eax                          ; ss
       50
 07AE  67& 66| 26: C7 47      C     mov     dword ptr es:[edi+_TSS_ESP],_sSTACK_limit               ; esp
       38 00008000
			      C   ; Stack 2
 07B8  66| B8 00000130	      C     mov     eax,_sSTACK2
 07BE  67& 66| 26: 89 47      C     mov     dword ptr es:[edi+_TSS_SS2],eax                         ; ss2
       18
 07C4  67& 66| 26: C7 47      C     mov     dword ptr es:[edi+_TSS_ESP2],_sSTACK2_limit             ; esp2
       14 00002000
			      C   ; Stack 1
 07CE  66| B8 00000128	      C     mov     eax,_sSTACK1
 07D4  67& 66| 26: 89 47      C     mov     dword ptr es:[edi+_TSS_SS1],eax                         ; ss1
       10
 07DA  67& 66| 26: C7 47      C     mov     dword ptr es:[edi+_TSS_ESP1],_sSTACK1_limit             ; esp1
       0C 00002000
			      C   ; Stack 0
 07E4  66| B8 00000120	      C     mov     eax,_sSTACK0
 07EA  67& 66| 26: 89 47      C     mov     dword ptr es:[edi+_TSS_SS0],eax                         ; ss0
       08
 07F0  67& 66| 26: C7 47      C     mov     dword ptr es:[edi+_TSS_ESP0],_sSTACK0_limit             ; esp0
       04 00002000
			      C   ; General purpose registers
 07FA  66| 33 C0	      C     xor     eax,eax
 07FD  67& 66| 26: 89 47      C     mov     dword ptr es:[edi+_TSS_EAX],eax                         ; eax
       28
 0803  67& 66| 26: 89 47      C     mov     dword ptr es:[edi+_TSS_ECX],eax                         ; ecx
       2C
 0809  67& 66| 26: 89 47      C     mov     dword ptr es:[edi+_TSS_EDX],eax                         ; edx
       30
 080F  67& 66| 26: 89 47      C     mov     dword ptr es:[edi+_TSS_EBX],eax                         ; ebx
       34
 0815  67& 66| 26: 89 47      C     mov     dword ptr es:[edi+_TSS_EBP],eax                         ; ebp
       3C
 081B  67& 66| 26: 89 47      C     mov     dword ptr es:[edi+_TSS_ESI],eax                         ; esi
       40
 0821  67& 66| 26: 89 47      C     mov     dword ptr es:[edi+_TSS_EDI],eax                         ; edi
       44
 0827  67& 66| 26: 89 47      C     mov     dword ptr es:[edi+_TSS_CR3],eax                         ; CR3, paging (not used in Exodus)
       1C
 082D  67& 66| 26: 89 47      C     mov     dword ptr es:[edi+_TSS_IO_MAP],eax                      ; IO Map Base Address, Trap bit
       66
 0833  67& 66| 26: 89 07      C     mov     dword ptr es:[edi+_TSS_BACK_LINK],eax                   ; Previous task link
 0838  66| 33 C0	      C     xor     eax,eax
 083B  67& 66| 26: 89 47      C     mov     dword ptr es:[edi+_TSS_LDT],eax                         ; LDT segment selector
       60
			      C   ; EFLAGS
 0841  66| 9C		      C     pushfd
 0843  66| 58		      C     pop     eax
 0845  67& 66| 26: 89 47      C     mov     dword ptr es:[edi+_TSS_EFLAGS],eax
       24
			      C 
			      C   ; Finished
 084B  66| 61		      C     popad
 084D  07		      C     pop     es
 084E  C3		      C     ret
 084F			      C create_exodus_tss_descriptor    ENDP
			      C 
			      C 
			      C 
			      C 
			      C 
 084F			      C create_call_gate_descriptor     PROC
			      C ; This routine is used to create a call gate
			      C ; Upon entry: ds:[esi] - far ptr to GDT
			      C ;                  eax - GDT slot # to create/update
			      C ;                  ebx - Offset for start of function
			      C ;                  ecx - Number of dwords to copy
			      C ;                   dx - code segment selector
			      C ;
 084F  66| 60		      C     pushad
			      C 
 0851  67& 89 54 C6 02	      C     mov     word ptr [esi+eax*8+2],dx                               ; code segment selector
 0856  83 E1 1F		      C     and     cx,011111b                                              ; Keep the lower 5 bits
 0859  81 C9 8C00	      C     or      cx,1000110000000000b                                    ; Put parameters in the upper 11 bits
 085D  67& 89 4C C6 04	      C     mov     word ptr [esi+eax*8+4],cx                               ; dword count + constants
 0862  67& 89 1C C6	      C     mov     word ptr [esi+eax*8+0],bx                               ; Lower 16-bits of 32-bit offset
 0866  66| C1 CB 10	      C     ror     ebx,16
 086A  67& 89 5C C6 06	      C     mov     word ptr [esi+eax*8+6],bx                               ; Upper 16-bits of 32-bit offset
			      C 
 086F  66| 61		      C     popad
 0871  C3		      C     ret
 0872			      C create_call_gate_descriptor     ENDP
			      C 
			      C 
			      C 
			      C 
			      C 
 0872			      C create_task_gate_descriptor     PROC
			      C ; Upon entry, ds:[esi] - far ptr to memory location for the TSS descriptor
			      C ;                  eax - slot # to insert
			      C ;                  bx - GDT slot for TSS
 0872  66| 60		      C     pushad
			      C 
 0874  66| C1 E3 10	      C     shl     ebx,16                                              ; Move bx(TSS selector) to high-order word in ebx
 0878  67& 66| 89 1C C6	      C     mov     dword ptr [esi+eax*8+0],ebx
 087D  66| 33 DB	      C     xor     ebx,ebx
 0880  B7 85		      C     mov     bh,10000101b                                        ; present=1:dpl=00:00101
 0882  67& 66| 89 5C C6	      C     mov     dword ptr [esi+eax*8+4],ebx
       04
			      C 
 0888  66| 61		      C     popad
 088A  C3		      C     ret
 088B			      C create_task_gate_descriptor     ENDP
			      C 
				    INCLUDE data16.asp
			      C ; data16.asp
			      C ;
			      C ; Exodus data used in the 16-bit segment
			      C ;
			      C 
			      C ; DATA
 088B 20 45 78 6F 64 75	      C     bootup_id1              db  " Exodus(tm) Operating System                                    10.10.2010.beta "
       73 28 74 6D 29 20
       4F 70 65 72 61 74
       69 6E 67 20 53 79
       73 74 65 6D 20 20
       20 20 20 20 20 20
       20 20 20 20 20 20
       20 20 20 20 20 20
       20 20 20 20 20 20
       20 20 20 20 20 20
       20 20 20 20 31 30
       2E 31 30 2E 32 30
       31 30 2E 62 65 74
       61 20
 08DB 20 28 63 29 20 43	      C     bootup_id2              db  " (c) Copyright Beatleworks, Inc.                                                "
       6F 70 79 72 69 67
       68 74 20 42 65 61
       74 6C 65 77 6F 72
       6B 73 2C 20 49 6E
       63 2E 20 20 20 20
       20 20 20 20 20 20
       20 20 20 20 20 20
       20 20 20 20 20 20
       20 20 20 20 20 20
       20 20 20 20 20 20
       20 20 20 20 20 20
       20 20 20 20 20 20
       20 20
			      C 
 092B FE 20 56 65 72 69	      C     verifying_crc           db  "þ Verifying CRC"
       66 79 69 6E 67 20
       43 52 43
 093A FE 20 45 6E 61 62	      C     enabling_gate_a20       db  "þ Enabling A20"
       6C 69 6E 67 20 41
       32 30
 0948 FE 20 53 65 74 75	      C     setup_pmode_vars        db  "þ Setup IDT, GDT"
       70 20 49 44 54 2C
       20 47 44 54
 0958 FE 20 45 6E 74 65	      C     entering_pmode          db  "þ Entering protected mode"
       72 69 6E 67 20 70
       72 6F 74 65 63 74
       65 64 20 6D 6F 64
       65
			      C 
 0971 0D 0A 78 78 78 78	      C     crc_comparitive         db  13,10,"xxxx  xxxx"
       20 20 78 78 78 78
 097D FE 20 43 52 43 20	      C     crc_error_start         db  "þ CRC error has been detected.",13,10
       65 72 72 6F 72 20
       68 61 73 20 62 65
       65 6E 20 64 65 74
       65 63 74 65 64 2E
       0D 0A
 099D FE 20 28 78 29 20	      C     crc_error_code          db  "þ (x) is the error code",13,10
       69 73 20 74 68 65
       20 65 72 72 6F 72
       20 63 6F 64 65 0D
       0A
 09B6  0D 0A		      C                             db  13,10
 09B8  FE 20 45 78 6F 64      C                             db  "þ Exodus cannot boot up when CRC errors are found.",13,10
       75 73 20 63 61 6E
       6E 6F 74 20 62 6F
       6F 74 20 75 70 20
       77 68 65 6E 20 43
       52 43 20 65 72 72
       6F 72 73 20 61 72
       65 20 66 6F 75 6E
       64 2E 0D 0A
 09EC  FE 20 50 6C 65 61      C                             db  "þ Please correct this error and try again.  You may need",13,10
       73 65 20 63 6F 72
       72 65 63 74 20 74
       68 69 73 20 65 72
       72 6F 72 20 61 6E
       64 20 74 72 79 20
       61 67 61 69 6E 2E
       20 20 59 6F 75 20
       6D 61 79 20 6E 65
       65 64 0D 0A
 0A26  20 20 74 6F 20 63      C                             db  "  to copy system files from the master Exodus Boot Disk.",13,10
       6F 70 79 20 73 79
       73 74 65 6D 20 66
       69 6C 65 73 20 66
       72 6F 6D 20 74 68
       65 20 6D 61 73 74
       65 72 20 45 78 6F
       64 75 73 20 42 6F
       6F 74 20 44 69 73
       6B 2E 0D 0A
 0A60  0D 0A		      C                             db  13,10
 0A62  FE 20 53 79 73 74      C                             db  "þ System halted.  Please press RESET to reboot."
       65 6D 20 68 61 6C
       74 65 64 2E 20 20
       50 6C 65 61 73 65
       20 70 72 65 73 73
       20 52 45 53 45 54
       20 74 6F 20 72 65
       62 6F 6F 74 2E
 0A91			      C     crc_error_end:
			      C 
 0A91 00000000		      C     boot_parameter_block    dd  0
 0A95 0000		      C     boot_parameter_count    dw  0
 0A97 00000000		      C     next_linear_address     dd  0
 0A9B 00000000		      C     boot_dt_linear          dd  0
 0A9F 00000000		      C     boot_np_linear          dd  0
 0AA3 00000000		      C     boot_rp_linear          dd  0
			      C 
 0AA7 0800		      C     IDT_ptr                 dw  _sIDT_limit     ; 256 slots, 8 bytes each = 7ffh bytes
 0AA9  0008A000		      C                             dd  _sIDT_base      ; Linear offset in memory
			      C 
 0AAD 8000		      C     GDT_ptr                 dw  _sGDT_limit     ; 4096 GDT entries
 0AAF  00000800		      C                             dd  _sGDT_base      ; Linear offset
			      C 

 0AB3				end_of_16_bit_segment:
 0AB3				_TEXT   ENDS





				;;
				;;  úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
				;;  úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
				;;  úÛÛÛÛÛúúúÛÛÛÛÛúúúúúúúúúúÛÛÛúúúúúúúúÛÛúúúúúúÛúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúÛÛÛúúúúúúúúúú
				;;  ÛÛúúúÛÛúÛÛúúúÛÛúúúúúúúúúúÛÛúúúúúúúúÛÛúúúúúÛÛúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúÛÛúúúúúúúúúú
				;;  úúúúúÛÛúúúúúúÛÛúúúúúúúúúúÛÛúúúúúúúúúúúúúúúÛÛúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúÛÛúúúúúúúúúú
				;;  úúúúúÛÛúúúúúÛÛúúúúúúúúúúúÛÛÛÛúúúúúÛÛÛúúúÛÛÛÛÛÛúúúúúúúúúúúÛÛÛÛÛúúúÛÛÛÛÛúúúúÛÛÛÛúúúÛÛÛÛÛúú
				;;  úúÛÛÛÛúúúúúÛÛúúúúúúúúúúúúÛÛúÛÛúúúúúÛÛúúúúúÛÛúúúúúúúúúúúúÛÛúúúÛÛúÛÛúúúÛÛúúÛÛúÛÛúúÛÛúúúÛÛú
				;;  úúúúúÛÛúúúÛÛúúúúúúúúúúúúúÛÛúúÛÛúúúúÛÛúúúúúÛÛúúúúúúúúúúúúÛÛúúúúúúÛÛúúúÛÛúÛÛúúÛÛúúÛÛÛÛÛÛÛú
				;;  úúúúúÛÛúúÛÛúúúúúúúúúúúúúúÛÛúúÛÛúúúúÛÛúúúúúÛÛúúúúúúúúúúúúÛÛúúúúúúÛÛúúúÛÛúÛÛúúÛÛúúÛÛúúúúúú
				;;  ÛÛúúúÛÛúÛÛúúúÛÛúúúúúúúúúúÛÛúúÛÛúúúúÛÛúúúúúÛÛúÛÛúúúúúúúúúÛÛúúúÛÛúÛÛúúúÛÛúÛÛúúÛÛúúÛÛúúúÛÛú
				;;  úÛÛÛÛÛúúÛÛÛÛÛÛÛúúúúúúúúúúÛÛÛÛÛúúúúÛÛÛÛúúúúúÛÛÛúúúúúúúúúúúÛÛÛÛÛúúúÛÛÛÛÛúúúÛÛÛúÛÛúúÛÛÛÛÛúú
				;;  úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
				;;  úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
				;;  úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
				;;
 00000000			_TEXT32 SEGMENT PUBLIC BYTE 'CODE' USE32
				    ASSUME NOTHING
				;;
				;; Exodus Bootup Program 32-bit kernel begins here
				;;
				;; -----
				;;
				;; PROTECTED MODE
				;; All services from here on out are internal
				;;

 00000000			first_pmode_instruction:                                            ; Setup segment selectors so they are loaded correctly
				;  ;; Indicate that we entered protected mode OK
				;    mov     dword ptr fs:[6*80*2 + (sizeof entering_pmode * 2)],'KO'      ; Line 6, plus the offset of whatever text was shown


				  ;; Turn off the nested-task flag
 00000000  9C			    pushfd
 00000001  81 24 24		    and     dword ptr ss:[esp],NOT _EFLAGS_NT_MASK
	   FFFFBFFF
 00000008  9D			    popfd


				  ;; Setup some of the required memory blocks
 00000009  E8 0000044C		    call    invSetup_memory_blocks                                  ; init32.asp


				  ;; Setup the Exodus native primatives
 0000000E  E8 00001EAA		    call    invSetup_native_primatives                              ; native.asp

				  ; Note, this is temporarily done manually until the iFDC drivers are installed
 00000013  B0 0C		    mov     al,001100b
 00000015  BA 000003F2		    mov     edx,03f2h
 0000001A  EE			    out     dx,al
				  ;; Parse the exodus.ini file
 0000001B  E8 0000276E		    call    invFind_Exodus_ini                                      ; ini.asp
 00000020  E8 00002C33		    call    invDetermine_Exodus_ini_ownership                       ;


				  ;; Reset the video mode
 00000025  83 EC 14		    sub     esp,20                                                  ; return values (+16=bpp, +12=hp, +8=vp, +4=refresh, +0=status)
 00000028  6A 00		    push    0                                                       ; param: graphics mode
 0000002A  6A 08		    push    8                                                       ; param: bits per pixel
 0000002C  68 00000140		    push    320                                                     ; param: horizontal pixels
 00000031  68 000000C8		    push    200                                                     ; param: vertical pixels
 00000036  6A 3C		    push    60                                                      ; param: refresh rate
 00000038  B8 00000001		    mov     eax,1
 0000003D  2E: FF 1D		    call    fword ptr cs:_VID_requestor
	   00001AE0 R
 00000044  83 C4 14		    add     esp,20                                                  ; get the return values off the stack (we know this works)


				  ;; Turn off the floppy drive motor
				;    mov     al,'A'
				;    call    fword ptr cs:_iFDC_motor_off

				  ;; Transfer control to EXODUS.COM
 00000047  2E: FF 2D		    jmp     fword ptr cs:_EXODUS_dot_com
	   00001AEA R
				;;
				;; END OF PROGRAM
				;;
				;; --------------
				;;
				;; Control will never return here
				;;
				;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
				;;



				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;
				;; Note:  Each of these include files contains only 32-bit code and/or data
				;;

				    INCLUDE init32.asp                                              ; Baseline initialization routines
			      C ; init32.asp
			      C ;
			      C ; Exodus initialization routines (32-bit code)
			      C ;
			      C ;  Functions:
			      C ;     Ã invCreate_call_gate_descriptor32            ; Creates a new call gate in the GDT
			      C ;     Ã invCreate_task_gate_descriptor32            ; Creates a new task gate in the GDT
			      C ;     Ã invCreate_interrupt_task_gate_descriptor32  ; Creates a new task gate in the IDT
			      C ;     Ã invCreate_code_descriptor32                 ; Creates a new code segment descriptor
			      C ;     Ã invCreate_data_descriptor32                 ; Creates a new data segment descriptor
			      C ;     Ã invCreate_tss_descriptor32                  ; Creates a new 32-bit TSS descriptor entry
			      C ;     Ã invCreate_tss32                             ; Initializes a 32-bit TSS
			      C ;     Ã invUpdate_interrupt_descriptor16            ; Used after initialization to update an IDT entry
			      C ;     Ã invUpdate_interrupt_descriptor32            ; Used after initialization to update an IDT entry
			      C ;     Ã invExtract_code_descriptor32                ; Extracts the information in a code descriptor segment
			      C ;     Ã invExtract_call_gate_descriptor32           ; Extracts the information in a call gate descriptor segment
			      C ;     Ã invExtract_data_descriptor32                ; Extracts the information in a data descriptor segment
			      C ;     Ã invAlter_descriptor32_base_limit            ; Used after initialization to alter a GDT entry's base and/or limit
			      C ;     Ã invSetup_memory_blocks                      ; Sets up the initial values in Exodus memory blocks
			      C ;     Ã invExtract_linear_offset_into_edx_from_ds   ; Extracts a linear offset from the current value of DS
			      C ;     Ã invSet_80x25_text_mode                      ; Calls the VID_requestor() function to enter 80x25 text mode (for errors)
			      C ;     À init_failed                                 ; Used when there is a problem initializing primatives
			      C ;
			      C 
			      C 
			      C 
 0000004E		      C invCreate_call_gate_descriptor32   PROC
			      C ; This routine is used to create a call gate
			      C ; Upon entry:   cpu is in pmode
			      C ;               eax - GDT slot # to create/update
			      C ;               ebx - Offset for start of function
			      C ;               ecx - Number of dwords to copy
			      C ;                dx - code segment selector
			      C ;
 0000004E  9C		      C     pushfd
			      C     .IF (eax <= _lastGDT)
 0000004F  3D 00000FFF	   *	    cmp    eax, _lastGDT
 00000054  77 3B	   *	    ja     @C0014
 00000056  1E		      C         push    ds
 00000057  56		      C         push    esi
 00000058  51		      C         push    ecx
 00000059  53		      C         push    ebx
			      C 
 0000005A  66| BE 0010	      C         mov     si,_sGDT
 0000005E  66| 8E DE	      C         mov     ds,si
 00000061  66| 89 14 C5	      C         mov     word ptr ds:[eax*8+2],dx                            ; code segment selector
	   00000002
 00000069  66| 83 E1 1F	      C         and     cx,011111b                                          ; Keep the lower 5 bits
 0000006D  66| 81 C9 8C00     C         or      cx,1000110000000000b                                ; Put parameters in the upper 11 bits
 00000072  66| 89 0C C5	      C         mov     word ptr ds:[eax*8+4],cx                            ; dword count + constants
	   00000004
 0000007A  66| 89 1C C5	      C         mov     word ptr ds:[eax*8+0],bx                            ; Lower 16-bits of 32-bit offset
	   00000000
 00000082  C1 CB 10	      C         ror     ebx,16
 00000085  66| 89 1C C5	      C         mov     word ptr ds:[eax*8+6],bx                            ; Upper 16-bits of 32-bit offset
	   00000006
			      C 
 0000008D  5B		      C         pop     ebx
 0000008E  59		      C         pop     ecx
 0000008F  5E		      C         pop     esi
 00000090  1F		      C         pop     ds
			      C     .ENDIF
 00000091		   *@C0014:
 00000091  9D		      C     popfd
 00000092  C3		      C     ret
 00000093		      C invCreate_call_gate_descriptor32   ENDP
			      C 
			      C 
			      C 
			      C 
 00000093		      C invCreate_task_gate_descriptor32   PROC
			      C ; This routine is used to create a task gate in the GDT
			      C ; Upon entry:   cpu is in pmode
			      C ;               eax - GDT slot # to create/update
			      C ;                bx - Task's TSS
			      C ;
 00000093  9C		      C     pushfd
			      C     .IF (eax <= _lastGDT)
 00000094  3D 00000FFF	   *	    cmp    eax, _lastGDT
 00000099  77 22	   *	    ja     @C0016
 0000009B  1E		      C         push    ds
 0000009C  56		      C         push    esi
 0000009D  53		      C         push    ebx
			      C 
 0000009E  66| BE 0010	      C         mov     si,_sGDT
 000000A2  66| 8E DE	      C         mov     ds,si
			      C 
 000000A5  C1 E3 10	      C         shl     ebx,16
 000000A8  89 1C C5	      C         mov     dword ptr ds:[eax*8+0],ebx                          ; TSS Segment Selector
	   00000000
 000000AF  33 DB	      C         xor     ebx,ebx
 000000B1  B7 85	      C         mov     bh,10000101b                                        ; P=1:DPL=00:00101:00000000
 000000B3  89 1C C5	      C         mov     dword ptr ds:[eax*8+4],ebx
	   00000004
			      C 
 000000BA  5B		      C         pop     ebx
 000000BB  5E		      C         pop     esi
 000000BC  1F		      C         pop     ds
			      C     .ENDIF
 000000BD		   *@C0016:
 000000BD  9D		      C     popfd
 000000BE  C3		      C     ret
 000000BF		      C invCreate_task_gate_descriptor32   ENDP
			      C 
			      C 
			      C 
			      C 
 000000BF		      C invCreate_interrupt_task_gate_descriptor32   PROC
			      C ; This routine is used to create a task gate in the IDT
			      C ; Upon entry:   cpu is in pmode
			      C ;               eax - IDT slot # to create/update
			      C ;                bx - Task's TSS
			      C ;
 000000BF  9C		      C     pushfd
			      C     .IF (eax <= 256)
 000000C0  3D 00000100	   *	    cmp    eax, 00100h
 000000C5  77 22	   *	    ja     @C0018
 000000C7  1E		      C         push    ds
 000000C8  56		      C         push    esi
 000000C9  53		      C         push    ebx
			      C 
 000000CA  66| BE 0008	      C         mov     si,_sIDT
 000000CE  66| 8E DE	      C         mov     ds,si
			      C 
 000000D1  C1 E3 10	      C         shl     ebx,16
 000000D4  89 1C C5	      C         mov     dword ptr ds:[eax*8+0],ebx                          ; TSS Segment Selector
	   00000000
 000000DB  33 DB	      C         xor     ebx,ebx
 000000DD  B7 85	      C         mov     bh,10000101b                                        ; P=1:DPL=00:00101:00000000
 000000DF  89 1C C5	      C         mov     dword ptr ds:[eax*8+4],ebx
	   00000004
			      C 
 000000E6  5B		      C         pop     ebx
 000000E7  5E		      C         pop     esi
 000000E8  1F		      C         pop     ds
			      C     .ENDIF
 000000E9		   *@C0018:
 000000E9  9D		      C     popfd
 000000EA  C3		      C     ret
 000000EB		      C invCreate_interrupt_task_gate_descriptor32   ENDP
			      C 
			      C 
			      C 
			      C 
 000000EB		      C invCreate_code_descriptor32    PROC    NEAR
			      C ; Upon entry, eax - slot # to insert
			      C ;             ebx - base
			      C ;             edx - limit
			      C ;
 000000EB  9C		      C     pushfd
			      C     .IF (eax <= _lastGDT)
 000000EC  3D 00000FFF	   *	    cmp    eax, _lastGDT
 000000F1  77 69	   *	    ja     @C001A
 000000F3  1E		      C         push    ds
 000000F4  56		      C         push    esi
 000000F5  53		      C         push    ebx
 000000F6  52		      C         push    edx
			      C 
 000000F7  66| BF 0010	      C         mov     di,_sGDT
 000000FB  66| 8E DF	      C         mov     ds,di
			      C 
			      C       ; Fixed information, not accessed, readable, conforming=0, DPL=00
 000000FE  C6 04 C5	      C         mov     byte ptr ds:[eax*8+5],10011010b
	   00000005 9A
			      C 
			      C       ; Base
 00000106  66| 89 1C C5	      C         mov     word ptr ds:[eax*8+2],bx                            ; base 0:15
	   00000002
 0000010E  C1 EB 10	      C         shr     ebx,16
 00000111  88 1C C5	      C         mov     byte ptr ds:[eax*8+4],bl                            ; base 16:23
	   00000004
 00000118  C1 EB 08	      C         shr     ebx,8
 0000011B  88 1C C5	      C         mov     byte ptr ds:[eax*8+7],bl                            ; base 24:31
	   00000007
			      C 
			      C       ; Limit
			      C         .IF (edx > 0fffffh)
 00000122  81 FA 000FFFFF  *	    cmp    edx, 0000FFFFFh
 00000128  76 16	   *	    jbe    @C001C
			      C           ; It's bigger than 20 bits (so, we have to change the granularity to 1)
			      C           ; This is a BIG data descriptor
			      C           ; Also, setting the granularity bit makes the limit value be the number of 4k segments
 0000012A  C1 EA 0C	      C             shr     edx,12                                          ; Divide by 4096
 0000012D  66| 89 14 C5	      C             mov     word ptr ds:[eax*8+0],dx                        ; Store the new limit 0:15
	   00000000
 00000135  C1 EA 10	      C             shr     edx,16                                          ; Move over to store the next part of the limit
 00000138  80 E2 0F	      C             and     dl,0fh                                          ; Mask off the top nibble (the limit is only 20 bits)
 0000013B  80 CA 80	      C             or      dl,10000000b                                    ; make granularity=1
			      C         .ELSE
 0000013E  EB 0E	   *	    jmp    @C001E
 00000140		   *@C001C:
			      C           ; It's a small data descriptor (leave the granularity at 0)
 00000140  66| 89 14 C5	      C             mov     word ptr ds:[eax*8+0],dx                        ; limit 0:15
	   00000000
 00000148  C1 EA 10	      C             shr     edx,16
 0000014B  80 E2 0F	      C             and     dl,0fh
			      C         .ENDIF
 0000014E		   *@C001E:
 0000014E  80 CA 40	      C         or      dl,01000000b                                        ; 32-bit code
 00000151  88 14 C5	      C         mov     byte ptr ds:[eax*8+6],dl                            ; limit 16:19, Granularity=0
	   00000006
			      C 
 00000158  5A		      C         pop     edx
 00000159  5B		      C         pop     ebx
 0000015A  5E		      C         pop     esi
 0000015B  1F		      C         pop     ds
			      C     .ENDIF
 0000015C		   *@C001A:
 0000015C  9D		      C     popfd
 0000015D  C3		      C     ret
 0000015E		      C invCreate_code_descriptor32    ENDP
			      C 
			      C 
			      C 
			      C 
 0000015E		      C invCreate_data_descriptor32    PROC    NEAR
			      C ; Upon entry, eax - slot # to insert
			      C ;             ebx - base
			      C ;             edx - limit
			      C ;
 0000015E  9C		      C     pushfd
			      C     .IF (eax <= _lastGDT)
 0000015F  3D 00000FFF	   *	    cmp    eax, _lastGDT
 00000164  77 63	   *	    ja     @C001F
 00000166  1E		      C         push    ds
 00000167  51		      C         push    ecx
 00000168  53		      C         push    ebx
 00000169  52		      C         push    edx
			      C 
 0000016A  66| B9 0010	      C         mov     cx,_sGDT
 0000016E  66| 8E D9	      C         mov     ds,cx
			      C 
 00000171  66| 89 1C C5	      C         mov     word ptr ds:[eax*8+2],bx                            ; base 0:15
	   00000002
 00000179  C1 EB 10	      C         shr     ebx,16
 0000017C  88 1C C5	      C         mov     byte ptr ds:[eax*8+4],bl                            ; base 16:23
	   00000004
 00000183  88 3C C5	      C         mov     byte ptr ds:[eax*8+7],bh                            ; base 24:31
	   00000007
 0000018A  C6 04 C5	      C         mov     byte ptr ds:[eax*8+5],10010010b                     ; Not accessed, writeable, expand=0, DPL=00
	   00000005 92
			      C         .IF (edx > 0fffffh)
 00000192  81 FA 000FFFFF  *	    cmp    edx, 0000FFFFFh
 00000198  76 16	   *	    jbe    @C0021
			      C           ; It's bigger than 20 bits (so, we have to change the granularity to 1)
			      C           ; This is a BIG data descriptor
			      C           ; Also, setting the granularity bit makes the limit value be the number of 4k segments
 0000019A  C1 EA 0C	      C             shr     edx,12                                          ; Divide by 4096
 0000019D  66| 89 14 C5	      C             mov     word ptr ds:[eax*8+0],dx                        ; Store the new limit 0:15
	   00000000
 000001A5  C1 EA 10	      C             shr     edx,16                                          ; Move over to store the next part of the limit
 000001A8  80 E2 0F	      C             and     dl,0fh                                          ; Mask off the top nibble (the limit is only 20 bits)
 000001AB  80 CA C0	      C             or      dl,11000000b                                    ; make granularity=1, big=1 (high bits in dl)
			      C         .ELSE
 000001AE  EB 0E	   *	    jmp    @C0023
 000001B0		   *@C0021:
			      C           ; It's a small data descriptor (leave the granularity at 0)
 000001B0  66| 89 14 C5	      C             mov     word ptr ds:[eax*8+0],dx                        ; limit 0:15
	   00000000
 000001B8  C1 EA 10	      C             shr     edx,16
 000001BB  80 E2 0F	      C             and     dl,0fh
			      C         .ENDIF
 000001BE		   *@C0023:
 000001BE  88 14 C5	      C         mov     byte ptr ds:[eax*8+6],dl                            ; limit 16:19, Granularity=0/1, big=0/1 (depends on size)
	   00000006
			      C 
 000001C5  5A		      C         pop     edx
 000001C6  5B		      C         pop     ebx
 000001C7  59		      C         pop     ecx
 000001C8  1F		      C         pop     ds
			      C     .ENDIF
 000001C9		   *@C001F:
 000001C9  9D		      C     popfd
 000001CA  C3		      C     ret
 000001CB		      C invCreate_data_descriptor32    ENDP
			      C 
			      C 
			      C 
			      C 
 000001CB		      C invExtract_code_descriptor32        PROC    NEAR
			      C ; This routine takes an already existent code segment and extracts the base and limit
			      C ;
			      C ; Upon entry, eax - GDT offset
			      C ;
			      C ; Upon exit:  ebx - base
			      C ;             edx - limit
			      C ;
 000001CB  9C		      C     pushfd
			      C     .IF (eax <= _lastGDT * 8)
 000001CC  3D 00007FF8	   *	    cmp    eax, _lastGDT * 008h
 000001D1  77 37	   *	    ja     @C0024
 000001D3  1E		      C         push    ds
 000001D4  51		      C         push    ecx
			      C 
 000001D5  66| B9 0010	      C         mov     cx,_sGDT
 000001D9  66| 8E D9	      C         mov     ds,cx
			      C 
			      C       ; Get the limit
 000001DC  33 D2	      C         xor     edx,edx
 000001DE  66| 8B 10	      C         mov     dx,word ptr [eax]
 000001E1  C1 CA 10	      C         ror     edx,16
 000001E4  8A 50 06	      C         mov     dl,byte ptr [eax+6]
 000001E7  80 E2 0F	      C         and     dl,0fh
 000001EA  C1 C2 10	      C         rol     edx,16
 000001ED  F6 40 06 80	      C         test    byte ptr [eax+6],10000000b                          ; See if the "G" bit is set
			      C         .IF (!zero?)
 000001F1  74 03	   *	    je     @C0026
			      C           ; It is set for granularity
 000001F3  C1 E2 0C	      C             shl     edx,12
			      C         .ENDIF
			      C 
			      C       ; Get the base
 000001F6		   *@C0026:
 000001F6  8B 58 02	      C         mov     ebx,dword ptr [eax+2]
 000001F9  81 E3 00FFFFFF     C         and     ebx,0ffffffh
 000001FF  C1 C3 08	      C         rol     ebx,8
 00000202  8A 58 07	      C         mov     bl,byte ptr [eax+7]
 00000205  C1 CB 08	      C         ror     ebx,8
			      C 
 00000208  59		      C         pop     ecx
 00000209  1F		      C         pop     ds
			      C     .ENDIF
 0000020A		   *@C0024:
 0000020A  9D		      C     popfd
 0000020B  C3		      C     ret
 0000020C		      C invExtract_code_descriptor32        ENDP
			      C 
			      C 
			      C 
			      C 
 0000020C		      C invExtract_call_gate_descriptor32       PROC    NEAR
			      C ; This routine takes an already existent code segment and extracts the base and limit
			      C ;
			      C ; Upon entry, eax - GDT offset
			      C ;
			      C ; Upon exit:  ebx - offset
			      C ;             ecx - param count
			      C ;             edx - code segment
			      C ;
 0000020C  9C		      C     pushfd
			      C     .IF (eax <= _lastGDT * 8)
 0000020D  3D 00007FF8	   *	    cmp    eax, _lastGDT * 008h
 00000212  77 20	   *	    ja     @C0028
 00000214  1E		      C         push    ds
			      C 
 00000215  BA 00000010	      C         mov     edx,_sGDT
 0000021A  8E DA	      C         mov     ds,edx
			      C 
			      C       ; Get the offset
 0000021C  33 DB	      C         xor     ebx,ebx
 0000021E  66| 8B 18	      C         mov     bx,word ptr ds:[eax]
 00000221  C1 CB 10	      C         ror     ebx,16
 00000224  66| 8B 58 06	      C         mov     bx,word ptr ds:[eax+6]
 00000228  C1 CB 10	      C         ror     ebx,16
			      C 
			      C       ; Get the param count
 0000022B  0F B6 48 04	      C         movzx   ecx,byte ptr ds:[eax+4]
			      C 
			      C       ; Get the code selector
 0000022F  0F B7 50 02	      C         movzx   edx,word ptr ds:[eax+2]
			      C 
 00000233  1F		      C         pop     ds
			      C     .ENDIF
 00000234		   *@C0028:
 00000234  9D		      C     popfd
 00000235  C3		      C     ret
 00000236		      C invExtract_call_gate_descriptor32       ENDP
			      C 
			      C 
			      C 
			      C 
 00000236		      C invExtract_data_descriptor32        PROC    NEAR
			      C ; This routine takes an already existent data segment and extracts the base and offset
			      C ;
			      C ; Upon entry:   eax - GDT offset
			      C ;
			      C ; Upon exit:    ebx - base
			      C ;               edx - limit
			      C ;
 00000236  9C		      C     pushfd
			      C     .IF (eax <= _lastGDT * 8)
 00000237  3D 00007FF8	   *	    cmp    eax, _lastGDT * 008h
 0000023C  77 37	   *	    ja     @C002A
 0000023E  1E		      C         push    ds
 0000023F  51		      C         push    ecx
			      C 
 00000240  B9 00000010	      C         mov     ecx,_sGDT
 00000245  8E D9	      C         mov     ds,ecx
			      C 
			      C       ; Get the limit
 00000247  33 D2	      C         xor     edx,edx
 00000249  66| 8B 10	      C         mov     dx,word ptr [eax]
 0000024C  C1 CA 10	      C         ror     edx,16
 0000024F  8A 50 06	      C         mov     dl,byte ptr [eax+6]
 00000252  80 E2 0F	      C         and     dl,0fh
 00000255  C1 C2 10	      C         rol     edx,16
 00000258  F6 40 06 80	      C         test    byte ptr [eax+6],10000000b                          ; See if the "G" bit is set
			      C         .IF (!zero?)
 0000025C  74 03	   *	    je     @C002C
			      C           ; It is set for granularity
 0000025E  C1 E2 0C	      C             shl     edx,12
			      C         .ENDIF
			      C 
			      C       ; Get the base
 00000261		   *@C002C:
 00000261  8B 58 02	      C         mov     ebx,dword ptr [eax+2]
 00000264  81 E3 00FFFFFF     C         and     ebx,0ffffffh
 0000026A  C1 C3 08	      C         rol     ebx,8
 0000026D  8A 58 07	      C         mov     bl,byte ptr [eax+7]
 00000270  C1 CB 08	      C         ror     ebx,8
			      C 
 00000273  59		      C         pop     ecx
 00000274  1F		      C         pop     ds
			      C     .ENDIF
 00000275		   *@C002A:
 00000275  9D		      C     popfd
 00000276  C3		      C     ret
 00000277		      C invExtract_data_descriptor32        ENDP
			      C 
			      C 
			      C 
			      C 
 00000277		      C invAlter_descriptor32_base_limit    PROC
			      C ; This routine is used to alter the base and/or limit of an existing GDT entry
			      C ;
			      C ; Upon entry:   edx - slot
			      C ;               esi - new base
			      C ;               edi - new limit
			      C ;
			      C ; Upon exit:    Value is updated if edx is valid
			      C ;
			      C 
 00000277  9C		      C     pushfd
			      C     .IF (edx <= _lastGDT)
 00000278  81 FA 00000FFF  *	    cmp    edx, _lastGDT
 0000027E  77 64	   *	    ja     @C002E
 00000280  1E		      C         push    ds
 00000281  51		      C         push    ecx
 00000282  53		      C         push    ebx
 00000283  50		      C         push    eax
			      C 
 00000284  B9 00000010	      C         mov     ecx,_sGDT
 00000289  8E D9	      C         mov     ds,ecx
			      C       ; Right now,  ds:[edx*8] - far ptr to GDT entry
			      C       ;             esi - new base
			      C       ;             edi - new limit
 0000028B  8B DE	      C         mov     ebx,esi
 0000028D  8B C7	      C         mov     eax,edi
			      C         .IF (eax > 0fffffh)
 0000028F  3D 000FFFFF	   *	    cmp    eax, 0000FFFFFh
 00000294  76 0D	   *	    jbe    @C0030
			      C           ; Turn on the granularity bit
 00000296  C1 E8 0C	      C             shr     eax,12
 00000299  80 0C D5	      C             or      byte ptr ds:[edx*8+6],10000000b
	   00000006 80
			      C         .ELSE
 000002A1  EB 08	   *	    jmp    @C0032
 000002A3		   *@C0030:
			      C           ; Turn off the granularity bit
 000002A3  80 24 D5	      C             and     byte ptr ds:[edx*8+6],not 10000000b
	   00000006 7F
			      C         .ENDIF
			      C 
 000002AB		   *@C0032:
 000002AB  66| 89 04 D5	      C         mov     word ptr ds:[edx*8+0],ax                            ; limit 0-15
	   00000000
 000002B3  66| 89 1C D5	      C         mov     word ptr ds:[edx*8+2],bx                            ; base 0-15
	   00000002
 000002BB  C1 E8 10	      C         shr     eax,16
 000002BE  C1 EB 10	      C         shr     ebx,16
 000002C1  88 1C D5	      C         mov     byte ptr ds:[edx*8+4],bl                            ; base 16-23
	   00000004
 000002C8  88 3C D5	      C         mov     byte ptr ds:[edx*8+7],bh                            ; base 24-31
	   00000007
			      C 
 000002CF  24 0F	      C         and     al,0fh
 000002D1  80 24 D5	      C         and     byte ptr ds:[edx*8+6],0f0h
	   00000006 F0
 000002D9  08 04 D5	      C         or      byte ptr ds:[edx*8+6],al
	   00000006
			      C       ; Right now, it's updated
			      C 
 000002E0  58		      C         pop     eax
 000002E1  5B		      C         pop     ebx
 000002E2  59		      C         pop     ecx
 000002E3  1F		      C         pop     ds
			      C     .ENDIF
 000002E4		   *@C002E:
 000002E4  9D		      C     popfd
 000002E5  C3		      C     ret
 000002E6		      C invAlter_descriptor32_base_limit    ENDP
			      C 
			      C 
			      C 
			      C 
 000002E6		      C invExtract_linear_offset_into_edx_from_ds   PROC
			      C ; This routine is used to extract the linear offset from the GDT value in ds
			      C ;
			      C ; Upon entry:   ds - GDT slot being searched for
			      C ;
			      C ; Upon exit:    edx - linear offset
			      C ;
 000002E6  9C		      C     pushfd
 000002E7  50		      C     push    eax
			      C 
 000002E8  8C D8	      C     mov     eax,ds
			      C     .IF (eax <= _lastGDT * 8)
 000002EA  3D 00007FF8	   *	    cmp    eax, _lastGDT * 008h
 000002EF  77 1D	   *	    ja     @C0033
 000002F1  1E		      C         push    ds
 000002F2  51		      C         push    ecx
			      C 
 000002F3  66| B9 0010	      C         mov     cx,_sGDT
 000002F7  66| 8E D9	      C         mov     ds,cx
			      C 
			      C       ; Get the base (linear offset)
 000002FA  8B 50 02	      C         mov     edx,dword ptr [eax+2]
 000002FD  81 E2 00FFFFFF     C         and     edx,0ffffffh
 00000303  C1 C2 08	      C         rol     edx,8
 00000306  8A 50 07	      C         mov     dl,byte ptr [eax+7]
 00000309  C1 CA 08	      C         ror     edx,8
			      C 
 0000030C  59		      C         pop     ecx
 0000030D  1F		      C         pop     ds
			      C     .ENDIF
 0000030E		   *@C0033:
			      C 
 0000030E  58		      C     pop     eax
 0000030F  9D		      C     popfd
 00000310  C3		      C     ret
 00000311		      C invExtract_linear_offset_into_edx_from_ds   ENDP
			      C 
			      C 
			      C 
			      C 
 00000311		      C invCreate_tss_descriptor32     PROC
			      C ; Upon entry, eax - slot # to insert
			      C ;             ebx - base
			      C ;             edx - limit
			      C ;
 00000311  9C		      C     pushfd
			      C     .IF (eax <= _lastGDT)
 00000312  3D 00000FFF	   *	    cmp    eax, _lastGDT
 00000317  77 45	   *	    ja     @C0035
 00000319  1E		      C         push    ds
 0000031A  56		      C         push    esi
 0000031B  53		      C         push    ebx
 0000031C  52		      C         push    edx
			      C 
 0000031D  66| BE 0010	      C         mov     si,_sGDT
 00000321  66| 8E DE	      C         mov     ds,si
			      C 
 00000324  66| 89 1C C5	      C         mov     word ptr [eax*8+2],bx                               ; base 0:15
	   00000002
 0000032C  C1 EB 10	      C         shr     ebx,16
 0000032F  88 1C C5	      C         mov     byte ptr [eax*8+4],bl                               ; base 16:23
	   00000004
 00000336  88 3C C5	      C         mov     byte ptr [eax*8+7],bh                               ; base 24:31
	   00000007
 0000033D  66| 89 14 C5	      C         mov     word ptr [eax*8+0],dx                               ; limit 0:15
	   00000000
 00000345  C1 EA 10	      C         shr     edx,16
 00000348  80 E2 0F	      C         and     dl,0fh                                              ; make the top nibble be all 0s
 0000034B  88 14 C5	      C         mov     byte ptr [eax*8+6],dl                               ; Granularity=0:0:0:Available=0:limit 16:19
	   00000006
 00000352  C6 04 C5	      C         mov     byte ptr [eax*8+5],10001001b                        ; present=1:dpl=00:010:busy=0:1
	   00000005 89
			      C 
 0000035A  5A		      C         pop     edx
 0000035B  5B		      C         pop     ebx
 0000035C  5E		      C         pop     esi
 0000035D  1F		      C         pop     ds
			      C     .ENDIF
 0000035E		   *@C0035:
 0000035E  9D		      C     popfd
 0000035F  C3		      C     ret
 00000360		      C invCreate_tss_descriptor32     ENDP
			      C 
			      C 
			      C 
			      C 
 00000360		      C invCreate_tss32    PROC
			      C ; Upon entry, ds:[esi] - far ptr to offset in memory to create the TSS
			      C ;                  ebx - code segment selector
			      C ;                  ecx - first instruction offset
			      C ;                  edx - stack segment selector
			      C ;                  edi - esp value
 00000360  50		      C     push eax
			      C 
			      C   ; Code segment register
 00000361  89 5E 4C	      C     mov     dword ptr ds:[esi+76],ebx                           ; cs
			      C   ; Instruction Pointer
 00000364  89 4E 20	      C     mov     dword ptr ds:[esi+32],ecx                           ; eip
			      C   ; Stack
 00000367  89 56 50	      C     mov     dword ptr ds:[esi+80],edx                           ; ss
 0000036A  89 7E 38	      C     mov     dword ptr ds:[esi+56],edi                           ; esp
			      C   ; Data segment registers
 0000036D  B8 00000048	      C     mov     eax,_sDATA
 00000372  89 46 54	      C     mov     dword ptr ds:[esi+84],eax                           ; ds
 00000375  89 46 48	      C     mov     dword ptr ds:[esi+72],eax                           ; es
			      C   ; Extra segment registers
 00000378  B8 00000038	      C     mov     eax,_sVGA
 0000037D  89 46 58	      C     mov     dword ptr ds:[esi+88],eax                           ; fs
 00000380  B8 00000030	      C     mov     eax,_sMONO
 00000385  89 46 5C	      C     mov     dword ptr ds:[esi+92],eax                           ; gs
			      C   ; Stack 2
 00000388  B8 00000130	      C     mov     eax,_sSTACK2
 0000038D  89 46 18	      C     mov     dword ptr ds:[esi+24],eax                           ; ss2
 00000390  C7 46 14	      C     mov     dword ptr ds:[esi+20],07fch                         ; esp2
	   000007FC
			      C   ; Stack 1
 00000397  B8 00000128	      C     mov     eax,_sSTACK1
 0000039C  89 46 10	      C     mov     dword ptr ds:[esi+16],eax                           ; ss1
 0000039F  C7 46 0C	      C     mov     dword ptr ds:[esi+12],07fch                         ; esp1
	   000007FC
			      C   ; Stack 0
 000003A6  B8 00000120	      C     mov     eax,_sSTACK0
 000003AB  89 46 08	      C     mov     dword ptr ds:[esi+8],eax                            ; ss0
 000003AE  C7 46 04	      C     mov     dword ptr ds:[esi+4],07fch                          ; esp0
	   000007FC
			      C   ; General purpose registers
 000003B5  33 C0	      C     xor     eax,eax
 000003B7  89 46 28	      C     mov     dword ptr ds:[esi+40],eax                           ; eax
 000003BA  89 46 2C	      C     mov     dword ptr ds:[esi+44],eax                           ; ecx
 000003BD  89 46 30	      C     mov     dword ptr ds:[esi+48],eax                           ; edx
 000003C0  89 46 34	      C     mov     dword ptr ds:[esi+52],eax                           ; ebx
 000003C3  89 46 3C	      C     mov     dword ptr ds:[esi+60],eax                           ; ebp
 000003C6  89 46 40	      C     mov     dword ptr ds:[esi+64],eax                           ; esi
 000003C9  89 46 44	      C     mov     dword ptr ds:[esi+68],eax                           ; edi
 000003CC  89 46 1C	      C     mov     dword ptr ds:[esi+28],eax                           ; CR3, paging (not used in Exodus)
 000003CF  89 46 64	      C     mov     dword ptr ds:[esi+100],eax                          ; IO Map Base Address, Trap bit
 000003D2  89 06	      C     mov     dword ptr ds:[esi+0],eax                            ; Previous task link
 000003D4  33 C0	      C     xor     eax,eax
 000003D6  89 46 60	      C     mov     dword ptr ds:[esi+96],eax                           ; LDT segment selector
			      C   ; EFLAGS
 000003D9  9C		      C     pushfd
 000003DA  58		      C     pop     eax
 000003DB  89 46 24	      C     mov     dword ptr ds:[esi+36],eax
			      C 
 000003DE  58		      C     pop     eax
 000003DF  C3		      C     ret
 000003E0		      C invCreate_tss32    ENDP
			      C 
			      C 
			      C 
			      C 
 000003E0		      C invUpdate_interrupt_descriptor16   PROC
			      C ; Upon entry, eax - interrupt # to update (0-based)
			      C ;             edx - offset in bx to routine
			      C ;              bx - segment selector of routine
 000003E0  51		      C     push    ecx
 000003E1  52		      C     push    edx
 000003E2  0F A0	      C     push    fs
			      C 
 000003E4  66| B9 0008	      C     mov     cx,_sIDT                                                ; IDT slot in GDT
 000003E8  66| 8E E1	      C     mov     fs,cx
 000003EB  8B CA	      C     mov     ecx,edx                                                 ; Copy 32-bit offset to ecx
 000003ED  81 E2 0000FFFF     C     and     edx,00000ffffh                                          ; Keep lower 16-bits in edx
 000003F3  81 E1 FFFF0000     C     and     ecx,0ffff0000h                                          ; Keep upper 16-bits in ecx
 000003F9  66| B9 8600	      C     mov     cx,1000011000000000b                                    ; Add lower 16-bits in ecx, 16-bit, DPL=0, Present
 000003FD  C1 CA 10	      C     ror     edx,16                                                  ; Move edx around so we can access the high word
 00000400  66| 8B D3	      C     mov     dx,bx                                                   ; Segment selector
 00000403  C1 CA 10	      C     ror     edx,16                                                  ; Ok, put it back the way it was
			      C 
 00000406  FA		      C     cli
 00000407  64: 89 14 C5	      C     mov     dword ptr fs:[eax*8+0],edx                              ; Store the IDT descriptor
	   00000000
 0000040F  64: 89 0C C5	      C     mov     dword ptr fs:[eax*8+4],ecx
	   00000004
 00000417  FB		      C     sti
			      C 
 00000418  0F A1	      C     pop     fs
 0000041A  5A		      C     pop     edx
 0000041B  59		      C     pop     ecx
 0000041C  C3		      C     ret
 0000041D		      C invUpdate_interrupt_descriptor16   ENDP
			      C 
			      C 
			      C 
			      C 
 0000041D		      C invUpdate_interrupt_descriptor32   PROC
			      C ; Upon entry, eax - interrupt # to update (0-based)
			      C ;             edx - offset in bx to routine
			      C ;              bx - segment selector of routine
 0000041D  51		      C     push    ecx
 0000041E  52		      C     push    edx
 0000041F  0F A0	      C     push    fs
			      C 
 00000421  66| B9 0008	      C     mov     cx,_sIDT                                                ; IDT slot in GDT
 00000425  66| 8E E1	      C     mov     fs,cx
 00000428  8B CA	      C     mov     ecx,edx                                                 ; Copy 32-bit offset to ecx
 0000042A  81 E2 0000FFFF     C     and     edx,00000ffffh                                          ; Keep lower 16-bits in edx
 00000430  81 E1 FFFF0000     C     and     ecx,0ffff0000h                                          ; Keep upper 16-bits in ecx
 00000436  66| B9 8E00	      C     mov     cx,1000111000000000b                                    ; Add control bits to ecx, 32-bit, DPL=0, Present
 0000043A  C1 CA 10	      C     ror     edx,16                                                  ; Move edx around so we can access the high word
 0000043D  66| 8B D3	      C     mov     dx,bx                                                   ; Segment selector
 00000440  C1 CA 10	      C     ror     edx,16                                                  ; Ok, put it back the way it was
			      C 
 00000443  FA		      C     cli
 00000444  64: 89 14 C5	      C     mov     dword ptr fs:[eax*8+0],edx                              ; Store the IDT descriptor
	   00000000
 0000044C  64: 89 0C C5	      C     mov     dword ptr fs:[eax*8+4],ecx
	   00000004
 00000454  FB		      C     sti
			      C 
 00000455  0F A1	      C     pop     fs
 00000457  5A		      C     pop     edx
 00000458  59		      C     pop     ecx
 00000459  C3		      C     ret
 0000045A		      C invUpdate_interrupt_descriptor32   ENDP
			      C 
			      C 
			      C 
			      C 
			      C 
 0000045A		      C invSetup_memory_blocks      PROC
			      C ; This routine is used to setup required memory blocks for Exodus
			      C ;
			      C ; Upon entry:   This function is called as the first function in protected mode
			      C ;               It is known that all of the standard GDT entries are setup (those before _sEXODUS_REQUESTOR)
			      C ;
			      C ; Upon exit:    These memory blocks are setup with their default structures/info:
			      C ;                   _sEXODUS_MEM            ; Refer to inf\exodus.inf for more information
			      C ;                   _sEXODUS_PORTS          ; Refer to inf\exodus.inf for more information
			      C ;                   _sEXODUS_INTS           ; Refer to inf\exodus.inf for more information
			      C ;                   _sSYSTEM                ; Various memory regions
			      C ;
 0000045A  50		      C     push    eax
 0000045B  56		      C     push    esi
 0000045C  1E		      C     push    ds
			      C 
			      C 
			      C ;; Do the Exodus memory block regions
 0000045D  66| B8 0050	      C     mov     ax,_sEXODUS_MEM
 00000461  66| 8E D8	      C     mov     ds,ax
 00000464  67& C7 06 0000     C     mov     dword ptr ds:[0],4 + _EXODUS_MEM_size                   ; The length of this structure plus the initial dword
	   00000014
 0000046D  BE 00000004	      C     mov     esi,4
 00000472  C6 06 00	      C     mov     byte ptr ds:[esi+_EXODUS_MEM_type],0                    ; Free block
 00000475  C7 46 04	      C     mov     dword ptr ds:[esi+_EXODUS_MEM_base],100000h             ; Start at 1MB
	   00100000
 0000047C  C7 46 08	      C     mov     dword ptr ds:[esi+_EXODUS_MEM_limit],100000h            ; Limit (1MB, Exodus requires 2MB of RAM to boot)
	   00100000
 00000483  C7 46 0C	      C     mov     dword ptr ds:[esi+_EXODUS_MEM_gdt],0
	   00000000
			      C 
			      C 
			      C ;; Do the Exodus port assignments
 0000048A  66| B8 0058	      C     mov     ax,_sEXODUS_PORTS
 0000048E  66| 8E D8	      C     mov     ds,ax
 00000491  67& C7 06 0000     C     mov     dword ptr ds:[0],4                                      ; 4 = The initial dword only (no ports are auto reserved)
	   00000004
			      C 
			      C 
			      C ;; Do the Exodus interrupt assignments
 0000049A  66| B8 0060	      C     mov     ax,_sEXODUS_INTS
 0000049E  66| 8E D8	      C     mov     ds,ax
 000004A1  67& C7 06 0000     C     mov     dword ptr ds:[0],4                                      ; 4 = The initial dword only (no ports are auto reserved)
	   00000004
			      C 
			      C 
			      C ;; Do the Exodus system memory area
 000004AA  66| B8 00A8	      C     mov     ax,_sSYSTEM
 000004AE  66| 8E D8	      C     mov     ds,ax
			      C   ; These values are Exodus internal
 000004B1  67& 66| C7 06      C     mov     word ptr ds:[_SYSTEM_i_GDT_TO_ASSIGN],_firstASSIGNMENT
	   0834 0032
 000004B9  67& 66| C7 06      C     mov     word ptr ds:[_SYSTEM_i_USER_GDT_TO_ASSIGN],_firstUSER_ASSIGNMENT
	   0836 0BB8
			      C   ; These values are user application accessible
 000004C1  67& C7 06 001C     C     mov     dword ptr ds:[_SYSTEM_TOTAL_MEMORY],200000h             ; Default to 2MB until we know otherwise
	   00200000
			      C 
			      C 
 000004CA  1F		      C     pop     ds
 000004CB  5E		      C     pop     esi
 000004CC  58		      C     pop     eax
 000004CD  C3		      C     ret
 000004CE		      C invSetup_memory_blocks      ENDP
			      C 
			      C 
			      C 
			      C 
 000004CE		      C invSet_80x25_text_mode      PROC
			      C ; This routine is called from various places in Exodus's core.  It calls the VID_requestor() function to enter an 80x25 text mode
			      C ; This is usually used for displaying errors, etc.
			      C ;
			      C ; Upon entry:   Nothing
			      C ;
			      C ; Upon exit:    Nothing
			      C ;
 000004CE  68 00000000	      C     push    dword ptr 0                                         ; return: bits per pixel
 000004D3  68 00000000	      C     push    dword ptr 0                                         ; return: horizontal pixels
 000004D8  68 00000000	      C     push    dword ptr 0                                         ; return: vertical pixels
 000004DD  68 00000000	      C     push    dword ptr 0                                         ; return: refresh rate
 000004E2  68 00000000	      C     push    dword ptr 0                                         ; return: status
 000004E7  68 00000001	      C     push    dword ptr 1                                         ; input: text mode
 000004EC  68 00000008	      C     push    dword ptr 8                                         ; input: bits per pixel
 000004F1  68 00000050	      C     push    dword ptr 80                                        ; input: horizontal pixels
 000004F6  68 00000019	      C     push    dword ptr 25                                        ; input: vertical pixels
 000004FB  68 0000003C	      C     push    dword ptr 60                                        ; input: refresh rate
 00000500  B8 00000001	      C     mov     eax,1
 00000505  2E: FF 1D	      C     call    fword ptr cs:_VID_requestor
	   00001AE0 R
 0000050C  83 C4 14	      C     add     esp,20                                              ; get the values off the stack (we know this works)
 0000050F  C3		      C     ret
 00000510		      C invSet_80x25_text_mode      ENDP
			      C 
				    INCLUDE data32.asp
			      C ; data32.asp
			      C ;
			      C ; Exodus data used in the 32-bit segment
			      C ;
			      C 
			      C 
			      C ;
			      C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			      C ; ³ invSetup_native_primative() ³
			      C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			      C ;
			      C ; These variables are used in the invSetup_native_primative() function
			      C ;
 00000510 6E 6F 20 73 75      C no_support_for_primative                db  "no support for primative"
	   70 70 6F 72 74
	   20 66 6F 72 20
	   70 72 69 6D 61
	   74 69 76 65
 00000528 00000000	      C code_gdt_offset                         dd  0                       ; used temporarily to hold permanent value of _csTEMP_PRIMATIVE
 0000052C 00000000	      C data_gdt_offset                         dd  0                       ; same, but for _dsTEMP_PRIMATIVE
 00000530 00000000	      C main_gdt_offset                         dd  0                       ; same, but for _cgTEMP_PRIMATIVE_MAIN
 00000534 00000000	      C requestor_gdt_offset                    dd  0                       ; same, but for _cgTEMP_PRIMATIVE_REQUESTOR
 00000538 00		      C vga_kbd_support                         db  0                       ; Indicates whether or not basic VGA/keyboard support
			      C                                                                     ; has been installed.  Will be set to 1 after both are
			      C                                                                     ; available.
			      C 
 00000539 20 28 45 78 6F      C exodus_internal_text                    db  " (Exodus Internal)",0
	   64 75 73 20 49
	   6E 74 65 72 6E
	   61 6C 29 00
 0000054C 20 28 75 6E 6B      C unknown_function_text                   db  " (unknown)",0
	   6E 6F 77 6E 29
	   00
 00000557 20 28 75 6E 6B      C unknown_user_function_text              db  " (unknown user function)",0
	   6E 6F 77 6E 20
	   75 73 65 72 20
	   66 75 6E 63 74
	   69 6F 6E 29 00
 00000570 20 28 75 6E 6B      C unknown_primative_text                  db  " (unknown primative)",0
	   6E 6F 77 6E 20
	   70 72 69 6D 61
	   74 69 76 65 29
	   00
 00000585 07 20 45 52 52      C error_loading_exodus_ini_1              db  " ERROR - An error occurred while parsing EXODUS.INI.",0
	   4F 52 20 2D 20
	   41 6E 20 65 72
	   72 6F 72 20 6F
	   63 63 75 72 72
	   65 64 20 77 68
	   69 6C 65 20 70
	   61 72 73 69 6E
	   67 20 45 58 4F
	   44 55 53 2E 49
	   4E 49 2E 00
 000005BB 07 20 45 52 52      C error_loading_exodus_ini_2              db  " ERROR - Exodus cannot find a required boot file: EXODUS.INI",0
	   4F 52 20 2D 20
	   45 78 6F 64 75
	   73 20 63 61 6E
	   6E 6F 74 20 66
	   69 6E 64 20 61
	   20 72 65 71 75
	   69 72 65 64 20
	   62 6F 6F 74 20
	   66 69 6C 65 3A
	   20 45 58 4F 44
	   55 53 2E 49 4E
	   49 00
 000005F9 07 20 45 52 52      C error_loading_exodus_ini_3              db  " ERROR - Exodus found multiple EXODUS.INI files on the boot drive.",0
	   4F 52 20 2D 20
	   45 78 6F 64 75
	   73 20 66 6F 75
	   6E 64 20 6D 75
	   6C 74 69 70 6C
	   65 20 45 58 4F
	   44 55 53 2E 49
	   4E 49 20 66 69
	   6C 65 73 20 6F
	   6E 20 74 68 65
	   20 62 6F 6F 74
	   20 64 72 69 76
	   65 2E 00
 0000063D 20 20 20 20 20      C error_loading_exodus_ini_4              db  "          Please correct this problem and try booting again.",0
	   20 20 20 20 20
	   50 6C 65 61 73
	   65 20 63 6F 72
	   72 65 63 74 20
	   74 68 69 73 20
	   70 72 6F 62 6C
	   65 6D 20 61 6E
	   64 20 74 72 79
	   20 62 6F 6F 74
	   69 6E 67 20 61
	   67 61 69 6E 2E
	   00
 0000067A 07 20 53 79 73      C system_halted                           db  " System is stopped.  Please press RESET or power down to restart.",0
	   74 65 6D 20 69
	   73 20 73 74 6F
	   70 70 65 64 2E
	   20 20 50 6C 65
	   61 73 65 20 70
	   72 65 73 73 20
	   52 45 53 45 54
	   20 6F 72 20 70
	   6F 77 65 72 20
	   64 6F 77 6E 20
	   74 6F 20 72 65
	   73 74 61 72 74
	   2E 00
 000006BD 20 28 66 6F 75      C found_it_text                           db  " (found it!)",0
	   6E 64 20 69 74
	   21 29 00
			      C 
 000006CA 4C 69 6E 65 20      C line_text                               db  "Line xxxxxx"
	   78 78 78 78 78
	   78
 000006D5 45 78 70 65 63      C parse_expected_bracket_paren            db  "Expected [ or (",0
	   74 65 64 20 5B
	   20 6F 72 20 28
	   00
 000006E5 45 78 70 65 63      C parse_expected_paren                    db  "Expected (",0
	   74 65 64 20 28
	   00
 000006F0 55 6E 65 78 70      C parse_unexpected_end_of_file            db  "Unexpected end of file",0
	   65 63 74 65 64
	   20 65 6E 64 20
	   6F 66 20 66 69
	   6C 65 00
 00000707 5B 5D 20 6E 61      C parse_bracket_group_name_too_long       db  "[] name is too long, can only be 4 characters",0
	   6D 65 20 69 73
	   20 74 6F 6F 20
	   6C 6F 6E 67 2C
	   20 63 61 6E 20
	   6F 6E 6C 79 20
	   62 65 20 34 20
	   63 68 61 72 61
	   63 74 65 72 73
	   00
			      C 
 00000735 00		      C loading_primatives_displayed            db  _NO
 00000736 FE 20 4C 6F 61      C loading_primatives                      db  "þ Loading primatives",0
	   64 69 6E 67 20
	   70 72 69 6D 61
	   74 69 76 65 73
	   00
 0000074B FE 20 4C 6F 61      C loading_drivers                         db  "þ Loading drivers",0
	   64 69 6E 67 20
	   64 72 69 76 65
	   72 73 00
 0000075D 20 20 C3 20 00      C next_item                               db  "  Ã ",0
 00000762 20 20 C0 20 00      C last_item                               db  "  À ",0
 00000767 2C 20 00	      C comma_space                             db  ", ",0
			      C 
			      C ; Boot screen
 0000076A		      C bootscreen_start:
			      C   ;INCLUDE bootscrn.inc
			      C   INCLUDE boot_scr.inc
 0000076A  0D 00 00 00 30     C db 00dh,000h,000h,000h,030h,030h,030h,030h,037h,030h,000h,000h,010h,018h,018h,020h,020h,020h,020h,03fh
	   30 30 30 37 30
	   00 00 10 18 18
	   20 20 20 20 3F
 0000077E  3E 3C 28 28 29     C db 03eh,03ch,028h,028h,029h,03fh,000h,000h,000h,03fh,000h,03fh,03fh,000h,000h,000h,03fh,03fh,03fh,03fh
	   3F 00 00 00 3F
	   00 3F 3F 00 00
	   00 3F 3F 3F 3F
 00000792  FF 03 FF 03 FF     C db 0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h
	   03 FF 03 FF 03
	   FF 03 FF 03 FF
	   03 FF 03 FF 03
 000007A6  FF 03 FF 03 FF     C db 0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h
	   03 FF 03 FF 03
	   FF 03 FF 03 FF
	   03 FF 03 FF 03
 000007BA  FF 03 FF 03 FF     C db 0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0c1h,003h,007h,00ch,0ffh,003h,03ah,003h,007h,00ch,0dah,003h
	   03 FF 03 C1 03
	   07 0C FF 03 3A
	   03 07 0C DA 03
 000007CE  14 0C 4B 03 07     C db 014h,00ch,04bh,003h,007h,00ch,086h,003h,029h,00bh,02bh,003h,014h,00ch,04bh,003h,007h,00ch,086h,003h
	   0C 86 03 29 0B
	   2B 03 14 0C 4B
	   03 07 0C 86 03
 000007E2  29 0B 2B 03 14     C db 029h,00bh,02bh,003h,014h,00ch,04bh,003h,007h,00ch,086h,003h,002h,00bh,025h,000h,002h,00bh,02bh,003h
	   0C 4B 03 07 0C
	   86 03 02 0B 25
	   00 02 0B 2B 03
 000007F6  14 0C 4B 03 07     C db 014h,00ch,04bh,003h,007h,00ch,086h,003h,002h,00bh,025h,000h,002h,00bh,02bh,003h,014h,00ch,04bh,003h
	   0C 86 03 02 0B
	   25 00 02 0B 2B
	   03 14 0C 4B 03
 0000080A  07 0C 86 03 02     C db 007h,00ch,086h,003h,002h,00bh,025h,000h,002h,00bh,02bh,003h,014h,00ch,04bh,003h,007h,00ch,086h,003h
	   0B 25 00 02 0B
	   2B 03 14 0C 4B
	   03 07 0C 86 03
 0000081E  02 0B 25 00 02     C db 002h,00bh,025h,000h,002h,00bh,02bh,003h,008h,00ch,032h,003h,001h,004h,001h,001h,002h,006h,003h,00ch
	   0B 2B 03 08 0C
	   32 03 01 04 01
	   01 02 06 03 0C
 00000832  02 06 01 01 01     C db 002h,006h,001h,001h,001h,005h,010h,003h,001h,005h,001h,002h,001h,006h,003h,00ch,001h,006h,001h,001h
	   05 10 03 01 05
	   01 02 01 06 03
	   0C 01 06 01 01
 00000846  01 04 01 03 07     C db 001h,004h,001h,003h,007h,00ch,026h,003h,001h,004h,001h,001h,001h,002h,001h,006h,005h,00ch,001h,006h
	   0C 26 03 01 04
	   01 01 01 02 01
	   06 05 0C 01 06
 0000085A  01 02 01 01 01     C db 001h,002h,001h,001h,001h,005h,053h,003h,002h,00bh,025h,000h,002h,00bh,02bh,003h,008h,00ch,010h,003h
	   05 53 03 02 0B
	   25 00 02 0B 2B
	   03 08 0C 10 03
 0000086E  01 02 06 0C 01     C db 001h,002h,006h,00ch,001h,006h,009h,003h,007h,00ch,001h,002h,007h,003h,001h,005h,001h,006h,00bh,00ch
	   06 09 03 07 0C
	   01 02 07 03 01
	   05 01 06 0B 0C
 00000882  01 06 01 05 0C     C db 001h,006h,001h,005h,00ch,003h,001h,005h,001h,006h,009h,00ch,001h,006h,007h,00ch,005h,003h,007h,00ch
	   03 01 05 01 06
	   09 0C 01 06 07
	   0C 05 03 07 0C
 00000896  09 03 07 0C 08     C db 009h,003h,007h,00ch,008h,003h,001h,005h,001h,002h,00eh,00ch,001h,002h,051h,003h,002h,00bh,025h,000h
	   03 01 05 01 02
	   0E 0C 01 02 51
	   03 02 0B 25 00
 000008AA  02 0B 2B 03 08     C db 002h,00bh,02bh,003h,008h,00ch,011h,003h,001h,006h,006h,00ch,001h,002h,007h,003h,001h,002h,006h,00ch
	   0C 11 03 01 06
	   06 0C 01 02 07
	   03 01 02 06 0C
 000008BE  01 06 07 03 01     C db 001h,006h,007h,003h,001h,007h,00fh,00ch,001h,007h,00ah,003h,001h,007h,013h,00ch,005h,003h,007h,00ch
	   07 0F 0C 01 07
	   0A 03 01 07 13
	   0C 05 03 07 0C
 000008D2  09 03 07 0C 07     C db 009h,003h,007h,00ch,007h,003h,001h,001h,011h,00ch,045h,003h,00eh,00bh,025h,000h,00bh,00bh,022h,003h
	   03 01 01 11 0C
	   45 03 0E 0B 25
	   00 0B 0B 22 03
 000008E6  08 0C 11 03 01     C db 008h,00ch,011h,003h,001h,004h,007h,00ch,001h,007h,005h,003h,001h,007h,007h,00ch,001h,004h,006h,003h
	   04 07 0C 01 07
	   05 03 01 07 07
	   0C 01 04 06 03
 000008FA  01 07 11 0C 01     C db 001h,007h,011h,00ch,001h,007h,008h,003h,001h,007h,014h,00ch,005h,003h,007h,00ch,009h,003h,007h,00ch
	   07 08 03 01 07
	   14 0C 05 03 07
	   0C 09 03 07 0C
 0000090E  06 03 01 01 12     C db 006h,003h,001h,001h,012h,00ch,045h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,008h,008h
	   0C 45 03 01 0B
	   0B 08 02 0B 25
	   00 02 0B 08 08
 00000922  01 0B 22 03 08     C db 001h,00bh,022h,003h,008h,00ch,012h,003h,001h,007h,007h,00ch,001h,004h,003h,003h,001h,004h,007h,00ch
	   0C 12 03 01 07
	   07 0C 01 04 03
	   03 01 04 07 0C
 00000936  01 05 06 03 01     C db 001h,005h,006h,003h,001h,004h,013h,00ch,001h,005h,006h,003h,001h,004h,015h,00ch,005h,003h,007h,00ch
	   04 13 0C 01 05
	   06 03 01 04 15
	   0C 05 03 07 0C
 0000094A  09 03 07 0C 05     C db 009h,003h,007h,00ch,005h,003h,001h,005h,013h,00ch,045h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h
	   03 01 05 13 0C
	   45 03 01 0B 0B
	   08 02 0B 25 00
 0000095E  02 0B 08 08 01     C db 002h,00bh,008h,008h,001h,00bh,022h,003h,013h,00ch,008h,003h,001h,001h,006h,00ch,001h,006h,003h,003h
	   0B 22 03 13 0C
	   08 03 01 01 06
	   0C 01 06 03 03
 00000972  01 06 06 0C 01     C db 001h,006h,006h,00ch,001h,001h,007h,003h,001h,006h,007h,00ch,001h,007h,003h,003h,001h,007h,007h,00ch
	   01 07 03 01 06
	   07 0C 01 07 03
	   03 01 07 07 0C
 00000986  01 06 06 03 01     C db 001h,006h,006h,003h,001h,002h,007h,00ch,001h,006h,001h,007h,003h,003h,001h,005h,001h,001h,007h,00ch
	   02 07 0C 01 06
	   01 07 03 03 01
	   05 01 01 07 0C
 0000099A  05 03 07 0C 09     C db 005h,003h,007h,00ch,009h,003h,007h,00ch,005h,003h,001h,002h,006h,00ch,001h,002h,001h,007h,001h,004h
	   03 07 0C 05 03
	   01 02 06 0C 01
	   02 01 07 01 04
 000009AE  03 03 01 05 01     C db 003h,003h,001h,005h,001h,007h,001h,001h,001h,006h,003h,00ch,045h,003h,001h,00bh,00bh,008h,002h,00bh
	   07 01 01 01 06
	   03 0C 45 03 01
	   0B 0B 08 02 0B
 000009C2  25 00 02 0B 08     C db 025h,000h,002h,00bh,008h,008h,001h,00bh,022h,003h,013h,00ch,009h,003h,001h,006h,006h,00ch,001h,001h
	   08 01 0B 22 03
	   13 0C 09 03 01
	   06 06 0C 01 01
 000009D6  01 03 01 01 06     C db 001h,003h,001h,001h,006h,00ch,001h,002h,007h,003h,001h,004h,007h,00ch,001h,005h,005h,003h,001h,005h
	   0C 01 02 07 03
	   01 04 07 0C 01
	   05 05 03 01 05
 000009EA  07 0C 01 04 04     C db 007h,00ch,001h,004h,004h,003h,001h,004h,007h,00ch,001h,002h,007h,003h,007h,00ch,005h,003h,007h,00ch
	   03 01 04 07 0C
	   01 02 07 03 07
	   0C 05 03 07 0C
 000009FE  09 03 07 0C 05     C db 009h,003h,007h,00ch,005h,003h,007h,00ch,00ah,003h,001h,004h,001h,002h,001h,00ch,045h,003h,001h,00bh
	   03 07 0C 0A 03
	   01 04 01 02 01
	   0C 45 03 01 0B
 00000A12  0B 08 02 0B 25     C db 00bh,008h,002h,00bh,025h,000h,002h,00bh,008h,008h,001h,00bh,022h,003h,013h,00ch,00ah,003h,001h,006h
	   00 02 0B 08 08
	   01 0B 22 03 13
	   0C 0A 03 01 06
 00000A26  06 0C 01 01 06     C db 006h,00ch,001h,001h,006h,00ch,001h,006h,008h,003h,001h,001h,006h,00ch,001h,002h,007h,003h,001h,002h
	   0C 01 06 08 03
	   01 01 06 0C 01
	   02 07 03 01 02
 00000A3A  06 0C 01 01 04     C db 006h,00ch,001h,001h,004h,003h,001h,001h,007h,00ch,008h,003h,007h,00ch,005h,003h,007h,00ch,009h,003h
	   03 01 01 07 0C
	   08 03 07 0C 05
	   03 07 0C 09 03
 00000A4E  07 0C 05 03 07     C db 007h,00ch,005h,003h,007h,00ch,001h,001h,051h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh
	   0C 01 01 51 03
	   01 0B 0B 08 02
	   0B 25 00 02 0B
 00000A62  08 08 01 0B 22     C db 008h,008h,001h,00bh,022h,003h,013h,00ch,00ah,003h,001h,005h,00dh,00ch,001h,005h,008h,003h,001h,006h
	   03 13 0C 0A 03
	   01 05 0D 0C 01
	   05 08 03 01 06
 00000A76  06 0C 01 07 07     C db 006h,00ch,001h,007h,007h,003h,001h,007h,006h,00ch,001h,006h,004h,003h,001h,002h,006h,00ch,001h,001h
	   03 01 07 06 0C
	   01 06 04 03 01
	   02 06 0C 01 01
 00000A8A  08 03 07 0C 05     C db 008h,003h,007h,00ch,005h,003h,007h,00ch,009h,003h,007h,00ch,005h,003h,009h,00ch,001h,006h,001h,001h
	   03 07 0C 09 03
	   07 0C 05 03 09
	   0C 01 06 01 01
 00000A9E  01 07 01 05 4C     C db 001h,007h,001h,005h,04ch,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,008h,008h,001h,00bh
	   03 01 0B 0B 08
	   02 0B 25 00 02
	   0B 08 08 01 0B
 00000AB2  22 03 13 0C 0B     C db 022h,003h,013h,00ch,00bh,003h,001h,007h,00bh,00ch,001h,007h,009h,003h,001h,006h,006h,00ch,001h,004h
	   03 01 07 0B 0C
	   01 07 09 03 01
	   06 06 0C 01 04
 00000AC6  07 03 01 04 06     C db 007h,003h,001h,004h,006h,00ch,001h,006h,004h,003h,001h,006h,006h,00ch,001h,005h,008h,003h,007h,00ch
	   0C 01 06 04 03
	   01 06 06 0C 01
	   05 08 03 07 0C
 00000ADA  05 03 07 0C 09     C db 005h,003h,007h,00ch,009h,003h,007h,00ch,005h,003h,001h,002h,00dh,00ch,001h,006h,001h,001h,001h,005h
	   03 07 0C 05 03
	   01 02 0D 0C 01
	   06 01 01 01 05
 00000AEE  48 03 01 0B 0B     C db 048h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,008h,008h,001h,00bh,022h,003h,013h,00ch
	   08 02 0B 25 00
	   02 0B 08 08 01
	   0B 22 03 13 0C
 00000B02  0C 03 01 02 09     C db 00ch,003h,001h,002h,009h,00ch,001h,002h,00ah,003h,007h,00ch,009h,003h,007h,00ch,004h,003h,007h,00ch
	   0C 01 02 0A 03
	   07 0C 09 03 07
	   0C 04 03 07 0C
 00000B16  09 03 07 0C 05     C db 009h,003h,007h,00ch,005h,003h,007h,00ch,009h,003h,007h,00ch,005h,003h,001h,004h,010h,00ch,001h,006h
	   03 07 0C 09 03
	   07 0C 05 03 01
	   04 10 0C 01 06
 00000B2A  01 07 46 03 01     C db 001h,007h,046h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,008h,008h,001h,00bh,022h,003h
	   0B 0B 08 02 0B
	   25 00 02 0B 08
	   08 01 0B 22 03
 00000B3E  08 0C 18 03 01     C db 008h,00ch,018h,003h,001h,006h,007h,00ch,001h,006h,00bh,003h,007h,00ch,009h,003h,007h,00ch,004h,003h
	   06 07 0C 01 06
	   0B 03 07 0C 09
	   03 07 0C 04 03
 00000B52  07 0C 09 03 07     C db 007h,00ch,009h,003h,007h,00ch,005h,003h,007h,00ch,009h,003h,007h,00ch,006h,003h,001h,007h,011h,00ch
	   0C 05 03 07 0C
	   09 03 07 0C 06
	   03 01 07 11 0C
 00000B66  01 07 45 03 01     C db 001h,007h,045h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,008h,008h,001h,00bh,022h,003h
	   0B 0B 08 02 0B
	   25 00 02 0B 08
	   08 01 0B 22 03
 00000B7A  08 0C 18 03 01     C db 008h,00ch,018h,003h,001h,006h,007h,00ch,001h,006h,00bh,003h,007h,00ch,009h,003h,007h,00ch,004h,003h
	   06 07 0C 01 06
	   0B 03 07 0C 09
	   03 07 0C 04 03
 00000B8E  07 0C 09 03 07     C db 007h,00ch,009h,003h,007h,00ch,005h,003h,007h,00ch,009h,003h,007h,00ch,007h,003h,001h,005h,001h,006h
	   0C 05 03 07 0C
	   09 03 07 0C 07
	   03 01 05 01 06
 00000BA2  10 0C 01 05 44     C db 010h,00ch,001h,005h,044h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,008h,008h,001h,00bh
	   03 01 0B 0B 08
	   02 0B 25 00 02
	   0B 08 08 01 0B
 00000BB6  22 03 08 0C 17     C db 022h,003h,008h,00ch,017h,003h,001h,002h,009h,00ch,001h,002h,00ah,003h,001h,006h,006h,00ch,001h,004h
	   03 01 02 09 0C
	   01 02 0A 03 01
	   06 06 0C 01 04
 00000BCA  08 03 06 0C 01     C db 008h,003h,006h,00ch,001h,006h,004h,003h,007h,00ch,009h,003h,007h,00ch,005h,003h,007h,00ch,009h,003h
	   06 04 03 07 0C
	   09 03 07 0C 05
	   03 07 0C 09 03
 00000BDE  07 0C 09 03 01     C db 007h,00ch,009h,003h,001h,007h,001h,002h,001h,006h,00dh,00ch,001h,002h,044h,003h,001h,00bh,00bh,008h
	   07 01 02 01 06
	   0D 0C 01 02 44
	   03 01 0B 0B 08
 00000BF2  02 0B 25 00 1A     C db 002h,00bh,025h,000h,01ah,00bh,013h,003h,008h,00ch,016h,003h,001h,007h,00bh,00ch,001h,007h,009h,003h
	   0B 13 03 08 0C
	   16 03 01 07 0B
	   0C 01 07 09 03
 00000C06  01 06 06 0C 01     C db 001h,006h,006h,00ch,001h,007h,007h,003h,001h,007h,006h,00ch,001h,006h,004h,003h,001h,006h,006h,00ch
	   07 07 03 01 07
	   06 0C 01 06 04
	   03 01 06 06 0C
 00000C1A  01 05 08 03 07     C db 001h,005h,008h,003h,007h,00ch,005h,003h,007h,00ch,001h,005h,008h,003h,007h,00ch,00dh,003h,001h,005h
	   0C 05 03 07 0C
	   01 05 08 03 07
	   0C 0D 03 01 05
 00000C2E  02 01 01 06 09     C db 002h,001h,001h,006h,009h,00ch,044h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,01ah,00bh,013h,003h
	   0C 44 03 01 0B
	   0B 08 02 0B 25
	   00 1A 0B 13 03
 00000C42  08 0C 15 03 01     C db 008h,00ch,015h,003h,001h,005h,00dh,00ch,001h,005h,008h,003h,001h,001h,006h,00ch,001h,002h,007h,003h
	   05 0D 0C 01 05
	   08 03 01 01 06
	   0C 01 02 07 03
 00000C56  01 02 06 0C 01     C db 001h,002h,006h,00ch,001h,001h,004h,003h,001h,002h,006h,00ch,001h,002h,008h,003h,007h,00ch,005h,003h
	   01 04 03 01 02
	   06 0C 01 02 08
	   03 07 0C 05 03
 00000C6A  07 0C 01 02 08     C db 007h,00ch,001h,002h,008h,003h,007h,00ch,005h,003h,001h,00ch,001h,001h,00bh,003h,001h,001h,007h,00ch
	   03 07 0C 05 03
	   01 0C 01 01 0B
	   03 01 01 07 0C
 00000C7E  44 03 01 0B 0B     C db 044h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,01ah,00bh,013h,003h,008h,00ch,015h,003h,001h,006h
	   08 02 0B 25 00
	   1A 0B 13 03 08
	   0C 15 03 01 06
 00000C92  06 0C 01 01 06     C db 006h,00ch,001h,001h,006h,00ch,001h,006h,008h,003h,001h,004h,007h,00ch,001h,005h,005h,003h,001h,005h
	   0C 01 06 08 03
	   01 04 07 0C 01
	   05 05 03 01 05
 00000CA6  07 0C 01 04 04     C db 007h,00ch,001h,004h,004h,003h,001h,007h,007h,00ch,001h,005h,007h,003h,007h,00ch,005h,003h,008h,00ch
	   03 01 07 07 0C
	   01 05 07 03 07
	   0C 05 03 08 0C
 00000CBA  01 01 01 05 03     C db 001h,001h,001h,005h,003h,003h,001h,007h,001h,002h,008h,00ch,005h,003h,002h,00ch,001h,006h,001h,007h
	   03 01 07 01 02
	   08 0C 05 03 02
	   0C 01 06 01 07
 00000CCE  0A 03 07 0C 44     C db 00ah,003h,007h,00ch,044h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,01ah,00bh,013h,003h,014h,00ch
	   03 01 0B 0B 08
	   02 0B 25 00 1A
	   0B 13 03 14 0C
 00000CE2  08 03 01 02 06     C db 008h,003h,001h,002h,006h,00ch,001h,001h,001h,003h,001h,001h,006h,00ch,001h,006h,008h,003h,001h,006h
	   0C 01 01 01 03
	   01 01 06 0C 01
	   06 08 03 01 06
 00000CF6  07 0C 01 07 03     C db 007h,00ch,001h,007h,003h,003h,001h,007h,007h,00ch,001h,006h,006h,003h,008h,00ch,001h,001h,001h,004h
	   03 01 07 07 0C
	   01 06 06 03 08
	   0C 01 01 01 04
 00000D0A  02 03 01 05 01     C db 002h,003h,001h,005h,001h,001h,008h,00ch,005h,003h,001h,006h,016h,00ch,005h,003h,005h,00ch,001h,002h
	   01 08 0C 05 03
	   01 06 16 0C 05
	   03 05 0C 01 02
 00000D1E  01 07 01 05 04     C db 001h,007h,001h,005h,004h,003h,001h,005h,001h,002h,006h,00ch,001h,002h,044h,003h,001h,00bh,00bh,008h
	   03 01 05 01 02
	   06 0C 01 02 44
	   03 01 0B 0B 08
 00000D32  02 0B 25 00 1A     C db 002h,00bh,025h,000h,01ah,00bh,013h,003h,014h,00ch,007h,003h,001h,001h,006h,00ch,001h,006h,003h,003h
	   0B 13 03 14 0C
	   07 03 01 01 06
	   0C 01 06 03 03
 00000D46  01 06 06 0C 01     C db 001h,006h,006h,00ch,001h,001h,007h,003h,001h,004h,013h,00ch,001h,004h,006h,003h,001h,001h,015h,00ch
	   01 07 03 01 04
	   13 0C 01 04 06
	   03 01 01 15 0C
 00000D5A  05 03 01 01 16     C db 005h,003h,001h,001h,016h,00ch,005h,003h,014h,00ch,001h,005h,044h,003h,001h,00bh,00bh,008h,002h,00bh
	   0C 05 03 14 0C
	   01 05 44 03 01
	   0B 0B 08 02 0B
 00000D6E  25 00 02 0B 13     C db 025h,000h,002h,00bh,013h,009h,005h,00bh,013h,003h,014h,00ch,006h,003h,001h,005h,007h,00ch,001h,005h
	   09 05 0B 13 03
	   14 0C 06 03 01
	   05 07 0C 01 05
 00000D82  03 03 01 04 07     C db 003h,003h,001h,004h,007h,00ch,001h,007h,007h,003h,001h,007h,011h,00ch,001h,007h,008h,003h,001h,006h
	   0C 01 07 07 03
	   01 07 11 0C 01
	   07 08 03 01 06
 00000D96  14 0C 06 03 16     C db 014h,00ch,006h,003h,016h,00ch,005h,003h,013h,00ch,001h,001h,045h,003h,001h,00bh,00bh,008h,002h,00bh
	   0C 05 03 13 0C
	   01 01 45 03 01
	   0B 0B 08 02 0B
 00000DAA  25 00 02 0B 13     C db 025h,000h,002h,00bh,013h,009h,005h,00bh,013h,003h,014h,00ch,005h,003h,001h,004h,007h,00ch,001h,001h
	   09 05 0B 13 03
	   14 0C 05 03 01
	   04 07 0C 01 01
 00000DBE  05 03 01 07 07     C db 005h,003h,001h,007h,007h,00ch,001h,004h,007h,003h,001h,007h,00fh,00ch,001h,007h,009h,003h,001h,005h
	   0C 01 04 07 03
	   01 07 0F 0C 01
	   07 09 03 01 05
 00000DD2  14 0C 06 03 01     C db 014h,00ch,006h,003h,001h,007h,00dh,00ch,001h,001h,007h,00ch,005h,003h,012h,00ch,001h,001h,046h,003h
	   07 0D 0C 01 01
	   07 0C 05 03 12
	   0C 01 01 46 03
 00000DE6  01 0B 0B 08 02     C db 001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,013h,003h,014h,00ch,005h,003h
	   0B 25 00 02 0B
	   13 09 05 0B 13
	   03 14 0C 05 03
 00000DFA  01 06 06 0C 01     C db 001h,006h,006h,00ch,001h,002h,007h,003h,001h,002h,006h,00ch,001h,006h,008h,003h,001h,005h,001h,006h
	   02 07 03 01 02
	   06 0C 01 06 08
	   03 01 05 01 06
 00000E0E  0B 0C 01 06 01     C db 00bh,00ch,001h,006h,001h,005h,00bh,003h,001h,005h,001h,006h,009h,00ch,001h,006h,001h,005h,007h,00ch
	   05 0B 03 01 05
	   01 06 09 0C 01
	   06 01 05 07 0C
 00000E22  07 03 01 07 0A     C db 007h,003h,001h,007h,00ah,00ch,001h,002h,002h,003h,007h,00ch,005h,003h,001h,007h,001h,002h,00eh,00ch
	   0C 01 02 02 03
	   07 0C 05 03 01
	   07 01 02 0E 0C
 00000E36  01 02 01 05 47     C db 001h,002h,001h,005h,047h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh
	   03 01 0B 0B 08
	   02 0B 25 00 02
	   0B 13 09 05 0B
 00000E4A  13 03 14 0C 04     C db 013h,003h,014h,00ch,004h,003h,001h,002h,006h,00ch,001h,006h,009h,003h,001h,006h,006h,00ch,001h,002h
	   03 01 02 06 0C
	   01 06 09 03 01
	   06 06 0C 01 02
 00000E5E  09 03 01 05 01     C db 009h,003h,001h,005h,001h,001h,002h,006h,003h,00ch,002h,006h,001h,001h,001h,005h,00fh,003h,001h,007h
	   01 02 06 03 0C
	   02 06 01 01 01
	   05 0F 03 01 07
 00000E72  01 02 04 0C 01     C db 001h,002h,004h,00ch,001h,006h,001h,002h,001h,005h,002h,003h,007h,00ch,009h,003h,001h,001h,001h,006h
	   06 01 02 01 05
	   02 03 07 0C 09
	   03 01 01 01 06
 00000E86  04 0C 01 06 01     C db 004h,00ch,001h,006h,001h,001h,001h,004h,003h,003h,007h,00ch,008h,003h,001h,007h,001h,001h,002h,006h
	   01 01 04 03 03
	   07 0C 08 03 01
	   07 01 01 02 06
 00000E9A  05 0C 01 06 01     C db 005h,00ch,001h,006h,001h,002h,001h,007h,001h,004h,049h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h
	   02 01 07 01 04
	   49 03 01 0B 0B
	   08 02 0B 25 00
 00000EAE  02 0B 13 09 05     C db 002h,00bh,013h,009h,005h,00bh,0f3h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,013h,009h
	   0B F3 03 01 0B
	   0B 08 02 0B 25
	   00 02 0B 13 09
 00000EC2  05 0B F3 03 01     C db 005h,00bh,0f3h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,0f3h,003h
	   0B 0B 08 02 0B
	   25 00 02 0B 13
	   09 05 0B F3 03
 00000ED6  01 0B 0B 08 02     C db 001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,0f3h,003h,001h,00bh,00bh,008h
	   0B 25 00 02 0B
	   13 09 05 0B F3
	   03 01 0B 0B 08
 00000EEA  02 0B 25 00 02     C db 002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,0f3h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h
	   0B 13 09 05 0B
	   F3 03 01 0B 0B
	   08 02 0B 25 00
 00000EFE  02 0B 13 09 05     C db 002h,00bh,013h,009h,005h,00bh,0f3h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,013h,009h
	   0B F3 03 01 0B
	   0B 08 02 0B 25
	   00 02 0B 13 09
 00000F12  05 0B EC 03 15     C db 005h,00bh,0ech,003h,015h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,0ech,003h,015h,00bh,025h,000h
	   0B 25 00 02 0B
	   13 09 05 0B EC
	   03 15 0B 25 00
 00000F26  02 0B 13 09 05     C db 002h,00bh,013h,009h,005h,00bh,0ech,003h,015h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,0ech,003h
	   0B EC 03 15 0B
	   25 00 02 0B 13
	   09 05 0B EC 03
 00000F3A  03 0B 10 0A 02     C db 003h,00bh,010h,00ah,002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,030h,003h,001h,007h,001h,001h
	   0B 25 00 02 0B
	   13 09 05 0B 30
	   03 01 07 01 01
 00000F4E  02 06 04 0C 02     C db 002h,006h,004h,00ch,002h,006h,001h,001h,001h,005h,011h,003h,001h,007h,001h,002h,001h,006h,004h,00ch
	   06 01 01 01 05
	   11 03 01 07 01
	   02 01 06 04 0C
 00000F62  01 06 01 02 01     C db 001h,006h,001h,002h,001h,001h,012h,003h,001h,007h,001h,002h,001h,006h,004h,00ch,001h,006h,001h,002h
	   01 12 03 01 07
	   01 02 01 06 04
	   0C 01 06 01 02
 00000F76  01 01 0E 03 01     C db 001h,001h,00eh,003h,001h,007h,001h,001h,002h,006h,004h,00ch,002h,006h,001h,001h,001h,005h,05fh,003h
	   07 01 01 02 06
	   04 0C 02 06 01
	   01 01 05 5F 03
 00000F8A  03 0B 10 0A 02     C db 003h,00bh,010h,00ah,002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,02dh,003h,001h,001h,001h,006h
	   0B 25 00 02 0B
	   13 09 05 0B 2D
	   03 01 01 01 06
 00000F9E  0D 0C 01 06 01     C db 00dh,00ch,001h,006h,001h,005h,00dh,003h,001h,001h,00ch,00ch,001h,001h,00eh,003h,001h,001h,00ch,00ch
	   05 0D 03 01 01
	   0C 0C 01 01 0E
	   03 01 01 0C 0C
 00000FB2  01 01 09 03 01     C db 001h,001h,009h,003h,001h,001h,001h,006h,00dh,00ch,001h,006h,001h,005h,05dh,003h,003h,00bh,010h,00ah
	   01 01 06 0D 0C
	   01 06 01 05 5D
	   03 03 0B 10 0A
 00000FC6  02 0B 25 00 02     C db 002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,02dh,003h,011h,00ch,001h,007h,00ah,003h,001h,005h
	   0B 13 09 05 0B
	   2D 03 11 0C 01
	   07 0A 03 01 05
 00000FDA  01 06 0E 0C 01     C db 001h,006h,00eh,00ch,001h,006h,001h,005h,00ah,003h,001h,005h,001h,006h,00eh,00ch,001h,006h,001h,005h
	   06 01 05 0A 03
	   01 05 01 06 0E
	   0C 01 06 01 05
 00000FEE  07 03 11 0C 01     C db 007h,003h,011h,00ch,001h,007h,05ch,003h,003h,00bh,010h,00ah,002h,00bh,025h,000h,002h,00bh,013h,009h
	   07 5C 03 03 0B
	   10 0A 02 0B 25
	   00 02 0B 13 09
 00001002  05 0B 2D 03 12     C db 005h,00bh,02dh,003h,012h,00ch,001h,007h,009h,003h,012h,00ch,00ah,003h,012h,00ch,007h,003h,012h,00ch
	   0C 01 07 09 03
	   12 0C 0A 03 12
	   0C 07 03 12 0C
 00001016  01 07 5B 03 03     C db 001h,007h,05bh,003h,003h,00bh,010h,00ah,002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,02dh,003h
	   0B 10 0A 02 0B
	   25 00 02 0B 13
	   09 05 0B 2D 03
 0000102A  13 0C 08 03 01     C db 013h,00ch,008h,003h,001h,006h,012h,00ch,001h,006h,008h,003h,001h,006h,012h,00ch,001h,006h,006h,003h
	   06 12 0C 01 06
	   08 03 01 06 12
	   0C 01 06 06 03
 0000103E  13 0C 5B 03 03     C db 013h,00ch,05bh,003h,003h,00bh,010h,00ah,002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,02dh,003h
	   0B 10 0A 02 0B
	   25 00 02 0B 13
	   09 05 0B 2D 03
 00001052  13 0C 01 01 06     C db 013h,00ch,001h,001h,006h,003h,001h,005h,008h,00ch,001h,007h,002h,003h,001h,007h,008h,00ch,001h,005h
	   03 01 05 08 0C
	   01 07 02 03 01
	   07 08 0C 01 05
 00001066  06 03 01 05 08     C db 006h,003h,001h,005h,008h,00ch,001h,007h,002h,003h,001h,007h,008h,00ch,001h,005h,005h,003h,013h,00ch
	   0C 01 07 02 03
	   01 07 08 0C 01
	   05 05 03 13 0C
 0000107A  01 01 5A 03 03     C db 001h,001h,05ah,003h,003h,00bh,010h,00ah,002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,02dh,003h
	   0B 10 0A 02 0B
	   25 00 02 0B 13
	   09 05 0B 2D 03
 0000108E  03 0C 01 02 01     C db 003h,00ch,001h,002h,001h,007h,001h,005h,003h,003h,001h,007h,001h,006h,008h,00ch,001h,006h,006h,003h
	   07 01 05 03 03
	   01 07 01 06 08
	   0C 01 06 06 03
 000010A2  01 02 07 0C 01     C db 001h,002h,007h,00ch,001h,007h,004h,003h,001h,007h,007h,00ch,001h,002h,006h,003h,001h,002h,007h,00ch
	   07 04 03 01 07
	   07 0C 01 02 06
	   03 01 02 07 0C
 000010B6  01 07 04 03 01     C db 001h,007h,004h,003h,001h,007h,007h,00ch,001h,002h,005h,003h,003h,00ch,001h,002h,001h,007h,001h,005h
	   07 07 0C 01 02
	   05 03 03 0C 01
	   02 01 07 01 05
 000010CA  03 03 01 07 01     C db 003h,003h,001h,007h,001h,006h,008h,00ch,001h,006h,05ah,003h,003h,00bh,010h,00ah,002h,00bh,025h,000h
	   06 08 0C 01 06
	   5A 03 03 0B 10
	   0A 02 0B 25 00
 000010DE  02 0B 13 09 05     C db 002h,00bh,013h,009h,005h,00bh,02dh,003h,001h,00ch,001h,001h,001h,004h,008h,003h,001h,006h,008h,00ch
	   0B 2D 03 01 0C
	   01 01 01 04 08
	   03 01 06 08 0C
 000010F2  06 03 07 0C 01     C db 006h,003h,007h,00ch,001h,006h,006h,003h,001h,006h,007h,00ch,006h,003h,007h,00ch,001h,006h,006h,003h
	   06 06 03 01 06
	   07 0C 06 03 07
	   0C 01 06 06 03
 00001106  01 06 07 0C 05     C db 001h,006h,007h,00ch,005h,003h,001h,00ch,001h,001h,001h,004h,008h,003h,001h,006h,008h,00ch,05ah,003h
	   03 01 0C 01 01
	   01 04 08 03 01
	   06 08 0C 5A 03
 0000111A  03 0B 10 0A 29     C db 003h,00bh,010h,00ah,029h,00bh,013h,009h,005h,00bh,038h,003h,001h,007h,008h,00ch,005h,003h,001h,007h
	   0B 13 09 05 0B
	   38 03 01 07 08
	   0C 05 03 01 07
 0000112E  07 0C 01 01 06     C db 007h,00ch,001h,001h,006h,003h,001h,001h,007h,00ch,001h,007h,004h,003h,001h,007h,007h,00ch,001h,001h
	   03 01 01 07 0C
	   01 07 04 03 01
	   07 07 0C 01 01
 00001142  06 03 01 01 07     C db 006h,003h,001h,001h,007h,00ch,001h,007h,00fh,003h,001h,007h,008h,00ch,05ah,003h,003h,00bh,010h,00ah
	   0C 01 07 0F 03
	   01 07 08 0C 5A
	   03 03 0B 10 0A
 00001156  29 0B 13 09 05     C db 029h,00bh,013h,009h,005h,00bh,039h,003h,008h,00ch,005h,003h,001h,001h,007h,00ch,001h,007h,006h,003h
	   0B 39 03 08 0C
	   05 03 01 01 07
	   0C 01 07 06 03
 0000116A  01 07 07 0C 01     C db 001h,007h,007h,00ch,001h,001h,004h,003h,001h,001h,007h,00ch,001h,007h,006h,003h,001h,007h,007h,00ch
	   01 04 03 01 01
	   07 0C 01 07 06
	   03 01 07 07 0C
 0000117E  01 01 10 03 08     C db 001h,001h,010h,003h,008h,00ch,05ah,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,039h,003h
	   0C 5A 03 03 0B
	   1F 0A 03 0B 2A
	   09 05 0B 39 03
 00001192  07 0C 01 06 05     C db 007h,00ch,001h,006h,005h,003h,001h,006h,007h,00ch,001h,005h,006h,003h,001h,005h,007h,00ch,001h,006h
	   03 01 06 07 0C
	   01 05 06 03 01
	   05 07 0C 01 06
 000011A6  04 03 01 06 07     C db 004h,003h,001h,006h,007h,00ch,001h,005h,006h,003h,001h,005h,007h,00ch,001h,006h,010h,003h,007h,00ch
	   0C 01 05 06 03
	   01 05 07 0C 01
	   06 10 03 07 0C
 000011BA  01 06 5A 03 03     C db 001h,006h,05ah,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,038h,003h,001h,005h,007h,00ch
	   0B 1F 0A 03 0B
	   2A 09 05 0B 38
	   03 01 05 07 0C
 000011CE  01 02 05 03 01     C db 001h,002h,005h,003h,001h,006h,007h,00ch,001h,004h,006h,003h,001h,004h,007h,00ch,001h,006h,004h,003h
	   06 07 0C 01 04
	   06 03 01 04 07
	   0C 01 06 04 03
 000011E2  01 06 07 0C 01     C db 001h,006h,007h,00ch,001h,004h,006h,003h,001h,004h,007h,00ch,001h,006h,00fh,003h,001h,005h,007h,00ch
	   04 06 03 01 04
	   07 0C 01 06 0F
	   03 01 05 07 0C
 000011F6  01 02 5A 03 03     C db 001h,002h,05ah,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,038h,003h,001h,001h,007h,00ch
	   0B 1F 0A 03 0B
	   2A 09 05 0B 38
	   03 01 01 07 0C
 0000120A  01 07 05 03 08     C db 001h,007h,005h,003h,008h,00ch,008h,003h,008h,00ch,004h,003h,008h,00ch,008h,003h,008h,00ch,00fh,003h
	   0C 08 03 08 0C
	   04 03 08 0C 08
	   03 08 0C 0F 03
 0000121E  01 01 07 0C 01     C db 001h,001h,007h,00ch,001h,007h,05ah,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,038h,003h
	   07 5A 03 03 0B
	   1F 0A 03 0B 2A
	   09 05 0B 38 03
 00001232  07 0C 01 06 06     C db 007h,00ch,001h,006h,006h,003h,008h,00ch,008h,003h,008h,00ch,004h,003h,008h,00ch,008h,003h,008h,00ch
	   03 08 0C 08 03
	   08 0C 04 03 08
	   0C 08 03 08 0C
 00001246  0F 03 07 0C 01     C db 00fh,003h,007h,00ch,001h,006h,05bh,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,037h,003h
	   06 5B 03 03 0B
	   1F 0A 03 0B 2A
	   09 05 0B 37 03
 0000125A  01 02 07 0C 01     C db 001h,002h,007h,00ch,001h,007h,006h,003h,008h,00ch,008h,003h,008h,00ch,004h,003h,008h,00ch,008h,003h
	   07 06 03 08 0C
	   08 03 08 0C 04
	   03 08 0C 08 03
 0000126E  08 0C 0E 03 01     C db 008h,00ch,00eh,003h,001h,002h,007h,00ch,001h,007h,05bh,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h
	   02 07 0C 01 07
	   5B 03 03 0B 1F
	   0A 03 0B 2A 09
 00001282  05 0B 36 03 01     C db 005h,00bh,036h,003h,001h,001h,007h,00ch,001h,002h,007h,003h,008h,00ch,008h,003h,008h,00ch,004h,003h
	   01 07 0C 01 02
	   07 03 08 0C 08
	   03 08 0C 04 03
 00001296  08 0C 08 03 08     C db 008h,00ch,008h,003h,008h,00ch,00dh,003h,001h,001h,007h,00ch,001h,002h,05ch,003h,003h,00bh,01fh,00ah
	   0C 0D 03 01 01
	   07 0C 01 02 5C
	   03 03 0B 1F 0A
 000012AA  03 0B 2A 09 05     C db 003h,00bh,02ah,009h,005h,00bh,035h,003h,001h,007h,007h,00ch,001h,006h,008h,003h,008h,00ch,008h,003h
	   0B 35 03 01 07
	   07 0C 01 06 08
	   03 08 0C 08 03
 000012BE  08 0C 04 03 08     C db 008h,00ch,004h,003h,008h,00ch,008h,003h,008h,00ch,00ch,003h,001h,007h,007h,00ch,001h,006h,05dh,003h
	   0C 08 03 08 0C
	   0C 03 01 07 07
	   0C 01 06 5D 03
 000012D2  03 0B 1F 0A 03     C db 003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,034h,003h,001h,007h,008h,00ch,001h,005h,008h,003h
	   0B 2A 09 05 0B
	   34 03 01 07 08
	   0C 01 05 08 03
 000012E6  08 0C 08 03 08     C db 008h,00ch,008h,003h,008h,00ch,004h,003h,008h,00ch,008h,003h,008h,00ch,00bh,003h,001h,007h,008h,00ch
	   0C 04 03 08 0C
	   08 03 08 0C 0B
	   03 01 07 08 0C
 000012FA  01 05 5D 03 03     C db 001h,005h,05dh,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,033h,003h,001h,007h,008h,00ch
	   0B 1F 0A 03 0B
	   2A 09 05 0B 33
	   03 01 07 08 0C
 0000130E  01 05 09 03 01     C db 001h,005h,009h,003h,001h,006h,007h,00ch,001h,004h,006h,003h,001h,004h,007h,00ch,001h,006h,004h,003h
	   06 07 0C 01 04
	   06 03 01 04 07
	   0C 01 06 04 03
 00001322  01 06 07 0C 01     C db 001h,006h,007h,00ch,001h,004h,006h,003h,001h,004h,007h,00ch,001h,006h,00ah,003h,001h,007h,008h,00ch
	   04 06 03 01 04
	   07 0C 01 06 0A
	   03 01 07 08 0C
 00001336  01 05 5E 03 03     C db 001h,005h,05eh,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,032h,003h,001h,001h,008h,00ch
	   0B 1F 0A 03 0B
	   2A 09 05 0B 32
	   03 01 01 08 0C
 0000134A  01 05 0A 03 01     C db 001h,005h,00ah,003h,001h,006h,007h,00ch,001h,005h,006h,003h,001h,005h,007h,00ch,001h,006h,004h,003h
	   06 07 0C 01 05
	   06 03 01 05 07
	   0C 01 06 04 03
 0000135E  01 06 07 0C 01     C db 001h,006h,007h,00ch,001h,005h,006h,003h,001h,005h,007h,00ch,001h,006h,009h,003h,001h,001h,008h,00ch
	   05 06 03 01 05
	   07 0C 01 06 09
	   03 01 01 08 0C
 00001372  01 05 5F 03 03     C db 001h,005h,05fh,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,031h,003h,001h,002h,007h,00ch
	   0B 1F 0A 03 0B
	   2A 09 05 0B 31
	   03 01 02 07 0C
 00001386  01 06 01 04 0B     C db 001h,006h,001h,004h,00bh,003h,001h,001h,007h,00ch,001h,007h,006h,003h,001h,007h,007h,00ch,001h,001h
	   03 01 01 07 0C
	   01 07 06 03 01
	   07 07 0C 01 01
 0000139A  04 03 01 01 07     C db 004h,003h,001h,001h,007h,00ch,001h,007h,006h,003h,001h,007h,007h,00ch,001h,001h,008h,003h,001h,002h
	   0C 01 07 06 03
	   01 07 07 0C 01
	   01 08 03 01 02
 000013AE  07 0C 01 06 01     C db 007h,00ch,001h,006h,001h,004h,060h,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,030h,003h
	   04 60 03 03 0B
	   1F 0A 03 0B 2A
	   09 05 0B 30 03
 000013C2  01 06 07 0C 01     C db 001h,006h,007h,00ch,001h,002h,00dh,003h,001h,007h,007h,00ch,001h,001h,006h,003h,001h,001h,007h,00ch
	   02 0D 03 01 07
	   07 0C 01 01 06
	   03 01 01 07 0C
 000013D6  01 07 04 03 01     C db 001h,007h,004h,003h,001h,007h,007h,00ch,001h,001h,006h,003h,001h,001h,007h,00ch,001h,007h,007h,003h
	   07 07 0C 01 01
	   06 03 01 01 07
	   0C 01 07 07 03
 000013EA  01 06 07 0C 01     C db 001h,006h,007h,00ch,001h,002h,062h,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,02eh,003h
	   02 62 03 03 0B
	   1F 0A 03 0B 2A
	   09 05 0B 2E 03
 000013FE  01 05 08 0C 01     C db 001h,005h,008h,00ch,001h,001h,00fh,003h,007h,00ch,001h,006h,006h,003h,001h,006h,007h,00ch,006h,003h
	   01 0F 03 07 0C
	   01 06 06 03 01
	   06 07 0C 06 03
 00001412  07 0C 01 06 06     C db 007h,00ch,001h,006h,006h,003h,001h,006h,007h,00ch,006h,003h,001h,005h,008h,00ch,001h,001h,063h,003h
	   03 01 06 07 0C
	   06 03 01 05 08
	   0C 01 01 63 03
 00001426  03 0B 1F 0A 03     C db 003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,02dh,003h,001h,007h,008h,00ch,001h,007h,010h,003h
	   0B 2A 09 05 0B
	   2D 03 01 07 08
	   0C 01 07 10 03
 0000143A  01 06 07 0C 01     C db 001h,006h,007h,00ch,001h,001h,004h,003h,001h,001h,007h,00ch,001h,002h,006h,003h,001h,006h,007h,00ch
	   01 04 03 01 01
	   07 0C 01 02 06
	   03 01 06 07 0C
 0000144E  01 01 04 03 01     C db 001h,001h,004h,003h,001h,001h,007h,00ch,001h,002h,005h,003h,001h,007h,008h,00ch,001h,007h,064h,003h
	   01 07 0C 01 02
	   05 03 01 07 08
	   0C 01 07 64 03
 00001462  03 0B 1F 0A 03     C db 003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,02ch,003h,001h,002h,015h,00ch,005h,003h,001h,005h
	   0B 2A 09 05 0B
	   2C 03 01 02 15
	   0C 05 03 01 05
 00001476  08 0C 01 01 02     C db 008h,00ch,001h,001h,002h,003h,001h,001h,008h,00ch,001h,005h,006h,003h,001h,005h,008h,00ch,001h,001h
	   03 01 01 08 0C
	   01 05 06 03 01
	   05 08 0C 01 01
 0000148A  02 03 01 01 08     C db 002h,003h,001h,001h,008h,00ch,001h,005h,004h,003h,001h,002h,015h,00ch,059h,003h,003h,00bh,01fh,00ah
	   0C 01 05 04 03
	   01 02 15 0C 59
	   03 03 0B 1F 0A
 0000149E  03 0B 2A 09 05     C db 003h,00bh,02ah,009h,005h,00bh,02ch,003h,016h,00ch,006h,003h,001h,006h,012h,00ch,001h,006h,008h,003h
	   0B 2C 03 16 0C
	   06 03 01 06 12
	   0C 01 06 08 03
 000014B2  01 06 12 0C 01     C db 001h,006h,012h,00ch,001h,006h,005h,003h,016h,00ch,059h,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h
	   06 05 03 16 0C
	   59 03 03 0B 1F
	   0A 03 0B 2A 09
 000014C6  05 0B 2C 03 16     C db 005h,00bh,02ch,003h,016h,00ch,007h,003h,012h,00ch,001h,004h,009h,003h,012h,00ch,001h,004h,005h,003h
	   0C 07 03 12 0C
	   01 04 09 03 12
	   0C 01 04 05 03
 000014DA  16 0C 59 03 03     C db 016h,00ch,059h,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,02ch,003h,016h,00ch,007h,003h
	   0B 1F 0A 03 0B
	   2A 09 05 0B 2C
	   03 16 0C 07 03
 000014EE  01 05 01 06 0E     C db 001h,005h,001h,006h,00eh,00ch,001h,006h,001h,005h,00ah,003h,001h,005h,001h,006h,00eh,00ch,001h,006h
	   0C 01 06 01 05
	   0A 03 01 05 01
	   06 0E 0C 01 06
 00001502  01 05 06 03 16     C db 001h,005h,006h,003h,016h,00ch,059h,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,02ch,003h
	   0C 59 03 03 0B
	   1F 0A 03 0B 2A
	   09 05 0B 2C 03
 00001516  16 0C 09 03 01     C db 016h,00ch,009h,003h,001h,001h,00ch,00ch,001h,001h,00eh,003h,001h,001h,00ch,00ch,001h,001h,008h,003h
	   01 0C 0C 01 01
	   0E 03 01 01 0C
	   0C 01 01 08 03
 0000152A  16 0C 59 03 25     C db 016h,00ch,059h,003h,025h,00bh,02ah,009h,005h,00bh,02ch,003h,016h,00ch,00bh,003h,001h,007h,001h,002h
	   0B 2A 09 05 0B
	   2C 03 16 0C 0B
	   03 01 07 01 02
 0000153E  01 06 04 0C 01     C db 001h,006h,004h,00ch,001h,006h,001h,002h,001h,001h,012h,003h,001h,007h,001h,002h,001h,006h,004h,00ch
	   06 01 02 01 01
	   12 03 01 07 01
	   02 01 06 04 0C
 00001552  01 06 01 02 01     C db 001h,006h,001h,002h,001h,001h,00ah,003h,016h,00ch,059h,003h,025h,00bh,02ah,009h,005h,00bh,0ech,003h
	   01 0A 03 16 0C
	   59 03 25 0B 2A
	   09 05 0B EC 03
 00001566  25 0B 2A 09 05     C db 025h,00bh,02ah,009h,005h,00bh,0f3h,003h,001h,00bh,009h,008h,005h,00bh,039h,009h,005h,00bh,0f3h,003h
	   0B F3 03 01 0B
	   09 08 05 0B 39
	   09 05 0B F3 03
 0000157A  01 0B 09 08 05     C db 001h,00bh,009h,008h,005h,00bh,039h,009h,005h,00bh,0f3h,003h,001h,00bh,009h,008h,005h,00bh,039h,009h
	   0B 39 09 05 0B
	   F3 03 01 0B 09
	   08 05 0B 39 09
 0000158E  05 0B F3 03 01     C db 005h,00bh,0f3h,003h,001h,00bh,009h,008h,005h,00bh,039h,009h,005h,00bh,0f3h,003h,001h,00bh,009h,008h
	   0B 09 08 05 0B
	   39 09 05 0B F3
	   03 01 0B 09 08
 000015A2  05 0B 39 09 05     C db 005h,00bh,039h,009h,005h,00bh,0f3h,003h,001h,00bh,009h,008h,005h,00bh,039h,009h,005h,00bh,0f3h,003h
	   0B F3 03 01 0B
	   09 08 05 0B 39
	   09 05 0B F3 03
 000015B6  01 0B 09 08 05     C db 001h,00bh,009h,008h,005h,00bh,039h,009h,005h,00bh,0f3h,003h,001h,00bh,009h,008h,005h,00bh,039h,009h
	   0B 39 09 05 0B
	   F3 03 01 0B 09
	   08 05 0B 39 09
 000015CA  05 0B F3 03 01     C db 005h,00bh,0f3h,003h,001h,00bh,009h,008h,005h,00bh,039h,009h,005h,00bh,0f3h,003h,001h,00bh,009h,008h
	   0B 09 08 05 0B
	   39 09 05 0B F3
	   03 01 0B 09 08
 000015DE  05 0B 39 09 05     C db 005h,00bh,039h,009h,005h,00bh,0f3h,003h,001h,00bh,009h,008h,005h,00bh,039h,009h,005h,00bh,0f3h,003h
	   0B F3 03 01 0B
	   09 08 05 0B 39
	   09 05 0B F3 03
 000015F2  0F 0B 39 09 05     C db 00fh,00bh,039h,009h,005h,00bh,0fdh,003h,005h,00bh,039h,009h,005h,00bh,045h,003h,002h,00bh,026h,003h
	   0B FD 03 05 0B
	   39 09 05 0B 45
	   03 02 0B 26 03
 00001606  02 0B 8E 03 05     C db 002h,00bh,08eh,003h,005h,00bh,007h,009h,002h,000h,002h,009h,003h,000h,007h,009h,002h,000h,002h,009h
	   0B 07 09 02 00
	   02 09 03 00 07
	   09 02 00 02 09
 0000161A  03 00 06 09 03     C db 003h,000h,006h,009h,003h,000h,003h,009h,002h,000h,003h,009h,002h,000h,002h,009h,003h,000h,005h,009h
	   00 03 09 02 00
	   03 09 02 00 02
	   09 03 00 05 09
 0000162E  05 0B 23 03 06     C db 005h,00bh,023h,003h,006h,00bh,016h,003h,002h,00bh,004h,003h,002h,00bh,026h,003h,002h,00bh,017h,003h
	   0B 16 03 02 0B
	   04 03 02 0B 26
	   03 02 0B 17 03
 00001642  04 0B 73 03 05     C db 004h,00bh,073h,003h,005h,00bh,006h,009h,001h,000h,002h,009h,001h,000h,004h,009h,001h,000h,005h,009h
	   0B 06 09 01 00
	   02 09 01 00 04
	   09 01 00 05 09
 00001656  01 00 02 09 01     C db 001h,000h,002h,009h,001h,000h,004h,009h,001h,000h,008h,009h,001h,000h,001h,009h,001h,000h,002h,009h
	   00 04 09 01 00
	   08 09 01 00 01
	   09 01 00 02 09
 0000166A  01 00 01 09 01     C db 001h,000h,001h,009h,001h,000h,002h,009h,001h,000h,004h,009h,001h,000h,004h,009h,005h,00bh,023h,003h
	   00 02 09 01 00
	   04 09 01 00 04
	   09 05 0B 23 03
 0000167E  02 0B 03 03 02     C db 002h,00bh,003h,003h,002h,00bh,015h,003h,002h,00bh,004h,003h,002h,00bh,026h,003h,002h,00bh,018h,003h
	   0B 15 03 02 0B
	   04 03 02 0B 26
	   03 02 0B 18 03
 00001692  02 0B 74 03 05     C db 002h,00bh,074h,003h,005h,00bh,006h,009h,001h,000h,002h,009h,001h,000h,004h,009h,001h,000h,002h,009h
	   0B 06 09 01 00
	   02 09 01 00 04
	   09 01 00 02 09
 000016A6  01 00 02 09 01     C db 001h,000h,002h,009h,001h,000h,002h,009h,001h,000h,004h,009h,001h,000h,002h,009h,001h,000h,005h,009h
	   00 02 09 01 00
	   04 09 01 00 02
	   09 01 00 05 09
 000016BA  01 00 01 09 01     C db 001h,000h,001h,009h,001h,000h,002h,009h,001h,000h,001h,009h,001h,000h,002h,009h,001h,000h,004h,009h
	   00 02 09 01 00
	   01 09 01 00 02
	   09 01 00 04 09
 000016CE  01 00 04 09 05     C db 001h,000h,004h,009h,005h,00bh,023h,003h,002h,00bh,003h,003h,002h,00bh,004h,003h,005h,00bh,004h,003h
	   0B 23 03 02 0B
	   03 03 02 0B 04
	   03 05 0B 04 03
 000016E2  05 0B 02 03 05     C db 005h,00bh,002h,003h,005h,00bh,002h,003h,002h,00bh,003h,003h,005h,00bh,003h,003h,002h,00bh,002h,003h
	   0B 02 03 02 0B
	   03 03 05 0B 03
	   03 02 0B 02 03
 000016F6  02 0B 02 03 02     C db 002h,00bh,002h,003h,002h,00bh,003h,003h,005h,00bh,003h,003h,002h,00bh,001h,003h,002h,00bh,001h,003h
	   0B 03 03 05 0B
	   03 03 02 0B 01
	   03 02 0B 01 03
 0000170A  02 0B 02 03 02     C db 002h,00bh,002h,003h,002h,00bh,003h,003h,005h,00bh,00ch,003h,002h,00bh,003h,003h,002h,00bh,001h,003h
	   0B 03 03 05 0B
	   0C 03 02 0B 03
	   03 02 0B 01 03
 0000171E  03 0B 04 03 05     C db 003h,00bh,004h,003h,005h,00bh,062h,003h,005h,00bh,006h,009h,001h,000h,002h,009h,001h,000h,002h,009h
	   0B 62 03 05 0B
	   06 09 01 00 02
	   09 01 00 02 09
 00001732  02 00 03 09 01     C db 002h,000h,003h,009h,001h,000h,002h,009h,001h,000h,002h,009h,001h,000h,002h,009h,002h,000h,003h,009h
	   00 02 09 01 00
	   02 09 01 00 02
	   09 02 00 03 09
 00001746  01 00 03 09 02     C db 001h,000h,003h,009h,002h,000h,002h,009h,001h,000h,002h,009h,001h,000h,001h,009h,001h,000h,002h,009h
	   00 02 09 01 00
	   02 09 01 00 01
	   09 01 00 02 09
 0000175A  01 00 02 09 02     C db 001h,000h,002h,009h,002h,000h,005h,009h,005h,00bh,023h,003h,002h,00bh,003h,003h,002h,00bh,003h,003h
	   00 05 09 05 0B
	   23 03 02 0B 03
	   03 02 0B 03 03
 0000176E  02 0B 03 03 02     C db 002h,00bh,003h,003h,002h,00bh,007h,003h,002h,00bh,002h,003h,002h,00bh,004h,003h,002h,00bh,002h,003h
	   0B 07 03 02 0B
	   02 03 02 0B 04
	   03 02 0B 02 03
 00001782  02 0B 03 03 02     C db 002h,00bh,003h,003h,002h,00bh,002h,003h,002h,00bh,002h,003h,002h,00bh,002h,003h,002h,00bh,002h,003h
	   0B 02 03 02 0B
	   02 03 02 0B 02
	   03 02 0B 02 03
 00001796  02 0B 03 03 02     C db 002h,00bh,003h,003h,002h,00bh,002h,003h,005h,00bh,001h,003h,002h,00bh,001h,003h,002h,00bh,003h,003h
	   0B 02 03 05 0B
	   01 03 02 0B 01
	   03 02 0B 03 03
 000017AA  02 0B 10 03 02     C db 002h,00bh,010h,003h,002h,00bh,003h,003h,003h,00bh,002h,003h,002h,00bh,002h,003h,002h,00bh,003h,003h
	   0B 03 03 03 0B
	   02 03 02 0B 02
	   03 02 0B 03 03
 000017BE  02 0B 61 03 05     C db 002h,00bh,061h,003h,005h,00bh,006h,009h,001h,000h,002h,009h,001h,000h,001h,009h,001h,000h,008h,009h
	   0B 06 09 01 00
	   02 09 01 00 01
	   09 01 00 08 09
 000017D2  01 00 02 09 01     C db 001h,000h,002h,009h,001h,000h,001h,009h,001h,000h,008h,009h,001h,000h,004h,009h,001h,000h,002h,009h
	   00 01 09 01 00
	   08 09 01 00 04
	   09 01 00 02 09
 000017E6  01 00 01 09 01     C db 001h,000h,001h,009h,001h,000h,002h,009h,001h,000h,001h,009h,001h,000h,007h,009h,005h,00bh,023h,003h
	   00 02 09 01 00
	   01 09 01 00 07
	   09 05 0B 23 03
 000017FA  07 0B 03 03 02     C db 007h,00bh,003h,003h,002h,00bh,003h,003h,002h,00bh,003h,003h,006h,00bh,002h,003h,002h,00bh,004h,003h
	   0B 03 03 02 0B
	   03 03 06 0B 02
	   03 02 0B 04 03
 0000180E  02 0B 02 03 02     C db 002h,00bh,002h,003h,002h,00bh,003h,003h,002h,00bh,002h,003h,002h,00bh,002h,003h,002h,00bh,002h,003h
	   0B 03 03 02 0B
	   02 03 02 0B 02
	   03 02 0B 02 03
 00001822  02 0B 02 03 02     C db 002h,00bh,002h,003h,002h,00bh,003h,003h,002h,00bh,002h,003h,002h,00bh,004h,003h,004h,00bh,004h,003h
	   0B 03 03 02 0B
	   02 03 02 0B 04
	   03 04 0B 04 03
 00001836  03 0B 0F 03 02     C db 003h,00bh,00fh,003h,002h,00bh,003h,003h,002h,00bh,003h,003h,002h,00bh,002h,003h,002h,00bh,066h,003h
	   0B 03 03 02 0B
	   03 03 02 0B 02
	   03 02 0B 66 03
 0000184A  05 0B 07 09 02     C db 005h,00bh,007h,009h,002h,000h,002h,009h,004h,000h,006h,009h,002h,000h,002h,009h,004h,000h,005h,009h
	   00 02 09 04 00
	   06 09 02 00 02
	   09 04 00 05 09
 0000185E  04 00 02 09 02     C db 004h,000h,002h,009h,002h,000h,003h,009h,002h,000h,002h,009h,004h,000h,004h,009h,005h,00bh,023h,003h
	   00 03 09 02 00
	   02 09 04 00 04
	   09 05 0B 23 03
 00001872  02 0B 04 03 02     C db 002h,00bh,004h,003h,002h,00bh,002h,003h,007h,00bh,002h,003h,002h,00bh,003h,003h,002h,00bh,002h,003h
	   0B 02 03 07 0B
	   02 03 02 0B 03
	   03 02 0B 02 03
 00001886  02 0B 04 03 02     C db 002h,00bh,004h,003h,002h,00bh,002h,003h,007h,00bh,002h,003h,002h,00bh,001h,003h,001h,00bh,002h,003h
	   0B 02 03 07 0B
	   02 03 02 0B 01
	   03 01 0B 02 03
 0000189A  01 0B 01 03 02     C db 001h,00bh,001h,003h,002h,00bh,002h,003h,002h,00bh,003h,003h,002h,00bh,002h,003h,002h,00bh,004h,003h
	   0B 02 03 02 0B
	   03 03 02 0B 02
	   03 02 0B 04 03
 000018AE  04 0B 05 03 04     C db 004h,00bh,005h,003h,004h,00bh,00dh,003h,002h,00bh,003h,003h,002h,00bh,003h,003h,002h,00bh,002h,003h
	   0B 0D 03 02 0B
	   03 03 02 0B 03
	   03 02 0B 02 03
 000018C2  02 0B 66 03 05     C db 002h,00bh,066h,003h,005h,00bh,039h,009h,005h,00bh,023h,003h,002h,00bh,004h,003h,002h,00bh,002h,003h
	   0B 39 09 05 0B
	   23 03 02 0B 04
	   03 02 0B 02 03
 000018D6  02 0B 07 03 02     C db 002h,00bh,007h,003h,002h,00bh,003h,003h,002h,00bh,002h,003h,002h,00bh,004h,003h,002h,00bh,002h,003h
	   0B 03 03 02 0B
	   02 03 02 0B 04
	   03 02 0B 02 03
 000018EA  02 0B 08 03 03     C db 002h,00bh,008h,003h,003h,00bh,002h,003h,003h,00bh,003h,003h,002h,00bh,003h,003h,002h,00bh,002h,003h
	   0B 02 03 03 0B
	   03 03 02 0B 03
	   03 02 0B 02 03
 000018FE  02 0B 04 03 02     C db 002h,00bh,004h,003h,002h,00bh,001h,003h,002h,00bh,006h,003h,003h,00bh,00ch,003h,002h,00bh,003h,003h
	   0B 01 03 02 0B
	   06 03 03 0B 0C
	   03 02 0B 03 03
 00001912  02 0B 03 03 02     C db 002h,00bh,003h,003h,002h,00bh,002h,003h,002h,00bh,066h,003h,005h,00bh,039h,009h,005h,00bh,023h,003h
	   0B 02 03 02 0B
	   66 03 05 0B 39
	   09 05 0B 23 03
 00001926  02 0B 04 03 02     C db 002h,00bh,004h,003h,002h,00bh,002h,003h,002h,00bh,003h,003h,002h,00bh,002h,003h,002h,00bh,003h,003h
	   0B 02 03 02 0B
	   03 03 02 0B 02
	   03 02 0B 03 03
 0000193A  02 0B 02 03 02     C db 002h,00bh,002h,003h,002h,00bh,004h,003h,002h,00bh,002h,003h,002h,00bh,003h,003h,002h,00bh,003h,003h
	   0B 04 03 02 0B
	   02 03 02 0B 03
	   03 02 0B 03 03
 0000194E  02 0B 04 03 02     C db 002h,00bh,004h,003h,002h,00bh,004h,003h,001h,00bh,003h,003h,002h,00bh,002h,003h,002h,00bh,004h,003h
	   0B 04 03 01 0B
	   03 03 02 0B 02
	   03 02 0B 04 03
 00001962  02 0B 02 03 02     C db 002h,00bh,002h,003h,002h,00bh,006h,003h,002h,00bh,002h,003h,003h,00bh,007h,003h,002h,00bh,003h,003h
	   0B 06 03 02 0B
	   02 03 03 0B 07
	   03 02 0B 03 03
 00001976  02 0B 03 03 02     C db 002h,00bh,003h,003h,002h,00bh,002h,003h,002h,00bh,003h,003h,002h,00bh,061h,003h,043h,00bh,023h,003h
	   0B 02 03 02 0B
	   03 03 02 0B 61
	   03 43 0B 23 03
 0000198A  07 0B 04 03 05     C db 007h,00bh,004h,003h,005h,00bh,004h,003h,006h,00bh,003h,003h,003h,00bh,002h,003h,002h,00bh,003h,003h
	   0B 04 03 06 0B
	   03 03 03 0B 02
	   03 02 0B 03 03
 0000199E  05 0B 04 03 02     C db 005h,00bh,004h,003h,002h,00bh,004h,003h,002h,00bh,004h,003h,005h,00bh,003h,003h,002h,00bh,004h,003h
	   0B 04 03 02 0B
	   04 03 05 0B 03
	   03 02 0B 04 03
 000019B2  02 0B 03 03 02     C db 002h,00bh,003h,003h,002h,00bh,001h,003h,005h,00bh,003h,003h,002h,00bh,007h,003h,004h,00bh,002h,003h
	   0B 01 03 05 0B
	   03 03 02 0B 07
	   03 04 0B 02 03
 000019C6  02 0B 03 03 02     C db 002h,00bh,003h,003h,002h,00bh,003h,003h,005h,00bh,062h,003h,043h,00bh,07dh,003h,002h,00bh,07eh,003h
	   0B 03 03 05 0B
	   62 03 43 0B 7D
	   03 02 0B 7E 03
 000019DA  43 0B 7C 03 02     C db 043h,00bh,07ch,003h,002h,00bh,07fh,003h,043h,00bh,07ch,003h,002h,00bh,07fh,003h,043h,00bh,0ffh,003h
	   0B 7F 03 43 0B
	   7C 03 02 0B 7F
	   03 43 0B FF 03
 000019EE  FF 03 FF 03 FF     C db 0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h
	   03 FF 03 FF 03
	   FF 03 FF 03 FF
	   03 FF 03 FF 03
 00001A02  FF 03 FF 03 FF     C db 0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h
	   03 FF 03 FF 03
	   FF 03 FF 03 FF
	   03 FF 03 FF 03
 00001A16  FF 03 FF 03 FF     C db 0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0e2h,003h,0ffh,00ch,041h,00ch,0ffh,000h,0ffh,000h,0ffh,000h
	   03 FF 03 E2 03
	   FF 0C 41 0C FF
	   00 FF 00 FF 00
 00001A2A  FF 00 FF 00 FF     C db 0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h
	   00 FF 00 FF 00
	   FF 00 FF 00 FF
	   00 FF 00 FF 00
 00001A3E  FF 00 FF 00 FF     C db 0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h
	   00 FF 00 FF 00
	   FF 00 FF 00 FF
	   00 FF 00 FF 00
 00001A52  FF 00 FF 00 FF     C db 0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h
	   00 FF 00 FF 00
	   FF 00 FF 00 FF
	   00 FF 00 FF 00
 00001A66  FF 00 FF 00 FF     C db 0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h
	   00 FF 00 FF 00
	   FF 00 FF 00 FF
	   00 FF 00 FF 00
 00001A7A  FF 00 FF 00 FF     C db 0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h
	   00 FF 00 FF 00
	   FF 00 FF 00 FF
	   00 FF 00 FF 00
 00001A8E  FF 00 FF 00 FF     C db 0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h
	   00 FF 00 FF 00
	   FF 00 FF 00 FF
	   00 FF 00 FF 00
 00001AA2  FF 00 FF 00 FF     C db 0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h
	   00 FF 00 FF 00
	   FF 00 FF 00 FF
	   00 FF 00 FF 00
 00001AB6  FF 00 FF 00 FF     C db 0ffh,000h,0ffh,000h,0ffh,000h,08ch,000h
	   00 8C 00
			      C 
 00001ABE		      C bootscreen_end:
			      C 
			      C 
			      C ; These functions are required during bootup
			      C ;
 00001ABE 0000		      C _EXODUS_requestor                       dw  0
 00001AC0 0000		      C _VID_clear_screen_vga                   dw  0
 00001AC2 00B0		      C _VID_display_decimal_in_edx_nr_vga      dw  _sEXODUS_REQUESTOR
 00001AC4 F000		      C _VID_display_string_ecx_nr_vga          dw  0f000h
 00001AC6 F000		      C _VID_display_string_ecx_vga             dw  0f000h
 00001AC8 F000		      C _VID_display_string_nr_vga              dw  0f000h
 00001ACA F000		      C _VID_display_string_vga                 dw  0f000h
 00001ACC F000		      C _VID_freeze_frame_vga                   dw  0f000h
 00001ACE F000		      C _VID_position_cursor_vga                dw  0f000h
 00001AD0 F000		      C _VID_mono_enter_graphics_mode           dw  0f000h
 00001AD2 F000		      C _VID_g_mono_display_text                dw  0f000h
 00001AD4 F000		      C _VID_g_mono_display_text_mode           dw  0f000h
 00001AD6 F000		      C _VID_g_mono_clear_screen                dw  0f000h
 00001AD8 F000		      C _VID_g_set_font_8x8                     dw  0f000h
 00001ADA F000		      C _VID_g_set_font_8x14                    dw  0f000h
 00001ADC F000		      C _VID_g_set_font_16x16                   dw  0f000h
 00001ADE F000		      C _VID_draw_logo                          dw  0f000h
 00001AE0 F000		      C _VID_requestor                          dw  0f000h
 00001AE2 F000		      C _VID_g_display_radix_in_edx_mono        dw  0f000h
 00001AE4 F000		      C _VID_freeze_frame_mono                  dw  0f000h
 00001AE6 F000		      C _VID_move_to_next_line_vga              dw  0f000h
 00001AE8 F000		      C _VID_set_attribute_vga                  dw  0f000h
 00001AEA F000		      C _EXODUS_dot_com                         dw  0f000h
 00001AEC F000		      C _VID_draw_exodus_boot_screen            dw  0f000h
 00001AEE  F000		      C                                         dw  0f000h
 00001AF0  F000		      C                                         dw  0f000h
			      C 
			      C 
			      C 
 00001AF2 14 56 49 44 5F      C required_native_primatives              db  20, "VID_clear_screen_vga"
	   63 6C 65 61 72
	   5F 73 63 72 65
	   65 6E 5F 76 67
	   61
 00001B07  21 56 49 44 5F     C                                         db  33, "VID_display_decimal_in_edx_nr_vga"
	   64 69 73 70 6C
	   61 79 5F 64 65
	   63 69 6D 61 6C
	   5F 69 6E 5F 65
	   64 78 5F 6E 72
	   5F 76 67 61
 00001B29  1D 56 49 44 5F     C                                         db  29, "VID_display_string_ecx_nr_vga"
	   64 69 73 70 6C
	   61 79 5F 73 74
	   72 69 6E 67 5F
	   65 63 78 5F 6E
	   72 5F 76 67 61
 00001B47  1A 56 49 44 5F     C                                         db  26, "VID_display_string_ecx_vga"
	   64 69 73 70 6C
	   61 79 5F 73 74
	   72 69 6E 67 5F
	   65 63 78 5F 76
	   67 61
 00001B62  19 56 49 44 5F     C                                         db  25, "VID_display_string_nr_vga"
	   64 69 73 70 6C
	   61 79 5F 73 74
	   72 69 6E 67 5F
	   6E 72 5F 76 67
	   61
 00001B7C  16 56 49 44 5F     C                                         db  22, "VID_display_string_vga"
	   64 69 73 70 6C
	   61 79 5F 73 74
	   72 69 6E 67 5F
	   76 67 61
 00001B93  14 56 49 44 5F     C                                         db  20, "VID_freeze_frame_vga"
	   66 72 65 65 7A
	   65 5F 66 72 61
	   6D 65 5F 76 67
	   61
 00001BA8  17 56 49 44 5F     C                                         db  23, "VID_position_cursor_vga"
	   70 6F 73 69 74
	   69 6F 6E 5F 63
	   75 72 73 6F 72
	   5F 76 67 61
 00001BC0  1C 56 49 44 5F     C                                         db  28, "VID_mono_enter_graphics_mode"
	   6D 6F 6E 6F 5F
	   65 6E 74 65 72
	   5F 67 72 61 70
	   68 69 63 73 5F
	   6D 6F 64 65
 00001BDD  17 56 49 44 5F     C                                         db  23, "VID_g_mono_display_text"
	   67 5F 6D 6F 6E
	   6F 5F 64 69 73
	   70 6C 61 79 5F
	   74 65 78 74
 00001BF5  1C 56 49 44 5F     C                                         db  28, "VID_g_mono_display_text_mode"
	   67 5F 6D 6F 6E
	   6F 5F 64 69 73
	   70 6C 61 79 5F
	   74 65 78 74 5F
	   6D 6F 64 65
 00001C12  17 56 49 44 5F     C                                         db  23, "VID_g_mono_clear_screen"
	   67 5F 6D 6F 6E
	   6F 5F 63 6C 65
	   61 72 5F 73 63
	   72 65 65 6E
 00001C2A  12 56 49 44 5F     C                                         db  18, "VID_g_set_font_8x8"
	   67 5F 73 65 74
	   5F 66 6F 6E 74
	   5F 38 78 38
 00001C3D  13 56 49 44 5F     C                                         db  19, "VID_g_set_font_8x14"
	   67 5F 73 65 74
	   5F 66 6F 6E 74
	   5F 38 78 31 34
 00001C51  14 56 49 44 5F     C                                         db  20, "VID_g_set_font_16x16"
	   67 5F 73 65 74
	   5F 66 6F 6E 74
	   5F 31 36 78 31
	   36
 00001C66  0D 56 49 44 5F     C                                         db  13, "VID_draw_logo"
	   64 72 61 77 5F
	   6C 6F 67 6F
 00001C74  0D 56 49 44 5F     C                                         db  13, "VID_requestor"
	   72 65 71 75 65
	   73 74 6F 72
 00001C82  1F 56 49 44 5F     C                                         db  31, "VID_g_display_radix_in_edx_mono"
	   67 5F 64 69 73
	   70 6C 61 79 5F
	   72 61 64 69 78
	   5F 69 6E 5F 65
	   64 78 5F 6D 6F
	   6E 6F
 00001CA2  15 56 49 44 5F     C                                         db  21, "VID_freeze_frame_mono"
	   66 72 65 65 7A
	   65 5F 66 72 61
	   6D 65 5F 6D 6F
	   6E 6F
 00001CB8  19 56 49 44 5F     C                                         db  25, "VID_move_to_next_line_vga"
	   6D 6F 76 65 5F
	   74 6F 5F 6E 65
	   78 74 5F 6C 69
	   6E 65 5F 76 67
	   61
 00001CD2  15 56 49 44 5F     C                                         db  21, "VID_set_attribute_vga"
	   73 65 74 5F 61
	   74 74 72 69 62
	   75 74 65 5F 76
	   67 61
 00001CE8  0E 45 58 4F 44     C                                         db  14, "EXODUS_dot_com"
	   55 53 5F 64 6F
	   74 5F 63 6F 6D
 00001CF7  1B 56 49 44 5F     C                                         db  27, "VID_draw_exodus_boot_screen"
	   64 72 61 77 5F
	   65 78 6F 64 75
	   73 5F 62 6F 6F
	   74 5F 73 63 72
	   65 65 6E
 00001D13  FF		      C                                         db  0ffh
			      C 
			      C 
			      C 
			      C ;_KBD_get_a_key                          dw  0f000h     ;    db  13, "KBD_get_a_key"
			      C ;_VID_display_decimal_in_edx_vga         dw  0f000h     ;    db  30, "VID_display_decimal_in_edx_vga"
			      C ;_VID_display_hex_string_ecx_nr_vga      dw  0f000h     ;    db  33, "VID_display_hex_string_ecx_nr_vga"
			      C ;_VID_display_hex_string_ecx_ro_vga      dw  0f000h     ;    db  33, "VID_display_hex_string_ecx_ro_vga"
			      C ;_VID_display_hex_string_ecx_vga         dw  0f000h     ;    db  30, "VID_display_hex_string_ecx_vga"
			      C ;_VID_display_hexidecimal_in_edx_nr_vga  dw  0f000h     ;    db  37, "VID_display_hexidecimal_in_edx_nr_vga"
			      C ;_VID_display_hexidecimal_in_edx_vga     dw  0f000h     ;    db  34, "VID_display_hexidecimal_in_edx_vga"
			      C ;_VID_display_radix_in_edx_nr_vga        dw  0f000h     ;    db  31, "VID_display_radix_in_edx_nr_vga"
			      C ;_VID_display_radix_in_edx_vga           dw  0f000h     ;    db  28, "VID_display_radix_in_edx_vga"
			      C ;_VID_get_cursor_vga                     dw  0f000h     ;    db  18, "VID_get_cursor_vga"
			      C ;_VID_move_to_next_line_vga              dw  0f000h     ;    db  25, "VID_move_to_next_line_vga"
			      C ;_VID_set_attribute_vga                  dw  0f000h     ;    db  21, "VID_set_attribute_vga"
			      C ;_VID_set_registers_for_vga              dw  0f000h     ;    db  25, "VID_set_registers_for_vga"
			      C ;_VID_clear_screen_mono                  dw  0f000h     ;    db  21, "VID_clear_screen_mono"
			      C ;_VID_display_decimal_in_edx_mono        dw  0f000h     ;    db  31, "VID_display_decimal_in_edx_mono"
			      C ;_VID_display_decimal_in_edx_nr_mono     dw  0f000h     ;    db  34, "VID_display_decimal_in_edx_nr_mono"
			      C ;_VID_display_hex_string_ecx_mono        dw  0f000h     ;    db  31, "VID_display_hex_string_ecx_mono"
			      C ;_VID_display_hex_string_ecx_nr_mono     dw  0f000h     ;    db  34, "VID_display_hex_string_ecx_nr_mono"
			      C ;_VID_display_hex_string_ecx_ro_mono     dw  0f000h     ;    db  34, "VID_display_hex_string_ecx_ro_mono"
			      C ;_VID_display_hexidecimal_in_edx_mono    dw  0f000h     ;    db  35, "VID_display_hexidecimal_in_edx_mono"
			      C ;_VID_display_hexidecimal_in_edx_nr_mono dw  0f000h     ;    db  38, "VID_display_hexidecimal_in_edx_nr_mono"
			      C ;_VID_display_radix_in_edx_mono          dw  0f000h     ;    db  29, "VID_display_radix_in_edx_mono"
			      C ;_VID_display_radix_in_edx_nr_mono       dw  0f000h     ;    db  32, "VID_display_radix_in_edx_nr_mono"
			      C ;_VID_display_string_ecx_mono            dw  0f000h     ;    db  27, "VID_display_string_ecx_mono"
			      C ;_VID_display_string_ecx_nr_mono         dw  0f000h     ;    db  30, "VID_display_string_ecx_nr_mono"
			      C ;_VID_display_string_mono                dw  0f000h     ;    db  23, "VID_display_string_mono"
			      C ;_VID_display_string_nr_mono             dw  0f000h     ;    db  26, "VID_display_string_nr_mono"
			      C ;_VID_get_cursor_mono                    dw  0f000h     ;    db  19, "VID_get_cursor_mono"
			      C ;_VID_move_to_next_line_mono             dw  0f000h     ;    db  26, "VID_move_to_next_line_mono"
			      C ;_VID_position_cursor_mono               dw  0f000h     ;    db  24, "VID_position_cursor_mono"
			      C ;_VID_set_attribute_mono                 dw  0f000h     ;    db  22, "VID_set_attribute_mono"
			      C ;_VID_set_registers_for_mono             dw  0f000h     ;    db  26, "VID_set_registers_for_mono"
			      C ;_VID_clear_screen_both                  dw  0f000h     ;    db  21, "VID_clear_screen_both"
			      C ;_VID_display_decimal_in_edx_both        dw  0f000h     ;    db  31, "VID_display_decimal_in_edx_both"
			      C ;_VID_display_decimal_in_edx_nr_both     dw  0f000h     ;    db  34, "VID_display_decimal_in_edx_nr_both"
			      C ;_VID_display_hex_string_ecx_both        dw  0f000h     ;    db  31, "VID_display_hex_string_ecx_both"
			      C ;_VID_display_hex_string_ecx_nr_both     dw  0f000h     ;    db  34, "VID_display_hex_string_ecx_nr_both"
			      C ;_VID_display_hex_string_ecx_ro_both     dw  0f000h     ;    db  34, "VID_display_hex_string_ecx_ro_both"
			      C ;_VID_display_hexidecimal_in_edx_both    dw  0f000h     ;    db  35, "VID_display_hexidecimal_in_edx_both"
			      C ;_VID_display_hexidecimal_in_edx_nr_both dw  0f000h     ;    db  38, "VID_display_hexidecimal_in_edx_nr_both"
			      C ;_VID_display_string_both                dw  0f000h     ;    db  23, "VID_display_string_both"
			      C ;_VID_display_radix_in_edx_nr_both       dw  0f000h     ;    db  32, "VID_display_radix_in_edx_nr_both"
			      C ;_VID_display_string_ecx_both            dw  0f000h     ;    db  27, "VID_display_string_ecx_both"
			      C ;_VID_display_string_ecx_nr_both         dw  0f000h     ;    db  30, "VID_display_string_ecx_nr_both"
			      C ;_VID_display_string_nr_both             dw  0f000h     ;    db  26, "VID_display_string_nr_both"
			      C ;_VID_freeze_frame_both                  dw  0f000h     ;    db  21, "VID_freeze_frame_both"
			      C ;_VID_move_to_next_line_both             dw  0f000h     ;    db  26, "VID_move_to_next_line_both"
			      C ;_VID_position_cursor_both               dw  0f000h     ;    db  24, "VID_position_cursor_both"
			      C ;_VID_set_attribute_both                 dw  0f000h     ;    db  22, "VID_set_attribute_both"
			      C ;_VID_mono_enter_text_mode               dw  0f000h     ;    db  24, "VID_mono_enter_text_mode"
			      C 
			      C 
			      C 
			      C ;
			      C ; Displays a message when an Exodus bootup device doesn't properly identify itself
			      C ; But, this is only displayed before VGA and KBD support is available.
			      C ; After that the invSetup_native_primates() function takes control and allows selective non-install, etc.
			      C ;
 00001D14 46 41 49 4C 45      C failed                                  db  "FAILED",13,10
	   44 0D 0A
 00001D1C  0D 0A	      C                                         db  13,10
 00001D1E  07 20 41 6E 20     C                                         db  " An Exodus Driver failed to initialize properly",13,10
	   45 78 6F 64 75
	   73 20 44 72 69
	   76 65 72 20 66
	   61 69 6C 65 64
	   20 74 6F 20 69
	   6E 69 74 69 61
	   6C 69 7A 65 20
	   70 72 6F 70 65
	   72 6C 79 0D 0A
 00001D50  07 20 54 68 69     C                                         db  " This was before VGA and keyboard support was available (to allow user action)",13,10
	   73 20 77 61 73
	   20 62 65 66 6F
	   72 65 20 56 47
	   41 20 61 6E 64
	   20 6B 65 79 62
	   6F 61 72 64 20
	   73 75 70 70 6F
	   72 74 20 77 61
	   73 20 61 76 61
	   69 6C 61 62 6C
	   65 20 28 74 6F
	   20 61 6C 6C 6F
	   77 20 75 73 65
	   72 20 61 63 74
	   69 6F 6E 29 0D
	   0A
 00001DA1  07 20 46 6F 72     C                                         db  " For this reason Exodus cannot continue to boot",13,10
	   20 74 68 69 73
	   20 72 65 61 73
	   6F 6E 20 45 78
	   6F 64 75 73 20
	   63 61 6E 6E 6F
	   74 20 63 6F 6E
	   74 69 6E 75 65
	   20 74 6F 20 62
	   6F 6F 74 0D 0A
 00001DD3  0D 0A	      C                                         db  13,10
 00001DD5  0D 0A	      C                                         db  13,10
 00001DD7  0D 0A	      C                                         db  13,10
 00001DD9  0D 0A	      C                                         db  13,10
 00001DDB  0D 0A	      C                                         db  13,10
 00001DDD  0D 0A	      C                                         db  13,10
 00001DDF  2D 2D 2D 2D 2D     C                                         db  "-----",13,10
	   0D 0A
 00001DE6  07 20 50 6C 65     C                                         db  " Please attempt to correct this problem and try again",13,10
	   61 73 65 20 61
	   74 74 65 6D 70
	   74 20 74 6F 20
	   63 6F 72 72 65
	   63 74 20 74 68
	   69 73 20 70 72
	   6F 62 6C 65 6D
	   20 61 6E 64 20
	   74 72 79 20 61
	   67 61 69 6E 0D
	   0A
 00001E1E  0D 0A	      C                                         db  13,10
 00001E20  07 20 49 66 20     C                                         db  " If the problem persists, you can reach us online (use a friend's computer)",13,10
	   74 68 65 20 70
	   72 6F 62 6C 65
	   6D 20 70 65 72
	   73 69 73 74 73
	   2C 20 79 6F 75
	   20 63 61 6E 20
	   72 65 61 63 68
	   20 75 73 20 6F
	   6E 6C 69 6E 65
	   20 28 75 73 65
	   20 61 20 66 72
	   69 65 6E 64 27
	   73 20 63 6F 6D
	   70 75 74 65 72
	   29 0D 0A
 00001E6E  20 20 C3 20 68     C                                         db  "  Ã http://www.beatleworks.com/boot_trouble",13,10
	   74 74 70 3A 2F
	   2F 77 77 77 2E
	   62 65 61 74 6C
	   65 77 6F 72 6B
	   73 2E 63 6F 6D
	   2F 62 6F 6F 74
	   5F 74 72 6F 75
	   62 6C 65 0D 0A
 00001E9B  20 20 C0 20 62     C                                         db  "  À boot_trouble@beatleworks.com",13,10
	   6F 6F 74 5F 74
	   72 6F 75 62 6C
	   65 40 62 65 61
	   74 6C 65 77 6F
	   72 6B 73 2E 63
	   6F 6D 0D 0A
 00001EBD		      C failed_end:
			      C 
				    INCLUDE native.asp                                              ; Native primatives
			      C ; native.asp
			      C ;
			      C ; Exodus Native Primatives declaration
			      C ; December 24, 2000
			      C ;
			      C ; * Refer to inf\native.inf for more information
			      C ; * Note, the mechanical operations of this process are governed by inf\primload.inf
			      C ; * Native Primatives run in the call gate range of 200 - 2999
			      C ;
			      C ;  Functions:
			      C ;    Ã invSetup_native_primatives               ; sets up the native primates specified as boot drivers
			      C ;    Ã default_primative_response               ; provides a system for undefined primatives
			      C ;    Ã invCopy_this_part                        ; copies a portion of data (called multiple times)
			      C ;    Ã invMove_temp_gdts_to_permanent           ; copies the temporary primative GDT entries to their permanent locations
			      C ;    Ã invAdd_primative                         ; adds a primative to between _MIN_PRIMATIVE and _MAX_PRIMATIVE call gates
			      C ;    À invUpdate_required_primatives            ; updates an driver/program with the required call gates to run
			      C ;
			      C ;
			      C 
			      C 
			      C 
			      C 
			      C 
 00001EBD		      C invSetup_native_primatives      PROC    NEAR
			      C ; This routine is responsible for setting up all Exodus native primatives
			      C ;
			      C ; Upon entry:   It is known that the GDT slots setup in the init16 algorithms are used
			      C ;
			      C ; Upon exit:    The native primative call gates are defined in the GDT and IDT
			      C ;
 00001EBD  0F A8	      C     push    gs
 00001EBF  0F A0	      C     push    fs
 00001EC1  06		      C     push    es
 00001EC2  1E		      C     push    ds
			      C   ; * Note:  Can't use EBP here because it is returned as a parameter from the primatives
			      C   ; * Note:  These references all use ESP.  No PUSH/POP's are to be used unless they are self-terminating
			      C   ;          and in-between references of ss:[esp+xx].
 00001EC3  83 EC 44	      C     sub     esp,68
			      C   ; [esp+64] - <Used for debugging>
			      C   ; [esp+60] - temporary
			      C   ; [esp+56] - temporary
			      C   ; [esp+52] - temporary
			      C   ; [esp+48] - temporary
			      C   ; [esp+44] - holds primative selector
			      C   ; [esp+40] - ptr to NP in linear memory
			      C   ; [esp+36] - ptr to DT in linear memory
			      C   ; [esp+32] - holds current value of esi (boot_parameter_block)
			      C   ; [esp+28] - temporary "Length of definition block" ptr into _sPRIMATIVE_LOAD_INFO
			      C   ; [esp+24] - requestor(-1) ebp - ptr to author text (null-terminated)
			      C   ; [esp+20] - requestor(-1) ebx - ptr to version text (null-terminated)
			      C   ; [esp+16] - requestor(-1) edi - ptr to driver self-identified name (null-terminated)
			      C   ; [esp+12] - requestor(-1) esi - ptr to native primative structure for this driver
			      C   ; [esp+08] - --Nuserved
			      C   ; [esp+04] - requestor(-1) ecx - actual number of bytes to keep after each driver is initialized
			      C   ; [esp+00] - driver name from NP (linear offset in memory)
			      C   ;
			      C 
 00001EC6  FC		      C     cld
			      C   ;; Setup the parameters for the default primative response
 00001EC7  33 C0	      C     xor     eax,eax
 00001EC9  BB 000023F0 R      C     mov     ebx,offset default_primative_response                   ; Offset to function
 00001ECE  33 C9	      C     xor     ecx,ecx                                                 ; Number of dword to copy if privledge level change
 00001ED0  66| BA 0020	      C     mov     dx,_sCODE                                               ; Code segment selector
 00001ED4  B8 000000C8	      C     mov     eax,_MIN_PRIMATIVE
			      C     .WHILE (eax <= _MAX_PRIMATIVE)
 00001ED9  EB 06	   *	    jmp    @C0037
 00001EDB		   *@C0038:
 00001EDB  E8 FFFFE16E	      C         call    invCreate_call_gate_descriptor32
 00001EE0  40		      C         inc     eax
			      C     .ENDW
 00001EE1		   *@C0037:
 00001EE1  3D 00000BB3	   *	    cmp    eax, _MAX_PRIMATIVE
 00001EE6  76 F3	   *	    jbe    @C0038
			      C 
			      C   ;; Initialize our primative memory areas
 00001EE8  B8 00000098	      C     mov     eax,_sPRIMATIVES
 00001EED  8E C0	      C     mov     es,eax
 00001EEF  33 FF	      C     xor     edi,edi
 00001EF1  B9 00004000	      C     mov     ecx,_sPRIMATIVES_limit
 00001EF6  B0 FF	      C     mov     al,0ffh
 00001EF8  F3/ AA	      C     rep     stosb
 00001EFA  67& 26: C7 06      C     mov     dword ptr es:[0],8
	   0000 00000008
 00001F04  67& 26: C7 06      C     mov     dword ptr es:[4],_MIN_PRIMATIVE
	   0004 000000C8
			      C 
 00001F0E  B8 000000A0	      C     mov     eax,_sPRIMATIVE_LOAD_INFO
 00001F13  8E C0	      C     mov     es,eax
 00001F15  33 FF	      C     xor     edi,edi
 00001F17  B9 00001000	      C     mov     ecx,_sPRIMATIVE_LOAD_INFO_limit
 00001F1C  32 C0	      C     xor     al,al
 00001F1E  F3/ AA	      C     rep     stosb
 00001F20  67& 26: C7 06      C     mov     dword ptr es:[0],4
	   0000 00000004
			      C 
			      C   ;; Now, process all of the drivers that were loaded at bootup
 00001F2A  B8 00000040	      C     mov     eax,_sALL_MEM
 00001F2F  8E D8	      C     mov     ds,eax
 00001F31  67& 2E: 8B 36      C     mov     esi,cs:boot_parameter_block
	   0A91 R
 00001F37  46		      C     inc     esi                                                     ; Move passed the boot drive letter
 00001F38  67& 2E: 8B 1E      C     mov     ebx,cs:boot_dt_linear
	   0A9B R
 00001F3E  67& 2E: 8B 0E      C     mov     ecx,cs:boot_np_linear
	   0A9F R
 00001F44  89 5C 24 24	      C     mov     dword ptr ss:[esp+36],ebx
 00001F48  89 4C 24 28	      C     mov     dword ptr ss:[esp+40],ecx
 00001F4C  C7 44 24 40	      C     mov     dword ptr ss:[esp+64],0                                 ; Used for debugging
	   00000000
			      C     .WHILE (byte ptr ds:[esi+_BOOT_PB_entry_type] != 0ffh)
 00001F54  E9 000001F6	   *	    jmp    @C003A
 00001F59		   *@C003B:
			      C       ; Let's see what this bad boy is
 00001F59  8A 46 14	      C         mov     al,byte ptr ds:[esi+_BOOT_PB_entry_type]
 00001F5C  24 0F	      C         and     al,1111b
			      C         .IF (al == 011b)
 00001F5E  3C 03	   *	    cmp    al, 003h
 00001F60  0F 85 000001E6  *	    jne    @C003C
			      C           ; It's a driver
			      C           ; Store driver name (linear offset to it)
 00001F66  89 74 24 20	      C             mov     dword ptr ss:[esp+32],esi
 00001F6A  8B 5C 24 24	      C             mov     ebx,dword ptr ss:[esp+36]
 00001F6E  8B 54 24 28	      C             mov     edx,dword ptr ss:[esp+40]
			      C 
 00001F72  33 C0	      C             xor     eax,eax
 00001F74  66| 8B 46 1A	      C             mov     ax,word ptr ds:[esi+_BOOT_PB_dt_offset]
 00001F78  03 D8	      C             add     ebx,eax
			      C             .IF (word ptr ds:[ebx+_BOOT_DT_np_offset] != 0ffffh)
 00001F7A  66| 83 7B 0B
	   FF		   *	    cmp    word ptr ds : [ebx + _BOOT_DT_np_offset], 0FFFFh
 00001F7F  74 10	   *	    je     @C003E
			      C               ; Name was specified
 00001F81  67& 2E: 8B 16      C                 mov     edx,cs:boot_np_linear
	   0A9F R
 00001F87  33 C0	      C                 xor     eax,eax
 00001F89  66| 8B 46 0B	      C                 mov     ax,word ptr ds:[esi+_BOOT_DT_np_offset]
 00001F8D  03 D0	      C                 add     edx,eax
			      C             .ELSE
 00001F8F  EB 05	   *	    jmp    @C0040
 00001F91		   *@C003E:
 00001F91  BA FFFFFFFF	      C                 mov     edx,0ffffffffh
			      C             .ENDIF
 00001F96		   *@C0040:
 00001F96  89 14 24	      C             mov     dword ptr ss:[esp+00],edx
			      C 
			      C           ;; Build the temporary GDT entries for our initialization
			      C 
			      C           ; Build the temporary code segment
 00001F99  B8 00000BB6	      C             mov     eax,_csTEMP_PRIMATIVE / 8
 00001F9E  8B 5E 16	      C             mov     ebx,dword ptr ds:[esi+_BOOT_PB_linear_offset]
 00001FA1  8B 16	      C             mov     edx,dword ptr ds:[esi+_BOOT_PB_size]
 00001FA3  E8 FFFFE143	      C             call    invCreate_code_descriptor32
			      C 
			      C           ; Build the temporary data segment
 00001FA8  B8 00000BB7	      C             mov     eax,_dsTEMP_PRIMATIVE / 8
 00001FAD  8B 5E 16	      C             mov     ebx,dword ptr ds:[esi+_BOOT_PB_linear_offset]
 00001FB0  8B 16	      C             mov     edx,dword ptr ds:[esi+_BOOT_PB_size]
 00001FB2  E8 FFFFE1A7	      C             call    invCreate_data_descriptor32
			      C 
			      C           ; Build the temporary call gates
 00001FB7  B8 00000BB4	      C             mov     eax,_cgTEMP_PRIMATIVE_MAIN / 8
 00001FBC  8B 5E 04	      C             mov     ebx,dword ptr ds:[esi+_BOOT_PB_main]
 00001FBF  33 C9	      C             xor     ecx,ecx
 00001FC1  66| BA 5DB0	      C             mov     dx,_csTEMP_PRIMATIVE
 00001FC5  E8 FFFFE084	      C             call    invCreate_call_gate_descriptor32
			      C 
 00001FCA  B8 00000BB5	      C             mov     eax,_cgTEMP_PRIMATIVE_REQUESTOR / 8
 00001FCF  8B 5E 08	      C             mov     ebx,dword ptr ds:[esi+_BOOT_PB_requestor]
 00001FD2  33 C9	      C             xor     ecx,ecx
 00001FD4  66| BA 5DB0	      C             mov     dx,_csTEMP_PRIMATIVE
 00001FD8  E8 FFFFE071	      C             call    invCreate_call_gate_descriptor32
			      C 
			      C ;; Call the requestor function to get "Program Information"
			      C ;; 'info'
			      C 
			      C           ; Ok, the temporary code segment, data segment and call gate are built
			      C           ; Now, we need to call the requestor function so it can work its magic
 00001FDD  B8 00005DB8	      C             mov     eax,_dsTEMP_PRIMATIVE
 00001FE2  8E D8	      C             mov     ds,eax
 00001FE4  B8 696E666F	      C             mov     eax,'info'                                      ; Requestor function for "Program Information"
			      C             callg   _cgTEMP_PRIMATIVE_REQUESTOR
			     1C ; This macro:   callg   _call_gate
 00001FE9  9A		     1C     db  9ah
 00001FEA  00000000	     1C     dd  0
 00001FEE  5DA8		     1C     dw  _cgTEMP_PRIMATIVE_REQUESTOR
			      C           ; Right now, the information specified in INF\REQUESTR.INF is supposed to be available
			      C             .IF (eax != 'nati')
 00001FF0  3D 6E617469	   *	    cmp    eax, 'nati'
 00001FF5  74 05	   *	    je     @C0041
			      C               ; This program was identified as a driver in DT, but it's not a native primative.  This is a fatal error.
 00001FF7  E8 00000710	      C                 call    init_failed                                 ; at the bottom of this source file
			      C                 ; * Note:  The init_failed() routine is terminal.  Control will never return here.
			      C             .ENDIF
			      C           ; It is a driver.  We should treat it as such. :)
			      C           ; Store the information it provided to us
 00001FFC		   *@C0041:
 00001FFC  89 4C 24 04	      C             mov     dword ptr ss:[esp+04],ecx
 00002000  89 74 24 0C	      C             mov     dword ptr ss:[esp+12],esi
 00002004  89 7C 24 10	      C             mov     dword ptr ss:[esp+16],edi
 00002008  89 5C 24 14	      C             mov     dword ptr ss:[esp+20],ebx
 0000200C  89 6C 24 18	      C             mov     dword ptr ss:[esp+24],ebp
			      C 
			      C           ; Now, let's copy the relevent information
 00002010  B8 00000098	      C             mov     eax,_sPRIMATIVES
 00002015  8E C0	      C             mov     es,eax
 00002017  B8 000000A0	      C             mov     eax,_sPRIMATIVE_LOAD_INFO
 0000201C  8E E0	      C             mov     fs,eax
 0000201E  B8 00000040	      C             mov     eax,_sALL_MEM
 00002023  8E E8	      C             mov     gs,eax
			      C 
			      C           ; Copy the this driver's code and data segment GDT entries from their temporary area to a permanent area
 00002025  67& 26: A1	      C             mov     eax,dword ptr es:[4]
	   0004
 0000202A  C1 E0 03	      C             shl     eax,3                                           ; Multiply by 8
 0000202D  8B 74 24 20	      C             mov     esi,dword ptr ss:[esp+32]
 00002031  E8 00000405	      C             call    invMove_temp_gdts_to_permanent
 00002036  C1 E8 03	      C             shr     eax,3                                           ; Divide by 8
 00002039  67& 26: A3	      C             mov     dword ptr es:[4],eax
	   0004
			      C 
			      C           ; Get our starting offsets into the two memory areas
 0000203E  67& 64: 8B 3E      C             mov     edi,dword ptr fs:[0]
	   0000
 00002044  67& 26: 8B 1E      C             mov     ebx,dword ptr es:[0]
	   0000
			      C 
			      C 
			      C           ;; Do the load info structure
			      C           ;; * Refer to inf\primload.inf for information on this structure
 0000204A  66| 64: 89 1F      C             mov     word ptr fs:[edi],bx                            ; store the offset in our load info structure
 0000204E  8B C7	      C             mov     eax,edi
 00002050  83 C0 02	      C             add     eax,2
 00002053  89 44 24 1C	      C             mov     dword ptr ss:[esp+28],eax                       ; Now, store a ptr to the location where we'll eventually
			      C                                                                     ;   store the length of the primative structure this driver
			      C                                                                     ;   has requested (the ptr is stored in temp variable space)
			      C           ; Move past those two word entries
 00002057  83 C7 04	      C             add     edi,4
			      C 
			      C           ; Store the driver's filename
			      C           ; A small degree of indirection here :)
 0000205A  8B 44 24 20	      C             mov     eax,dword ptr ss:[esp+32]                       ; Get a pointer to this driver's boot_parameter_block entry
 0000205E  33 DB	      C             xor     ebx,ebx
 00002060  66| 65: 8B 58      C             mov     bx,word ptr gs:[eax+_BOOT_PB_dt_offset]         ; Which tells us where our DT entry is
	   1A
 00002065  83 C3 02	      C             add     ebx,2                                           ; Move past the sector indicator
 00002068  03 5C 24 24	      C             add     ebx,dword ptr ss:[esp+36]
 0000206C  66| 65: 8B 5B      C             mov     bx,word ptr gs:[ebx+_BOOT_DT_np_offset]         ; Which tells us where our NP entry is
	   0B
 00002071  81 E3 0000FFFF     C             and     ebx,0ffffh
 00002077  83 C3 02	      C             add     ebx,2
 0000207A  03 5C 24 28	      C             add     ebx,dword ptr ss:[esp+40]
 0000207E  33 C9	      C             xor     ecx,ecx
 00002080  65: 8A 0B	      C             mov     cl,byte ptr gs:[ebx]                            ; Where we get our filename length
 00002083  41		      C             inc     ecx
			      C             .REPEAT                                                 ; And finally, where we copy the text from
 00002084		   *@C0043:
 00002084  65: 8A 03	      C                 mov     al,byte ptr gs:[ebx]
 00002087  64: 88 07	      C                 mov     byte ptr fs:[edi],al
 0000208A  43		      C                 inc     ebx
 0000208B  47		      C                 inc     edi
			      C             .UNTILCXZ
 0000208C  E2 F6	   *	    loop   @C0043
			      C 
			      C           ; Store the driver's self-assigned name (what it calls itself)
 0000208E  8B 5C 24 10	      C             mov     ebx,dword ptr ss:[esp+16]
 00002092  E8 00000384	      C             call    invCopy_this_part
			      C 
			      C           ; Store the driver's version text
 00002097  8B 5C 24 14	      C             mov     ebx,dword ptr ss:[esp+20]
 0000209B  E8 0000037B	      C             call    invCopy_this_part
			      C 
			      C           ; Store the author's name text
 000020A0  8B 5C 24 18	      C             mov     ebx,dword ptr ss:[esp+24]
 000020A4  E8 00000372	      C             call    invCopy_this_part
			      C 
			      C           ; Store the GDT offsets for the main portions of this function
 000020A9  0F A8	      C             push    gs
 000020AB  B8 000000A8	      C             mov     eax,_sSYSTEM
 000020B0  8E E8	      C             mov     gs,eax
 000020B2  67& 65: A1	      C             mov     eax,dword ptr gs:[_SYSTEM_i_CODE_GDT_OFFSET]
	   0824
 000020B7  64: 89 07	      C             mov     dword ptr fs:[edi],eax
 000020BA  8B E8	      C             mov     ebp,eax
 000020BC  83 C7 04	      C             add     edi,4
 000020BF  67& 65: A1	      C             mov     eax,dword ptr gs:[_SYSTEM_i_DATA_GDT_OFFSET]
	   0828
 000020C4  64: 89 07	      C             mov     dword ptr fs:[edi],eax
 000020C7  83 C7 04	      C             add     edi,4
 000020CA  67& 65: A1	      C             mov     eax,dword ptr gs:[_SYSTEM_i_MAIN_GDT_OFFSET]
	   082C
 000020CF  64: 89 07	      C             mov     dword ptr fs:[edi],eax
 000020D2  83 C7 04	      C             add     edi,4
 000020D5  67& 65: A1	      C             mov     eax,dword ptr gs:[_SYSTEM_i_REQUESTOR_GDT_OFFSET]
	   0830
 000020DA  64: 89 07	      C             mov     dword ptr fs:[edi],eax
 000020DD  83 C7 04	      C             add     edi,4
 000020E0  0F A9	      C             pop     gs
			      C 
			      C           ; And, finally, update the next location pointer in this _sPRIMATIVE_LOAD_INFO structure
 000020E2  67& 64: 89 3E      C             mov     dword ptr fs:[0],edi
	   0000
			      C 
			      C           ;; Parse their primatives structure
			      C           ;; * Refer to inf\primload.inf for information on the structure this information is converted to in Exodus
			      C           ;; * Refer to inf\requestr.inf for information on the structure the driver provides
 000020E8  8B 74 24 0C	      C             mov     esi,dword ptr ss:[esp+12]
 000020EC  33 C9	      C             xor     ecx,ecx
			      C             .WHILE (byte ptr [esi] != 0ffh)
 000020EE  EB 23	   *	    jmp    @C0044
 000020F0		   *@C0045:
 000020F0  8A 0E	      C                 mov     cl,byte ptr [esi]
 000020F2  46		      C                 inc     esi
 000020F3  8B 14 31	      C                 mov     edx,dword ptr [esi+ecx]                     ; Offset to function
 000020F6  66| 8B 5C 31	      C                 mov     bx,word ptr [esi+ecx+4]                     ; Dwords to copy
	   04
 000020FB  67& 26: A1	      C                 mov     eax,dword ptr es:[4]                        ; Call gate for this primative
	   0004
 00002100  C1 E0 03	      C                 shl     eax,3                                       ; Multiply by 8 to get the call gate offset (rather than slot)
			      C               ; Right now,      ds:[esi] - far ptr to primative function name
			      C               ;                      ebp - code segment for this driver
			      C               ;                      eax - GDT slot
			      C               ;                      ecx - length
			      C               ;                      edx - offset into driver for access to this function
			      C               ;                       bx - dwords to copy
			      C 
			      C               ; Let's add it
 00002103  E8 000003DA	      C                 call    invAdd_primative
 00002108  67& 26: FF 06      C                 inc     dword ptr es:[4]                            ; Move to the next primative SLOT
	   0004
			      C 
 0000210E  03 F1	      C                 add     esi,ecx                                     ; Move past the function name
 00002110  83 C6 06	      C                 add     esi,6                                       ; Move past the function offset (dword)
			      C             .ENDW                                                   ;   and number of dwords to copy (word)
 00002113		   *@C0044:
 00002113  80 3E FF	   *	    cmp    byte ptr [esi], 0FFh
 00002116  75 D8	   *	    jne    @C0045
			      C 
			      C 
			      C           ; At this point, we've received all the information from this first REQUESTOR request
			      C           ; The additional request, 'prim' and 'ints' are not executed until after *ALL* the drivers are loaded (in case they're
			      C           ;                         loaded out of order.  Look below for the followup loads that take place once all the
			      C           ;                         primatives have been installed.
			      C 
			      C           ; Phew!
			      C           ; It's loaded and all processed and everything
			      C             .IF (cs:vga_kbd_support == 0)
 00002118  2E: 80 3D
	   00000538 R 00   *	    cmp    cs : vga_kbd_support, 000h
 00002120  75 1F	   *	    jne    @C0047
			      C               ; We don't have our VGA/keyboard drivers installed yet, let's see if this most recent driver installed any of them
 00002122  B8 00000048	      C                 mov     eax,_sDATA
 00002127  8E D8	      C                 mov     ds,eax
			      C 
 00002129  BE 00001AF2 R      C                 mov     esi,offset required_native_primatives
 0000212E  BF 00001AC0 R      C                 mov     edi,offset _VID_clear_screen_vga
 00002133  E8 000003FC	      C                 call    invUpdate_required_primatives
			      C                 .IF (!carry?)
 00002138  72 07	   *	    jb     @C0049
			      C                   ; All required primatives were found
			      C                   ; We have the ability to display stuff on the screen and get a key
 0000213A  C6 05 00000538 R   C                     mov     ds:vga_kbd_support,1
	   01
			      C                 .ENDIF
			      C             .ENDIF
 00002141		   *@C0049:
			      C 
 00002141		      C           @@:
			      C           ; Proceed along happily to the next driver :)
 00002141		   *@C0047:
 00002141  B8 00000040	      C             mov     eax,_sALL_MEM
 00002146  8E D8	      C             mov     ds,eax
 00002148  8B 74 24 20	      C             mov     esi,dword ptr ss:[esp+32]
			      C         .ENDIF
			      C 
 0000214C		      C       next_native_primative:
 0000214C		   *@C003C:
 0000214C  83 C6 20	      C         add     esi,_BOOT_PB_structure_size
			      C     .ENDW
 0000214F		   *@C003A:
 0000214F  80 7E 14 FF	   *	    cmp    byte ptr ds : [esi + _BOOT_PB_entry_type], 0FFh
 00002153  0F 85 FFFFFE00  *	    jne    @C003B
			      C 
			      C 
			      C   ; If we're here, then everything has loaded ok, or the ones that didn't load correctly were ignored
			      C   ; Now, since all of the drivers were loaded we need to go ahead and call the remaining requestor() functions, 'prim' and 'ints'
			      C   ; Once those are called we call main() in each one in the order loaded
			      C   ;
			      C   ; * Note:  When we get here, all of the [esp+xx] references above are no longer in use
			      C   ;
			      C 
			      C 
			      C 
			      C   ; Setup the video information for the following portion of code.  From here on out we're fully digital, baby! :)
			      C   ;
 00002159  B8 00000048	      C     mov     eax,_sDATA
 0000215E  8E C0	      C     mov     es,eax
 00002160  BB 000000A0	      C     mov     ebx,_sPRIMATIVE_LOAD_INFO
 00002165  8E E3	      C     mov     fs,ebx
 00002167  B8 00000004	      C     mov     eax,4
			      C     .WHILE (eax < dword ptr fs:[0])
 0000216C  E9 00000122	   *	    jmp    @C004C
 00002171		   *@C004D:
			      C 
 00002171  33 C9	      C         xor     ecx,ecx
 00002173  83 C0 04	      C         add     eax,4
 00002176  64: 8A 08	      C         mov     cl,byte ptr fs:[eax]                                ; Get the length of the driver file name
 00002179  40		      C         inc     eax
 0000217A  03 C1	      C         add     eax,ecx
 0000217C  64: 8A 08	      C         mov     cl,byte ptr fs:[eax]                                ; Get the length of the driver's self-assigned name
 0000217F  40		      C         inc     eax
 00002180  03 C1	      C         add     eax,ecx
 00002182  64: 8A 08	      C         mov     cl,byte ptr fs:[eax]                                ; Get the length of the version text
 00002185  40		      C         inc     eax
 00002186  03 C1	      C         add     eax,ecx
 00002188  64: 8A 08	      C         mov     cl,byte ptr fs:[eax]                                ; Get the length of the author text
 0000218B  40		      C         inc     eax
 0000218C  03 C1	      C         add     eax,ecx
 0000218E  8B F8	      C         mov     edi,eax
			      C 
			      C       ;
			      C       ; Right now, fs:[edi] - far ptr to GDT offsets for:
			      C       ;
			      C       ;                     Offset  Length  Description             How to access
			      C       ;                     ------  ------  --------------------    -------------------------------------
			      C       ;                        0      4     code segment            to access (word ptr fs:[eax+0])
			      C       ;                        4      4     data segment            to access (word ptr fs:[eax+4])
			      C       ;                        8      4     main call gate          to access (call fword ptr fs:[eax+4])
			      C       ;                        12     4     requestor, call gate    to access (call fword ptr fs:[eax+8])
			      C       ;
			      C 
			      C       ; Physically call the primative
 00002190  50		      C         push    eax
			      C 
 00002191  33 DB	      C         xor     ebx,ebx
 00002193  66| 64: 8B 58      C         mov     bx,word ptr fs:[eax+12]                             ; Modify the selector for this primative
	   0C
 00002198  BE 0000227F R      C         mov     esi,offset id_offset
 0000219D  66| 26: 89 1E      C         mov     word ptr es:[esi],bx
 000021A1  BE 000021DA R      C         mov     esi,offset prim_offset
 000021A6  66| 26: 89 1E      C         mov     word ptr es:[esi],bx
 000021AA  BE 00002216 R      C         mov     esi,offset note_offset
 000021AF  66| 26: 89 1E      C         mov     word ptr es:[esi],bx
 000021B3  EB 00	      C         jmp     $+2                                                 ; Clear the prefetch cache (just in case)
			      C 
 000021B5  B8 7072696D	      C         mov     eax,'prim'                                          ; requested primative function
 000021BA  66| 64: 8E 5F      C         mov     ds,word ptr fs:[edi+4]                              ; this primative's permanent data segment
	   04
 000021BF  64: 8B 5F 08	      C         mov     ebx,dword ptr fs:[edi+8]                            ; main() call gate
 000021C3  64: 8B 4F 0C	      C         mov     ecx,dword ptr fs:[edi+12]                           ; requestor() call gate
 000021C7  33 D2	      C         xor     edx,edx
 000021C9  33 F6	      C         xor     esi,esi
 000021CB  33 FF	      C         xor     edi,edi
 000021CD  33 ED	      C         xor     ebp,ebp
 000021CF  8E C2	      C         mov     es,edx
 000021D1  8E E2	      C         mov     fs,edx
 000021D3  8E EA	      C         mov     gs,edx
			      C ;        call    invExtract_linear_offset_into_edx_from_ds
			      C       ;
			      C       ; Right now, eax - 'prim', indicating what requestor() function we're calling
			      C       ;             bx - main() call gate
			      C       ;             cx - requestor() call gate
			      C       ;            edx - null
			      C       ;            esi - null
			      C       ;            edi - null
			      C       ;            ebp - null
			      C       ;             ds - permanent data segment for this primative
			      C       ;             es - null
			      C       ;             fs - null
			      C       ;             gs - null
 000021D5  9A		      C         db  9ah                     ; Call immed16:32
 000021D6  00000000	      C         dd  0                       ; Offset (the value here doesn't matter because we're calling a call gate)
 000021DA		      C       prim_offset:
 000021DA  0000		      C         dw  0                       ; Selector (this part changes for each primative, see the code above (before jmp $+2))
			      C 
			      C       ; Right now, esi - offset to list of names to find
			      C       ;            edi - offset to corresponding call gate area
			      C         .IF (esi != 0ffffffffh)
 000021DC  83 FE FF	   *	    cmp    esi, 0FFFFFFFFh
 000021DF  0F 84 0000009C  *	    je     @C004E
			      C           ; They have specified a list of primatives they need
 000021E5  E8 0000034A	      C             call    invUpdate_required_primatives
			      C             .IF (carry?)
 000021EA  73 33	   *	    jae    @C0050
			      C               ; Not all of them are available, we need to call the driver and tell them
 000021EC  B8 000000A8	      C                 mov     eax,_sSYSTEM
 000021F1  8E E0	      C                 mov     fs,eax
 000021F3  B8 6E6F7465	      C                 mov     eax,'note'
 000021F8  BB 7072696D	      C                 mov     ebx,'prim'
 000021FD  67& 64: 8B 0E      C                 mov     ecx,dword ptr fs:[_SYSTEM_i_SCRATCH_DWORD1]     ; Total
	   0BFC
 00002203  67& 64: 8B 2E      C                 mov     ebp,dword ptr fs:[_SYSTEM_i_SCRATCH_DWORD2]     ; Number that weren't found
	   0BF8
 00002209  33 D2	      C                 xor     edx,edx
 0000220B  33 F6	      C                 xor     esi,esi
 0000220D  33 FF	      C                 xor     edi,edi
 0000220F  8E E2	      C                 mov     fs,edx
			      C               ; Now, call the 'note' requestor function
 00002211  9A		      C                 db  9ah             ; Call immed16:32
 00002212  00000000	      C                 dd  0               ; Offset (the value here doesn't matter because we're calling a call gate)
 00002216		      C               note_offset:
 00002216  0000		      C                 dw  0               ; Selector (this part changes for each primative, see the code above (before jmp $+2))
			      C 
			      C                 .IF (carry?)
 00002218  73 05	   *	    jae    @C0052
			      C                   ; They've indicated this driver cannot continue without those primatives
 0000221A  E8 000004ED	      C                     call    init_failed
			      C                 .ENDIF
			      C             .ENDIF
 0000221F		   *@C0052:
			      C 
			      C           ; Right now, everything's loaded OK.
 0000221F		   *@C0050:
 0000221F  BB 000000A0	      C             mov     ebx,_sPRIMATIVE_LOAD_INFO
 00002224  8E E3	      C             mov     fs,ebx
 00002226  8B 04 24	      C             mov     eax,dword ptr ss:[esp]                          ; Get our offset off the stack
 00002229  83 C0 10	      C             add     eax,16                                          ; And move to the next location to see WHERE IT'S AT! (Got 2 turn tables and a microphone...)
 0000222C  1E		      C             push    ds
 0000222D  60		      C             pushad
 0000222E  BE 00001ACE R      C             mov     esi,offset _VID_display_string_vga + 4
			      C             .IF (eax < dword ptr fs:[0])
 00002233  67& 64: 3B 06
	   0000		   *	    cmp    eax, dword ptr fs : [000h]
 00002239  73 07	   *	    jae    @C0054
 0000223B  BE 0000075D R      C                 mov     esi,offset next_item
			      C             .ELSE
 00002240  EB 05	   *	    jmp    @C0056
 00002242		   *@C0054:
 00002242  BE 00000762 R      C                 mov     esi,offset last_item
			      C             .ENDIF
 00002247		   *@C0056:
 00002247  B8 00000048	      C             mov     eax,_sDATA
 0000224C  8E D8	      C             mov     ds,eax
			      C             .IF (ds:loading_primatives_displayed == _NO)
 0000224E  80 3D 00000735 R
	   00		   *	    cmp    ds : loading_primatives_displayed, _NO
 00002255  75 15	   *	    jne    @C0057
 00002257  C6 05 00000735 R   C                 mov     ds:loading_primatives_displayed,_YES
	   01
 0000225E  60		      C                 pushad
 0000225F  BE 00000736 R      C                 mov     esi,offset loading_primatives
 00002264  2E: FF 1D	      C                 call    fword ptr cs:_VID_display_string_nr_vga
	   00001AC8 R
 0000226B  61		      C                 popad
			      C             .ENDIF
 0000226C		   *@C0057:
 0000226C  2E: FF 1D	      C             call    fword ptr cs:_VID_display_string_vga
	   00001ACA R
 00002273  61		      C             popad
 00002274  1F		      C             pop     ds
			      C           ; Ask the driver to identify itself on the VGA display
 00002275  B8 69642020	      C             mov     eax,'id  '
 0000227A  9A		      C             db  9ah                 ; Call immed16:32
 0000227B  00000000	      C             dd  0                   ; Offset (the value here doesn't matter because we're calling a call gate)
 0000227F		      C           id_offset:
 0000227F  0000		      C             dw  0                   ; Selector (this part changes for each primative, see the code above (before jmp $+2))
			      C 
			      C         .ENDIF
			      C 
 00002281		   *@C004E:
 00002281  58		      C         pop     eax
			      C       ; Reset the data segments for use in our procedure
 00002282  BB 00000048	      C         mov     ebx,_sDATA
 00002287  8E C3	      C         mov     es,ebx
 00002289  BB 000000A0	      C         mov     ebx,_sPRIMATIVE_LOAD_INFO
 0000228E  8E E3	      C         mov     fs,ebx
			      C 
 00002290  83 C0 10	      C         add     eax,16
			      C     .ENDW
 00002293		   *@C004C:
 00002293  67& 64: 3B 06
	   0000		   *	    cmp    eax, dword ptr fs : [000h]
 00002299  0F 82 FFFFFED2  *	    jb     @C004D
			      C 
			      C 
			      C   ; At this point, all of the requestor() functions have been setup for all drivers
			      C   ; Now, it's time to call main() on each one of them
			      C   ; Before we do that we need to setup Exodus's requestor() memory blocks
 0000229F  B8 00000050	      C     mov     eax,_sEXODUS_MEM
 000022A4  8E D8	      C     mov     ds,eax
 000022A6  67& C7 06 0000     C     mov     dword ptr ds:[0],4                                      ; Starting location to write data for memory blocks
	   00000004
 000022AF  B8 00000058	      C     mov     eax,_sEXODUS_PORTS
 000022B4  8E D8	      C     mov     ds,eax
 000022B6  67& C7 06 0000     C     mov     dword ptr ds:[0],4                                      ; Starting location to write data for port requests
	   00000004
 000022BF  B8 00000060	      C     mov     eax,_sEXODUS_INTS
 000022C4  8E D8	      C     mov     ds,eax
 000022C6  67& C7 06 0000     C     mov     dword ptr ds:[0],4                                      ; Starting location to write data for interrupt requests
	   00000004
			      C 
			      C   ; Display the driver's name before we begin call main()
 000022CF  B8 00000048	      C     mov     eax,_sDATA
 000022D4  8E D8	      C     mov     ds,eax
 000022D6  BE 0000074B R      C     mov     esi,offset loading_drivers
 000022DB  2E: FF 1D	      C     call    fword ptr cs:_VID_display_string_nr_vga
	   00001AC8 R
			      C 
 000022E2  BB 000000A0	      C     mov     ebx,_sPRIMATIVE_LOAD_INFO
 000022E7  8E DB	      C     mov     ds,ebx
 000022E9  B8 00000004	      C     mov     eax,4
 000022EE  8B EC	      C     mov     ebp,esp
			      C     .WHILE (eax < dword ptr ds:[0])
 000022F0  E9 000000E6	   *	    jmp    @C005A
 000022F5		   *@C005B:
 000022F5  33 C9	      C         xor     ecx,ecx
 000022F7  83 C0 04	      C         add     eax,4
 000022FA  8A 08	      C         mov     cl,byte ptr ds:[eax]                                ; Get the length of the driver file name
 000022FC  40		      C         inc     eax
 000022FD  03 C1	      C         add     eax,ecx
 000022FF  8A 08	      C         mov     cl,byte ptr ds:[eax]                                ; Get the length of the driver's self-assigned name
 00002301  40		      C         inc     eax
 00002302  89 45 30	      C         mov     dword ptr ss:[ebp+48],eax                           ; Save for later use (below)
 00002305  89 4D 34	      C         mov     dword ptr ss:[ebp+52],ecx                           ; Save for later use (below)
 00002308  03 C1	      C         add     eax,ecx
 0000230A  8A 08	      C         mov     cl,byte ptr ds:[eax]                                ; Get the length of the version text
 0000230C  40		      C         inc     eax
 0000230D  89 45 38	      C         mov     dword ptr ss:[ebp+56],eax                           ; Save for later use (below)
 00002310  89 4D 3C	      C         mov     dword ptr ss:[ebp+60],ecx                           ; Save for later use (below)
 00002313  03 C1	      C         add     eax,ecx
 00002315  8A 08	      C         mov     cl,byte ptr ds:[eax]                                ; Get the length of the author text
 00002317  40		      C         inc     eax
 00002318  03 C1	      C         add     eax,ecx
 0000231A  8B F8	      C         mov     edi,eax
 0000231C  50		      C         push    eax
			      C 
 0000231D  33 DB	      C         xor     ebx,ebx
 0000231F  66| 64: 8B 58      C         mov     bx,word ptr fs:[eax+4]                              ; Get the data segment for this primative
	   04
 00002324  89 5D 2C	      C         mov     dword ptr ss:[ebp+44],ebx
 00002327  66| 64: 8B 58      C         mov     bx,word ptr fs:[eax+8]                              ; Get the main() selector for this primative
	   08
 0000232C  BE 000023CE R      C         mov     esi,offset main_offset
 00002331  66| 26: 89 1E      C         mov     word ptr es:[esi],bx
			      C       ;
			      C       ; Right now,          ds - data segment for this primative's name in the _sPRIMATIVE_LOAD_INFO structure
			      C       ;            ss:[ebp+48] - ptr to offset of driver's self-assigned name
			      C       ;            ss:[ebp+52] - length of the name at that location
			      C       ;
 00002335  83 C7 10	      C         add     edi,16
			      C         .IF (edi < dword ptr ds:[0])
 00002338  67& 3B 3E 0000  *	    cmp    edi, dword ptr ds : [000h]
 0000233D  73 07	   *	    jae    @C005C
 0000233F  BE 0000075D R      C             mov     esi,offset next_item
			      C         .ELSE
 00002344  EB 05	   *	    jmp    @C005E
 00002346		   *@C005C:
 00002346  BE 00000762 R      C             mov     esi,offset last_item
			      C         .ENDIF
			      C 
 0000234B		   *@C005E:
 0000234B  1E		      C         push    ds
 0000234C  B8 00000048	      C         mov     eax,_sDATA
 00002351  8E D8	      C         mov     ds,eax
 00002353  2E: FF 1D	      C         call    fword ptr cs:_VID_display_string_vga
	   00001ACA R
 0000235A  1F		      C         pop     ds
			      C 
			      C       ; Display what the driver calls itself
 0000235B  8B 75 30	      C         mov     esi,dword ptr ss:[ebp+48]
 0000235E  8B 4D 34	      C         mov     ecx,dword ptr ss:[ebp+52]
			      C       ; This code removes anything that comes after the ASCII-255 (indicating not-displayed information)
 00002361  8B C1	      C         mov     eax,ecx
			      C         .WHILE (eax > 0)
 00002363  EB 0B	   *	    jmp    @C005F
 00002365		   *@C0060:
			      C             .IF (byte ptr ds:[esi+eax-1] == 255)
 00002365  80 7C 30 FF FF  *	    cmp    byte ptr ds : [esi + eax - 001h], 0FFh
 0000236A  75 03	   *	    jne    @C0061
 0000236C  8B C8	      C                 mov     ecx,eax
 0000236E  49		      C                 dec     ecx
			      C             .ENDIF
 0000236F		   *@C0061:
 0000236F  48		      C             dec     eax
			      C         .ENDW
 00002370		   *@C005F:
 00002370  83 F8 00	   *	    cmp    eax, 000h
 00002373  77 F0	   *	    ja     @C0060
			      C         .IF (ecx != 0 && ecx < 7fffffffh)
 00002375  0B C9	   *	    or	ecx, ecx
 00002377  74 24	   *	    je     @C0064
 00002379  81 F9 7FFFFFFF  *	    cmp    ecx, 07FFFFFFFh
 0000237F  73 1C	   *	    jae    @C0064
			      C           ; Display the name
 00002381  2E: FF 1D	      C             call    fword ptr cs:_VID_display_string_ecx_vga
	   00001AC6 R
			      C 
 00002388  1E		      C             push    ds
 00002389  B8 00000048	      C             mov     eax,_sDATA
 0000238E  8E D8	      C             mov     ds,eax
 00002390  BE 00000767 R      C             mov     esi,offset comma_space
 00002395  2E: FF 1D	      C             call    fword ptr cs:_VID_display_string_vga
	   00001ACA R
 0000239C  1F		      C             pop     ds
			      C         .ENDIF
			      C 
			      C       ; Display the version information
 0000239D		   *@C0064:
 0000239D  8B 75 38	      C         mov     esi,dword ptr ss:[ebp+56]
 000023A0  8B 4D 3C	      C         mov     ecx,dword ptr ss:[ebp+60]
 000023A3  2E: FF 1D	      C         call    fword ptr cs:_VID_display_string_ecx_nr_vga
	   00001AC4 R
			      C 
 000023AA  60		      C         pushad
 000023AB  1E		      C         push    ds
 000023AC  06		      C         push    es
 000023AD  0F A0	      C         push    fs
 000023AF  0F A8	      C         push    gs
 000023B1  66| 8E 5D 2C	      C         mov     ds,word ptr ss:[ebp+44]
 000023B5  33 ED	      C         xor     ebp,ebp
 000023B7  33 C0	      C         xor     eax,eax
 000023B9  33 DB	      C         xor     ebx,ebx
 000023BB  33 C9	      C         xor     ecx,ecx
 000023BD  33 D2	      C         xor     edx,edx
 000023BF  33 F6	      C         xor     esi,esi
 000023C1  33 FF	      C         xor     edi,edi
 000023C3  8E C0	      C         mov     es,eax
 000023C5  8E E0	      C         mov     fs,eax
 000023C7  8E E8	      C         mov     gs,eax
			      C       ; Ok, we've displayed its name on the screen....
			      C       ; Right now:  ds - The primative data segment
			      C       ;             everything else is NULL
			      C       ; Now, we let it initialize itself
 000023C9  9A		      C         db  9ah                     ; Call immed16:32
 000023CA  00000000	      C         dd  0                       ; Offset (the value here doesn't matter because we're calling a call gate)
 000023CE		      C       main_offset:
 000023CE  0000		      C         dw  0                       ; Selector (this part changes for each primative, see the code near "offset main_offset")
 000023D0  0F A9	      C         pop     gs
 000023D2  0F A1	      C         pop     fs
 000023D4  07		      C         pop     es
 000023D5  1F		      C         pop     ds
 000023D6  61		      C         popad
			      C 
 000023D7  58		      C         pop     eax
 000023D8  83 C0 10	      C         add     eax,16
			      C     .ENDW
 000023DB		   *@C005A:
 000023DB  67& 3B 06 0000  *	    cmp    eax, dword ptr ds : [000h]
 000023E0  0F 82 FFFFFF0F  *	    jb     @C005B
			      C 
 000023E6  83 C4 44	      C     add     esp,68
 000023E9  1F		      C     pop     ds
 000023EA  07		      C     pop     es
 000023EB  0F A1	      C     pop     fs
 000023ED  0F A9	      C     pop     gs
 000023EF  C3		      C     ret
 000023F0		      C invSetup_native_primatives      ENDP
			      C 
			      C 
			      C 
			      C 
 000023F0		      C default_primative_response      PROC    NEAR
			      C ; This routine is called on any primative that has not been defined.
			      C ;
			      C ; * The primative call gates represent a range defined at the top of this program
			      C ;   Any primative call gate that has not been used by a defined function points to this routine
			      C ;   It returns the text "no support for primative" in the registers
			      C ;
 000023F0  2E: A1	      C     mov     eax,dword ptr cs:no_support_for_primative[00]
	   00000510 R
 000023F6  2E: 8B 1D	      C     mov     ebx,dword ptr cs:no_support_for_primative[04]
	   00000514 R
 000023FD  2E: 8B 0D	      C     mov     ecx,dword ptr cs:no_support_for_primative[08]
	   00000518 R
 00002404  2E: 8B 15	      C     mov     edx,dword ptr cs:no_support_for_primative[12]
	   0000051C R
 0000240B  2E: 8B 35	      C     mov     esi,dword ptr cs:no_support_for_primative[16]
	   00000520 R
 00002412  2E: 8B 3D	      C     mov     edi,dword ptr cs:no_support_for_primative[20]
	   00000524 R
 00002419  F9		      C     stc
 0000241A  CB		      C     retf
 0000241B		      C default_primative_response      ENDP
			      C 
			      C 
			      C 
			      C 
 0000241B		      C invCopy_this_part   PROC    NEAR
			      C ; This routine is used to copy data from ds:[ebx] to fs:[edi]
			      C ;
			      C ; Upon entry:   ds:[ebx] - ptr to source string
			      C ;               fs:[edi] - ptr to destination string
			      C ;
			      C ; Upon exit:    ecx - number of bytes copied
			      C ;
 0000241B  52		      C     push    edx
 0000241C  51		      C     push    ecx
 0000241D  53		      C     push    ebx
 0000241E  50		      C     push    eax
			      C 
 0000241F  8B D7	      C     mov     edx,edi
 00002421  47		      C     inc     edi
 00002422  33 C9	      C     xor     ecx,ecx
			      C     .WHILE (byte ptr ds:[ebx] != 0)
 00002424  EB 08	   *	    jmp    @C0068
 00002426		   *@C0069:
 00002426  8A 03	      C         mov     al,byte ptr ds:[ebx]
 00002428  64: 88 07	      C         mov     byte ptr fs:[edi],al
 0000242B  43		      C         inc     ebx
 0000242C  47		      C         inc     edi
 0000242D  41		      C         inc     ecx
			      C     .ENDW
 0000242E		   *@C0068:
 0000242E  80 3B 00	   *	    cmp    byte ptr ds : [ebx], 000h
 00002431  75 F3	   *	    jne    @C0069
 00002433  64: 88 0A	      C     mov     byte ptr fs:[edx],cl
			      C 
 00002436  58		      C     pop     eax
 00002437  5B		      C     pop     ebx
 00002438  59		      C     pop     ecx
 00002439  5A		      C     pop     edx
 0000243A  C3		      C     ret
 0000243B		      C invCopy_this_part   ENDP
			      C 
			      C 
			      C 
			      C 
 0000243B		      C invMove_temp_gdts_to_permanent      PROC    NEAR
			      C ; This routine is used to copy the temporary primative GDT entries to their permanent location
			      C ;
			      C ; Upon entry:   eax - starting GDT offset to use
			      C ;               ecx - actual code segment/data segment length
			      C ;               _csTEMP_PRIMATIVE - defined as Code segment
			      C ;               _dsTEMP_PRIMATIVE - defined as Data segment
			      C ;          _cgTEMP_PRIMATIVE_MAIN - defined as call gate to main()
			      C ;     _cgTEMP_PRIMATIVE_REQUESTOR - defined as call gate to requestor()
			      C ;
			      C ; Upon exit:    _csTEMP_PRIMATIVE - copied to the next available location
			      C ;               _dsTEMP_PRIMATIVE - copied to the one after that
			      C ;                             eax - next GDT offset to use
			      C ;                                   * Note:  If the value in ebx != 0, then the limit of the
			      C ;
 0000243B  57		      C     push    edi
 0000243C  53		      C     push    ebx
 0000243D  1E		      C     push    ds
 0000243E  06		      C     push    es
 0000243F  0F A0	      C     push    fs
 00002441  0F A8	      C     push    gs
			      C 
 00002443  BB 00000010	      C     mov     ebx,_sGDT
 00002448  8E DB	      C     mov     ds,ebx
 0000244A  BB 000000A8	      C     mov     ebx,_sSYSTEM
 0000244F  8E C3	      C     mov     es,ebx
 00002451  BB 00000048	      C     mov     ebx,_sDATA
 00002456  8E E3	      C     mov     fs,ebx
 00002458  BB 000000A8	      C     mov     ebx,_sSYSTEM
 0000245D  8E EB	      C     mov     gs,ebx
			      C 
			      C   ; Copy the code segment
 0000245F  BF 00005DB0	      C     mov     edi,_csTEMP_PRIMATIVE
 00002464  8B 1F	      C     mov     ebx,dword ptr [edi]
 00002466  89 18	      C     mov     dword ptr [eax],ebx
 00002468  8B 5F 04	      C     mov     ebx,dword ptr [edi+4]
 0000246B  89 58 04	      C     mov     dword ptr [eax+4],ebx
			      C   ; Derive the GDT information (to see if we need to adjust it)
 0000246E  E8 FFFFDD58	      C     call    invExtract_code_descriptor32
			      C ;    .IF (ecx < edx)
			      C ;      ; We need to make the limit field shorter because they don't need all of the memory in the file
			      C ;        push    eax
			      C ;        shr     eax,3                                               ; Divide by 8
			      C ;        mov     edx,ecx                                             ; Decrease the limit to the value specified by requestor()
			      C ;        call    invCreate_code_descriptor32
			      C ;        pop     eax
			      C ;    .ENDIF
 00002473  67& 65: A3	      C     mov     dword ptr gs:[_SYSTEM_i_CODE_GDT_OFFSET],eax
	   0824
 00002478  83 C0 08	      C     add     eax,8
			      C 
			      C   ; Copy the data segment
 0000247B  BF 00005DB8	      C     mov     edi,_dsTEMP_PRIMATIVE
 00002480  8B 1F	      C     mov     ebx,dword ptr [edi]
 00002482  89 18	      C     mov     dword ptr [eax],ebx
 00002484  8B 5F 04	      C     mov     ebx,dword ptr [edi+4]
 00002487  89 58 04	      C     mov     dword ptr [eax+4],ebx
 0000248A  E8 FFFFDDA7	      C     call    invExtract_data_descriptor32
			      C ;    .IF (ecx < edx)
			      C ;      ; We need to make the limit field shorter because they don't need all of the memory in the file
			      C ;        push    eax
			      C ;        shr     eax,3                                               ; Divide by 8
			      C ;        mov     edx,ecx                                             ; Decrease the limit to the value specified by requestor()
			      C ;        call    invCreate_data_descriptor32
			      C ;        pop     eax
			      C ;    .ENDIF
 0000248F  67& 65: A3	      C     mov     dword ptr gs:[_SYSTEM_i_DATA_GDT_OFFSET],eax
	   0828
 00002494  83 C0 08	      C     add     eax,8
			      C 
			      C   ; Copy the main call gate
 00002497  BF 00005DA0	      C     mov     edi,_cgTEMP_PRIMATIVE_MAIN
 0000249C  8B 1F	      C     mov     ebx,dword ptr [edi]
 0000249E  89 18	      C     mov     dword ptr [eax],ebx
 000024A0  8B 5F 04	      C     mov     ebx,dword ptr [edi+4]
 000024A3  89 58 04	      C     mov     dword ptr [eax+4],ebx
 000024A6  67& 65: A3	      C     mov     dword ptr gs:[_SYSTEM_i_MAIN_GDT_OFFSET],eax
	   082C
			      C   ; Now, update the code segment selector for this newly located code segment (see above)
 000024AB  67& 65: 8B 1E      C     mov     ebx,dword ptr gs:[_SYSTEM_i_CODE_GDT_OFFSET]
	   0824
 000024B1  66| 89 58 02	      C     mov     word ptr [eax+2],bx
 000024B5  83 C0 08	      C     add     eax,8
			      C 
			      C   ; Copy the requestor call gate
 000024B8  BF 00005DA8	      C     mov     edi,_cgTEMP_PRIMATIVE_REQUESTOR
 000024BD  8B 1F	      C     mov     ebx,dword ptr [edi]
 000024BF  89 18	      C     mov     dword ptr [eax],ebx
 000024C1  8B 5F 04	      C     mov     ebx,dword ptr [edi+4]
 000024C4  89 58 04	      C     mov     dword ptr [eax+4],ebx
 000024C7  67& 65: A3	      C     mov     dword ptr gs:[_SYSTEM_i_REQUESTOR_GDT_OFFSET],eax
	   0830
			      C   ; And, update this one's code selector also (see above)
 000024CC  67& 65: 8B 1E      C     mov     ebx,dword ptr gs:[_SYSTEM_i_CODE_GDT_OFFSET]
	   0824
 000024D2  66| 89 58 02	      C     mov     word ptr [eax+2],bx
 000024D6  83 C0 08	      C     add     eax,8
			      C 
 000024D9  0F A9	      C     pop     gs
 000024DB  0F A1	      C     pop     fs
 000024DD  07		      C     pop     es
 000024DE  1F		      C     pop     ds
 000024DF  5B		      C     pop     ebx
 000024E0  5F		      C     pop     edi
 000024E1  C3		      C     ret
 000024E2		      C invMove_temp_gdts_to_permanent      ENDP
			      C 
			      C 
			      C 
			      C 
 000024E2		      C invAdd_primative    PROC    NEAR
			      C ; This routine is used to add a primative to the following items:
			      C ;   #1 - The _sPRIMATIVE structure
			      C ;   #2 - The GDT as a call gate
			      C ;
			      C ; Upon entry:        eax - GDT offset for this primative's call gate
			      C ;               ds:[esi] - far ptr to primative function name
			      C ;                     bx - dword to copy
			      C ;                    ecx - length
			      C ;                    edx - offset into the driver for this function
			      C ;                    ebp - Code segment for the driver this primative comes from
			      C ;
			      C ; Upon exit:    This routine is self contained
			      C ;               If control is returned to the calling function then it can be assumed that it is ok to continue
			      C ;               The data is added (or not added)
			      C ;
 000024E2  60		      C     pushad
 000024E3  06		      C     push    es
			      C 
			      C     .IF (eax < _MAX_PRIMATIVE*8)
 000024E4  3D 00005D98	   *	    cmp    eax, _MAX_PRIMATIVE * 008h
 000024E9  73 46	   *	    jae    @C006B
			      C       ; We're within the range for this primative
 000024EB  BF 00000098	      C         mov     edi,_sPRIMATIVES
 000024F0  8E C7	      C         mov     es,edi
			      C 
 000024F2  67& 26: 8B 3E      C         mov     edi,dword ptr es:[0]
	   0000
 000024F8  66| 26: 89 07      C         mov     word ptr es:[edi],ax                                ; store the call gate
 000024FC  83 C7 02	      C         add     edi,2
			      C 
 000024FF  26: C6 07 01	      C         mov     byte ptr es:[edi],1                                 ; active? (0-No, 1-Yes)
 00002503  47		      C         inc     edi
			      C 
 00002504  26: 88 0F	      C         mov     byte ptr es:[edi],cl                                ; length of the function name
 00002507  47		      C         inc     edi
			      C 
			      C       ; Store the primative function name
			      C       ; Right now, ds:[esi] - far ptr to their primative name
			      C       ;            es:[edi] - far ptr to store it
			      C       ;                 ecx - length of that name
 00002508  50		      C         push    eax
			      C         .REPEAT
 00002509		   *@C006D:
 00002509  8A 06	      C             mov     al,byte ptr [esi]
			      C             .IF (al >= "A" && al <= "Z")
 0000250B  3C 41	   *	    cmp    al, 'A'
 0000250D  72 06	   *	    jb     @C006E
 0000250F  3C 5A	   *	    cmp    al, 'Z'
 00002511  77 02	   *	    ja     @C006E
 00002513  0C 20	      C                 or      al,20h                                      ; force the name to lower-case
			      C             .ENDIF
 00002515		   *@C006E:
 00002515  46		      C             inc     esi
 00002516  26: 88 07	      C             mov     byte ptr es:[edi],al
 00002519  47		      C             inc     edi
			      C         .UNTILCXZ
 0000251A  E2 ED	   *	    loop   @C006D
 0000251C  58		      C         pop     eax
			      C 
			      C       ; Update for the next location
 0000251D  67& 26: 89 3E      C         mov     dword ptr es:[0],edi
	   0000
			      C 
			      C       ; Now, physically create the call gate to this primative
 00002523  8B CB	      C         mov     ecx,ebx                                             ; dwords to copy
 00002525  8B DA	      C         mov     ebx,edx                                             ; Offset to start of function
 00002527  8B D5	      C         mov     edx,ebp                                             ; Code segment
 00002529  C1 E8 03	      C         shr     eax,3                                               ; Divide by 8 to get the GDT slot
 0000252C  E8 FFFFDB1D	      C         call    invCreate_call_gate_descriptor32
			      C     .ENDIF
 00002531		   *@C006B:
			      C 
 00002531  07		      C     pop     es
 00002532  61		      C     popad
 00002533  C3		      C     ret
 00002534		      C invAdd_primative    ENDP
			      C 
			      C 
			      C 
			      C 
 00002534		      C invUpdate_required_primatives   PROC    NEAR
			      C ; This routine is used to update the required primatives required by a particular function
			      C ; * Refer to inf\
			      C ;
			      C ; Upon entry:   ds:[esi] - Offset to name structure of the required primatives
			      C ;               ds:[edi] - Offset to the start of the structure used for the call gates to assign to them
			      C ;
			      C ; Upon exit:    carry? - CLEAR=all functions were found (meaning they've already been installed)
			      C ;                          SET=error
			      C ;                              À ecx - number of functions not found
			      C ;
 00002534  60		      C     pushad
 00002535  06		      C     push    es
 00002536  0F A0	      C     push    fs
 00002538  C8 0014 00	      C     enter   20,0
			      C   ; [ebp-04] - dword, --Nuserved
			      C   ; [ebp-08] - dword, current value of eax
			      C   ; [ebp-12] - dword, current value of ecx for inner loop
			      C   ; [ebp-16] - dword, current value of esi
			      C   ; [ebp-20] - dword, curent value of ecx for outter loop
 0000253C  B8 00000098	      C     mov     eax,_sPRIMATIVES
 00002541  8E C0	      C     mov     es,eax
 00002543  B8 000000A8	      C     mov     eax,_sSYSTEM
 00002548  8E E0	      C     mov     fs,eax
			      C 
 0000254A  67& 64: C7 06      C     mov     dword ptr fs:[_SYSTEM_i_SCRATCH_DWORD1],0               ; Holds total number of primative names found
	   0BFC 00000000
 00002554  67& 64: C7 06      C     mov     dword ptr fs:[_SYSTEM_i_SCRATCH_DWORD2],0               ; Holds total number not matched with installed primatives
	   0BF8 00000000
			      C 
 0000255E  33 C9	      C     xor     ecx,ecx
			      C     .WHILE (byte ptr ds:[esi] != 0ffh)
 00002560  E9 00000080	   *	    jmp    @C0071
 00002565		   *@C0072:
 00002565  89 75 F0	      C         mov     dword ptr ss:[ebp-16],esi
 00002568  8A 0E	      C         mov     cl,byte ptr ds:[esi]
 0000256A  89 4D EC	      C         mov     dword ptr ss:[ebp-20],ecx
 0000256D  67& 64: FF 06      C         inc     dword ptr fs:[_SYSTEM_i_SCRATCH_DWORD1]
	   0BFC
			      C 
			      C       ; Start at the beginning of the _sPRIMATIVE structure for each pass
 00002573  B8 00000008	      C         mov     eax,8
			      C       ; Right now, es:[eax] - far ptr to start of primative's structure, refer to inf\primload.inf for information
			      C         .WHILE (eax < dword ptr es:[0])
 00002578  EB 4B	   *	    jmp    @C0073
 0000257A		   *@C0074:
 0000257A  26: 8A 48 03	      C             mov     cl,byte ptr es:[eax+3]
 0000257E  89 4D F4	      C             mov     dword ptr ss:[ebp-12],ecx
 00002581  8B 75 F0	      C             mov     esi,dword ptr ss:[ebp-16]
			      C             .IF (byte ptr es:[eax+2] == 1 && cl == byte ptr ds:[esi])
 00002584  26: 80 78 02
	   01		   *	    cmp    byte ptr es : [eax + 002h], 001h
 00002589  75 35	   *	    jne    @C0075
 0000258B  3A 0E	   *	    cmp    cl, byte ptr ds : [esi]
 0000258D  75 31	   *	    jne    @C0075
 0000258F  66| 26: 8B 18      C                 mov     bx,word ptr es:[eax]                        ; Get the call gate
 00002593  89 45 F8	      C                 mov     dword ptr ss:[ebp-08],eax
 00002596  83 C0 04	      C                 add     eax,4
 00002599  46		      C                 inc     esi
			      C               ; Right now, es:[eax] - far ptr to _sPRIMATIVE name
			      C               ;            ds:[esi] - far ptr to current native primative name the application is requiring
			      C               ;                 ecx - length
			      C               ;                  bx - call gate for this primative
			      C                 .REPEAT
 0000259A		   *@C0078:
 0000259A  8A 16	      C                     mov     dl,byte ptr ds:[esi]
			      C                     .IF (dl >= 'A' && dl <= 'Z')
 0000259C  80 FA 41	   *	    cmp    dl, 'A'
 0000259F  72 08	   *	    jb     @C0079
 000025A1  80 FA 5A	   *	    cmp    dl, 'Z'
 000025A4  77 03	   *	    ja     @C0079
 000025A6  80 C2 20	      C                         add     dl,020h                             ; force lowercase
			      C                     .ENDIF
			      C                     .IF (dl != byte ptr es:[eax])
 000025A9		   *@C0079:
 000025A9  26: 3A 10	   *	    cmp    dl, byte ptr es : [eax]
 000025AC  74 02	   *	    je     @C007C
			      C                       ; It wasn't a match
 000025AE  EB 0A	      C                         jmp     @F
			      C                     .ENDIF
 000025B0		   *@C007C:
 000025B0  40		      C                     inc     eax
 000025B1  46		      C                     inc     esi
			      C                 .UNTILCXZ
 000025B2  E2 E6	   *	    loop   @C0078
			      C               ; If we're here, then this was a match
 000025B4  66| 89 5F 04	      C                 mov     word ptr ds:[edi+4],bx
 000025B8  EB 1F	      C                 jmp     next_primative
			      C 
 000025BA		      C               @@:
 000025BA  8B 4D F4	      C                 mov     ecx,dword ptr ss:[ebp-12]
 000025BD  8B 45 F8	      C                 mov     eax,dword ptr ss:[ebp-08]
			      C             .ENDIF
 000025C0		   *@C0075:
 000025C0  03 C1	      C             add     eax,ecx
 000025C2  83 C0 04	      C             add     eax,4
			      C         .ENDW
 000025C5		   *@C0073:
 000025C5  67& 26: 3B 06
	   0000		   *	    cmp    eax, dword ptr es : [000h]
 000025CB  72 AD	   *	    jb     @C0074
			      C       ; If we're here, then the item wasn't found
 000025CD  66| C7 47 04	      C         mov     word ptr ds:[edi+4],0ffffh                          ; Set it so it will indicate it "wasn't found"
	   FFFF
 000025D3  67& 64: FF 06      C         inc     dword ptr fs:[_SYSTEM_i_SCRATCH_DWORD2]             ; Increase the number of items not found
	   0BF8
			      C 
 000025D9		      C       next_primative:
 000025D9  8B 4D EC	      C         mov     ecx,dword ptr ss:[ebp-20]
 000025DC  8B 75 F0	      C         mov     esi,dword ptr ss:[ebp-16]
 000025DF  03 F1	      C         add     esi,ecx
 000025E1  46		      C         inc     esi
 000025E2  83 C7 02	      C         add     edi,2
			      C     .ENDW
 000025E5		   *@C0071:
 000025E5  80 3E FF	   *	    cmp    byte ptr ds : [esi], 0FFh
 000025E8  0F 85 FFFFFF77  *	    jne    @C0072
			      C 
			      C 
			      C     .IF (dword ptr fs:[_SYSTEM_i_SCRATCH_DWORD2] != 0)
 000025EE  67& 64: 83 3E
	   0BF8 00	   *	    cmp    dword ptr fs : [_SYSTEM_i_SCRATCH_DWORD2], 000h
 000025F5  74 03	   *	    je     @C0080
 000025F7  F9		      C         stc
			      C     .ELSE
 000025F8  EB 01	   *	    jmp    @C0082
 000025FA		   *@C0080:
 000025FA  F8		      C         clc
			      C     .ENDIF
 000025FB		   *@C0082:
			      C 
 000025FB  C9		      C     leave
 000025FC  0F A1	      C     pop     fs
 000025FE  07		      C     pop     es
 000025FF  61		      C     popad
 00002600  C3		      C     ret
 00002601		      C invUpdate_required_primatives   ENDP
			      C 
			      C 
			      C 
			      C 
 00002601		      C default_interrupt_handler32     PROC
			      C ; This is the default interrupt handler
			      C ; All IDT entries are initially setup to this in init16.asp
			      C ; invSetup_native_primatives updates those that are relevant to
 00002601  50		      C     push    eax
 00002602  B0 20	      C     mov     al,20h
 00002604  E6 20	      C     out     20h,al
 00002606  58		      C     pop     eax
 00002607  CF		      C     iretd
 00002608		      C default_interrupt_handler32     ENDP
			      C 
			      C 
			      C 
			      C 
			      C ;VID_display_radix_in_edx_vga    PROC
			      C ;    pushad
			      C ;    push    ds
			      C ;    sub     esp,16                                                  ; Assume a maximum length of 12 chars (4 extra for boundary)
			      C ;    mov     ebp,esp
			      C ;
			      C ;    call    iString_generate_radix_string
			      C ;    call    VID_display_string_vga
			      C ;
			      C ;    add     esp,16
			      C ;    pop     ds
			      C ;    popad
			      C ;    ret
			      C ;VID_display_radix_in_edx_vga    ENDP
			      C 
			      C 
			      C 
			      C 
 00002608		      C VID_display_radix_in_edx_mono   PROC
 00002608  60		      C     pushad
 00002609  1E		      C     push    ds
 0000260A  83 EC 10	      C     sub     esp,16                                                  ; Assume a maximum length of 12 chars (4 extra for boundry)
 0000260D  8B EC	      C     mov     ebp,esp
			      C 
 0000260F  E8 0000000B	      C     call    iString_generate_radix_string
 00002614  E8 00000039	      C     call    VID_display_string_mono
			      C 
 00002619  83 C4 10	      C     add     esp,16
 0000261C  1F		      C     pop     ds
 0000261D  61		      C     popad
 0000261E  C3		      C     ret
 0000261F		      C VID_display_radix_in_edx_mono   ENDP
			      C 
			      C 
			      C 
			      C 
 0000261F		      C iString_generate_radix_string   PROC
 0000261F  C6 45 0C 00	      C     mov     byte ptr [ebp+12],0                                 ; NULL terminate the string we're building
 00002623  8B F5	      C     mov     esi,ebp
 00002625  83 C6 0B	      C     add     esi,11
 00002628  8B C2	      C     mov     eax,edx
 0000262A  81 E3 0000FFFF     C     and     ebx,0ffffh
 00002630		      C   @@:
 00002630  33 D2	      C     xor     edx,edx
 00002632  F7 F3	      C     div     ebx
			      C     .IF (dl > 9)
 00002634  80 FA 09	   *	    cmp    dl, 009h
 00002637  76 05	   *	    jbe    @C0083
 00002639  80 C2 57	      C         add     dl,'a'-10                                       ; Make it a letter if it's above 9 (10+ cannot be represented in 1 digit)
			      C     .ELSE
 0000263C  EB 03	   *	    jmp    @C0085
 0000263E		   *@C0083:
 0000263E  80 C2 30	      C         add     dl,'0'                                          ; Make it a number
			      C     .ENDIF
 00002641		   *@C0085:
 00002641  36: 88 16	      C     mov     byte ptr ss:[esi],dl
 00002644  4E		      C     dec     esi                                                 ; Decrement (move to next position to store data)
 00002645  3B F5	      C     cmp     esi,ebp
 00002647  74 05	      C     jz      @F
 00002649  83 F8 00	      C     cmp     eax,0
 0000264C  75 E2	      C     jnz     @B
 0000264E		      C   @@:
 0000264E  16		      C     push    ss
 0000264F  1F		      C     pop     ds
 00002650  46		      C     inc     esi                                                 ; Add back for the one we decremented above
			      C   ; Right now, ds:[esi] - pointer to the value to display
 00002651  C3		      C     ret
 00002652		      C iString_generate_radix_string   ENDP
			      C 
			      C 
			      C 
			      C 
			      C ;VID_display_string_vga    PROC
			      C ;; ds:[esi] - far pointer to null-terminated string
			      C ;;      edi - offset into video memory to write
			      C ;    pushad
			      C ;    push    es
			      C ;    push    fs
			      C ;
			      C ;    mov     eax,_sDATA
			      C ;    mov     es,eax
			      C ;    mov     eax,_sVGA
			      C ;    mov     fs,eax
			      C ;    mov     ah,7
			      C ;    .WHILE (byte ptr ds:[esi] != 0)                                 ; Loop until the NULL terminated string is found
			      C ;        lodsb
			      C ;        mov     byte ptr fs:[edi],al                                ; Write character
			      C ;        inc     di
			      C ;        mov     byte ptr fs:[edi],ah                                ; Write color
			      C ;        inc     di
			      C ;    .ENDW
			      C ;
			      C ;    pop     fs
			      C ;    pop     es
			      C ;    popad
			      C ;    ret
			      C ;VID_display_string_vga    ENDP
			      C 
			      C 
			      C 
			      C 
 00002652		      C VID_display_string_mono   PROC
			      C ; ds:[esi] - far pointer to null-terminated string
			      C ;      edi - offset into video memory to write
 00002652  60		      C     pushad
 00002653  06		      C     push    es
 00002654  0F A0	      C     push    fs
			      C 
 00002656  B8 00000048	      C     mov     eax,_sDATA
 0000265B  8E C0	      C     mov     es,eax
 0000265D  B8 00000030	      C     mov     eax,_sMONO
 00002662  8E E0	      C     mov     fs,eax
 00002664  B4 07	      C     mov     ah,7
			      C     .WHILE (byte ptr ds:[esi] != 0)                                 ; Loop until the NULL terminated string is found
 00002666  EB 0B	   *	    jmp    @C0086
 00002668		   *@C0087:
 00002668  AC		      C         lodsb
 00002669  64: 88 07	      C         mov     byte ptr fs:[edi],al                                ; Write character
 0000266C  66| 47	      C         inc     di
 0000266E  64: 88 27	      C         mov     byte ptr fs:[edi],ah                                ; Write color
 00002671  66| 47	      C         inc     di
			      C     .ENDW
 00002673		   *@C0086:
 00002673  80 3E 00	   *	    cmp    byte ptr ds : [esi], 000h
 00002676  75 F0	   *	    jne    @C0087
			      C 
 00002678  0F A1	      C     pop     fs
 0000267A  07		      C     pop     es
 0000267B  61		      C     popad
 0000267C  C3		      C     ret
 0000267D		      C VID_display_string_mono   ENDP
			      C 
			      C 
			      C 
			      C 
			      C ;VID_display_string_ecx_vga      PROC
			      C ;; ds:[esi] - far pointer to null-terminated string
			      C ;;      edi - offset into video memory to write
			      C ;;      ecx - count
			      C ;    pushad
			      C ;    push    es
			      C ;    push    fs
			      C ;
			      C ;    mov     eax,_sDATA
			      C ;    mov     es,eax
			      C ;    mov     eax,_sVGA
			      C ;    mov     fs,eax
			      C ;    mov     ah,7
			      C ;    .REPEAT
			      C ;        lodsb
			      C ;        mov     byte ptr fs:[edi],al                                ; Write character
			      C ;        inc     di
			      C ;        mov     byte ptr fs:[edi],ah                                ; Write color
			      C ;        inc     di
			      C ;    .UNTILCXZ
			      C ;
			      C ;    pop     fs
			      C ;    pop     es
			      C ;    popad
			      C ;    ret
			      C ;VID_display_string_ecx_vga      ENDP
			      C ;
			      C ;
			      C ;
			      C ;
 0000267D		      C VID_display_string_ecx_mono     PROC
			      C ; ds:[esi] - far pointer to null-terminated string
			      C ;      edi - offset into video memory to write
			      C ;      ecx - count
 0000267D  60		      C     pushad
 0000267E  06		      C     push    es
 0000267F  0F A0	      C     push    fs
			      C 
			      C     .IF (ecx != 0)
 00002681  0B C9	   *	    or	ecx, ecx
 00002683  74 1D	   *	    je     @C0089
 00002685  B8 00000048	      C         mov     eax,_sDATA
 0000268A  8E C0	      C         mov     es,eax
 0000268C  B8 00000030	      C         mov     eax,_sMONO
 00002691  8E E0	      C         mov     fs,eax
 00002693  B4 07	      C         mov     ah,7
			      C         .REPEAT
 00002695		   *@C008B:
 00002695  AC		      C             lodsb
 00002696  64: 88 07	      C             mov     byte ptr fs:[edi],al                                ; Write character
 00002699  66| 47	      C             inc     di
 0000269B  64: 88 27	      C             mov     byte ptr fs:[edi],ah                                ; Write color
 0000269E  66| 47	      C             inc     di
			      C         .UNTILCXZ
 000026A0  E2 F3	   *	    loop   @C008B
			      C     .ENDIF
 000026A2		   *@C0089:
			      C 
 000026A2  0F A1	      C     pop     fs
 000026A4  07		      C     pop     es
 000026A5  61		      C     popad
 000026A6  C3		      C     ret
 000026A7		      C VID_display_string_ecx_mono     ENDP
			      C ;
			      C ;
			      C ;
			      C ;
			      C ;
 000026A7		      C VID_display_hex_string_ecx_mono     PROC
			      C ; ds:[esi] - far pointer to null-terminated string
			      C ;     ecx - number of hexidecimal digits to display
			      C ; offset_mono- pointer into the screen where to start writing
 000026A7  60		      C     pushad
 000026A8  0F A8	      C     push    gs
			      C 
			      C     .IF (ecx != 0)
 000026AA  0B C9	   *	    or	ecx, ecx
 000026AC  74 3D	   *	    je     @C008C
 000026AE  B8 00000030	      C         mov     eax,_sMONO
 000026B3  8E E8	      C         mov     gs,eax
 000026B5  B4 07	      C         mov     ah,7
			      C         .REPEAT
 000026B7		   *@C008E:
 000026B7  AC		      C             lodsb
 000026B8  8A D0	      C             mov     dl,al
 000026BA  E8 00000030	      C             call    hex_adjust_al_dl
 000026BF  65: C6 07 20	      C             mov     byte ptr gs:[edi],32                                ; Write a space before hexidecimal values
 000026C3  66| 47	      C             inc     di
 000026C5  65: 88 27	      C             mov     byte ptr gs:[edi],ah                                ; Write color
 000026C8  66| 47	      C             inc     di
 000026CA  65: 88 17	      C             mov     byte ptr gs:[edi],dl                                ; Write left 1/2 of hexidecimal values character
 000026CD  66| 47	      C             inc     di
 000026CF  65: 88 27	      C             mov     byte ptr gs:[edi],ah                                ; Write color
 000026D2  66| 47	      C             inc     di
 000026D4  65: 88 07	      C             mov     byte ptr gs:[edi],al                                ; Write right 1/2 of hexidecimal values character
 000026D7  66| 47	      C             inc     di
 000026D9  65: 88 27	      C             mov     byte ptr gs:[edi],ah                                ; Write color
 000026DC  66| 47	      C             inc     di
 000026DE  65: C6 07 20	      C             mov     byte ptr gs:[edi],32                                ; Write a space after hexidecimal value
 000026E2  66| 47	      C             inc     di
 000026E4  65: 88 27	      C             mov     byte ptr gs:[edi],ah                                ; Write color
 000026E7  66| 47	      C             inc     di
			      C         .UNTILCXZ
 000026E9  E2 CC	   *	    loop   @C008E
			      C     .ENDIF
 000026EB		   *@C008C:
			      C 
 000026EB  0F A9	      C     pop     gs
 000026ED  61		      C     popad
 000026EE  C3		      C     ret
 000026EF		      C VID_display_hex_string_ecx_mono     ENDP
			      C 
			      C 
			      C 
			      C 
 000026EF		      C hex_adjust_al_dl    PROC
 000026EF  C0 EA 04	      C     shr     dl,4
			      C     .IF (dl <= 9)
 000026F2  80 FA 09	   *	    cmp    dl, 009h
 000026F5  77 05	   *	    ja     @C008F
 000026F7  80 C2 30	      C         add     dl,'0'
			      C     .ELSE
 000026FA  EB 03	   *	    jmp    @C0091
 000026FC		   *@C008F:
 000026FC  80 C2 57	      C         add     dl,'a'-10
			      C     .ENDIF
 000026FF		   *@C0091:
 000026FF  24 0F	      C     and     al,0fh
			      C     .IF (al <= 9)
 00002701  3C 09	   *	    cmp    al, 009h
 00002703  77 04	   *	    ja     @C0092
 00002705  04 30	      C         add     al,'0'
			      C     .ELSE
 00002707  EB 02	   *	    jmp    @C0094
 00002709		   *@C0092:
 00002709  04 57	      C         add     al,'a'-10
			      C     .ENDIF
 0000270B		   *@C0094:
 0000270B  C3		      C     ret
 0000270C		      C hex_adjust_al_dl    ENDP
			      C 
			      C 
			      C 
			      C 
 0000270C		      C init_failed     PROC    NEAR
			      C ; This routine returns to real mode and goes to a section of code that indicates a failed to boot message.
			      C ; It is called when Exodus is trying to boot up but received unexpected information from a device driver before VGA/keyboard
			      C ; support had been installed.
			      C ;
 0000270C  B8 00000038	      C     mov     eax,_sVGA
 00002711  8E E0	      C     mov     fs,eax
 00002713  B8 00000030	      C     mov     eax,_sMONO
 00002718  8E E8	      C     mov     gs,eax
 0000271A  BF 000003C0	      C     mov     edi,6*80*2
			      C 
 0000271F  BE 00001D14 R      C     mov     esi,offset failed
 00002724  B4 07	      C     mov     ah,7
			      C     .WHILE (esi < offset failed_end)
 00002726  EB 5B	   *	    jmp    @C0095
 00002728		   *@C0096:
 00002728  2E: 8A 06	      C         mov     al,byte ptr cs:[esi]
 0000272B  46		      C         inc     esi
			      C         .IF (al == 13)
 0000272C  3C 0D	   *	    cmp    al, 00Dh
 0000272E  75 08	   *	    jne    @C0097
			      C           ; It's a carriage return
 00002730  81 C7 000000A0     C             add     edi,80*2
			      C         .ELSEIF (al == 10)
 00002736  EB 4B	   *	    jmp    @C0099
 00002738		   *@C0097:
 00002738  3C 0A	   *	    cmp    al, 00Ah
 0000273A  75 13	   *	    jne    @C009A
			      C           ; It's a line feed
 0000273C  50		      C             push    eax
 0000273D  33 D2	      C             xor     edx,edx
 0000273F  8B C7	      C             mov     eax,edi
 00002741  BB 000000A0	      C             mov     ebx,80*2
 00002746  F7 F3	      C             div     ebx
 00002748  F7 E3	      C             mul     ebx
 0000274A  8B F8	      C             mov     edi,eax
 0000274C  58		      C             pop     eax
			      C         .ELSEIF (al == 'ô')
 0000274D  EB 34	   *	    jmp    @C009C
 0000274F		   *@C009A:
 0000274F  3C F4	   *	    cmp    al, 'ô'
 00002751  75 04	   *	    jne    @C009D
 00002753  B4 70	      C             mov     ah,112
			      C         .ELSEIF (al == 'õ')
 00002755  EB 2C	   *	    jmp    @C009F
 00002757		   *@C009D:
 00002757  3C F5	   *	    cmp    al, 'õ'
 00002759  75 04	   *	    jne    @C00A0
 0000275B  B4 07	      C             mov     ah,7
			      C         .ELSEIF (al == 'Ý')
 0000275D  EB 24	   *	    jmp    @C00A2
 0000275F		   *@C00A0:
 0000275F  3C DD	   *	    cmp    al, 'Ý'
 00002761  75 04	   *	    jne    @C00A3
 00002763  B4 0F	      C             mov     ah,15
			      C         .ELSEIF (al == 'Þ')
 00002765  EB 1C	   *	    jmp    @C00A5
 00002767		   *@C00A3:
 00002767  3C DE	   *	    cmp    al, 'Þ'
 00002769  75 04	   *	    jne    @C00A6
 0000276B  B4 07	      C             mov     ah,7
			      C         .ELSEIF (al == '¨')
 0000276D  EB 14	   *	    jmp    @C00A8
 0000276F		   *@C00A6:
 0000276F  3C A8	   *	    cmp    al, '¨'
 00002771  75 05	   *	    jne    @C00A9
 00002773  80 C4 80	      C             add     ah,128
			      C         .ELSE
 00002776  EB 0B	   *	    jmp    @C00AB
 00002778		   *@C00A9:
 00002778  66| 64: 89 07      C             mov     word ptr fs:[edi],ax
 0000277C  66| 65: 89 07      C             mov     word ptr gs:[edi],ax
 00002780  83 C7 02	      C             add     edi,2
			      C         .ENDIF
			      C     .ENDW
 00002783		   *@C00AB:
 00002783		   *@C00A8:
 00002783		   *@C00A5:
 00002783		   *@C00A2:
 00002783		   *@C009F:
 00002783		   *@C009C:
 00002783		   *@C0099:
 00002783		   *@C0095:
 00002783  81 FE 00001EBD R *	    cmp    esi, offset failed_end
 00002789  72 9D	   *	    jb     @C0096
			      C 
 0000278B		      C   @@:
 0000278B  F4		      C     hlt
 0000278C  EB FD	      C     jmp     @B
 0000278E		      C init_failed     ENDP
			      C 
				    INCLUDE ini.asp
			      C ; ini.asp
			      C ;
			      C ; Exodus parse EXODUS.INI routines
			      C ;
			      C ;  Functions:
			      C ;     Ã invParse_Exodus_ini                             ; Locate the Exodus.INI table
			      C ;     Ã invParse_Exodus_ini_build_structure             ; Physically build the bootup structure
			      C ;     À invDetermine_Exodus_ini_ownership               ; Calls the requestor('ini ') functions of all native primatives to
			      C ;                                                       ;  find out who the owner of each item is
			      C ;
			      C 
			      C 
			      C 
 0000278E		      C invFind_Exodus_ini      PROC    NEAR
			      C ; This routine is used to parse the EXODUS.INI
			      C ;
			      C ; Upon entry:   Nothing
			      C ;
			      C ; Upon exit:    The EXODUS.INI text file has been converted
			      C ;
 0000278E  C8 0054 00	      C     enter   84,0
			      C   ;------------
			      C   ; These two variables are defined in this procedure
			      C   ; [ebp-04] - dword, length of exodus.ini
			      C   ; [ebp-08] - dword, linear offset in memory to start of exodus.ini
			      C   ; [ebp-12] - dword, count (number of exodus.ini's found)
			      C   ;------------
			      C   ; The rest of this local variable space is defined and used in invParse_Exodus_ini()
			      C   ; Please look there for their definitions
			      C   ;
 00002792  60		      C     pushad
 00002793  1E		      C     push    ds
 00002794  06		      C     push    es
 00002795  0F A0	      C     push    fs
 00002797  0F A8	      C     push    gs
			      C 
 00002799  C7 45 FC	      C     mov     dword ptr ss:[ebp-04],0ffffffffh                        ; length
	   FFFFFFFF
 000027A0  C7 45 F8	      C     mov     dword ptr ss:[ebp-08],0ffffffffh                        ; linear offset
	   FFFFFFFF
 000027A7  C7 45 F4	      C     mov     dword ptr ss:[ebp-12],0                                 ; count
	   00000000
			      C 
 000027AE  66| B8 0040	      C     mov     ax,_sALL_MEM
 000027B2  8E D8	      C     mov     ds,eax
 000027B4  67& 2E: 8B 3E      C     mov     edi,cs:boot_parameter_block
	   0A91 R
 000027BA  47		      C     inc     edi                                                     ; Skip past the "drive booted from" byte
			      C   ; Right now, ds:[edi] - far ptr to the boot parameter block
			      C     .WHILE (byte ptr ds:[edi] != 0ffh)
 000027BB  EB 1A	   *	    jmp    @C00AD
 000027BD		   *@C00AE:
 000027BD  8A 47 14	      C         mov     al,byte ptr ds:[edi+_BOOT_PB_entry_type]
 000027C0  24 0F	      C         and     al,1111b
			      C         .IF (al == 0001b)
 000027C2  3C 01	   *	    cmp    al, 001h
 000027C4  75 0E	   *	    jne    @C00AF
			      C           ; It's EXODUS.INI (refer to INF\FILE_SYS.INF for information on these bits)
 000027C6  8B 17	      C             mov     edx,dword ptr ds:[edi+_BOOT_PB_size]
 000027C8  89 55 FC	      C             mov     dword ptr ss:[ebp-04],edx
 000027CB  8B 57 16	      C             mov     edx,dword ptr ds:[edi+_BOOT_PB_linear_offset]
 000027CE  89 55 F8	      C             mov     dword ptr ss:[ebp-08],edx
 000027D1  FF 45 F4	      C             inc     dword ptr ss:[ebp-12]
			      C         .ENDIF
			      C 
 000027D4		   *@C00AF:
 000027D4  83 C7 20	      C         add     edi,_BOOT_PB_structure_size
			      C     .ENDW
 000027D7		   *@C00AD:
 000027D7  80 3F FF	   *	    cmp    byte ptr ds : [edi], 0FFh
 000027DA  75 E1	   *	    jne    @C00AE
			      C     .IF (dword ptr ss:[ebp-12] == 1)
 000027DC  83 7D F4 01	   *	    cmp    dword ptr ss : [ebp - 00Ch], 001h
 000027E0  75 12	   *	    jne    @C00B2
			      C       ; Only one EXODUS.INI was found, so we're in business
 000027E2  E8 00000072	      C         call    invParse_Exodus_ini
			      C         .IF (carry?)
 000027E7  73 67	   *	    jae    @C00B4
			      C           ; Some error occurred during the parse
 000027E9  C7 45 F4	      C             mov     dword ptr ss:[ebp-12],0ffffffffh
	   FFFFFFFF
 000027F0  EB 02	      C             jmp     @F
			      C         .ENDIF
			      C     .ELSE
 000027F2  EB 5C	   *	    jmp    @C00B6
 000027F4		   *@C00B2:
			      C       ; More than one EXODUS.INI was found, or there were errors from processing invParse_Exodus_ini() above
 000027F4		      C       @@:
			      C       ;; Set the VGA video mode to 80x25 text and the color to red
 000027F4  66| B8 0048	      C         mov     ax,_sDATA
 000027F8  8E D8	      C         mov     ds,eax
 000027FA  E8 FFFFDCCF	      C         call    invSet_80x25_text_mode
 000027FF  B0 0C	      C         mov     al,12
 00002801  2E: FF 1D	      C         call    fword ptr cs:_VID_set_attribute_vga
	   00001AE8 R
 00002808  2E: FF 1D	      C         call    fword ptr cs:_VID_move_to_next_line_vga
	   00001AE6 R
			      C         .IF (dword ptr ss:[ebp-12] == 0ffffffffh)
 0000280F  83 7D F4 FF	   *	    cmp    dword ptr ss : [ebp - 00Ch], 0FFFFFFFFh
 00002813  75 07	   *	    jne    @C00B7
			      C           ; Error occurred during processing
 00002815  BE 00000585 R      C             mov     esi,offset error_loading_exodus_ini_1
			      C         .ELSEIF (dword ptr ss:[ebp-12] == 0)
 0000281A  EB 12	   *	    jmp    @C00B9
 0000281C		   *@C00B7:
 0000281C  83 7D F4 00	   *	    cmp    dword ptr ss : [ebp - 00Ch], 000h
 00002820  75 07	   *	    jne    @C00BA
			      C           ; No EXODUS.INI was found
 00002822  BE 000005BB R      C             mov     esi,offset error_loading_exodus_ini_2
			      C         .ELSE
 00002827  EB 05	   *	    jmp    @C00BC
 00002829		   *@C00BA:
			      C           ; Multiple EXODUS.INI's were found
 00002829  BE 000005F9 R      C             mov     esi,offset error_loading_exodus_ini_3
			      C         .ENDIF
 0000282E		   *@C00BC:
 0000282E		   *@C00B9:
 0000282E  2E: FF 1D	      C         call    fword ptr cs:_VID_display_string_nr_vga
	   00001AC8 R
			      C 
			      C       ; These messages are in BOOTUP\DATA32.ASP
 00002835  BE 0000063D R      C         mov     esi,offset error_loading_exodus_ini_4
 0000283A  2E: FF 1D	      C         call    fword ptr cs:_VID_display_string_nr_vga
	   00001AC8 R
			      C 
 00002841  BE 0000067A R      C         mov     esi,offset system_halted
 00002846  2E: FF 1D	      C         call    fword ptr cs:_VID_display_string_nr_vga
	   00001AC8 R
 0000284D		      C       @@:
 0000284D  F4		      C         hlt
 0000284E  EB FD	      C         jmp @B
			      C     .ENDIF
 00002850		   *@C00B6:
 00002850		   *@C00B4:
			      C 
			      C 
 00002850		      C   finished:
 00002850  0F A9	      C     pop     gs
 00002852  0F A1	      C     pop     fs
 00002854  07		      C     pop     es
 00002855  1F		      C     pop     ds
 00002856  61		      C     popad
 00002857  C9		      C     leave
 00002858  C3		      C     ret
 00002859		      C invFind_Exodus_ini      ENDP
			      C 
			      C 
			      C 
			      C 
			      C 
 00002859		      C invParse_Exodus_ini     PROC
			      C ; This routine is used to parse the Exodus.INI file and build an internal structure that's suitable for parsing.
			      C ;
			      C ; Upon entry:   [ebp-04] - length of file
			      C ;               [ebp-08] - offset to start of EXODUS.INI
			      C ;                     ds - _sALL_MEM (used for Exodus.ini and the output structure)
			      C ;               * Note also that this algorithm uses the stack frame/local variables created in invFind_Exodus_ini
			      C ;               * Refer to that algorithm for local variables
			      C ;
			      C ; Upon exit:    The structure is updated
			      C ;               edx - !zero if any errors encountered
			      C ;
			      C ;
			      C   ; The variables above are defined in the invFind_Exodus_ini() algorithm above.
			      C   ; They already exist when this procedure gets control.
			      C   ; [ebp-04] - dword, length of exodus.ini
			      C   ; [ebp-08] - dword, linear offset in memory to start of exodus.ini
			      C   ; [ebp-12] - Note, this value is reused as its significance is no longer significant. :)
			      C   ;----------
			      C   ; These slots are all defined here and are used here and in invParse_Exodus_ini_store_error()
			      C   ; [ebp-12] - dword, line number of exodus.ini
			      C   ; [ebp-16] - dword, are we in a bracket grouping?  0-no, 1-yes
			      C   ; [ebp-20] - dword, are we in a paren grouping?  0-no, 1-yes
			      C   ; [ebp-24] - dword, source line offset (start of)
			      C   ; [ebp-28] - dword, store line to error area?  0-no, 1-yes
			      C   ; [ebp-32] - dword, header offset
			      C   ; [ebp-36] - dword, current bracket group structure item
			      C   ; [ebp-40] - dword, currently processing a bracket group? 0-no, 1-yes
			      C   ; [ebp-44] - dword, currently processing a paren cask? 0-no, 1-yes
			      C   ; [ebp-48] - dword, total # of paren casks
			      C   ; [ebp-52] - dword, count of bytes left in exodus.ini
			      C   ; [ebp-56] - dword, souce line offset (first non-whitespace)
			      C   ; [ebp-60] - dword, current paren cask structure
			      C   ; [ebp-64] - dword, number of chars to backup (due to ¯'s being found)
			      C   ; [ebp-68] - dword, current paren cask structure (if more than one per line)
			      C   ; [ebp-70] - word,  --Nuserved
			      C   ; [ebp-80] - tbyte, miscellaneous BCD values used to report error line numbers, etc
			      C   ; [ebp-84] - dword, last data item
 00002859  CC		      C int 3
 0000285A  C3		      C     ret
 0000285B  C7 45 F4	      C     mov     dword ptr ss:[ebp-12],1                                 ; starting line number (base-1)
	   00000001
 00002862  C7 45 F0	      C     mov     dword ptr ss:[ebp-16],0                                 ; bracket grouping?  0-no
	   00000000
 00002869  C7 45 EC	      C     mov     dword ptr ss:[ebp-20],0                                 ; paren grouping?  0-no
	   00000000
			      C 
			      C   ; Load the EXODUS.INI variables
 00002870  8B 4D FC	      C     mov     ecx,dword ptr ss:[ebp-04]
 00002873  8B 75 F8	      C     mov     esi,dword ptr ss:[ebp-08]
 00002876  89 4D CC	      C     mov     dword ptr ss:[ebp-52],ecx
			      C 
 00002879  BA 00000190	      C     mov     edx,_sEXODUS_INI
 0000287E  8E C2	      C     mov     es,edx
 00002880  BA 00000198	      C     mov     edx,_sEXODUS_INI_ERRORS
 00002885  8E E2	      C     mov     fs,edx
 00002887  33 FF	      C     xor     edi,edi
 00002889  33 D2	      C     xor     edx,edx
			      C   ; Right now,   ecx - count
			      C   ;         ds:[esi] - far ptr to start of exodus.ini
			      C   ;         es:[edi] - where we'll store our converted structure
			      C   ;         fs:[edx] - where we'll store error text
			      C 
			      C   ; Initialize our EXODUS.INI structure
 0000288B  26: C7 07	      C     mov     dword ptr es:[edi+_EXODUS_INI_FIRST_BRACKET],0ffffffffh
	   FFFFFFFF
 00002892  26: C7 47 04	      C     mov     dword ptr es:[edi+_EXODUS_INI_TOTAL_BYTES],0
	   00000000
 0000289A  26: C7 47 08	      C     mov     dword ptr es:[edi+_EXODUS_INI_TOTAL_BRACKET_GROUPS],0
	   00000000
 000028A2  26: C7 47 0C	      C     mov     dword ptr es:[edi+_EXODUS_INI_TOTAL_PAREN_CASKS],0
	   00000000
			      C 
			      C   ; Initalize our starting variables
 000028AA  89 7D E0	      C     mov     dword ptr ss:[ebp-32],edi                               ; Start of header
 000028AD  83 C7 10	      C     add     edi,_EXODUS_INI_HEADER_LENGTH
 000028B0  89 7D DC	      C     mov     dword ptr ss:[ebp-36],edi                               ; Start of data
			      C 
 000028B3  C7 45 D8	      C     mov     dword ptr ss:[ebp-40],0                                 ; No bracket group
	   00000000
 000028BA  C7 45 D4	      C     mov     dword ptr ss:[ebp-44],0                                 ; No paren cask
	   00000000
			      C 
			      C   ; Right now, es:[edi] - ready for starting structure
			      C     .WHILE (dword ptr ss:[ebp-52] > 0)
 000028C1  E9 00000309	   *	    jmp    @C00BD
 000028C6		   *@C00BE:
			      C       ; Skip passed any leading spaces or tabs
 000028C6  C7 45 E4	      C         mov     dword ptr ss:[ebp-28],0                             ; store line to error area?  0-no
	   00000000
 000028CD  89 75 E8	      C         mov     dword ptr ss:[ebp-24],esi                           ; start of line
			      C         .WHILE (byte ptr ds:[esi] == 32 || byte ptr ds:[esi] == 9 && dword ptr ss:[ebp-52] > 0)
 000028D0  EB 04	   *	    jmp    @C00BF
 000028D2		   *@C00C0:
 000028D2  46		      C             inc     esi
 000028D3  FF 4D CC	      C             dec     dword ptr ss:[ebp-52]
			      C         .ENDW
 000028D6		   *@C00BF:
 000028D6  80 3E 20	   *	    cmp    byte ptr ds : [esi], 020h
 000028D9  74 F7	   *	    je     @C00C0
 000028DB  80 3E 09	   *	    cmp    byte ptr ds : [esi], 009h
 000028DE  75 06	   *	    jne    @C00C1
 000028E0  83 7D CC 00	   *	    cmp    dword ptr ss : [ebp - 034h], 000h
 000028E4  77 EC	   *	    ja     @C00C0
 000028E6		   *@C00C1:
 000028E6  83 7D CC 00	      C         cmp     dword ptr ss:[ebp-52],0
 000028EA  0F 84 000002E9     C         jz      finished
			      C 
			      C       ; Right now we're passed the white spaces
 000028F0  8B 06	      C         mov     eax,dword ptr ds:[esi]
			      C         .IF (al == ';' || ax == 0d0ah || ax == 0a0dh)
 000028F2  3C 3B	   *	    cmp    al, ';'
 000028F4  74 0C	   *	    je     @C00C5
 000028F6  66| 3D 0D0A	   *	    cmp    ax, 00D0Ah
 000028FA  74 06	   *	    je     @C00C5
 000028FC  66| 3D 0A0D	   *	    cmp    ax, 00A0Dh
 00002900  75 05	   *	    jne    @C00C4
 00002902		   *@C00C5:
			      C           ; This is a comment line, we skip it
 00002902  E9 0000026C	      C             jmp     next_line
			      C         .ENDIF
			      C 
			      C       ; Store first non-whitespace offset
 00002907		   *@C00C4:
 00002907  89 75 C8	      C         mov     dword ptr ss:[ebp-56],esi
			      C 
			      C       ; Right now we're at the start of something
			      C         .IF (al == '[')
 0000290A  3C 5B	   *	    cmp    al, '['
 0000290C  0F 85 000000D7  *	    jne    @C00C8
			      C           ; It's the start of a bracket grouping
			      C             .IF (dword ptr ss:[ebp-40] != 0)
 00002912  83 7D D8 00	   *	    cmp    dword ptr ss : [ebp - 028h], 000h
 00002916  74 08	   *	    je     @C00CA
			      C               ; We're already processing a bracket group, we have to close this one out
 00002918  8B 5D DC	      C                 mov     ebx,dword ptr ss:[ebp-36]
			      C               ; Right now, es:[ebx] - far ptr to previous bracket group structure
 0000291B  26: 89 3B	      C                 mov     dword ptr es:[ebx+_EXODUS_BRACKET_NEXT],edi
			      C             .ELSE
 0000291E  EB 0F	   *	    jmp    @C00CC
 00002920		   *@C00CA:
			      C               ; We're starting anew
			      C               ; Update header (if necessary)
 00002920  8B 5D E0	      C                  mov     ebx,dword ptr ss:[ebp-32]
			      C                 .IF (dword ptr es:[ebx+_EXODUS_INI_FIRST_BRACKET] == 0ffffffffh)
 00002923  26: 83 3B FF	   *	    cmp    dword ptr es : [ebx + _EXODUS_INI_FIRST_BRACKET], 0FFFFFFFFh
 00002927  75 06	   *	    jne    @C00CD
 00002929  8B 45 DC	      C                     mov     eax,dword ptr ss:[ebp-36]
 0000292C  26: 89 03	      C                     mov     dword ptr es:[ebx+_EXODUS_INI_FIRST_BRACKET],eax
			      C                 .ENDIF
			      C             .ENDIF
 0000292F		   *@C00CD:
			      C           ; Get the name into eax
 0000292F		   *@C00CC:
 0000292F  33 C0	      C             xor     eax,eax
 00002931  33 C9	      C             xor     ecx,ecx
 00002933  46		      C             inc     esi
 00002934  FF 4D CC	      C             dec     dword ptr ss:[ebp-52]
			      C             .WHILE (dword ptr ss:[ebp-52] > 0 && ecx < 4 && byte ptr ds:[esi] != ']')
 00002937  EB 0A	   *	    jmp    @C00CF
 00002939		   *@C00D0:
 00002939  C1 E0 08	      C                 shl     eax,8
 0000293C  8A 06	      C                 mov     al,byte ptr ds:[esi]
 0000293E  46		      C                 inc     esi
 0000293F  FF 4D CC	      C                 dec     dword ptr ss:[ebp-52]
 00002942  41		      C                 inc     ecx
			      C             .ENDW
 00002943		   *@C00CF:
 00002943  83 7D CC 00	   *	    cmp    dword ptr ss : [ebp - 034h], 000h
 00002947  76 0A	   *	    jbe    @C00D1
 00002949  83 F9 04	   *	    cmp    ecx, 004h
 0000294C  73 05	   *	    jae    @C00D1
 0000294E  80 3E 5D	   *	    cmp    byte ptr ds : [esi], ']'
 00002951  75 E6	   *	    jne    @C00D0
			      C             .IF (ecx == 4)
 00002953		   *@C00D1:
 00002953  83 F9 04	   *	    cmp    ecx, 004h
 00002956  75 16	   *	    jne    @C00D4
			      C               ; The bracket group's name is too long
 00002958  BB 00000707 R      C                 mov     ebx,offset parse_bracket_group_name_too_long
 0000295D  E8 00000278	      C                 call    invParse_Exodus_ini_store_error
 00002962  C7 45 E4	      C                 mov     dword ptr ss:[ebp-28],1
	   00000001
 00002969  E9 00000205	      C                 jmp     next_line
			      C             .ENDIF
			      C             .IF (byte ptr ds:[esi] != ']')
 0000296E		   *@C00D4:
 0000296E  80 3E 5D	   *	    cmp    byte ptr ds : [esi], ']'
 00002971  74 16	   *	    je     @C00D6
			      C               ; We hit the end of file before we loaded everything
 00002973  BB 000006F0 R      C                 mov     ebx,offset parse_unexpected_end_of_file
 00002978  E8 0000025D	      C                 call    invParse_Exodus_ini_store_error
 0000297D  C7 45 E4	      C                 mov     dword ptr ss:[ebp-28],1
	   00000001
 00002984  E9 000001EA	      C                 jmp     next_line
			      C             .ENDIF
			      C 
			      C           ; Everything is good
			      C           ; Pad any names less than 4 characters with spaces
			      C             .WHILE (ecx < 4)
 00002989		   *@C00D6:
 00002989  EB 06	   *	    jmp    @C00D8
 0000298B		   *@C00D9:
 0000298B  C1 E0 08	      C                 shl     eax,8
 0000298E  B0 20	      C                 mov     al,32
 00002990  41		      C                 inc     ecx
			      C             .ENDW
 00002991		   *@C00D8:
 00002991  83 F9 04	   *	    cmp    ecx, 004h
 00002994  72 F5	   *	    jb     @C00D9
			      C 
			      C           ; Right now, eax contains the name to use
			      C           ; Initialize this item's structure
 00002996  26: C7 07	      C             mov     dword ptr es:[edi+_EXODUS_BRACKET_NEXT],0ffffffffh
	   FFFFFFFF
 0000299D  26: C7 47 04	      C             mov     dword ptr es:[edi+_EXODUS_BRACKET_PAREN_CASKS],0ffffffffh
	   FFFFFFFF
 000029A5  26: C7 47 08	      C             mov     dword ptr es:[edi+_EXODUS_BRACKET_TOTAL_PARENS],0
	   00000000
 000029AD  26: 89 47 0C	      C             mov     dword ptr es:[edi+_EXODUS_BRACKET_NAME],eax
 000029B1  26: C7 47 10	      C             mov     dword ptr es:[edi+_EXODUS_BRACKET_HANDLE],0ffffffffh
	   FFFFFFFF
 000029B9  66| 26: C7 47      C             mov     word ptr es:[edi+_EXODUS_BRACKET_REQUESTOR],0ffffh
	   14 FFFF
 000029C0  26: C7 47 16	      C             mov     dword ptr es:[edi+_EXODUS_BRACKET_REQUESTOR_FUNC],0ffffffffh
	   FFFFFFFF
 000029C8  26: C7 47 1A	      C             mov     dword ptr es:[edi+_EXODUS_BRACKET_SCRATCH_AREA],0ffffffffh
	   FFFFFFFF
			      C 
			      C           ; Raise/lower the flags
 000029D0  C7 45 D8	      C             mov     dword ptr ss:[ebp-40],1                     ; Bracket group flag
	   00000001
 000029D7  C7 45 D4	      C             mov     dword ptr ss:[ebp-44],0                     ; Paren cask flag
	   00000000
			      C 
			      C           ; Store the current bracket group pointer
 000029DE  89 7D DC	      C             mov     dword ptr ss:[ebp-36],edi
			      C 
			      C           ; Move past this structure (for future data)
 000029E1  83 C7 1E	      C             add     edi,_EXODUS_BRACKET_LENGTH
			      C 
			      C         .ELSEIF (al == '(')
 000029E4  E9 0000018A	   *	    jmp    @C00DB
 000029E9		   *@C00C8:
 000029E9  3C 28	   *	    cmp    al, '('
 000029EB  0F 85 00000171  *	    jne    @C00DC
			      C           ; It's the start of a paren cask
 000029F1  CC		      C int 3
			      C             .IF (dword ptr ss:[ebp-44] != 0)
 000029F2  83 7D D4 00	   *	    cmp    dword ptr ss : [ebp - 02Ch], 000h
 000029F6  74 08	   *	    je     @C00DE
			      C               ; We're already processing a cask, we have to close this one out
 000029F8  8B 5D C4	      C                 mov     ebx,dword ptr ss:[ebp-60]
			      C               ; Right now, es:[ebx] - far ptr to previous bracket group structure
 000029FB  26: 89 3B	      C                 mov     dword ptr es:[ebx+_EXODUS_PAREN_NEXT],edi
			      C             .ELSE
 000029FE  EB 07	   *	    jmp    @C00E0
 00002A00		   *@C00DE:
			      C               ; We're starting anew
			      C               ; Update bracket group item (if necessary)
 00002A00  8B 5D DC	      C                 mov     ebx,dword ptr ss:[ebp-36]
 00002A03  26: 89 43 04	      C                 mov     dword ptr es:[ebx+_EXODUS_BRACKET_PAREN_CASKS],eax
			      C             .ENDIF
			      C 
			      C           ; Lower flag for more than one cask per line
 00002A07		   *@C00E0:
 00002A07  C7 45 BC	      C             mov     dword ptr ss:[ebp-68],0ffffffffh
	   FFFFFFFF
			      C 
			      C           ; Initialize this item's structure
 00002A0E		      C           do_next_cask:
 00002A0E  26: C7 07	      C             mov     dword ptr es:[edi+_EXODUS_PAREN_NEXT],0ffffffffh
	   FFFFFFFF
 00002A15  26: C7 47 04	      C             mov     dword ptr es:[edi+_EXODUS_PAREN_NEXT_SAME_LINE],0ffffffffh
	   FFFFFFFF
 00002A1D  26: C7 47 08	      C             mov     dword ptr es:[edi+_EXODUS_PAREN_DATA_ITEMS],0ffffffffh
	   FFFFFFFF
 00002A25  26: C7 47 0C	      C             mov     dword ptr es:[edi+_EXODUS_PAREN_TOTAL_DATA_ITEMS],0
	   00000000
 00002A2D  26: 89 77 10	      C             mov     dword ptr es:[edi+_EXODUS_PAREN_SOURCE_LINE],esi
 00002A31  26: C7 47 14	      C             mov     dword ptr es:[edi+_EXODUS_PAREN_SOURCE_LINE_LENGTH],0
	   00000000
 00002A39  26: C7 47 18	      C             mov     dword ptr es:[edi+_EXODUS_PAREN_HANDLE],0ffffffffh
	   FFFFFFFF
 00002A41  66| 26: C7 47      C             mov     word ptr es:[edi+_EXODUS_PAREN_REQUESTOR],0ffffh
	   1A FFFF
 00002A48  26: C7 47 1E	      C             mov     dword ptr es:[edi+_EXODUS_PAREN_REQUESTOR_FUNC],0ffffffffh
	   FFFFFFFF
 00002A50  26: C7 47 22	      C             mov     dword ptr es:[edi+_EXODUS_PAREN_SCRATCH_AREA],0ffffffffh
	   FFFFFFFF
			      C 
			      C           ; Raise/lower the flags
 00002A58  C7 45 D4	      C             mov     dword ptr ss:[ebp-44],1                         ; Raise the "processing paren cask" flag
	   00000001
 00002A5F  C7 45 C0	      C             mov     dword ptr ss:[ebp-64],0                         ; Back off for ¯ chars
	   00000000
			      C 
			      C           ; Copy current structure pointer to ebx
 00002A66  8B DF	      C             mov     ebx,edi
			      C           ; And move to next structure pointer in edi
 00002A68  83 C7 26	      C             add     edi,_EXODUS_PAREN_LENGTH
			      C 
			      C           ; Now, process the cask to load all of its data items
			      C           ; Right now, ebx - used as the pointer to the current structure
 00002A6B  46		      C             inc     esi
 00002A6C  FF 4D CC	      C             dec     dword ptr ss:[ebp-52]
 00002A6F  26: FF 43 14	      C             inc     dword ptr es:[ebx+_EXODUS_PAREN_SOURCE_LINE_LENGTH]
			      C 
			      C           ; Create the data item structure
 00002A73  C7 45 AC	      C             mov     dword ptr ss:[ebp-84],0ffffffffh                ; Lower the "last data item" flag
	   FFFFFFFF
 00002A7A		      C           do_next_data_item:
 00002A7A  26: C7 07	      C             mov     dword ptr es:[edi+_EXODUS_DATA_NEXT],0ffffffffh
	   FFFFFFFF
 00002A81  26: 89 77 04	      C             mov     dword ptr es:[edi+_EXODUS_DATA_DATA_ITEM_SOURCE],esi
 00002A85  26: C7 47 08	      C             mov     dword ptr es:[edi+_EXODUS_DATA_DATA_ITEM_LENGTH],0
	   00000000
			      C             .WHILE (byte ptr ds:[esi] != ')' && dword ptr ss:[ebp-52] > 0 && word ptr ds:[esi] != 0d0ah && word ptr ds:[esi] != 0a0dh)
 00002A8D  EB 4A	   *	    jmp    @C00E1
 00002A8F		   *@C00E2:
			      C                 .IF (byte ptr ds:[esi] == '¯')
 00002A8F  80 3E AF	   *	    cmp    byte ptr ds : [esi], '¯'
 00002A92  75 05	   *	    jne    @C00E3
			      C                   ; We skip past this character and assume that the next one is the real one
			      C                   ; This character means "whatever is next is to be used literally", thereby giving a way for () and | chars to
			      C                   ; be used as data within a cask (also, if the ¯ character needs to appear it has to be represented by ¯¯)
 00002A94  FF 45 C0	      C                     inc     dword ptr ss:[ebp-64]
			      C                 .ELSE
 00002A97  EB 32	   *	    jmp    @C00E5
 00002A99		   *@C00E3:
			      C                     .IF (byte ptr ds:[esi] == '|' || byte ptr ds:[esi] == ')')
 00002A99  80 3E 7C	   *	    cmp    byte ptr ds : [esi], '|'
 00002A9C  74 05	   *	    je     @C00E7
 00002A9E  80 3E 29	   *	    cmp    byte ptr ds : [esi], ')'
 00002AA1  75 28	   *	    jne    @C00E6
 00002AA3		   *@C00E7:
			      C                       ; This is a data item separator or a cask closer
 00002AA3  8B D6	      C                         mov     edx,esi
 00002AA5  26: 2B 57 04	      C                         sub     edx,dword ptr es:[edi+_EXODUS_DATA_DATA_ITEM_SOURCE]
 00002AA9  26: 89 57 08	      C                         mov     dword ptr es:[edi+_EXODUS_DATA_DATA_ITEM_LENGTH],edx
			      C                         .IF (dword ptr ss:[ebp-84] == 0ffffffffh)
 00002AAD  83 7D AC FF	   *	    cmp    dword ptr ss : [ebp - 054h], 0FFFFFFFFh
 00002AB1  75 09	   *	    jne    @C00E9
			      C                           ; This is the first data item
 00002AB3  89 7D AC	      C                             mov     dword ptr ss:[ebp-84],edi
 00002AB6  26: 89 7B 08	      C                             mov     dword ptr es:[ebx+_EXODUS_PAREN_DATA_ITEMS],edi
			      C                         .ELSE
 00002ABA  EB 06	   *	    jmp    @C00EB
 00002ABC		   *@C00E9:
 00002ABC  8B 55 AC	      C                             mov     edx,dword ptr ss:[ebp-84]
 00002ABF  26: 89 3A	      C                             mov     dword ptr es:[edx+_EXODUS_DATA_NEXT],edi
			      C                         .ENDIF
 00002AC2		   *@C00EB:
 00002AC2  26: FF 43 0C	      C                         inc     dword ptr es:[ebx+_EXODUS_PAREN_TOTAL_DATA_ITEMS]
 00002AC6  83 C7 0C	      C                         add     edi,_EXODUS_DATA_LENGTH
 00002AC9  EB AF	      C                         jmp     do_next_data_item
			      C                     .ENDIF
			      C                 .ENDIF
 00002ACB		   *@C00E6:
			      C                 .IF (dword ptr ss:[ebp-52] > 0)
 00002ACB		   *@C00E5:
 00002ACB  83 7D CC 00	   *	    cmp    dword ptr ss : [ebp - 034h], 000h
 00002ACF  76 08	   *	    jbe    @C00EC
 00002AD1  46		      C                     inc     esi
 00002AD2  FF 4D CC	      C                     dec     dword ptr ss:[ebp-52]
 00002AD5  26: FF 43 14	      C                     inc     dword ptr es:[ebx+_EXODUS_PAREN_SOURCE_LINE_LENGTH]
			      C                 .ENDIF
			      C             .ENDW
 00002AD9		   *@C00EC:
 00002AD9		   *@C00E1:
 00002AD9  80 3E 29	   *	    cmp    byte ptr ds : [esi], ')'
 00002ADC  74 14	   *	    je     @C00EE
 00002ADE  83 7D CC 00	   *	    cmp    dword ptr ss : [ebp - 034h], 000h
 00002AE2  76 0E	   *	    jbe    @C00EE
 00002AE4  66| 81 3E 0D0A  *	    cmp    word ptr ds : [esi], 00D0Ah
 00002AE9  74 07	   *	    je     @C00EE
 00002AEB  66| 81 3E 0A0D  *	    cmp    word ptr ds : [esi], 00A0Dh
 00002AF0  75 9D	   *	    jne    @C00E2
			      C             .IF (dword ptr ss:[ebp-52] == 0 || word ptr ds:[esi] != 0d0ah || word ptr ds:[esi] != 0a0dh)
 00002AF2		   *@C00EE:
 00002AF2  83 7D CC 00	   *	    cmp    dword ptr ss : [ebp - 034h], 000h
 00002AF6  74 0E	   *	    je     @C00F3
 00002AF8  66| 81 3E 0D0A  *	    cmp    word ptr ds : [esi], 00D0Ah
 00002AFD  75 07	   *	    jne    @C00F3
 00002AFF  66| 81 3E 0A0D  *	    cmp    word ptr ds : [esi], 00A0Dh
 00002B04  74 13	   *	    je     @C00F2
 00002B06		   *@C00F3:
			      C               ; We have unexpectedly hit the end of file
 00002B06  BB 000006F0 R      C                 mov     ebx,offset parse_unexpected_end_of_file
 00002B0B  E8 000000CA	      C                 call    invParse_Exodus_ini_store_error
 00002B10  C7 45 E4	      C                 mov     dword ptr ss:[ebp-28],1
	   00000001
 00002B17  EB 5A	      C                 jmp     next_line
			      C             .ENDIF
			      C 
 00002B19		      C           cask_finished:
			      C           ; We're past this cask, see if there are any more on the same line
			      C             .WHILE (byte ptr ds:[esi] == 32 || byte ptr ds:[esi] == 9 && dword ptr ss:[ebp-52] > 0)
 00002B19		   *@C00F2:
 00002B19  EB 04	   *	    jmp    @C00F6
 00002B1B		   *@C00F7:
 00002B1B  46		      C                 inc     esi
 00002B1C  FF 4D CC	      C                 dec     dword ptr ss:[ebp-52]
			      C             .ENDW
 00002B1F		   *@C00F6:
 00002B1F  80 3E 20	   *	    cmp    byte ptr ds : [esi], 020h
 00002B22  74 F7	   *	    je     @C00F7
 00002B24  80 3E 09	   *	    cmp    byte ptr ds : [esi], 009h
 00002B27  75 06	   *	    jne    @C00F8
 00002B29  83 7D CC 00	   *	    cmp    dword ptr ss : [ebp - 034h], 000h
 00002B2D  77 EC	   *	    ja     @C00F7
			      C             .IF (dword ptr ss:[ebp-52] == 0 || byte ptr ds:[esi] != '(')
 00002B2F		   *@C00F8:
 00002B2F  83 7D CC 00	   *	    cmp    dword ptr ss : [ebp - 034h], 000h
 00002B33  74 05	   *	    je     @C00FC
 00002B35  80 3E 28	   *	    cmp    byte ptr ds : [esi], '('
 00002B38  74 02	   *	    je     @C00FB
 00002B3A		   *@C00FC:
 00002B3A  EB 37	      C                 jmp     next_line
			      C             .ENDIF
			      C 
			      C             .IF (byte ptr ds:[esi] == '(')
 00002B3C		   *@C00FB:
 00002B3C  80 3E 28	   *	    cmp    byte ptr ds : [esi], '('
 00002B3F  75 0E	   *	    jne    @C00FE
			      C               ; There is another cask, we need to process this one
 00002B41  26: 89 7B 04	      C                 mov     dword ptr es:[ebx+_EXODUS_PAREN_NEXT_SAME_LINE],edi
 00002B45  89 7D BC	      C                 mov     dword ptr ss:[ebp-68],edi
 00002B48  E9 FFFFFEC1	      C                 jmp     do_next_cask
			      C             .ELSE
 00002B4D  EB 24	   *	    jmp    @C0100
 00002B4F		   *@C00FE:
 00002B4F  BB 000006E5 R      C                 mov     ebx,offset parse_expected_paren
 00002B54  E8 00000081	      C                 call    invParse_Exodus_ini_store_error
 00002B59  C7 45 E4	      C                 mov     dword ptr ss:[ebp-28],1
	   00000001
			      C             .ENDIF
			      C 
			      C         .ELSE
 00002B60  EB 11	   *	    jmp    @C0101
 00002B62		   *@C00DC:
			      C           ; This is an error.  Lines cannot stand by themselves with data on it
 00002B62  BB 000006D5 R      C             mov     ebx,offset parse_expected_bracket_paren
 00002B67  E8 0000006E	      C             call    invParse_Exodus_ini_store_error
 00002B6C  C7 45 E4	      C             mov     dword ptr ss:[ebp-28],1
	   00000001
			      C         .ENDIF
			      C 
 00002B73		      C       next_line:
			      C       ; Skip until we reach the end of the line
			      C         .IF (dword ptr ss:[ebp-28] != 0)
 00002B73		   *@C0101:
 00002B73		   *@C00DB:
 00002B73		   *@C0100:
 00002B73  83 7D E4 00	   *	    cmp    dword ptr ss : [ebp - 01Ch], 000h
 00002B77  74 03	   *	    je     @C0102
			      C           ; We have to copy this line to the error output
 00002B79  8B 75 E8	      C             mov     esi,dword ptr ss:[ebp-24]
			      C         .ENDIF
			      C         .WHILE (word ptr ds:[esi] != 0d0ah && word ptr ds:[esi] != 0a0dh && dword ptr ss:[ebp-52] > 0)
 00002B7C		   *@C0102:
 00002B7C  EB 10	   *	    jmp    @C0104
 00002B7E		   *@C0105:
			      C             .IF (dword ptr ss:[ebp-28] != 0)
 00002B7E  83 7D E4 00	   *	    cmp    dword ptr ss : [ebp - 01Ch], 000h
 00002B82  74 06	   *	    je     @C0106
			      C               ; We need to copy this line to the error area
 00002B84  8A 06	      C                 mov     al,byte ptr ds:[esi]
 00002B86  64: 88 02	      C                 mov     byte ptr fs:[edx],al
 00002B89  42		      C                 inc     edx
			      C             .ENDIF
 00002B8A		   *@C0106:
 00002B8A  46		      C             inc     esi
 00002B8B  FF 4D CC	      C             dec     dword ptr ss:[ebp-52]
			      C         .ENDW
 00002B8E		   *@C0104:
 00002B8E  66| 81 3E 0D0A  *	    cmp    word ptr ds : [esi], 00D0Ah
 00002B93  74 0D	   *	    je     @C0108
 00002B95  66| 81 3E 0A0D  *	    cmp    word ptr ds : [esi], 00A0Dh
 00002B9A  74 06	   *	    je     @C0108
 00002B9C  83 7D CC 00	   *	    cmp    dword ptr ss : [ebp - 034h], 000h
 00002BA0  77 DC	   *	    ja     @C0105
			      C         .IF (dword ptr ss:[ebp-28] != 0)
 00002BA2		   *@C0108:
 00002BA2  83 7D E4 00	   *	    cmp    dword ptr ss : [ebp - 01Ch], 000h
 00002BA6  74 09	   *	    je     @C010B
			      C           ; Store CR/LF to the error line
 00002BA8  66| 64: C7 02      C             mov     word ptr fs:[edx],0a0dh
	   0A0D
 00002BAE  83 C2 02	      C             add     edx,2
			      C         .ENDIF
			      C         .IF ((word ptr ds:[esi] == 0d0ah || word ptr ds:[esi] == 0a0dh) && dword ptr ss:[ebp-52] >= 2)
 00002BB1		   *@C010B:
 00002BB1  66| 81 3E 0D0A  *	    cmp    word ptr ds : [esi], 00D0Ah
 00002BB6  74 07	   *	    je     @C010F
 00002BB8  66| 81 3E 0A0D  *	    cmp    word ptr ds : [esi], 00A0Dh
 00002BBD  75 0D	   *	    jne    @C010D
 00002BBF		   *@C010F:
 00002BBF  83 7D CC 02	   *	    cmp    dword ptr ss : [ebp - 034h], 002h
 00002BC3  72 07	   *	    jb     @C010D
 00002BC5  83 C6 02	      C             add     esi,2
 00002BC8  83 6D CC 02	      C             sub     dword ptr ss:[ebp-52],2
			      C         .ENDIF
 00002BCC		   *@C010D:
 00002BCC  FF 45 F4	      C         inc     dword ptr ss:[ebp-12]                               ; increase line number
			      C     .ENDW
 00002BCF		   *@C00BD:
 00002BCF  83 7D CC 00	   *	    cmp    dword ptr ss : [ebp - 034h], 000h
 00002BD3  0F 87 FFFFFCED  *	    ja     @C00BE
			      C 
 00002BD9		      C   finished:
 00002BD9  C3		      C     ret
 00002BDA		      C invParse_Exodus_ini     ENDP
			      C 
			      C 
			      C 
			      C 
 00002BDA		      C invParse_Exodus_ini_store_error     PROC
			      C ; This routine is used to copy the line number and an error message from cs:[ebx] to fs:[edx]
			      C ;
			      C ; Upon entry:   cs:[ebx] - far ptr to null-terminated message to store
			      C ;               fs:[edx] - far ptr to where to store
			      C ;
			      C ; Upon exit:    It's stored
			      C ;               edx - where the next message will be stored
			      C ;
 00002BDA  53		      C     push    ebx
			      C 
			      C ;-------
 00002BDB  56		      C     push    esi
 00002BDC  51		      C     push    ecx
 00002BDD  53		      C     push    ebx
 00002BDE  06		      C     push    es
			      C 
			      C   ; Store the line number
 00002BDF  B8 00000048	      C     mov     eax,_sDATA
 00002BE4  8E C0	      C     mov     es,eax
 00002BE6  9B DB E3	      C     finit
 00002BE9  DB 45 F4	      C     fild    dword ptr ss:[ebp-12]
 00002BEC  DF 75 B0	      C     fbstp   tbyte ptr ss:[ebp-80]
 00002BEF  8B 45 B0	      C     mov     eax,dword ptr ss:[ebp-80]
 00002BF2  BE 000006CF R      C     mov     esi,offset line_text + 5
			      C   ; Right now, eax contains the BCD nibbles of the current line number
 00002BF7  B9 00000008	      C     mov     ecx,8                                                   ; This lowers the flag in ch and stores 8 to cl
 00002BFC		      C   @@:
 00002BFC  C1 C0 04	      C     rol     eax,4
 00002BFF  8A D8	      C     mov     bl,al
 00002C01  80 E3 0F	      C     and     bl,0fh
			      C     .IF (bl != 0 || (bl == 0 && ch != 0))
 00002C04  0A DB	   *	    or	bl, bl
 00002C06  75 08	   *	    jne    @C0113
 00002C08  0A DB	   *	    or	bl, bl
 00002C0A  75 0D	   *	    jne    @C0112
 00002C0C  0A ED	   *	    or	ch, ch
 00002C0E  74 09	   *	    je     @C0112
 00002C10		   *@C0113:
			      C       ; We're storing this value
 00002C10  80 C3 30	      C         add     bl,'0'
 00002C13  26: 88 1E	      C         mov     byte ptr es:[esi],bl
 00002C16  46		      C         inc     esi
 00002C17  B5 01	      C         mov     ch,1                                                ; raise the flag to copy bytes
			      C     .ENDIF
 00002C19		   *@C0112:
 00002C19  FE C9	      C     dec     cl
 00002C1B  75 DF	      C     jnz     @B
 00002C1D  26: C7 06	      C     mov     dword ptr es:[esi+0],00202d20h                          ; this is "<null>_-_"
	   00202D20
			      C 
			      C   ; Store the line number
 00002C24  BE 000006CA R      C     mov     esi,offset line_text
			      C     .WHILE (byte ptr es:[esi] != 0)
 00002C29  EB 08	   *	    jmp    @C0116
 00002C2B		   *@C0117:
 00002C2B  26: 8A 06	      C         mov     al,byte ptr es:[esi]
 00002C2E  46		      C         inc     esi
 00002C2F  64: 88 02	      C         mov     byte ptr fs:[edx],al
 00002C32  42		      C         inc     edx
			      C     .ENDW
 00002C33		   *@C0116:
 00002C33  26: 80 3E 00	   *	    cmp    byte ptr es : [esi], 000h
 00002C37  75 F2	   *	    jne    @C0117
			      C 
 00002C39  07		      C     pop     es
 00002C3A  5B		      C     pop     ebx
 00002C3B  59		      C     pop     ecx
 00002C3C  5E		      C     pop     esi
			      C ;-------
			      C 
			      C   ; Store the error message
			      C     .WHILE (byte ptr cs:[ebx] != 0)
 00002C3D  EB 08	   *	    jmp    @C0119
 00002C3F		   *@C011A:
 00002C3F  2E: 8A 03	      C         mov     al,byte ptr cs:[ebx]
 00002C42  43		      C         inc     ebx
 00002C43  64: 88 02	      C         mov     byte ptr fs:[edx],al
 00002C46  42		      C         inc     edx
			      C     .ENDW
 00002C47		   *@C0119:
 00002C47  2E: 80 3B 00	   *	    cmp    byte ptr cs : [ebx], 000h
 00002C4B  75 F2	   *	    jne    @C011A
			      C 
			      C   ; Store the trailing CR/LF
 00002C4D  66| 64: C7 02      C     mov     word ptr fs:[edx],0a0dh
	   0A0D
 00002C53  83 C2 02	      C     add     edx,2
			      C 
 00002C56  5B		      C     pop     ebx
 00002C57  C3		      C     ret
 00002C58		      C invParse_Exodus_ini_store_error     ENDP
			      C 
			      C 
			      C 
 00002C58		      C invDetermine_Exodus_ini_ownership       PROC    NEAR
			      C ; This routine is used to call all of the Requestor('ini ') routines for all the native primatives.  It allows them to decide
			      C ; what items in the exodus.ini file they have ownership of
			      C ;
			      C ; Upon entry:   Nothing
			      C ;
			      C ; Upon exit:    Nothing
			      C ;
			      C 
 00002C58  C3		      C     ret
			      C 
 00002C59		      C invDetermine_Exodus_ini_ownership       ENDP
			      C 
				    INCLUDE req.asp                                                 ; requestor()
			      C ; req.asp
			      C ;
			      C ; Exodus requestor()
			      C ; January 02, 2001
			      C ;
			      C ; * Refer to inf\requestr.inf for more information
			      C ; * The Exodus requestor call gate points here.  It is _sEXODUS_REQUESTOR
			      C ;
			      C ;  Functions:
			      C ;    À requestor                        ; Exodus's requestor function
			      C ;
			      C ;
			      C 
			      C 
			      C 
			      C 
			      C 
 00002C59		      C requestor       PROC    NEAR
			      C ; This routine is responsible for all Exodus requestor functions
			      C ; Only FAR CALLS will be made to this routine
			      C ; * Refer to inf\requestr.inf for info on this function
			      C ; * Refer to inf\exodus.inf for info on the data structures used in memory regions _sEXODUS_MEM, _sEXODUS_PORTS and _sEXODUS_INTS
			      C ;
			      C ; Upon entry:   eax - requestor request
			      C ;             other - varies
			      C ;
			      C ; Upon exit:  varies based on input
			      C ;
			      C   ; [ebp+08] - dword, cs
			      C   ; [ebp+04] - dword, eip
			      C   ; [ebp+00] - dword, ebp
 00002C59  C8 0014 00	      C     enter   20,0
			      C   ; [ebp-04] - dword, --Nuserved                                    ; This space was reserved for future expansion
			      C   ; [ebp-08] - dword, --Nuserved
			      C   ; [ebp-12] - dword, --Nuserved
			      C   ; [ebp-16] - dword, --Nuserved
			      C   ; [ebp-20] - dword, --Nuserved
 00002C5D  0F A0	      C     push    fs
			      C   ; [ebp-24] - dword, fs
 00002C5F  60		      C     pushad
			      C   ; [ebp-28] - dword, eax                                           ; These locations are noted in case some variables need
			      C   ; [ebp-32] - dword, ecx                                           ; to be updated for the return
			      C   ; [ebp-36] - dword, edx
			      C   ; [ebp-40] - dword, ebx
			      C   ; [ebp-44] - dword, esp
			      C   ; [ebp-48] - dword, ebp
			      C   ; [ebp-52] - dword, esi
			      C   ; [ebp-56] - dword, edi
			      C 
			      C     .IF (eax == 'bmem')
 00002C60  3D 626D656D	   *	    cmp    eax, 'bmem'
 00002C65  0F 85 000000CD  *	    jne    @C011C
			      C       ; They're requesting a quantity of memory
			      C       ; Upon entry: dl - action ÄÄÂ 0-free memory
			      C       ;                           ³   À ebx - number of bytes requested
			      C       ;                           Ã 1-allocate memory
			      C       ;                           ³   À dx - previous selector
			      C       ;                           À 2-make smaller
			      C       ;                               Ã ebx - new number of bytes
			      C       ;                               À dx - previous selector
			      C       ; Upon exit:  carry? - SET if ERROR, CLEAR if OK
			      C       ;                 dx - block selector if successful
			      C       ;
 00002C6B  66| B8 0050	      C         mov     ax,_sEXODUS_MEM
 00002C6F  66| 8E E0	      C         mov     fs,ax
 00002C72  BE 00000004	      C         mov     esi,4
			      C         .IF (dl == 0)
 00002C77  0A D2	   *	    or	dl, dl
 00002C79  75 05	   *	    jne    @C011E
			      C           ; They want to free up a little memory, you know ... for old time's sake.
			      C         .ELSEIF (dl == 1)
 00002C7B  E9 000000B2	   *	    jmp    @C0120
 00002C80		   *@C011E:
 00002C80  80 FA 01	   *	    cmp    dl, 001h
 00002C83  0F 85 000000A1  *	    jne    @C0121
			      C           ; They want a hunk of our precious memory ... so, what the hell ... we'll oblige
			      C             .WHILE (esi < dword ptr fs:[0])
 00002C89  E9 0000008E	   *	    jmp    @C0123
 00002C8E		   *@C0124:
 00002C8E  64: 8A 06	      C                 mov     al,byte ptr fs:[esi]
			      C                 .IF (al == 0 && dword ptr fs:[esi+_EXODUS_MEM_limit] >= ebx)
 00002C91  0A C0	   *	    or	al, al
 00002C93  0F 85 00000080  *	    jne    @C0125
 00002C99  64: 39 5E 08	   *	    cmp    dword ptr fs : [esi + _EXODUS_MEM_limit], ebx
 00002C9D  72 7A	   *	    jb     @C0125
			      C                   ; This block is free and it's big enough
			      C                   ; Update it with the new information
 00002C9F  8B 55 08	      C                     mov     edx,dword ptr ss:[ebp+08]               ; Get the calling code segment off the stack
 00002CA2  8B CA	      C                     mov     ecx,edx                                 ; Find out what PL it is
 00002CA4  83 E1 03	      C                     and     ecx,011b
			      C                     .IF (dword ptr fs:[esi+_EXODUS_MEM_limit] == ebx)
 00002CA7  64: 39 5E 08	   *	    cmp    dword ptr fs : [esi + _EXODUS_MEM_limit], ebx
 00002CAB  75 66	   *	    jne    @C0128
			      C                       ; They're exactly the same size
			      C                         .IF (dx == _sCODE)
 00002CAD  66| 83 FA 20	   *	    cmp    dx, _sCODE
 00002CB1  75 0C	   *	    jne    @C012A
			      C                           ; It's Exodus itself
 00002CB3  64: C6 06 01	      C                             mov     byte ptr fs:[esi+_EXODUS_MEM_type],1
 00002CB7  66| 64: 89 56      C                             mov     word ptr fs:[esi+_EXODUS_MEM_gdt],dx
	   0C
 00002CBC  F8		      C                             clc
			      C                         .ELSEIF (dx >= (_MIN_PRIMATIVE * 8) && dx <= (_MAX_PRIMATIVE * 8) && ecx == 0)
 00002CBD  EB 54	   *	    jmp    @C012C
 00002CBF		   *@C012A:
 00002CBF  66| 81 FA 0640  *	    cmp    dx, _MIN_PRIMATIVE * 008h
 00002CC4  72 46	   *	    jb     @C012D
 00002CC6  66| 81 FA 5D98  *	    cmp    dx, _MAX_PRIMATIVE * 008h
 00002CCB  77 3F	   *	    ja     @C012D
 00002CCD  0B C9	   *	    or	ecx, ecx
 00002CCF  75 3B	   *	    jne    @C012D
			      C                           ; It's a native primative
 00002CD1  66| 64: 89 56      C                             mov     word ptr fs:[esi+_EXODUS_MEM_gdt],dx
	   0C
 00002CD6  1E		      C                             push    ds
 00002CD7  66| B9 0098	      C                             mov     cx,_sPRIMATIVES
 00002CDB  66| 8E D9	      C                             mov     ds,cx
			      C                             .IF (dword ptr ds:[4] < _MAX_PRIMATIVE)
 00002CDE  67& 81 3E 0004
	   00000BB3	   *	    cmp    dword ptr ds : [004h], _MAX_PRIMATIVE
 00002CE7  73 1A	   *	    jae    @C0131
			      C                               ; We have room to add this into their memory space
 00002CE9  67& A1 0004	      C                                 mov     eax,dword ptr ds:[4]
 00002CED  67& FF 06 0004     C                                 inc     dword ptr ds:[4]                            ; Move to next call gate
 00002CF2  64: C6 06 02	      C                                 mov     byte ptr fs:[esi+_EXODUS_MEM_type],2        ; This is a user application (primative)
 00002CF6  66| 64: 89 56      C                                 mov     word ptr fs:[esi+_EXODUS_MEM_gdt],dx        ; Store their code segment
	   0C
 00002CFB  66| 64: 89 46      C                                 mov     word ptr fs:[esi+_EXODUS_MEM_ldt],ax        ; Store the GDT where this block will go
	   0E
			      C                               ; Right now, ebx - number of bytes requested
			      C                               ;             ax - GDT slot where it will go
 00002D00  F8		      C                                 clc
			      C                             .ELSE
 00002D01  EB 01	   *	    jmp    @C0133
 00002D03		   *@C0131:
 00002D03  F9		      C                                 stc
			      C                             .ENDIF
 00002D04		   *@C0133:
 00002D04  1F		      C                             pop     ds
 00002D05  E9 00000550	      C                             jmp     requestor_quit
			      C                         .ELSE
 00002D0A  EB 07	   *	    jmp    @C0134
 00002D0C		   *@C012D:
			      C                           ; It's a user application
 00002D0C  66| 64: 89 56      C                             mov     word ptr fs:[esi+_EXODUS_MEM_gdt],dx
	   0C
			      C                           ; We have to add in the LDT of the calling program
			      C ;; REMEMBER
			      C                         .ENDIF
			      C                     .ELSE
 00002D11  EB 00	   *	    jmp    @C0135
 00002D13		   *@C0128:
			      C                       ; It's bigger, so we have to update this one and add a new entry
			      C 
			      C                     .ENDIF
			      C                   ; Create an entry in the user's LDT
 00002D13		   *@C0135:
 00002D13		   *@C0134:
 00002D13		   *@C012C:
 00002D13  F8		      C                     clc
 00002D14  E9 00000541	      C                     jmp     requestor_quit
			      C                 .ENDIF
 00002D19		   *@C0125:
 00002D19  83 C6 10	      C                 add     esi,_EXODUS_MEM_size
			      C             .ENDW
 00002D1C		   *@C0123:
 00002D1C  67& 64: 3B 36
	   0000		   *	    cmp    esi, dword ptr fs : [000h]
 00002D22  0F 82 FFFFFF66  *	    jb     @C0124
			      C           ; If we're here then there were no free memory blocks, or none of sufficient size (out of memory)
			      C 
			      C         .ELSEIF (dl == 2)
 00002D28  EB 08	   *	    jmp    @C0137
 00002D2A		   *@C0121:
 00002D2A  80 FA 02	   *	    cmp    dl, 002h
 00002D2D  75 02	   *	    jne    @C0138
			      C           ; They want to decrease a previously allocated block of memory
			      C 
			      C         .ELSE
 00002D2F  EB 01	   *	    jmp    @C013A
 00002D31		   *@C0138:
			      C           ; And now ... here they are on our doorstep asking for more.  The greedy little programs!
 00002D31  F9		      C             stc
			      C         .ENDIF
			      C       ; If we're here, then there were some error
 00002D32		   *@C013A:
 00002D32		   *@C0137:
 00002D32		   *@C0120:
 00002D32  F9		      C         stc
			      C     .ELSEIF (eax == 'bprt')
 00002D33  E9 00000522	   *	    jmp    @C013B
 00002D38		   *@C011C:
 00002D38  3D 62707274	   *	    cmp    eax, 'bprt'
 00002D3D  75 1E	   *	    jne    @C013C
			      C       ; They're requesting exclusive access to a particular port (or range of ports)
			      C       ; Upon entry: ebx - number of ports
			      C       ;             edx - starting port
			      C       ;
			      C       ; Upon exit:  carry? - CLEAR=ok, SET=nope, can't have it
			      C       ;
 00002D3F  66| B8 0058	      C         mov     ax,_sEXODUS_PORTS
 00002D43  66| 8E E0	      C         mov     fs,ax
 00002D46  BE 00000004	      C         mov     esi,4
			      C         .WHILE (esi < dword ptr fs:[0])
 00002D4B  EB 03	   *	    jmp    @C013E
 00002D4D		   *@C013F:
 00002D4D  83 C6 10	      C             add     esi,_EXODUS_PORTS_size
			      C         .ENDW
 00002D50		   *@C013E:
 00002D50  67& 64: 3B 36
	   0000		   *	    cmp    esi, dword ptr fs : [000h]
 00002D56  72 F5	   *	    jb     @C013F
			      C     .ELSEIF (eax == 'bint')
 00002D58  E9 000004FD	   *	    jmp    @C0141
 00002D5D		   *@C013C:
 00002D5D  3D 62696E74	   *	    cmp    eax, 'bint'
 00002D62  75 72	   *	    jne    @C0142
			      C       ; They're requesting exclusive access to a particular interrupt (or range of interrupts)
			      C       ; Upon entry:  bl - interrupt
			      C       ;              cl - count
			      C       ;             edx - offset to interrupt service routine
			      C       ;
			      C       ; Upon exit:  carry? - CLEAR=ok, SET=nope, can't have it
			      C       ;
 00002D64  66| B8 0060	      C         mov     ax,_sEXODUS_INTS
 00002D68  66| 8E E0	      C         mov     fs,ax
 00002D6B  BE 00000004	      C         mov     esi,4
			      C 
 00002D70  8A FB	      C         mov     bh,bl
 00002D72  02 F9	      C         add     bh,cl
 00002D74  FE CF	      C         dec     bh
			      C       ; Right now, bl - starting interrupt
			      C       ;            bh - ending interrupt
			      C         .WHILE (esi < dword ptr fs:[0])
 00002D76  EB 23	   *	    jmp    @C0144
 00002D78		   *@C0145:
 00002D78  66| 64: 8B 06      C             mov     ax,word ptr fs:[esi]
 00002D7C  8A EC	      C             mov     ch,ah
 00002D7E  FE C8	      C             dec     al
 00002D80  02 E8	      C             add     ch,al
			      C           ; Right now, ah - starting interrupt
			      C           ;            ch - ending interrupt
			      C             .IF ((bl >= ah && bl <= ch) || (bh >= ah && bh <= ch))
 00002D82  38 E3	   *	    cmp    bl, ah
 00002D84  72 04	   *	    jb     @C0148
 00002D86  38 EB	   *	    cmp    bl, ch
 00002D88  76 08	   *	    jbe    @C0147
 00002D8A		   *@C0148:
 00002D8A  38 E7	   *	    cmp    bh, ah
 00002D8C  72 0A	   *	    jb     @C0146
 00002D8E  38 EF	   *	    cmp    bh, ch
 00002D90  77 06	   *	    ja     @C0146
 00002D92		   *@C0147:
			      C               ; This one is already used
 00002D92  F9		      C                 stc
 00002D93  E9 000004C2	      C                 jmp     requestor_quit
			      C             .ENDIF
 00002D98		   *@C0146:
 00002D98  83 C6 02	      C             add     esi,_EXODUS_INTS_size
			      C         .ENDW
 00002D9B		   *@C0144:
 00002D9B  67& 64: 3B 36
	   0000		   *	    cmp    esi, dword ptr fs : [000h]
 00002DA1  72 D5	   *	    jb     @C0145
			      C         .IF (esi == _sEXODUS_INTS_limit)
 00002DA3  81 FE 00000200  *	    cmp    esi, _sEXODUS_INTS_limit
 00002DA9  75 06	   *	    jne    @C014C
			      C           ; We're at the end
 00002DAB  F9		      C             stc
 00002DAC  E9 000004A9	      C             jmp     requestor_quit
			      C         .ENDIF
			      C       ; If we're here, then it wasn't used.  We add it.
 00002DB1		   *@C014C:
 00002DB1  64: 88 0E	      C         mov     byte ptr fs:[esi],cl
 00002DB4  64: 88 5E 01	      C         mov     byte ptr fs:[esi+1],bl
			      C 
			      C       ; Now, create the IDT entry(s)
 00002DB8  81 E1 000000FF     C         and     ecx,0ffh
			      C       ; Right now,  bl - starting interrupt number
			      C       ;            ecx - number of interrupts to intercept/keep
			      C       ;            edx - offset to ISR
 00002DBE  8A C3	      C         mov     al,bl
 00002DC0  25 000000FF	      C         and     eax,0ffh
 00002DC5  8B 5D 08	      C         mov     ebx,dword ptr ss:[ebp+08]
			      C         .REPEAT
 00002DC8		   *@C014E:
			      C           ; Right now, eax - interrupt number to update
			      C           ;            edx - offset to ISR
			      C           ;             bx - selector to ISR
 00002DC8  E8 FFFFD650	      C             call    invUpdate_interrupt_descriptor32
 00002DCD  40		      C             inc     eax
			      C         .UNTILCXZ
 00002DCE  E2 F8	   *	    loop   @C014E
 00002DD0  F8		      C         clc
			      C     .ELSEIF (eax == 'boot')
 00002DD1  E9 00000484	   *	    jmp    @C014F
 00002DD6		   *@C0142:
 00002DD6  3D 626F6F74	   *	    cmp    eax, 'boot'
 00002DDB  75 2B	   *	    jne    @C0150
			      C         .IF (ebx == 'logo')
 00002DDD  81 FB 6C6F676F  *	    cmp    ebx, 'logo'
 00002DE3  0F 85 00000471  *	    jne    @C0152
 00002DE9  1E		      C             push    ds
			      C 
 00002DEA  B8 00000048	      C             mov     eax,_sDATA
 00002DEF  8E D8	      C             mov     ds,eax
 00002DF1  BE 0000076A R      C             mov     esi,offset bootscreen_start
 00002DF6  B9 00001354	      C             mov     ecx,offset bootscreen_end - bootscreen_start
 00002DFB  2E: FF 1D	      C             call    fword ptr cs:_VID_draw_exodus_boot_screen
	   00001AEC R
			      C 
 00002E02  1F		      C             pop     ds
			      C         .ENDIF
			      C     .ELSEIF (eax == 'find' && edi == 'func')
 00002E03  E9 00000452	   *	    jmp    @C0154
 00002E08		   *@C0150:
 00002E08  3D 66696E64	   *	    cmp    eax, 'find'
 00002E0D  0F 85 000001A0  *	    jne    @C0155
 00002E13  81 FF 66756E63  *	    cmp    edi, 'func'
 00002E19  0F 85 00000194  *	    jne    @C0155
			      C       ; They want to find a function by it's call gate and an offset
			      C       ;
			      C       ; Upon entry:   edx - code segment
			      C       ;               ebx - instruction pointer
			      C       ;          ds:[esi] - far ptr where to store
			      C       ;               ecx - maximum # of bytes to store
			      C       ;
			      C       ; Upon exit:    If found it's inserted, if not then it's not
			      C       ;
			      C       ; [ebp+12]+ (other parameters)
			      C       ; [ebp+08] - cs
			      C       ; [ebp+04] - eip
			      C       ; [ebp+00] - ebp
 00002E1F  C8 0014 00	      C         enter   20,0
			      C       ; [ebp-04] - dword, edx at start
			      C       ; [ebp-08] - dword, ebx at start
			      C       ; [ebp-12] - dword, Last pointer to primative that was found
			      C       ; [ebp-16] - dword, Distance from primative offset to ebx at start (indicates how far away from start of function it is)
			      C       ; [ebp-20] - dword, ecx at start
 00002E23  89 55 FC	      C         mov     dword ptr ss:[ebp-04],edx
 00002E26  89 5D F8	      C         mov     dword ptr ss:[ebp-08],ebx
 00002E29  C7 45 F4	      C         mov     dword ptr ss:[ebp-12],0ffffffffh
	   FFFFFFFF
 00002E30  C7 45 F0	      C         mov     dword ptr ss:[ebp-16],0ffffffffh
	   FFFFFFFF
 00002E37  89 4D EC	      C         mov     dword ptr ss:[ebp-20],ecx
			      C 
 00002E3A  06		      C         push    es
 00002E3B  B8 00000048	      C         mov     eax,_sDATA
 00002E40  66| 8E C0	      C         mov     es,ax
 00002E43  8B C2	      C         mov     eax,edx
 00002E45  83 E0 03	      C         and     eax,011b
			      C         .IF (eax == 011b)
 00002E48  83 F8 03	   *	    cmp    eax, 003h
 00002E4B  75 10	   *	    jne    @C0158
			      C           ; It's a ring-3 application
			      C ;; REMEMBER
			      C           ; Indicate it's an unknown user function
 00002E4D  BF 00000557 R      C             mov     edi,offset unknown_user_function_text
 00002E52  F9		      C             stc
 00002E53  E9 00000133	      C             jmp     find_func_copy_text
			      C         .ELSE
 00002E58  E9 0000014F	   *	    jmp    @C015A
 00002E5D		   *@C0158:
			      C             .IF (edx >= _MIN_PRIMATIVE*8 && edx <= _MAX_PRIMATIVE*8)
 00002E5D  81 FA 00000640  *	    cmp    edx, _MIN_PRIMATIVE * 008h
 00002E63  0F 82 00000117  *	    jb     @C015B
 00002E69  81 FA 00005D98  *	    cmp    edx, _MAX_PRIMATIVE * 008h
 00002E6F  0F 87 0000010B  *	    ja     @C015B
 00002E75  B8 00000098	      C                 mov     eax,_sPRIMATIVES
 00002E7A  66| 8E E0	      C                 mov     fs,ax
 00002E7D  BF 00000008	      C                 mov     edi,8                                       ; Start after this structure, see inf\primload.inf
			      C                 .WHILE (edi < dword ptr fs:[0])
 00002E82  EB 34	   *	    jmp    @C015E
 00002E84		   *@C015F:
			      C                     .IF (byte ptr fs:[edi+2] == 1)
 00002E84  64: 80 7F 02
	   01		   *	    cmp    byte ptr fs : [edi + 002h], 001h
 00002E89  75 23	   *	    jne    @C0160
			      C                       ; This one is active, lookup the GDT entry to determine the code selector and offset
 00002E8B  64: 0F B7 07	      C                         movzx   eax,word ptr fs:[edi]               ; Get the GDT entry for this primative
 00002E8F  E8 FFFFD378	      C                         call    invExtract_call_gate_descriptor32
			      C                         .IF (edx == dword ptr ss:[ebp-04])
 00002E94  3B 55 FC	   *	    cmp    edx, dword ptr ss : [ebp - 004h]
 00002E97  75 15	   *	    jne    @C0162
			      C                           ; It's the right code segment, is it the right offset?
			      C                             .IF (ebx <= dword ptr ss:[ebp-08])
 00002E99  3B 5D F8	   *	    cmp    ebx, dword ptr ss : [ebp - 008h]
 00002E9C  77 10	   *	    ja     @C0164
			      C                               ; It's before the current instruction pointer ... so it's a candidate
 00002E9E  8B 4D F8	      C                                 mov     ecx,dword ptr ss:[ebp-08]
 00002EA1  2B CB	      C                                 sub     ecx,ebx
			      C                                 .IF (ecx < dword ptr ss:[ebp-16])
 00002EA3  3B 4D F0	   *	    cmp    ecx, dword ptr ss : [ebp - 010h]
 00002EA6  73 06	   *	    jae    @C0166
			      C                                   ; We're closer than the previous one
 00002EA8  89 7D F4	      C                                     mov     dword ptr ss:[ebp-12],edi
 00002EAB  89 4D F0	      C                                     mov     dword ptr ss:[ebp-16],ecx
			      C                                 .ENDIF
			      C                             .ENDIF
 00002EAE		   *@C0166:
			      C                         .ENDIF
 00002EAE		   *@C0164:
			      C                     .ENDIF
 00002EAE		   *@C0162:
 00002EAE		   *@C0160:
 00002EAE  64: 0F B6 47	      C                     movzx   eax,byte ptr fs:[edi+3]
	   03
 00002EB3  03 F8	      C                     add     edi,eax
 00002EB5  83 C7 04	      C                     add     edi,4
			      C                 .ENDW
 00002EB8		   *@C015E:
 00002EB8  67& 64: 3B 3E
	   0000		   *	    cmp    edi, dword ptr fs : [000h]
 00002EBE  72 C4	   *	    jb     @C015F
			      C                 .IF (dword ptr ss:[ebp-12] != 0ffffffffh)
 00002EC0  83 7D F4 FF	   *	    cmp    dword ptr ss : [ebp - 00Ch], 0FFFFFFFFh
 00002EC4  0F 84 000000AC  *	    je     @C0169
			      C                   ; We found something
 00002ECA  8B 7D F4	      C                     mov     edi,dword ptr ss:[ebp-12]
 00002ECD  64: 0F B6 4F	      C                     movzx   ecx,byte ptr fs:[edi+3]
	   03
 00002ED2  83 C7 04	      C                     add     edi,4
 00002ED5  8B 45 EC	      C                     mov     eax,dword ptr ss:[ebp-20]
			      C                   ; Right now, fs:[edi] - far ptr to the name of this function
			      C                   ;                 ecx - length of the function name
			      C                   ;            ds:[esi] - far ptr to where we're supposed to store this name
			      C                   ;                 eax - maximum # of characters ds:[esi] can hold
			      C                     .IF (eax > 4)
 00002ED8  83 F8 04	   *	    cmp    eax, 004h
 00002EDB  76 0E	   *	    jbe    @C016B
			      C                       ; Store the word " at "
 00002EDD  C7 06 20746120     C                         mov     dword ptr ds:[esi],' ta '
 00002EE3  83 C6 04	      C                         add     esi,4
 00002EE6  83 E8 04	      C                         sub     eax,4
			      C                     .ELSEIF (eax > 1)
 00002EE9  EB 0A	   *	    jmp    @C016D
 00002EEB		   *@C016B:
 00002EEB  83 F8 01	   *	    cmp    eax, 001h
 00002EEE  76 05	   *	    jbe    @C016E
			      C                       ; Not enough room for the phrase " at ", so we just add a space and copy what we can
 00002EF0  C6 06 20	      C                         mov     byte ptr ds:[esi],32
 00002EF3  46		      C                         inc     esi
 00002EF4  48		      C                         dec     eax
			      C                     .ENDIF
			      C                   ; Now, copy the function name
			      C                     .WHILE (byte ptr fs:[edi] != 0 && ecx > 0 && eax > 0)
 00002EF5		   *@C016E:
 00002EF5		   *@C016D:
 00002EF5  EB 09	   *	    jmp    @C0170
 00002EF7		   *@C0171:
 00002EF7  64: 8A 07	      C                         mov     al,byte ptr fs:[edi]
 00002EFA  88 06	      C                         mov     byte ptr ds:[esi],al
 00002EFC  46		      C                         inc     esi
 00002EFD  47		      C                         inc     edi
 00002EFE  49		      C                         dec     ecx
 00002EFF  48		      C                         dec     eax
			      C                     .ENDW
 00002F00		   *@C0170:
 00002F00  64: 80 3F 00	   *	    cmp    byte ptr fs : [edi], 000h
 00002F04  74 0A	   *	    je     @C0172
 00002F06  83 F9 00	   *	    cmp    ecx, 000h
 00002F09  76 05	   *	    jbe    @C0172
 00002F0B  83 F8 00	   *	    cmp    eax, 000h
 00002F0E  77 E7	   *	    ja     @C0171
			      C                   ; Ok, right now the name has been copied
			      C                     .IF (eax > 2)
 00002F10		   *@C0172:
 00002F10  83 F8 02	   *	    cmp    eax, 002h
 00002F13  76 0B	   *	    jbe    @C0175
			      C                       ; Store the () part of a function()
 00002F15  66| C7 06 2928     C                         mov     word ptr ds:[esi],')('
 00002F1A  83 E8 02	      C                         sub     eax,2
 00002F1D  83 C6 02	      C                         add     esi,2
			      C                     .ENDIF
			      C                     .IF (eax > 0)
 00002F20		   *@C0175:
 00002F20  83 F8 00	   *	    cmp    eax, 000h
 00002F23  76 4C	   *	    jbe    @C0177
			      C                       ; We need to try to copy the offset
 00002F25  C6 06 2B	      C                         mov     byte ptr ds:[esi],"+"
 00002F28  46		      C                         inc     esi
 00002F29  48		      C                         dec     eax
			      C                         .IF (eax > 0)
 00002F2A  83 F8 00	   *	    cmp    eax, 000h
 00002F2D  76 42	   *	    jbe    @C0179
			      C                           ; Now, copy the offset text to the string
 00002F2F  8B 55 F0	      C                             mov     edx,dword ptr ss:[ebp-16]
 00002F32  B9 00000008	      C                             mov     ecx,8
			      C                           ; Skip past any leading 0s
 00002F37		      C                           @@:
 00002F37  C1 C2 04	      C                             rol     edx,4
 00002F3A  8A DA	      C                             mov     bl,dl
 00002F3C  80 E3 0F	      C                             and     bl,0fh
			      C                             .IF (bl != 0)
 00002F3F  0A DB	   *	    or	bl, bl
 00002F41  74 02	   *	    je     @C017B
 00002F43  EB 0B	      C                                 jmp     @F
			      C                             .ENDIF
 00002F45		   *@C017B:
 00002F45  E2 F0	      C                             loop    @B
			      C                             .IF (ecx == 0)
 00002F47  0B C9	   *	    or	ecx, ecx
 00002F49  75 05	   *	    jne    @C017D
			      C                               ; There are no values to store
 00002F4B  B9 00000001	      C                                 mov     ecx,1
			      C                             .ENDIF
			      C                           ; Write the string
 00002F50		      C                           @@:
 00002F50		   *@C017D:
 00002F50  8A DA	      C                             mov     bl,dl
 00002F52  80 E3 0F	      C                             and     bl,0fh
			      C                             .IF (bl <= 9)                           ; Convert from ASCII to text, "0" to "9" or "a" to "f"
 00002F55  80 FB 09	   *	    cmp    bl, 009h
 00002F58  77 05	   *	    ja     @C017F
 00002F5A  80 C3 30	      C                                 add     bl,'0'
			      C                             .ELSE
 00002F5D  EB 03	   *	    jmp    @C0181
 00002F5F		   *@C017F:
 00002F5F  80 C3 57	      C                                 add     bl,'a'-10
			      C                             .ENDIF
 00002F62		   *@C0181:
 00002F62  88 1E	      C                             mov     byte ptr ds:[esi],bl
 00002F64  46		      C                             inc     esi
 00002F65  48		      C                             dec     eax
			      C                             .IF (eax == 0)
 00002F66  0B C0	   *	    or	eax, eax
 00002F68  75 02	   *	    jne    @C0182
 00002F6A  EB 05	      C                                 jmp     @F
			      C                             .ENDIF
 00002F6C		   *@C0182:
 00002F6C  C1 C2 04	      C                             rol     edx,4
 00002F6F  E2 DF	      C                             loop    @B
 00002F71		      C                           @@:
			      C                         .ENDIF
			      C                     .ENDIF
 00002F71		   *@C0179:
 00002F71		   *@C0177:
 00002F71  F8		      C                     clc
 00002F72  EB 38	      C                     jmp     find_func_quit
			      C                 .ELSE
 00002F74  EB 36	   *	    jmp    @C0184
 00002F76		   *@C0169:
			      C                   ; We didn't find it
 00002F76  BF 00000570 R      C                     mov     edi,offset unknown_primative_text
 00002F7B  F9		      C                     stc
 00002F7C  EB 0D	      C                     jmp     find_func_copy_text
			      C                 .ENDIF
			      C             .ELSEIF (edx == _sCODE)
 00002F7E  EB 2C	   *	    jmp    @C0185
 00002F80		   *@C015B:
 00002F80  83 FA 20	   *	    cmp    edx, _sCODE
 00002F83  75 1F	   *	    jne    @C0186
			      C               ; It's Exodus itself!!!  WOAH!  This is bad.  We're not supposed to have any problems.  "It must be a human error."
 00002F85  BF 00000539 R      C                 mov     edi,offset exodus_internal_text
 00002F8A  F8		      C                 clc
 00002F8B		      C               find_func_copy_text:
 00002F8B  9C		      C                 pushfd
			      C                 .WHILE (byte ptr es:[edi] != 0 && ecx > 0)
 00002F8C  EB 08	   *	    jmp    @C0188
 00002F8E		   *@C0189:
 00002F8E  26: 8A 07	      C                     mov     al,byte ptr es:[edi]
 00002F91  88 06	      C                     mov     byte ptr ds:[esi],al
 00002F93  46		      C                     inc     esi
 00002F94  47		      C                     inc     edi
 00002F95  49		      C                     dec     ecx
			      C                 .ENDW
 00002F96		   *@C0188:
 00002F96  26: 80 3F 00	   *	    cmp    byte ptr es : [edi], 000h
 00002F9A  74 05	   *	    je     @C018A
 00002F9C  83 F9 00	   *	    cmp    ecx, 000h
 00002F9F  77 ED	   *	    ja     @C0189
 00002FA1		   *@C018A:
 00002FA1  9D		      C                 popfd
			      C             .ELSE
 00002FA2  EB 08	   *	    jmp    @C018C
 00002FA4		   *@C0186:
			      C               ; It's an unknown function
 00002FA4  BF 0000054C R      C                 mov     edi,offset unknown_function_text
 00002FA9  F9		      C                 stc
 00002FAA  EB DF	      C                 jmp     find_func_copy_text
			      C             .ENDIF
			      C         .ENDIF
 00002FAC		   *@C018C:
 00002FAC		   *@C0185:
 00002FAC		   *@C0184:
			      C 
 00002FAC		      C       find_func_quit:
 00002FAC		   *@C015A:
 00002FAC  07		      C         pop     es
 00002FAD  C9		      C         leave
			      C     .ELSEIF (eax == 'altr')
 00002FAE  E9 000002A7	   *	    jmp    @C018D
 00002FB3		   *@C0155:
 00002FB3  3D 616C7472	   *	    cmp    eax, 'altr'
 00002FB8  75 44	   *	    jne    @C018E
			      C       ; They want to alter something
			      C         .IF (ebx == 'gdt ')
 00002FBA  81 FB 67647420  *	    cmp    ebx, 'gdt '
 00002FC0  75 36	   *	    jne    @C0190
			      C           ; This function is used to alter the base/limit of a GDT entry
			      C           ;
			      C           ; Upon entry: edx - GDT slot
			      C           ;             esi - new base
			      C           ;             edi - new limit
			      C           ;
			      C           ; Upon exit:  carry? - clear if acceptable
			      C           ;
			      C             .IF (edx == _sVGA/8 && (esi == _sVGA_base || esi == _sVGA_BACKUP_base) && (edi == _sVGA_limit || edi == _sVGA_BACKUP_limit))
 00002FC2  83 FA 07	   *	    cmp    edx, _sVGA / 008h
 00002FC5  75 2B	   *	    jne    @C0192
 00002FC7  81 FE 000B8000  *	    cmp    esi, _sVGA_base
 00002FCD  74 08	   *	    je     @C0194
 00002FCF  81 FE 00060000  *	    cmp    esi, _sVGA_BACKUP_base
 00002FD5  75 1B	   *	    jne    @C0192
 00002FD7		   *@C0194:
 00002FD7  81 FF 00008000  *	    cmp    edi, _sVGA_limit
 00002FDD  74 08	   *	    je     @C0193
 00002FDF  81 FF 00008000  *	    cmp    edi, _sVGA_BACKUP_limit
 00002FE5  75 0B	   *	    jne    @C0192
 00002FE7		   *@C0193:
			      C               ; It's the _sVGA, this one is acceptable to alter
 00002FE7  E8 FFFFD28B	      C                 call    invAlter_descriptor32_base_limit
 00002FEC  F8		      C                 clc
			      C             .ELSE
 00002FED  E9 00000268	   *	    jmp    @C0198
 00002FF2		   *@C0192:
			      C               ; Unrecognized request
 00002FF2  F9		      C                 stc
			      C             .ENDIF
			      C         .ELSE
 00002FF3  E9 00000262	   *	    jmp    @C0199
 00002FF8		   *@C0190:
			      C           ; Unrecognized request
 00002FF8  F9		      C             stc
			      C         .ENDIF
			      C     .ELSEIF (eax == 'get ')
 00002FF9  E9 0000025C	   *	    jmp    @C019A
 00002FFE		   *@C018E:
 00002FFE  3D 67657420	   *	    cmp    eax, 'get '
 00003003  0F 85 00000135  *	    jne    @C019B
			      C       ; They want to get some information about something
			      C         .IF (ebx == 'gdtd')
 00003009  81 FB 67647464  *	    cmp    ebx, 'gdtd'
 0000300F  75 25	   *	    jne    @C019D
			      C           ; This function is used extract the base/limit of a data GDT entry
			      C           ;
			      C           ; Upon entry: edx - GDT slot
			      C           ;
			      C           ; Upon exit:  carry? - clear if acceptable
			      C           ;             ebx - base
			      C           ;             edx - limit
			      C           ;
 00003011  F7 45 08	      C             test    dword ptr ss:[ebp+08],111b
	   00000007
			      C             .IF (zero?)
 00003018  75 16	   *	    jne    @C019F
			      C               ; This function is only available to PL=00 tasks
 0000301A  8B C2	      C                 mov     eax,edx
 0000301C  C1 E0 03	      C                 shl     eax,3
 0000301F  E8 FFFFD212	      C                 call    invExtract_data_descriptor32
 00003024  89 5D D8	      C                 mov     dword ptr ss:[ebp-40],ebx
 00003027  89 55 DC	      C                 mov     dword ptr ss:[ebp-36],edx
 0000302A  F8		      C                 clc
			      C             .ELSE
 0000302B  E9 0000022A	   *	    jmp    @C01A1
 00003030		   *@C019F:
 00003030  F9		      C                 stc
			      C             .ENDIF
			      C 
			      C         .ELSEIF (ebx == 'gdtc')
 00003031  E9 00000224	   *	    jmp    @C01A2
 00003036		   *@C019D:
 00003036  81 FB 67647463  *	    cmp    ebx, 'gdtc'
 0000303C  75 25	   *	    jne    @C01A3
			      C           ; This function is used extract the base/limit of a code GDT entry
			      C           ;
			      C           ; Upon entry: edx - GDT slot
			      C           ;
			      C           ; Upon exit:  carry? - clear if acceptable
			      C           ;             ebx - base
			      C           ;             edx - limit
			      C           ;
 0000303E  F7 45 08	      C             test    dword ptr ss:[ebp+08],111b
	   00000007
			      C             .IF (zero?)
 00003045  75 16	   *	    jne    @C01A5
			      C               ; This function is only available to PL=00 tasks
 00003047  8B C2	      C                 mov     eax,edx
 00003049  C1 E0 03	      C                 shl     eax,3
 0000304C  E8 FFFFD17A	      C                 call    invExtract_code_descriptor32
 00003051  89 5D D8	      C                 mov     dword ptr ss:[ebp-40],ebx
 00003054  89 55 DC	      C                 mov     dword ptr ss:[ebp-36],edx
 00003057  F8		      C                 clc
			      C             .ELSE
 00003058  E9 000001FD	   *	    jmp    @C01A7
 0000305D		   *@C01A5:
 0000305D  F9		      C                 stc
			      C             .ENDIF
			      C 
			      C         .ELSEIF (ebx == 'gdt ')
 0000305E  E9 000001F7	   *	    jmp    @C01A8
 00003063		   *@C01A3:
 00003063  81 FB 67647420  *	    cmp    ebx, 'gdt '
 00003069  75 32	   *	    jne    @C01A9
			      C           ; This function is used extract the quadword GDT entry
			      C           ;
			      C           ; Upon entry: edx - GDT slot
			      C           ;
 0000306B  F7 45 08	      C             test    dword ptr ss:[ebp+08],111b
	   00000007
			      C             .IF (zero?)
 00003072  75 23	   *	    jne    @C01AB
 00003074  1E		      C                 push    ds
 00003075  B8 00000010	      C                 mov     eax,_sGDT
 0000307A  8E D8	      C                 mov     ds,eax
 0000307C  8B 1C D5	      C                 mov     ebx,dword ptr ds:[edx*8+4]
	   00000004
 00003083  8B 14 D5	      C                 mov     edx,dword ptr ds:[edx*8+0]
	   00000000
 0000308A  89 5D D8	      C                 mov     dword ptr ss:[ebp-40],ebx
 0000308D  89 55 DC	      C                 mov     dword ptr ss:[ebp-36],edx
 00003090  1F		      C                 pop     ds
 00003091  F8		      C                 clc
			      C             .ELSE
 00003092  E9 000001C3	   *	    jmp    @C01AD
 00003097		   *@C01AB:
 00003097  F9		      C                 stc
			      C             .ENDIF
			      C 
			      C         .ELSEIF (ebx == 'tss ')
 00003098  E9 000001BD	   *	    jmp    @C01AE
 0000309D		   *@C01A9:
 0000309D  81 FB 74737320  *	    cmp    ebx, 'tss '
 000030A3  75 29	   *	    jne    @C01AF
			      C           ; This function is used extract the TSS base address from a CALL GATE GDT entry
			      C           ;
			      C           ; Upon entry: edx - call gate GDT slot
			      C           ;
 000030A5  F7 45 08	      C             test    dword ptr ss:[ebp+08],111b
	   00000007
			      C             .IF (zero?)
 000030AC  75 1A	   *	    jne    @C01B1
 000030AE  8B C2	      C                 mov     eax,edx
 000030B0  C1 E0 03	      C                 shl     eax,3
 000030B3  E8 FFFFD154	      C                 call    invExtract_call_gate_descriptor32
 000030B8  8B C2	      C                 mov     eax,edx
 000030BA  E8 FFFFD177	      C                 call    invExtract_data_descriptor32
 000030BF  89 5D D8	      C                 mov     dword ptr ss:[ebp-40],ebx
 000030C2  F8		      C                 clc
			      C             .ELSE
 000030C3  E9 00000192	   *	    jmp    @C01B3
 000030C8		   *@C01B1:
 000030C8  F9		      C                 stc
			      C             .ENDIF
			      C 
			      C         .ELSEIF (ebx == 'base')
 000030C9  E9 0000018C	   *	    jmp    @C01B4
 000030CE		   *@C01AF:
 000030CE  81 FB 62617365  *	    cmp    ebx, 'base'
 000030D4  75 2D	   *	    jne    @C01B5
			      C           ; They want the base from an unknown selector (could be local, could be global)
			      C           ;
			      C           ; Upon entry: edx - offset in GDT
			      C           ;
			      C           ; Upon exit:  carry? - clear if found, set if not
			      C           ;                ecx - base if found
			      C           ;
 000030D6  F7 45 08	      C             test dword ptr ss:[ebp+08],111b
	   00000007
			      C             .IF (zero?)
 000030DD  75 1E	   *	    jne    @C01B7
 000030DF  F7 45 DC	      C                 test dword ptr ss:[ebp-36],111b                     ; Check edx
	   00000007
			      C                 .IF (zero?)
 000030E6  75 10	   *	    jne    @C01B9
			      C                   ; It's a PL=00 descriptor
 000030E8  8B C2	      C                     mov     eax,edx
 000030EA  E8 FFFFD147	      C                     call    invExtract_data_descriptor32
 000030EF  89 5D E0	      C                     mov     dword ptr ss:[ebp-32],ebx               ; Store base in ecx
 000030F2  F8		      C                     clc
			      C                 .ELSE
 000030F3  E9 00000162	   *	    jmp    @C01BB
 000030F8		   *@C01B9:
			      C                   ; We have to find it the hard way
			      C                 .ENDIF
			      C             .ELSE
 000030F8  E9 0000015D	   *	    jmp    @C01BC
 000030FD		   *@C01B7:
 000030FD  F9		      C                 stc
			      C             .ENDIF
			      C 
			      C         .ELSEIF (ebx == 'limi')
 000030FE  E9 00000157	   *	    jmp    @C01BD
 00003103		   *@C01B5:
 00003103  81 FB 6C696D69  *	    cmp    ebx, 'limi'
 00003109  75 2D	   *	    jne    @C01BE
			      C           ; They want the limit from an unknown selector (could be local, could be global)
			      C           ;
			      C           ; Upon entry: edx - offset in GDT
			      C           ;
			      C           ; Upon exit:  carry? - clear if found, set if not
			      C           ;                ecx - limit if found
			      C           ;
 0000310B  F7 45 08	      C             test dword ptr ss:[ebp+08],111b
	   00000007
			      C             .IF (zero?)
 00003112  75 1E	   *	    jne    @C01C0
 00003114  F7 45 DC	      C                 test dword ptr ss:[ebp-36],111b                     ; Check edx
	   00000007
			      C                 .IF (zero?)
 0000311B  75 10	   *	    jne    @C01C2
			      C                   ; It's a PL=00 descriptor
 0000311D  8B C2	      C                     mov     eax,edx
 0000311F  E8 FFFFD112	      C                     call    invExtract_data_descriptor32
 00003124  89 55 E0	      C                     mov     dword ptr ss:[ebp-32],edx               ; Store limit in ecx
 00003127  F8		      C                     clc
			      C                 .ELSE
 00003128  E9 0000012D	   *	    jmp    @C01C4
 0000312D		   *@C01C2:
			      C                   ; We have to find it the hard way
			      C                 .ENDIF
			      C             .ELSE
 0000312D  E9 00000128	   *	    jmp    @C01C5
 00003132		   *@C01C0:
 00003132  F9		      C                 stc
			      C             .ENDIF
			      C 
			      C         .ELSE
 00003133  E9 00000122	   *	    jmp    @C01C6
 00003138		   *@C01BE:
			      C           ; Unrecognized request
 00003138  F9		      C             stc
			      C         .ENDIF
			      C     .ELSEIF (eax == 'set ')
 00003139  E9 0000011C	   *	    jmp    @C01C7
 0000313E		   *@C019B:
 0000313E  3D 73657420	   *	    cmp    eax, 'set '
 00003143  75 60	   *	    jne    @C01C8
			      C       ; They want to set some information about something
			      C         .IF (ebx == 'gdtd')
 00003145  81 FB 67647464  *	    cmp    ebx, 'gdtd'
 0000314B  75 25	   *	    jne    @C01CA
			      C           ; This function is used extract the base/limit of a data GDT entry
			      C           ;
			      C           ; Upon entry: edx - GDT slot
			      C           ;             esi - base
			      C           ;             edi - limit
			      C           ;
			      C           ; Upon exit:  carry? - clear if acceptable
			      C           ;
 0000314D  F7 45 08	      C             test    dword ptr ss:[ebp+08],111b
	   00000007
			      C             .IF (zero?)
 00003154  75 16	   *	    jne    @C01CC
			      C               ; This function is only available to PL=00 tasks
			      C                 .IF (edx == _sDEBI_temp/8)
 00003156  83 FA 1F	   *	    cmp    edx, _sDEBI_temp / 008h
 00003159  75 0B	   *	    jne    @C01CE
 0000315B  8B C2	      C                     mov     eax,edx
 0000315D  8B DE	      C                     mov     ebx,esi
 0000315F  8B D7	      C                     mov     edx,edi
 00003161  E8 FFFFCFF8	      C                     call    invCreate_data_descriptor32
			      C                 .ENDIF
 00003166		   *@C01CE:
 00003166  F8		      C                 clc
			      C             .ELSE
 00003167  E9 000000EE	   *	    jmp    @C01D0
 0000316C		   *@C01CC:
 0000316C  F9		      C                 stc
			      C             .ENDIF
			      C 
			      C         .ELSEIF (ebx == 'gdtc')
 0000316D  E9 000000E8	   *	    jmp    @C01D1
 00003172		   *@C01CA:
 00003172  81 FB 67647463  *	    cmp    ebx, 'gdtc'
 00003178  75 25	   *	    jne    @C01D2
			      C           ; This function is used extract the base/limit of a code GDT entry
			      C           ;
			      C           ; Upon entry: edx - GDT slot
			      C           ;             esi - base
			      C           ;             edi - limit
			      C           ;
			      C           ; Upon exit:  carry? - clear if acceptable
			      C           ;
 0000317A  F7 45 08	      C             test    dword ptr ss:[ebp+08],111b
	   00000007
			      C             .IF (zero?)
 00003181  75 16	   *	    jne    @C01D4
			      C               ; This function is only available to PL=00 tasks
			      C                 .IF (edx == _sDEBI_temp/8)
 00003183  83 FA 1F	   *	    cmp    edx, _sDEBI_temp / 008h
 00003186  75 0B	   *	    jne    @C01D6
 00003188  8B C2	      C                     mov     eax,edx
 0000318A  8B DE	      C                     mov     ebx,esi
 0000318C  8B D7	      C                     mov     edx,edi
 0000318E  E8 FFFFCF58	      C                     call    invCreate_code_descriptor32
			      C                 .ENDIF
 00003193		   *@C01D6:
 00003193  F8		      C                 clc
			      C             .ELSE
 00003194  E9 000000C1	   *	    jmp    @C01D8
 00003199		   *@C01D4:
 00003199  F9		      C                 stc
			      C             .ENDIF
			      C 
			      C         .ELSE
 0000319A  E9 000000BB	   *	    jmp    @C01D9
 0000319F		   *@C01D2:
			      C           ; Unrecognized request
 0000319F  F9		      C             stc
			      C         .ENDIF
			      C     .ELSEIF (eax == 'stop')
 000031A0  E9 000000B5	   *	    jmp    @C01DA
 000031A5		   *@C01C8:
 000031A5  3D 73746F70	   *	    cmp    eax, 'stop'
 000031AA  0F 85 000000A9  *	    jne    @C01DB
			      C         .IF (ebx == 'load')
 000031B0  81 FB 6C6F6164  *	    cmp    ebx, 'load'
 000031B6  0F 85 0000009E  *	    jne    @C01DD
			      C           ; An error occurred during initialization
			      C           ;
			      C           ; Upon entry: ds:[esi] - far ptr to null-terminated ID string to display
			      C           ;
			      C           ; Upon exit:  No exit. This routine locks up Debi
			      C           ;
			      C           ; Clear the screens for this message
			      C           ; Mono
 000031BC  B8 00000030	      C             mov     eax,_sMONO
 000031C1  8E C0	      C             mov     es,eax
 000031C3  8E E0	      C             mov     fs,eax
 000031C5  33 FF	      C             xor     edi,edi
 000031C7  B9 000003E8	      C             mov     ecx,80*2*25 / 4
 000031CC  33 C0	      C             xor     eax,eax
 000031CE  F3/ AB	      C             rep     stosd
			      C 
			      C           ; VGA
 000031D0  B8 00000038	      C             mov     eax,_sVGA
 000031D5  8E C0	      C             mov     es,eax
 000031D7  33 FF	      C             xor     edi,edi
 000031D9  B9 000003E8	      C             mov     ecx,80*2*25 / 4
 000031DE  33 C0	      C             xor     eax,eax
 000031E0  F3/ AB	      C             rep     stosd
			      C 
			      C           ; Store the name they've provided
 000031E2  B9 00000050	      C             mov     ecx,80
 000031E7  33 FF	      C             xor     edi,edi
			      C             .REPEAT
 000031E9		   *@C01DF:
 000031E9  8A 06	      C                 mov     al,byte ptr ds:[esi]
			      C                 .IF (al != 0 && ecx != 80)
 000031EB  0A C0	   *	    or	al, al
 000031ED  74 08	   *	    je     @C01E0
 000031EF  83 F9 50	   *	    cmp    ecx, 050h
 000031F2  74 03	   *	    je     @C01E0
 000031F4  46		      C                     inc     esi
			      C                 .ELSE
 000031F5  EB 02	   *	    jmp    @C01E3
 000031F7		   *@C01E0:
 000031F7  B0 20	      C                     mov     al,32
			      C                 .ENDIF
 000031F9		   *@C01E3:
 000031F9  26: 88 07	      C                 mov     byte ptr es:[edi],al                        ; VGA
 000031FC  64: 88 07	      C                 mov     byte ptr fs:[edi],al                        ; Mono
 000031FF  47		      C                 inc     edi
 00003200  B0 70	      C                 mov     al,112
 00003202  26: 88 07	      C                 mov     byte ptr es:[edi],al
 00003205  64: 88 07	      C                 mov     byte ptr fs:[edi],al
 00003208  47		      C                 inc     edi
			      C             .UNTILCXZ
 00003209  E2 DE	   *	    loop   @C01DF
			      C 
			      C           ; Store the generic text
 0000320B  BE 00001D14 R      C             mov     esi,offset failed
 00003210  BF 00000320	      C             mov     edi,80*2*5
			      C             .WHILE (esi < offset failed_end)
 00003215  EB 35	   *	    jmp    @C01E4
 00003217		   *@C01E5:
 00003217  2E: 8A 06	      C                 mov     al,byte ptr cs:[esi]
 0000321A  46		      C                 inc     esi
			      C                 .IF (al == 13)
 0000321B  3C 0D	   *	    cmp    al, 00Dh
 0000321D  75 11	   *	    jne    @C01E6
			      C                   ; Move to start of current line
 0000321F  33 D2	      C                     xor     edx,edx
 00003221  8B C7	      C                     mov     eax,edi
 00003223  BB 000000A0	      C                     mov     ebx,80*2
 00003228  F7 F3	      C                     div     ebx
 0000322A  F7 E3	      C                     mul     ebx
 0000322C  8B F8	      C                     mov     edi,eax
			      C                 .ELSEIF (al == 10)
 0000322E  EB 1C	   *	    jmp    @C01E8
 00003230		   *@C01E6:
 00003230  3C 0A	   *	    cmp    al, 00Ah
 00003232  75 08	   *	    jne    @C01E9
			      C                   ; Move down one line
 00003234  81 C7 000000A0     C                     add     edi,80*2
			      C                 .ELSE
 0000323A  EB 10	   *	    jmp    @C01EB
 0000323C		   *@C01E9:
 0000323C  26: 88 07	      C                     mov     byte ptr es:[edi],al
 0000323F  64: 88 07	      C                     mov     byte ptr fs:[edi],al
 00003242  47		      C                     inc     edi
 00003243  B0 07	      C                     mov     al,7
 00003245  26: 88 07	      C                     mov     byte ptr es:[edi],al
 00003248  64: 88 07	      C                     mov     byte ptr fs:[edi],al
 0000324B  47		      C                     inc     edi
			      C                 .ENDIF
			      C             .ENDW
 0000324C		   *@C01EB:
 0000324C		   *@C01E8:
 0000324C		   *@C01E4:
 0000324C  81 FE 00001EBD R *	    cmp    esi, offset failed_end
 00003252  72 C3	   *	    jb     @C01E5
			      C 
			      C           ; Lock up the system
 00003254		      C           @@:
 00003254  F4		      C             hlt
 00003255  EB FD	      C             jmp @B
			      C         .ENDIF
			      C     .ELSE
 00003257  EB 01	   *	    jmp    @C01ED
 00003259		   *@C01DB:
 00003259  F9		      C         stc
			      C     .ENDIF
 0000325A		   *@C01ED:
 0000325A		   *@C01DA:
 0000325A		   *@C01C7:
 0000325A		   *@C019A:
 0000325A		   *@C018D:
 0000325A		   *@C0154:
 0000325A		   *@C014F:
 0000325A		   *@C0141:
 0000325A		   *@C013B:
 0000325A		   *@C0152:
 0000325A		   *@C0199:
 0000325A		   *@C0198:
 0000325A		   *@C01C6:
 0000325A		   *@C01BD:
 0000325A		   *@C01B4:
 0000325A		   *@C01AE:
 0000325A		   *@C01A8:
 0000325A		   *@C01A2:
 0000325A		   *@C01A1:
 0000325A		   *@C01A7:
 0000325A		   *@C01AD:
 0000325A		   *@C01B3:
 0000325A		   *@C01BC:
 0000325A		   *@C01BB:
 0000325A		   *@C01C5:
 0000325A		   *@C01C4:
 0000325A		   *@C01D9:
 0000325A		   *@C01D1:
 0000325A		   *@C01D0:
 0000325A		   *@C01D8:
 0000325A		   *@C01DD:
			      C 
 0000325A		      C   requestor_quit:
 0000325A  61		      C     popad
 0000325B  0F A1	      C     pop     fs
 0000325D  C9		      C     leave
 0000325E  CB		      C     retf
 0000325F		      C requestor       ENDP
			      C 

 0000325F			end_of_32_bit_segment:
 325F				_TEXT32 ENDS


				END
