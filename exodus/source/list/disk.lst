Microsoft (R) Macro Assembler Version 6.11a		    03/08/09 18:22:58
Disk							     Page 1 - 1


				; disk.asm
				;
				; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				; ³ Exodus Disk Primatives ³
				; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				;
				; Exodus native primative disk driver
				; This routines handles all logical disk functions as well as internal drive scheduling
				;


				TITLE Disk

				    .MODEL tiny

				    .STACK 0h

				INCLUDE \exodus\source\common\equates.asp
			      C ; equates.asp
			      C ;
			      C ; Exodus constants.  These are used at various places.
			      C ; This file provides a common area to modify constant values, rather than sifting through programs, etc.
			      C ;
			      C 
			      C 
			      C 
			      C INCLUDE x86_eq.asp
			      C ; x86_eq.asp
			      C ;
			      C ; Constants specific to the Intel architecture
			      C ;
			      C 
			      C 
			      C 
 = 0000			      C _TSS_BACK_LINK              EQU 0
 = 0004			      C _TSS_ESP0                   EQU 4
 = 0008			      C _TSS_SS0                    EQU 8
 = 000C			      C _TSS_ESP1                   EQU 12
 = 0010			      C _TSS_SS1                    EQU 16
 = 0014			      C _TSS_ESP2                   EQU 20
 = 0018			      C _TSS_SS2                    EQU 24
 = 001C			      C _TSS_CR3                    EQU 28
 = 0020			      C _TSS_EIP                    EQU 32
 = 0024			      C _TSS_EFLAGS                 EQU 36
 = 0028			      C _TSS_EAX                    EQU 40
 = 002C			      C _TSS_ECX                    EQU 44
 = 0030			      C _TSS_EDX                    EQU 48
 = 0034			      C _TSS_EBX                    EQU 52
 = 0038			      C _TSS_ESP                    EQU 56
 = 003C			      C _TSS_EBP                    EQU 60
 = 0040			      C _TSS_ESI                    EQU 64
 = 0044			      C _TSS_EDI                    EQU 68
 = 0048			      C _TSS_ES                     EQU 72
 = 004C			      C _TSS_CS                     EQU 76
 = 0050			      C _TSS_SS                     EQU 80
 = 0054			      C _TSS_DS                     EQU 84
 = 0058			      C _TSS_FS                     EQU 88
 = 005C			      C _TSS_GS                     EQU 92
 = 0060			      C _TSS_LDT                    EQU 96
 = 0064			      C _TSS_TRAP_BIT               EQU 100
 = 0001			      C _TSS_TRAP_BIT_MASK          EQU 1b
 = 0066			      C _TSS_IO_MAP                 EQU 102
			      C ; The following area is used by Exodus.  It appears immediate after the TSS in memory
 = 0068			      C _TSS_FPU_SAVE_AREA          EQU 104
			      C 
			      C 
			      C ; EFLAGS register constants to access individual flags
 = 0000			      C _EFLAGS_CF                  EQU 0
 = 0002			      C _EFLAGS_PF                  EQU 2
 = 0004			      C _EFLAGS_ACF                 EQU 4
 = 0006			      C _EFLAGS_ZF                  EQU 6
 = 0007			      C _EFLAGS_SF                  EQU 7
 = 0008			      C _EFLAGS_TF                  EQU 8
 = 0009			      C _EFLAGS_IF                  EQU 9
 = 000A			      C _EFLAGS_DF                  EQU 10
 = 000B			      C _EFLAGS_OF                  EQU 11
 = 000C			      C _EFLAGS_IOPL                EQU 12
 = 000E			      C _EFLAGS_NT                  EQU 14
 = 0010			      C _EFLAGS_RF                  EQU 16
 = 0011			      C _EFLAGS_VM                  EQU 17
			      C ; Masks to access specific bits
 = 0001			      C _EFLAGS_CF_MASK             EQU  1b SHL _EFLAGS_CF
 = 0004			      C _EFLAGS_PF_MASK             EQU  1b SHL _EFLAGS_PF
 = 0010			      C _EFLAGS_ACF_MASK            EQU  1b SHL _EFLAGS_ACF
 = 0040			      C _EFLAGS_ZF_MASK             EQU  1b SHL _EFLAGS_ZF
 = 0080			      C _EFLAGS_SF_MASK             EQU  1b SHL _EFLAGS_SF
 = 0100			      C _EFLAGS_TF_MASK             EQU  1b SHL _EFLAGS_TF
 = 0200			      C _EFLAGS_IF_MASK             EQU  1b SHL _EFLAGS_IF
 = 0400			      C _EFLAGS_DF_MASK             EQU  1b SHL _EFLAGS_DF
 = 0800			      C _EFLAGS_OF_MASK             EQU  1b SHL _EFLAGS_OF
 = 3000			      C _EFLAGS_IOPL_MASK           EQU 11b SHL _EFLAGS_IOPL
 = 4000			      C _EFLAGS_NT_MASK             EQU  1b SHL _EFLAGS_NT
 = 00010000		      C _EFLAGS_RF_MASK             EQU  1b SHL _EFLAGS_RF
 = 00020000		      C _EFLAGS_VM_MASK             EQU  1b SHL _EFLAGS_VM
			      C 
 = 1000			      C _CW_INFINITY                EQU 1000000000000b
 = 0C00			      C _CW_ROUNDING                EQU  110000000000b
 = 0000			      C _CW_ROUNDING_00             EQU  000000000000b
 = 0400			      C _CW_ROUNDING_01             EQU  010000000000b
 = 0800			      C _CW_ROUNDING_10             EQU  100000000000b
 = 0C00			      C _CW_ROUNDING_11             EQU  110000000000b
 = 0300			      C _CW_PRECISION               EQU    1100000000b
 = 0000			      C _CW_PRECISION_00            EQU    0000000000b
 = 0100			      C _CW_PRECISION_01            EQU    0100000000b
 = 0200			      C _CW_PRECISION_10            EQU    1000000000b
 = 0300			      C _CW_PRECISION_11            EQU    1100000000b
 = 0020			      C _CW_PM                      EQU        100000b
 = 0010			      C _CW_UM                      EQU         10000b
 = 0008			      C _CW_OM                      EQU          1000b
 = 0004			      C _CW_ZM                      EQU           100b
 = 0002			      C _CW_DM                      EQU            10b
 = 0001			      C _CW_IM                      EQU             1b
			      C 
 = 8000			      C _SW_BUSY                    EQU 1000000000000000b
 = 4000			      C _SW_C3                      EQU  100000000000000b
 = 3800			      C _SW_TOS                     EQU   11100000000000b
 = 0400			      C _SW_C2                      EQU      10000000000b
 = 0200			      C _SW_C1                      EQU       1000000000b
 = 0100			      C _SW_C0                      EQU        100000000b
 = 0080			      C _SW_ERROR_SUMMARY           EQU         10000000b
 = 0040			      C _SW_STACK_FAULT             EQU          1000000b
 = 0020			      C _SW_PE                      EQU           100000b
 = 0010			      C _SW_UE                      EQU            10000b
 = 0008			      C _SW_OE                      EQU             1000b
 = 0004			      C _SW_ZE                      EQU              100b
 = 0002			      C _SW_DE                      EQU               10b
 = 0001			      C _SW_IE                      EQU                1b
			      C 
			      C 
			      C 
			      C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			      C ; ³ GDT ENTRIES ³
			      C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 = 0008			      C     _sIDT                       EQU 1 * 8       ; IDT
 = 0010			      C     _sGDT                       EQU 2 * 8       ; GDT
 = 0018			      C     _sSTACK                     EQU 3 * 8       ; STACK
 = 0020			      C     _sCODE                      EQU 4 * 8       ; kernel CODE for kernel code
 = 0048			      C     _sDATA                      EQU 9 * 8       ; kernel DATA selector for kernel data
 = 0028			      C     _sGRAPHICS                  EQU 5 * 8       ; Graphics video (0a0000h)
 = 0030			      C     _sMONO                      EQU 6 * 8       ; Mono video (0b0000h)
 = 0038			      C     _sVGA                       EQU 7 * 8       ; VGA video (0b8000h)
 = 0040			      C     _sALL_MEM                   EQU 8 * 8       ; All memory (for debugging)
			      C     ; 9 is above, _sDATA
 = 0050			      C     _sEXODUS_MEM                EQU 10 * 8      ; Exodus assigned memory
 = 0058			      C     _sEXODUS_PORTS              EQU 11 * 8      ; Exodus assigned ports
 = 0060			      C     _sEXODUS_INTS               EQU 12 * 8      ; Exodus assigned ints
			      C     ;_sNOT_USED                                 ; available
 = 0070			      C     _sEXODUS_TSS                EQU 14 * 8      ; Exodus TSS
 = 0078			      C     _sEXODUS_TASK_GATE          EQU 15 * 8      ; Exodus kernel task gate (points to _sEXODUS_TSS)
 = 0080			      C     _sEXODUS_SLAVE_TSS          EQU 16 * 8      ; Exodus Slave TSS
 = 0088			      C     _sEXODUS_SLAVE_TASK_GATE    EQU 17 * 8      ; Exodus kernel slave task gate (points to _sEXODUS_SLAVE_TSS)
			      C     ;_sNOT USED
 = 0098			      C     _sPRIMATIVES                EQU 19 * 8      ; Primative structure for natives
 = 00A0			      C     _sPRIMATIVE_LOAD_INFO       EQU 20 * 8      ; Primative load information (for reporting on each driver)
 = 00A8			      C     _sSYSTEM                    EQU 21 * 8      ; Exodus system memory
 = 00B0			      C     _sEXODUS_REQUESTOR          EQU 22 * 8      ; Call gate to Exodus's requestor() function
 = 00B8			      C     _sSYSTEM_RING1              EQU 23 * 8      ; Exodus system memory for ring-1 apps
 = 00C0			      C     _sSYSTEM_RING2              EQU 24 * 8      ; Exodus system memory for ring-2 apps
 = 00C8			      C     _sSYSTEM_RING3              EQU 25 * 8      ; Exodus system memory for ring-3 apps
 = 00D0			      C     _sDEBI_screen               EQU 26 * 8      ; low-level DEBI debugger's save screen buffer
 = 00D8			      C     _sDEBI_memory               EQU 27 * 8      ; low-level DEBI debugger's memory
 = 00E0			      C     _sFLOPPY_TRACK              EQU 28 * 8      ; Floppy disk data I/O for one full track
 = 00E8			      C     _sVGA_BACKUP                EQU 29 * 8      ; VGA video (060000h, used when in a graphics mode so writes
			      C                                                 ;  to the text screen are still valid)
 = 00F0			      C     _sDEBI_screen2              EQU 30 * 8      ; low-level DEBI debugger's save screen buffer2 (for popups and menus)
 = 00F8			      C     _sDEBI_temp                 EQU 31 * 8      ; low-level DEBI debugger's temporary selector (used for various things)
 = 0100			      C     _sEXODUS_OBJECTS            EQU 32 * 8      ; Exodus objects
 = 0108			      C     _sTASK_SWITCH_TSS           EQU 33 * 8      ; Task Manager's switch_task() function
 = 0110			      C     _sTASK_SWITCH_TASK_GATE     EQU 34 * 8      ; Task Manager's task gate (points to _sTASK_SWITCH_TSS)
 = 0118			      C     _sTASK_STACK                EQU 35 * 8      ; Task Manger task's stack
 = 0120			      C     _sSTACK0                    EQU 36 * 8      ; Exodus Stack 0
 = 0128			      C     _sSTACK1                    EQU 37 * 8      ; Exodus Stack 1
 = 0130			      C     _sSTACK2                    EQU 38 * 8      ; Exodus Stack 2
 = 0138			      C     _sDEBI_dt                   EQU 39 * 8      ; low-level DEBI debugger's DT storage
 = 0140			      C     _sDEBI_np                   EQU 40 * 8      ; low-level DEBI debugger's NP storage
 = 0148			      C     _sDEBI_rp                   EQU 41 * 8      ; low-level DEBI debugger's RP storage
			      C 
			      C   ; Variable base/limit GDT slots setup in INIT32.ASP
 = 0190			      C     _sEXODUS_INI                EQU 50 * 8      ; Holds the parsed EXODUS.INI sructure
 = 0198			      C     _sEXODUS_INI_ERRORS         EQU 51 * 8      ; Holds any errors found while parsing EXODUS.INI
 = 01A0			      C     _sTASK_SYSTEM               EQU 52 * 8      ; Holds all tasks
			      C 
 = 5DA0			      C     _cgTEMP_PRIMATIVE_MAIN      EQU 2996 * 8
 = 5DA8			      C     _cgTEMP_PRIMATIVE_REQUESTOR EQU 2997 * 8
 = 5DB0			      C     _csTEMP_PRIMATIVE           EQU 2998 * 8
 = 5DB8			      C     _dsTEMP_PRIMATIVE           EQU 2999 * 8
			      C 
			      C 
			      C 
			      C ; ÚÄÄÄÄÄÄÄÄÄÄÄ¿
			      C ; ³ CONSTANTS ³
			      C ; ÀÄÄÄÄÄÄÄÄÄÄÄÙ
 = 00C8			      C     _MIN_PRIMATIVE              EQU 200                             ; Start of the primatives
 = 0BB3			      C     _MAX_PRIMATIVE              EQU 2995                            ; End of the primatives
 = 0FFF			      C     _lastGDT                    EQU 4095                            ; Last valid GDT in the GDT
 = 0032			      C     _firstASSIGNMENT            EQU 50                              ; The first Exodus assigned GDT entry for various items
 = 00C7			      C     _lastASSIGNMENT             EQU 199                             ; The last Exodus assigned GDT entry for various items
 = 0BB8			      C     _firstUSER_ASSIGNMENT       EQU 3000
 = 0FFF			      C     _lastUSER_ASSIGNMENT        EQU 4095
 = 00C7			      C     _sGDT_init                  EQU 199                             ; Only initialize the first 199 GDT entries
			      C 
			      C 
			      C   ; Required memory structures for Exodus
			      C   ; Refer to Bootup(internal) document for definitive memory locations
 = 0008A000		      C     _sIDT_base                  EQU 8a000h
 = 0800			      C     _sIDT_limit                 EQU 800h
 = 0800			      C     _sGDT_base                  EQU 0800h
 = 8000			      C     _sGDT_limit                 EQU 8000h
 = 00098000		      C     _sSTACK_base                EQU 98000h
 = 8000			      C     _sSTACK_limit               EQU 8000h
 = 00010000		      C     _sCODE_base                 EQU 10000h
 = 00040000		      C     _sCODE_limit                EQU 40000h
 = 00010000		      C     _sDATA_base                 EQU 10000h
 = 00030000		      C     _sDATA_limit                EQU 30000h
 = 000A0000		      C     _sGRAPHICS_base             EQU 0a0000h
 = 00010000		      C     _sGRAPHICS_limit            EQU 10000h
 = 000B0000		      C     _sMONO_base                 EQU 0b0000h
 = 8000			      C     _sMONO_limit                EQU 8000h
 = 000B8000		      C     _sVGA_base                  EQU 0b8000h     ; Also, see _sVGA_BACKUP_ below
 = 8000			      C     _sVGA_limit                 EQU 8000h
 = 0000			      C     _sALL_MEM_base              EQU 0
 = FFFFFFFF		      C     _sALL_MEM_limit             EQU 0ffffffffh
 = 00070C00		      C     _sEXODUS_MEM_base           EQU 70c00h
 = 4000			      C     _sEXODUS_MEM_limit          EQU 4000h
 = 0006CC00		      C     _sEXODUS_PORTS_base         EQU 6cc00h
 = 4000			      C     _sEXODUS_PORTS_limit        EQU 4000h
 = 00097E00		      C     _sEXODUS_INTS_base          EQU 97e00h
 = 0200			      C     _sEXODUS_INTS_limit         EQU 200h
 = 00068100		      C     _sEXODUS_TSS_base           EQU 68100h
 = 0100			      C     _sEXODUS_TSS_limit          EQU 100h        ; 256 bytes
			      C    ;_sEXODUS_TASK_GATE          EQU task gate pointing to _sEXODUS_TSS
 = 00068200		      C     _sEXODUS_SLAVE_TSS_base     EQU 68200h
 = 0100			      C     _sEXODUS_SLAVE_TSS_limit    EQU 100h        ; 256 bytes
 = 0008D380		      C     _sPRIMATIVES_base           EQU 8d380h
 = 4000			      C     _sPRIMATIVES_limit          EQU 4000h       ; 16k
 = 0008C380		      C     _sPRIMATIVE_LOAD_INFO_base  EQU 8c380h
 = 1000			      C     _sPRIMATIVE_LOAD_INFO_limit EQU 1000h       ; 4k
 = 00089400		      C     _sSYSTEM_base               EQU 89400h
 = 0C00			      C     _sSYSTEM_limit              EQU 0c00h       ; 3k
 = 0800			      C     _sSYSTEM_USER_limit         EQU 0800h       ; 2k
 = 00281400		      C     _sDEBI_screen_base          EQU 281400h                         ; ; ; ; ; Added 2 MB, 02/26/2009 - RCH
 = 8000			      C     _sDEBI_screen_limit         EQU 8000h       ; 32k
 = 00279400		      C     _sDEBI_memory_base          EQU 279400h                         ; ; ; ; ; Added 2 MB, 02/26/2009 - RCH
 = 8000			      C     _sDEBI_memory_limit         EQU 8000h       ; 32k
 = 00074C00		      C     _sFLOPPY_TRACK_base         EQU 74c00h
 = 4800			      C     _sFLOPPY_TRACK_limit        EQU 4800h       ; 512 bytes per sector * 18 sectors * 2 sides = 18k
 = 00060000		      C     _sVGA_BACKUP_base           EQU 60000h      ; Note, the backup area is used when in graphics modes that use a0000h
 = 8000			      C     _sVGA_BACKUP_limit          EQU 8000h       ; so all video writes to the text window are still saved
 = 00258000		      C     _sDEBI_screen2_base         EQU 258000h
 = 00028000		      C     _sDEBI_screen2_limit        EQU 28000h       ; 32k
 = 00068000		      C     _sTASK_SWITCH_TSS_base      EQU 68000h
 = 0100			      C     _sTASK_SWITCH_TSS_limit     EQU 100h        ; 256 bytes
 = 00220000		      C     _sTASK_STACK_base           EQU 220000h                         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 8000			      C     _sTASK_STACK_limit          EQU 8000h       ; 32k
 = 00095380		      C     _sSTACK0_base               EQU 95380h
 = 2000			      C     _sSTACK0_limit              EQU 2000h       ; 8k
 = 00093380		      C     _sSTACK1_base               EQU 93380h
 = 2000			      C     _sSTACK1_limit              EQU 2000h       ; 8k
 = 00091380		      C     _sSTACK2_base               EQU 91380h
 = 2000			      C     _sSTACK2_limit              EQU 2000h       ; 8k
 = 00240000		      C     _sDEBI_dt_base              EQU 240000h                         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 8000			      C     _sDEBI_dt_limit             EQU 8000h       ; 32k
 = 00248000		      C     _sDEBI_np_base              EQU 248000h                         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 8000			      C     _sDEBI_np_limit             EQU 8000h       ; 32k
 = 00250000		      C     _sDEBI_rp_base              EQU 250000h                         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 8000			      C     _sDEBI_rp_limit             EQU 8000h       ; 32k
			      C 
 = 00050000		      C     _sEXODUS_OBJECTS_base       EQU 50000h
 = 8000			      C     _sEXODUS_OBJECTS_limit      EQU 8000h       ; 32k
 = 00200000		      C     _sEXODUS_INI_base           EQU 200000h     ; 1MB               ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 00010000		      C     _sEXODUS_INI_limit          EQU 10000h      ; 64k
 = 00210000		      C     _sEXODUS_INI_ERRORS_base    EQU 210000h     ; 1MB + 64k         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 4000			      C     _sEXODUS_INI_ERRORS_limit   EQU 4000h       ; 16k
 = 00210000		      C     _sTASK_SYSTEM_base          EQU 210000h     ; 1MB + 64k         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 00010000		      C     _sTASK_SYSTEM_limit         EQU 010000h     ; 64k
			      C 
			      C 
			      C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			      C ; ³ BOOT DT STRUCTURE ³
			      C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 = 0000			      C     _BOOT_DT_object_type        EQU 0
 = 0001			      C     _BOOT_DT_days               EQU 1
 = 0005			      C     _BOOT_DT_seconds            EQU 5
 = 0008			      C     _BOOT_DT_rp_offset          EQU 8
 = 000A			      C     _BOOT_DT_entry_type         EQU 10
 = 000B			      C     _BOOT_DT_np_offset          EQU 11
			      C 
			      C 
			      C 
			      C 
			      C 
			      C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			      C ; ³ BOOT PARAMETER BLOCK STRUCTURE ³
			      C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 = 0000			      C     _BOOT_PB_size               EQU 0
 = 0004			      C     _BOOT_PB_main               EQU 4
 = 0008			      C     _BOOT_PB_requestor          EQU 8
 = 000C			      C     _BOOT_PB_start_head         EQU 12
 = 000D			      C     _BOOT_PB_start_track        EQU 13
 = 000E			      C     _BOOT_PB_start_sector       EQU 14
 = 0010			      C     _BOOT_PB_end_head           EQU 16
 = 0011			      C     _BOOT_PB_end_track          EQU 17
 = 0012			      C     _BOOT_PB_end_sector         EQU 18
 = 0014			      C     _BOOT_PB_entry_type         EQU 20
 = 0016			      C     _BOOT_PB_linear_offset      EQU 22
 = 001A			      C     _BOOT_PB_dt_offset          EQU 26
 = 001C			      C     _BOOT_PB_crc16              EQU 28
 = 0020			      C     _BOOT_PB_structure_size     EQU 32
			      C 
			      C 
			      C 
			      C 
			      C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			      C ; ³ EXODUS.INI STRUCTURES ³
			      C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 = 0000			      C     _EXODUS_INI_FIRST_BRACKET       EQU 0
 = 0004			      C     _EXODUS_INI_TOTAL_BYTES         EQU 4
 = 0008			      C     _EXODUS_INI_TOTAL_BRACKET_GROUPS EQU 8
 = 000C			      C     _EXODUS_INI_TOTAL_PAREN_CASKS   EQU 12
 = 0010			      C     _EXODUS_INI_HEADER_LENGTH       EQU 16
			      C 
 = 0000			      C     _EXODUS_BRACKET_NEXT            EQU 0
 = 0004			      C     _EXODUS_BRACKET_PAREN_CASKS     EQU 4
 = 0008			      C     _EXODUS_BRACKET_TOTAL_PARENS    EQU 8
 = 000C			      C     _EXODUS_BRACKET_NAME            EQU 12
 = 0010			      C     _EXODUS_BRACKET_HANDLE          EQU 16
 = 0014			      C     _EXODUS_BRACKET_REQUESTOR       EQU 20
 = 0016			      C     _EXODUS_BRACKET_REQUESTOR_FUNC  EQU 22
 = 001A			      C     _EXODUS_BRACKET_SCRATCH_AREA    EQU 26
 = 001E			      C     _EXODUS_BRACKET_LENGTH          EQU 30
			      C 
 = 0000			      C     _EXODUS_PAREN_NEXT              EQU 0
 = 0004			      C     _EXODUS_PAREN_NEXT_SAME_LINE    EQU 4
 = 0008			      C     _EXODUS_PAREN_DATA_ITEMS        EQU 8
 = 000C			      C     _EXODUS_PAREN_TOTAL_DATA_ITEMS  EQU 12
 = 0010			      C     _EXODUS_PAREN_SOURCE_LINE       EQU 16
 = 0014			      C     _EXODUS_PAREN_SOURCE_LINE_LENGTH EQU 20
 = 0018			      C     _EXODUS_PAREN_HANDLE            EQU 24
 = 001A			      C     _EXODUS_PAREN_REQUESTOR         EQU 26
 = 001E			      C     _EXODUS_PAREN_REQUESTOR_FUNC    EQU 30
 = 0022			      C     _EXODUS_PAREN_SCRATCH_AREA      EQU 34
 = 0026			      C     _EXODUS_PAREN_LENGTH            EQU 38
			      C 
 = 0000			      C     _EXODUS_DATA_NEXT               EQU 0
 = 0004			      C     _EXODUS_DATA_DATA_ITEM_SOURCE   EQU 4
 = 0008			      C     _EXODUS_DATA_DATA_ITEM_LENGTH   EQU 8
 = 000C			      C     _EXODUS_DATA_LENGTH             EQU 12
			      C 
			      C 
			      C 
			      C 
			      C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			      C ; ³ EXODUS xxx STRUCTURES ³
			      C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 = 0000			      C     _EXODUS_MEM_type                EQU 0
 = 0004			      C     _EXODUS_MEM_base                EQU 4
 = 0008			      C     _EXODUS_MEM_limit               EQU 8
 = 000C			      C     _EXODUS_MEM_gdt                 EQU 12
 = 000E			      C     _EXODUS_MEM_ldt                 EQU 14
 = 0010			      C     _EXODUS_MEM_size                EQU 16
			      C 
 = 0010			      C     _EXODUS_PORTS_size              EQU 16
			      C 
 = 0002			      C     _EXODUS_INTS_size               EQU 2
			      C 
			      C 
			      C 
			      C 
			      C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			      C ; ³ EXODUS SYSTEM MEMORY ³
			      C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			      C ; Note, when updates are made here they need to be reflected in INF\SYSTEM.INF
			      C ; Note, when updates are made here and INF\SYSTEM.INF, the "Exodus Quick Reference" manual needs to be updated
 = 0000			      C     _SYSTEM_SECONDS_SINCE_BOOTUP    EQU 0                           ; dword
 = 0004			      C     _SYSTEM_SECONDS_SINCE_MIDNIGHT  EQU 4                           ; dword
 = 0008			      C     _SYSTEM_HOURS                   EQU 8                           ; byte
 = 0009			      C     _SYSTEM_MINUTES                 EQU 9                           ; byte
 = 000A			      C     _SYSTEM_SECONDS                 EQU 10                          ; byte
 = 000B			      C     _SYSTEM_182S_OF_A_SECOND        EQU 11                          ; byte
 = 000C			      C     _SYSTEM_DAY                     EQU 12                          ; byte
 = 000D			      C     _SYSTEM_MONTH                   EQU 13                          ; byte
 = 000E			      C     _SYSTEM_YEAR                    EQU 14                          ; word
 = 0010			      C     _SYSTEM_DAY_OF_YEAR             EQU 16                          ; word
 = 0012			      C     _SYSTEM_BUILD                   EQU 18                          ; 10-byte string in the format: "mm.dd.yyyy"
 = 001C			      C     _SYSTEM_TOTAL_MEMORY            EQU 28                          ; dword, total ram in bytes
 = 0020			      C     _SYSTEM_VGA_HORIZONTAL          EQU 32                          ; word (pixels-graphics, or columns-text)
 = 0022			      C     _SYSTEM_VGA_VERTICAL            EQU 34                          ; word (pixels-graphics, or rows-text)
 = 0024			      C     _SYSTEM_VGA_VIDEO_MODE          EQU 36                          ; byte (0-graphics, 1-text)
 = 0025			      C     _SYSTEM_MONO_VIDEO_MODE         EQU 37                          ; byte (0-graphics, 1-text, 0ffh-Unknown)
			      C 
			      C   ; Non-user accessible system memory areas (Exodus internal, hence the use of the _i_)
 = 0800			      C     _SYSTEM_i_FATAL                 EQU 2048                        ; dword
 = 0804			      C     _SYSTEM_i_TASKS_CREATED         EQU 2052                        ; dword
 = 0808			      C     _SYSTEM_i_TASKS_BY_USER         EQU 2056                        ; dword
 = 080C			      C     _SYSTEM_i_TASKS_BY_ERROR        EQU 2060                        ; dword
 = 0810			      C     _SYSTEM_i_IRQ6_INDICATOR        EQU 2064                        ; byte, IRQ6 indicator (changes each time an IRQ6 is signaled)
 = 0811			      C     _SYSTEM_i_IRQ6_INDICATOR_LAST   EQU 2065                        ; byte, IRQ6 indicator previous, used to see when an IRQ6 is signaled
 = 0812			      C     _SYSTEM_i_BASE                  EQU 2066                        ; dword
 = 0816			      C     _SYSTEM_i_LIMIT                 EQU 2070                        ; dword
 = 081A			      C     _SYSTEM_i_DWORD_TO_COPY         EQU 2074                        ; word
 = 081C			      C     _SYSTEM_i_LAST_GDT_REFERENCED   EQU 2076                        ; qword
 = 0824			      C     _SYSTEM_i_CODE_GDT_OFFSET       EQU 2084                        ; dword (used temporarily during native primative install)
 = 0828			      C     _SYSTEM_i_DATA_GDT_OFFSET       EQU 2088                        ; dword (used temporarily during native primative install)
 = 082C			      C     _SYSTEM_i_MAIN_GDT_OFFSET       EQU 2092                        ; dword (used temporarily during native primative install)
 = 0830			      C     _SYSTEM_i_REQUESTOR_GDT_OFFSET  EQU 2096                        ; dword (used temporarily during native primative install)
 = 0834			      C     _SYSTEM_i_GDT_TO_ASSIGN         EQU 2100                        ; word (used various places to assign GDT entries)
 = 0836			      C     _SYSTEM_i_USER_GDT_TO_ASSIGN    EQU 2102                        ; word (used various places to assign USER Program GDTs)
			      C   ; Next offset is 2104
			      C 
			      C 
			      C   ; These scratch items exist from end of memory down
 = 0BF8			      C     _SYSTEM_i_SCRATCH_DWORD2        EQU 3064                        ; dword (used various places as a scratch buffer)
 = 0BFC			      C     _SYSTEM_i_SCRATCH_DWORD1        EQU 3068                        ; dword (used various places as a scratch buffer)
			      C 
			      C 
			      C 
			      C 
			      C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			      C ; ³ BOCHS SUPPORT ³
			      C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			      C ; These equates are used to communicate via INT 0FFh
			      C ; Values here are in ecx, with edx being used for data information.
			      C ; Values in eax must be
 = 12345678		      C     _BOCHS1                         EQU 12345678h
 = 87654321		      C     _BOCHS2                         EQU 87654321h
 = 0000			      C     _BOCHS_GET_MONO_MOUSE_XY        EQU 0
 = 0001			      C     _BOCHS_GET_MONO_CURSOR          EQU 1
			      C 
				INCLUDE \exodus\source\common\macros.asp
			      C ; macros.asp
			      C ;
			      C ; Exodus macros, used various places
			      C ;
			      C 
			      C 
			      C 
			      C callfp     MACRO   _seg:REQ, _offset:REQ
			      C ; This macro:   callfp  _code_seg, _offset
			      C ;
			      C     db  9ah
			      C     dd  _offset
			      C     dw  _seg
			      C ENDM
			      C 
			      C 
			      C 
			      C 
			      C callg      MACRO   _seg:REQ
			      C ; This macro:   callg   _call_gate
			      C     db  9ah
			      C     dd  0
			      C     dw  _seg
			      C ENDM
			      C 
			      C 
			      C 
			      C 
			      C jmpg       MACRO   _seg:REQ
			      C ; This macro:   jmpg    _call_gate
			      C     db  0eah
			      C     dd  0
			      C     dw  _seg
			      C ENDM
			      C 
			      C 
			      C 
			      C 
			      C callf      MACRO   _func:REQ
			      C ; This macro:   callf   function_name
			      C     push    cs
			      C     call    _func
			      C ENDM
			      C 
			      C 
			      C 
			      C 
			      C @IO_pause   MACRO
			      C     jmp     $+2
			      C ENDM
			      C 

				    .386P
 00000000			_TEXT32 SEGMENT BYTE 'CODE' USE32
				    ASSUME NOTHING

				; These are required to be the first 2 dwords in the file
 00000000  00000087 R		dd  offset main
 00000004  00000008 R		dd  offset requestor




 00000008			    requestor   PROC
				    ; This routine is called by Exodus.  When this function is called multi-tasking is not installed.  This is a linear function.
				    ;
				    ; Upon entry:   eax - requested function
				    ;                ds - temporary ORG 0h data segment for use with these requestor() functions
				    ;
				    ; Upon exit:    results vary based on value of eax
				    ;
				        .IF (eax == 'info')
 00000008  3D 696E666F	   *	    cmp    eax, 'info'
 0000000D  75 26	   *	    jne    @C0001
				          ; Program information
 0000000F  B8 6E617469		            mov     eax,'nati'                              ; Identifying this program as a native primative
 00000014  B9 000003CC R	            mov     ecx,offset end_of_required_data         ; The maximum number of bytes to retain after loading

 00000019  BE 000003CC R	            mov     esi,offset driver_primatives            ; Offset to the native primatives structure
 0000001E  BF 000000B3 R	            mov     edi,offset driver_name
 00000023  BB 000000D1 R	            mov     ebx,offset version
 00000028  BA 000000E1 R	            mov     edx,offset copyright
 0000002D  BD 00000101 R	            mov     ebp,offset author
 00000032  F8			            clc
				        .ELSEIF (eax == 'prim')
 00000033  EB 51	   *	    jmp    @C0003
 00000035		   *@C0001:
 00000035  3D 7072696D	   *	    cmp    eax, 'prim'
 0000003A  75 14	   *	    jne    @C0004
				          ; Native primatives this program will use
 0000003C  66| 8C 1D		            mov     ds:data_segment,ds
	   00000136 R
 00000043  BE 00000142 R	            mov     esi,offset required_primatives          ; This primative requires these functions
 00000048  BF 0000013A R	            mov     edi,offset primative_call_gates
 0000004D  F8			            clc
				        .ELSEIF (eax == 'id  ')
 0000004E  EB 36	   *	    jmp    @C0006
 00000050		   *@C0004:
 00000050  3D 69642020	   *	    cmp    eax, 'id  '
 00000055  75 0F	   *	    jne    @C0007
				          ; Display this program's ID on the VGA monitor
 00000057  BE 000000B3 R	            mov     esi,offset driver_name
 0000005C  2E: FF 1D		            call    fword ptr cs:_VID_display_string_nr_vga
	   0000013C R
 00000063  F8			            clc
				        .ELSEIF (eax == 'note')
 00000064  EB 20	   *	    jmp    @C0009
 00000066		   *@C0007:
 00000066  3D 6E6F7465	   *	    cmp    eax, 'note'
 0000006B  75 18	   *	    jne    @C000A
 0000006D  B8 73746F70		            mov     eax,'stop'
 00000072  BB 6C6F6164		            mov     ebx,'load'
 00000077  BE 000000B3 R	            mov     esi,offset driver_name
 0000007C  2E: FF 1D		            call    fword ptr cs:_EXODUS_requestor
	   00000138 R
				        .ELSE
 00000083  EB 01	   *	    jmp    @C000C
 00000085		   *@C000A:
 00000085  F9			            stc
				        .ENDIF
 00000086		   *@C000C:
 00000086		   *@C0009:
 00000086		   *@C0006:
 00000086		   *@C0003:
 00000086  CB			        retf
 00000087			    requestor   ENDP




 00000087			    main    PROC
				    ; This routine is called once by Exodus once initialization is complete (all calls to requestor() are finished)
				    ; It is used by Exodus to allow this driver to properly initialize itself.
				    ; When this function is called multi-tasking is not installed.  This is a linear function.
				    ;
				    ; Upon entry:   Nothing
				    ;
				    ; Upon exit:    A "continued status of execution" is expected by Exodus.  This indicates whether or not everything
				    ;               initialized ok or is available.  If everything is OK the carry? flag is CLEAR.  If there is an error
				    ;               and this driver cannot continue then the carry? should be SET.
				    ;               carry? - CLEAR=Ok to continue
				    ;                          SET=Error initializing
				    ;
 00000087  66| 2E: 8E 1D	        mov     ds,cs:data_segment
	   00000136 R
 0000008F  C6 05 00000135 R	        mov     ds:bootup,0
	   00
 00000096  E8 0000000A		        call    initialize_driver
				      ; Right now, carry? is SET or CLEAR indicating status of driver
 0000009B  CB			        retf
 0000009C			    main    ENDP




 0000009C			    DISK_open_file      PROC
 0000009C  CB			        retf
 0000009D			    DISK_open_file      ENDP




 0000009D			    DISK_read_file      PROC
 0000009D  CB			        retf
 0000009E			    DISK_read_file      ENDP




 0000009E			    DISK_seek_file      PROC
 0000009E  CB			        retf
 0000009F			    DISK_seek_file      ENDP




 0000009F			    DISK_insert_file        PROC
 0000009F  CB			        retf
 000000A0			    DISK_insert_file        ENDP




 000000A0			    DISK_write_file     PROC
 000000A0  CB			        retf
 000000A1			    DISK_write_file     ENDP




 000000A1			    DISK_close_file     PROC
 000000A1  CB			        retf
 000000A2			    DISK_close_file     ENDP




 000000A2			    DISK_delete_file        PROC
 000000A2  CB			        retf
 000000A3			    DISK_delete_file        ENDP




				;    iDISK_add_drive     PROC
				;    ; This routine is used to add a physical drive to the drive structure table
				;    ; Upon entry:   The stack is populated with the structure below
				;    ;
				;    ; Upon exit:    al - internal disk number identifier
				;    ;
				;        push    ebp
				;        mov     ebp,esp
				;      ; stack frame
				;      ; -----------
				;      ; [ebp+31] - BYTE,  FLOPPY:  Drive type
				;      ;                   OTHERS:  --Nuserved
				;      ; [ebp+30] - BYTE,  device specs
				;      ; [ebp+29] - BYTE,  type of device
				;      ; [ebp+28] - BYTE,  type of controller
				;      ; [ebp+24] - DWORD, number_of_heads
				;      ; [ebp+20] - DWORD, bytes_per_sector
				;      ; [ebp+16] - DWORD, sectors_per_track
				;      ; [ebp+12] - DWORD, number_of_tracks
				;      ; [ebp+08] - DWORD, capacity in bytes
				;      ; [ebp+04] - eip
				;      ; [ebp+00] - ebp
				;      ; [ebp-02] - es
				;        push    es
				;
				;        mov     ax,_sDISK_DRIVES
				;        mov     es,ax
				;        xor     edi,edi
				;        xor     cx,cx
				;        .WHILE (byte ptr es:[edi] != 0ffh && edi < 1024)
				;            add     edi,_DISK_STRUCTURE_SIZE
				;            inc     cx
				;        .ENDW
				;        .IF (edi < 1024)
				;          ; Type of controller
				;            mov     al,byte ptr ss:[ebp+28]
				;            mov     byte ptr es:[edi+_DISK_CONTROLLER_OFFSET],al
				;            .IF (al == _DISK_CONTROLLER_FLOPPY)
				;              ; Drive type (drive is physically only a 360k, or a 1.2MB, or a 720k, or a 1.44MB or even a 2.88MB drive)
				;                mov     al,byte ptr ss:[ebp+31]
				;                mov     byte ptr es:[edi+_DISK_FLOPPY_DRIVE_TYPE_OFFSET],al
				;            .ENDIF
				;          ; Type of device
				;            mov     al,byte ptr ss:[ebp+29]
				;            mov     byte ptr es:[edi+_DISK_DEVICE_OFFSET],al
				;          ; Capacity
				;            mov     eax,dword ptr ss:[ebp+8]
				;            mov     dword ptr es:[edi+_DISK_CAPACITY_OFFSET],eax
				;          ; Number of heads
				;            mov     eax,dword ptr ss:[ebp+24]
				;            mov     dword ptr es:[edi+_DISK_NUM_HEADS_OFFSET],eax
				;          ; Number of tracks
				;            mov     eax,dword ptr ss:[ebp+12]
				;            mov     dword ptr es:[edi+_DISK_NUM_TRACKS_OFFSET],eax
				;          ; Number of sectors
				;            mov     eax,dword ptr ss:[ebp+16]
				;            mov     dword ptr es:[edi+_DISK_NUM_SECTORS_OFFSET],eax
				;          ; Device specs
				;            mov     al,byte ptr ss:[ebp+30]
				;            mov     byte ptr es:[edi+_DISK_DEVICE_SPECS_OFFSET],al
				;          ; Bytes per sector
				;            mov     eax,dword ptr ss:[ebp+20]
				;            mov     dword ptr es:[edi+_DISK_BYTES_PER_SECTOR_OFFSET],eax
				;          ; Mark the next record as the last one
				;            add     di,_DISK_STRUCTURE_SIZE
				;            mov     byte ptr es:[edi+_DISK_CONTROLLER_OFFSET],_STOPPER
				;          ; Get the disk number for this entry (returned in al)
				;            mov     al,cl
				;            clc
				;        .ELSE
				;            stc
				;            mov     al,0ffh                                             ; Disk #
				;        .ENDIF
				;
				;        pop     es
				;        pop     ebp
				;        ret     24
				;    iDISK_add_drive     ENDP
				;
				;
				;
				;
				;    iDISK_add_partition     PROC
				;    ; This routine is used to add a physical drive to the drive structure table
				;        enter   0,0
				;      ; stack frame
				;      ; -----------
				;      ; [ebp+46] - WORD,  Nuserved
				;      ; [ebp+45] - BYTE,  file system
				;      ; [ebp+44] - BYTE,  disk number
				;      ; [ebp+40] - DWORD, starting head
				;      ; [ebp+36] - DWORD, starting track
				;      ; [ebp+32] - DWORD, starting sector
				;      ; [ebp+28] - DWORD, ending head
				;      ; [ebp+24] - DWORD, ending track
				;      ; [ebp+20] - DWORD, ending sector
				;      ; [ebp+16] - DWORD, GDT selector
				;      ; [ebp+12] - DWORD, access rights
				;      ; [ebp+08] - DWORD, drive letter
				;      ; [ebp+04] - eip
				;      ; [ebp+00] - ebp
				;      ; [ebp-04] - es
				;        push    es
				;
				;        mov     ax,_sDISK_PARTITIONS
				;        mov     es,ax
				;        xor     edi,edi
				;        .WHILE (byte ptr es:[edi] != _STOPPER && edi < 4096)
				;            add     edi,_PARTITION_STRUCTURE_SIZE
				;        .ENDW
				;        .IF (edi < 4096)
				;          ; Disk number
				;            mov     ax,word ptr ss:[ebp+44]
				;            mov     byte ptr es:[edi+_PARTITION_DISK_NUMBER_OFFSET],al
				;          ; File system type
				;            mov     byte ptr es:[edi+_PARTITION_FILE_SYSTEM_TYPE_OFFSET],ah
				;          ; Starting head
				;            mov     eax,dword ptr ss:[ebp+40]
				;            mov     dword ptr es:[edi+_PARTITION_STARTING_HEAD_OFFSET],eax
				;          ; Starting track
				;            mov     eax,dword ptr ss:[ebp+36]
				;            mov     dword ptr es:[edi+_PARTITION_STARTING_TRACK_OFFSET],eax
				;          ; Starting sector
				;            mov     eax,dword ptr ss:[ebp+32]
				;            mov     dword ptr es:[edi+_PARTITION_STARTING_SECTOR_OFFSET],eax
				;          ; Ending head
				;            mov     eax,dword ptr ss:[ebp+28]
				;            mov     dword ptr es:[edi+_PARTITION_ENDING_HEAD_OFFSET],eax
				;          ; Ending track
				;            mov     eax,dword ptr ss:[ebp+24]
				;            mov     dword ptr es:[edi+_PARTITION_ENDING_TRACK_OFFSET],eax
				;          ; Ending sector
				;            mov     eax,dword ptr ss:[ebp+20]
				;            mov     dword ptr es:[edi+_PARTITION_ENDING_SECTOR_OFFSET],eax
				;          ; starting GDT
				;            mov     eax,dword ptr ss:[ebp+16]
				;            mov     word ptr es:[edi+_PARTITION_STARTING_GDT_OFFSET],ax
				;          ; Access rights
				;            mov     eax,dword ptr ss:[ebp+12]
				;            mov     word ptr es:[edi+_PARTITION_ACCESS_WORD_OFFSET],ax
				;          ; Drive letter
				;            mov     eax,dword ptr ss:[ebp+08]
				;            mov     byte ptr es:[edi+_PARTITION_DRIVE_LETTER_OFFSET],al
				;          ; Mark the next record as the last one
				;            add     edi,_PARTITION_STRUCTURE_SIZE
				;            mov     byte ptr es:[edi+_PARTITION_DISK_NUMBER_OFFSET],_STOPPER
				;            clc
				;        .ELSE
				;            stc
				;        .ENDIF
				;
				;        pop     es
				;        leave
				;        ret     40
				;    iDISK_add_partition     ENDP
				;
				;
				;
				;
				;    iDISK_update_media      PROC
				;    ; This routine is used to update the media type (it updates the partition information to the type of media currently in the drive)
				;    ; * Note:  This routine is a primative, so not too much checking goes on.  It is possible to corrupt the information for this
				;    ;          device.  Care should be taken when issuing this command.
				;    ;
				;    ; Upon entry:   al - drive letter to update
				;    ;               cl - (floppy only) gap length
				;    ;               dh - sectors
				;    ;               dl - tracks
				;    ;              ebx - total capacity in bytes
				;    ;
				;    ;  Upon exit:   carry? - CLEAR if ok, SET if error
				;    ;                  eax - error code if error
				;    ;               CLEAR:
				;    ;                   The sectors, tracks, capacity, (gap length) are updated and "Accessed yet?" bit is updated in the Access byte
				;    ;
				;        push    ds      ; [esp+24]
				;        push    esi     ; [esp+20]
				;        push    es      ; [esp+16]
				;        push    edi     ; [esp+12]
				;        push    eax     ; [esp+08]
				;        push    ecx     ; [esp+04]
				;        push    ebx     ; [esp+00]
				;
				;        mov     bl,al
				;        call    invDISK_find_drive_by_letter
				;        .IF (!carry?)
				;          ; Right now, ds:[esi] - far pointer to disk drive structure
				;          ;            es:[edi] - far pointer to disk partition structure
				;            mov     al,byte ptr ds:[esi+_DISK_DEVICE_SPECS_OFFSET]
				;            and     al,_DISK_DEVICE_MEDIA_REMOVABLE
				;            .IF (al != 0)
				;              ; This device is removable, so it's ok that they define it
				;                mov     ebx,dword ptr ss:[esp]
				;                xor     ecx,ecx
				;                mov     cl,dh
				;                and     edx,0ffh
				;              ; Check to see if these ending values are beyond the physical capabilities of the drive
				;                .IF (edx < dword ptr es:[edi+_PARTITION_STARTING_TRACK_OFFSET])
				;                  ; The ending track is less than the starting track
				;                  @@:
				;                    stc
				;                    mov     eax,_DISK_INVALID_PARAMETERS
				;                .ELSEIF (ecx < dword ptr es:[edi+_PARTITION_STARTING_SECTOR_OFFSET])
				;                  ; The ending sector is less than the starting sector
				;                    jmp     @B
				;                .ELSEIF (edx > dword ptr ds:[esi+_DISK_NUM_TRACKS_OFFSET])
				;                  ; They've specified a track greater than the number physically available on the device
				;                    jmp     @B
				;                .ELSEIF (ecx > dword ptr ds:[esi+_DISK_NUM_SECTORS_OFFSET])
				;                  ; They've specified a sector greater than the number physically available on the device
				;                    jmp     @B
				;                .ELSE
				;                  ; It's ok
				;                    mov     dword ptr es:[edi+_PARTITION_ENDING_TRACK_OFFSET],edx
				;                    mov     dword ptr es:[edi+_PARTITION_ENDING_SECTOR_OFFSET],ecx
				;                  ; Turn off "accessed yet?" and "read/write pending" flags
				;                    and     word ptr es:[edi+_PARTITION_ACCESS_WORD_OFFSET],not 1000000010000000b
				;                    mov     dword ptr es:[edi+_PARTITION_PARTITION_CAPACITY],ebx
				;                    mov     dword ptr es:[edi+_PARTITION_PARTITION_CAPACITY+4],0
				;                    .IF (byte ptr ds:[esi+_DISK_CONTROLLER_OFFSET] == _DISK_CONTROLLER_FLOPPY)
				;                      ; It's a floppy disk, update the gap length
				;                        mov     ecx,dword ptr ss:[esp+04]
				;                        mov     byte ptr ds:[esi+_DISK_FLOPPY_GAP_LENGTH_OFFSET],cl
				;                    .ENDIF
				;                  ; Everything is updated
				;                    clc
				;                .ENDIF
				;            .ELSE
				;              ; This device is not removable.  They're trying to update something that's invalid
				;                stc
				;                mov     eax,_DISK_INVALID_REQUEST
				;            .ENDIF
				;        .ELSE
				;            stc
				;            mov     eax,_DISK_INVALID_DRIVE
				;        .ENDIF
				;
				;        pop     ebx
				;        pop     ecx
				;        pop     eax
				;        pop     edi
				;        pop     es
				;        pop     esi
				;        pop     ds
				;        retf
				;    iDISK_update_media      ENDP




 000000A3			    DISK_requestor     PROC
				    ; This procedure is used to answer general requests
				    ; Upon entry:   eax - request code
				    ; Upon exit:    carry? - CLEAR if ok, SET if error
				    ;
				;        pushad
				;        push    ds
				;        push    es
				;        push    fs
				;        push    gs
				;        enter   0,0
				;
				;        .IF (eax == _RQ_iDISK_FLOPPY_DRIVE_TYPE)
				;          ; They want to know the floppy drive type
				;          ; Upon entry:  bl - drive letter they're querying
				;          ;  Upon exit: eax - physical drive type   * Note, refer to _DISK_CONTROLLER_* equate variables
				;            call    invDISK_find_drive_by_letter
				;            .IF (!carry?)
				;                xor     eax,eax
				;                mov     al,byte ptr ds:[esi+_DISK_FLOPPY_DRIVE_TYPE_OFFSET]
				;                clc
				;            .ELSE
				;                stc
				;                mov     eax,_RQ_iDISK_DRIVE_NOT_FOUND
				;            .ENDIF
				;        .ELSE
				;            mov     eax,_RQ_UNKNOWN_REQUEST
				;          iDISK_requestor_error:
				;            stc
				;        .ENDIF
				;
				;      iDISK_requestor_done:
				;        mov     dword ptr ss:[esp+48],eax                               ; Save eax's new value on the stack
				;        leave
				;        pop     gs
				;        pop     fs
				;        pop     es
				;        pop     ds
				;        popad
 000000A3  CB			        retf
 000000A4			    DISK_requestor     ENDP




 000000A4			    invDISK_find_drive_by_letter    PROC
				    ; This routine is used to find a drive partition by its letter
				    ; Upon entry:   bl - drive letter we're searching for
				    ;  Upon exit:   ds:[esi] - far pointer to drive information
				    ;               es:[edi] - far pointer to partition information
				;        push    ecx
				;
				;        mov     cx,_sDISK_DRIVES                                        ; ds:[esi] - far pointer to disk drives
				;        mov     ds,cx
				;
				;        mov     cx,_sDISK_partitions                                    ; es:[edi] - far pointer to partitions
				;        mov     es,cx
				;        xor     edi,edi
				;
;        .WHILE (byte ptr es:[edi+_PARTITION_DISK_NUMBER_OFFSET] != _STOPPER && edi < 4096)
				;            .IF (byte ptr es:[edi+_PARTITION_DRIVE_LETTER_OFFSET] == bl)
				;              ; This is the drive letter, now we point ds:[esi] to the disk information
				;                xor     ecx,ecx
				;                mov     cl,byte ptr es:[edi+_PARTITION_DISK_NUMBER_OFFSET]
				;                shl     ecx,5                                           ; Multiply by 32
				;                mov     esi,ecx
				;              ; Right now, ds:esi - pointer to the drive information
				;              ;            es:edi - pointer to the partition information
				;                clc
				;                jmp     @F
				;            .ENDIF
				;            add     edi,_PARTITION_STRUCTURE_SIZE
				;        .ENDW
				;      ; If we're here, it wasn't found
				;        stc
				;
				;      @@:
				;        pop     ecx
 000000A4  C3			        ret
 000000A5			    invDISK_find_drive_by_letter    ENDP




 000000A5			    initialize_driver   PROC
				    ; This routine is used to initialize the driver
				    ; But, there is no initialization in this system
 000000A5  BE 0000016B R	        mov     esi,offset DISK_boot_logo
 000000AA  2E: FF 1D		        call    fword ptr cs:_VID_draw_logo
	   0000013A R
 000000B1  F8			        clc
 000000B2  C3			        ret
 000000B3			    initialize_driver   ENDP




				; DATA
 000000B3 44 69 73 6B 20	    driver_name                             db  "Disk Driver",255,"(source:disk.dbg)",0
	   44 72 69 76 65
	   72 FF 28 73 6F
	   75 72 63 65 3A
	   64 69 73 6B 2E
	   64 62 67 29 00
 000000D1 31 30 2E 31 30	    version                                 db  "10.10.2010 BETA",0
	   2E 32 30 31 30
	   20 42 45 54 41
	   00
 000000E1 28 63 29 20 43	    copyright                               db  "(c) Copyright Beatleworks, Inc.",0
	   6F 70 79 72 69
	   67 68 74 20 42
	   65 61 74 6C 65
	   77 6F 72 6B 73
	   2C 20 49 6E 63
	   2E 00
 00000101 52 69 63 6B 20	    author                                  db  "Rick C. Hodgin",0
	   43 2E 20 48 6F
	   64 67 69 6E 00
 00000110 44 69 73 6B 20	    debi_text                               db  "Disk Primative",0
	   50 72 69 6D 61
	   74 69 76 65 00
 0000011F 28 63 29 20 42	    beatleworks_text                        db  "(c) Beatleworks, Inc.",0
	   65 61 74 6C 65
	   77 6F 72 6B 73
	   2C 20 49 6E 63
	   2E 00
 00000135 01			    bootup                                  db  1                   ; Changed to 0 after bootup is complete
 00000136 0000			    data_segment                            dw  0

 00000138 0000			    _EXODUS_requestor                       dw  0
 0000013A			  primative_call_gates:
 0000013A 0000			    _VID_draw_logo                          dw  0
 0000013C 00B0			    _VID_display_string_nr_vga              dw  _sEXODUS_REQUESTOR
 0000013E  F000			                                            dw  0f000h
 00000140  F000			                                            dw  0f000h

 00000142 0D 56 49 44 5F	    required_primatives                     db  13, "VID_draw_logo"
	   64 72 61 77 5F
	   6C 6F 67 6F
 00000150  19 56 49 44 5F	                                            db  25, "VID_display_string_nr_vga"
	   64 69 73 70 6C
	   61 79 5F 73 74
	   72 69 6E 67 5F
	   6E 72 5F 76 67
	   61
 0000016A  FF			                                            db  0ffh


				    ; This logo consists of a three-wide image (the +2 portion (the 2 stands for "an extra 2 18x16 images wide"))
				    ; It wants a box drawn around it (the +80h portion)
				    ; And the color we want to use is 8 (dark grey, the "+(8 SHL 3) portion)
				    ; * Refer to
 0000016B C9			    DISK_boot_logo                          db  0c9h     ; * Refer to VGA\INF\VGA.INF for information on this byte's format
 0000016C  0F 0F 0F 0F 0F	                                            db  0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh
	   0F 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   0F 0F 0F
 00000192  0F 07 07 07 07	                                            db  0fh,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,0fh
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 0F
 000001B8  0F 07 0F 0F 0F	                                            db  0fh,07h,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,07h,0fh
	   0F 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   0F 07 0F
 000001DE  0F 07 0F 07 07	                                            db  0fh,07h,0fh,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,0fh,07h,0fh
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   0F 07 0F
 00000204  0F 07 0F 07 07	                                            db  0fh,07h,0fh,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,0fh,07h,0fh
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   0F 07 0F
 0000022A  0F 07 0F 07 07	                                            db  0fh,07h,0fh,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,0fh,07h,0fh
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   0F 07 0F
 00000250  0F 07 0F 07 07	                                            db  0fh,07h,0fh,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,0fh,07h,0fh
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   0F 07 0F
 00000276  0F 07 0F 07 07	                                            db  0fh,07h,0fh,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,0fh,07h,0fh
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   0F 07 0F
 0000029C  0F 07 0F 07 07	                                            db  0fh,07h,0fh,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,0fh,07h,0fh
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   0F 07 0F
 000002C2  0F 07 0F 07 07	                                            db  0fh,07h,0fh,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,0fh,07h,0fh
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   0F 07 0F
 000002E8  0F 07 0F 07 07	                                            db  0fh,07h,0fh,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,0ah,0ah,07h,0fh,07h,0fh
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 0A 0A 07
	   0F 07 0F
 0000030E  0F 07 0F 07 07	                                            db  0fh,07h,0fh,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,0ah,0ah,07h,0fh,07h,0fh
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 0A 0A 07
	   0F 07 0F
 00000334  0F 07 0F 07 07	                                            db  0fh,07h,0fh,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,0fh,07h,0fh
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   0F 07 0F
 0000035A  0F 07 0F 0F 0F	                                            db  0fh,07h,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,07h,0fh
	   0F 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   0F 07 0F
 00000380  0F 07 07 07 07	                                            db  0fh,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,07h,0fh
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 07 07 07
	   07 07 0F
 000003A6  0F 0F 0F 0F 0F	                                            db  0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh
	   0F 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   0F 0F 0F


 000003CC			 end_of_required_data:
 000003CC 0E 44 49 53 4B	    driver_primatives                       db  14, "DISK_open_file"
	   5F 6F 70 65 6E
	   5F 66 69 6C 65
 000003DB  0000009C R		                                            dd  offset DISK_open_file
 000003DF  0000			                                            dw  0

 000003E1  0E 44 49 53 4B	                                            db  14, "DISK_read_file"
	   5F 72 65 61 64
	   5F 66 69 6C 65
 000003F0  0000009D R		                                            dd  offset DISK_read_file
 000003F4  0000			                                            dw  0

 000003F6  0E 44 49 53 4B	                                            db  14, "DISK_seek_file"
	   5F 73 65 65 6B
	   5F 66 69 6C 65
 00000405  0000009E R		                                            dd  offset DISK_seek_file
 00000409  0000			                                            dw  0

 0000040B  10 44 49 53 4B	                                            db  16, "DISK_insert_file"
	   5F 69 6E 73 65
	   72 74 5F 66 69
	   6C 65
 0000041C  0000009F R		                                            dd  offset DISK_insert_file
 00000420  0000			                                            dw  0

 00000422  0F 44 49 53 4B	                                            db  15, "DISK_write_file"
	   5F 77 72 69 74
	   65 5F 66 69 6C
	   65
 00000432  000000A0 R		                                            dd  offset DISK_write_file
 00000436  0000			                                            dw  0

 00000438  0F 44 49 53 4B	                                            db  15, "DISK_close_file"
	   5F 63 6C 6F 73
	   65 5F 66 69 6C
	   65
 00000448  000000A1 R		                                            dd  offset DISK_close_file
 0000044C  0000			                                            dw  0

 0000044E  10 44 49 53 4B	                                            db  16, "DISK_delete_file"
	   5F 64 65 6C 65
	   74 65 5F 66 69
	   6C 65
 0000045F  000000A2 R		                                            dd  offset DISK_delete_file
 00000463  0000			                                            dw  0

 00000465  0E 44 49 53 4B	                                            db  14, "DISK_requestor"
	   5F 72 65 71 75
	   65 73 74 6F 72
 00000474  000000A3 R		                                            dd  offset DISK_requestor
 00000478  0000			                                            dw  0

 0000047A  FFFF			                                            dw  0ffffh              ; Teriminator


 047C				_TEXT32 ENDS

				END
