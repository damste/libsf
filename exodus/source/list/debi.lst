Microsoft (R) Macro Assembler Version 6.11a		    03/07/09 22:34:58
Debi Debugger						     Page 1 - 1


				; debi.asm
				;
				; ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
				; ¥ Debi Debugger ≥
				; ¿√√√√√√√√√√√√√√√Ÿ
				;
				; Exodus native primative debugger, called Debi. :)
				;
				; -----
				;   00000 - Window Supportive Algorithms/Handlers
				;   11111 - External interfaces (Timer, Mouse, Kbd)
				;   22222 - Screen related functions
				;   33333 - MOUSE Events
				;   44444 - MENU system
				;   55555 - MENUs for screen objects
				;   66666 - Actions taken when various menu items are selected
				;   77777 - Menu bar events
				;   88888 - DRAG and DRAG RELEASE handlers
				;   99999 - Keyboard Events
				;   AAAAA - INCLUDE files
				;


				TITLE Debi Debugger

				    .MODEL tiny

				    .STACK 0h

				INCLUDE \exodus\source\common\keylist.asp
			      C ; keylist.asp
			      C 
 = 3B00			      C f1                      EQU 03b00h
 = 3C00			      C f2                      EQU 03c00h
 = 3D00			      C f3                      EQU 03d00h
 = 3E00			      C f4                      EQU 03e00h
 = 3F00			      C f5                      EQU 03f00h
 = 4000			      C f6                      EQU 04000h
 = 4100			      C f7                      EQU 04100h
 = 4200			      C f8                      EQU 04200h
 = 4300			      C f9                      EQU 04300h
 = 4400			      C f10                     EQU 04400h
 = 8500			      C f11                     EQU 08500h
 = 8600			      C f12                     EQU 08600h
 = 6800			      C alt_f1                  EQU 06800h
 = 6900			      C alt_f2                  EQU 06900h
 = 6A00			      C alt_f3                  EQU 06a00h
 = 6B00			      C alt_f4                  EQU 06b00h
 = 6C00			      C alt_f5                  EQU 06c00h
 = 6D00			      C alt_f6                  EQU 06d00h
 = 6E00			      C alt_f7                  EQU 06e00h
 = 6F00			      C alt_f8                  EQU 06f00h
 = 7000			      C alt_f9                  EQU 07000h
 = 7100			      C alt_f10                 EQU 07100h
 = 8B00			      C alt_f11                 EQU 08b00h
 = 8C00			      C alt_f12                 EQU 08c00h
 = 5E00			      C ctrl_f1                 EQU 05e00h
 = 5F00			      C ctrl_f2                 EQU 05f00h
 = 6000			      C ctrl_f3                 EQU 06000h
 = 6100			      C ctrl_f4                 EQU 06100h
 = 6200			      C ctrl_f5                 EQU 06200h
 = 6300			      C ctrl_f6                 EQU 06300h
 = 6400			      C ctrl_f7                 EQU 06400h
 = 6500			      C ctrl_f8                 EQU 06500h
 = 6600			      C ctrl_f9                 EQU 06600h
 = 6700			      C ctrl_f10                EQU 06700h
 = 8900			      C ctrl_f11                EQU 08900h
 = 8A00			      C ctrl_f12                EQU 08a00h
 = 5400			      C shift_f1                EQU 05400h
 = 5500			      C shift_f2                EQU 05500h
 = 5600			      C shift_f3                EQU 05600h
 = 5700			      C shift_f4                EQU 05700h
 = 5800			      C shift_f5                EQU 05800h
 = 5900			      C shift_f6                EQU 05900h
 = 5A00			      C shift_f7                EQU 05a00h
 = 5B00			      C shift_f8                EQU 05b00h
 = 5C00			      C shift_f9                EQU 05c00h
 = 5D00			      C shift_f10               EQU 05d00h
 = 8700			      C shift_f11               EQU 08700h
 = 8800			      C shift_f12               EQU 08800h
 = 48E0			      C grey_up                 EQU 048e0h
 = 50E0			      C grey_down               EQU 050e0h
 = 4BE0			      C grey_left               EQU 04be0h
 = 4DE0			      C grey_right              EQU 04de0h
 = 49E0			      C grey_pgup               EQU 049e0h
 = 51E0			      C grey_pgdn               EQU 051e0h
 = 52E0			      C grey_insert             EQU 052e0h
 = 53E0			      C grey_delete             EQU 053e0h
 = 47E0			      C grey_home               EQU 047e0h
 = 4FE0			      C grey_end                EQU 04fe0h
 = E00D			      C grey_enter              EQU 0e00dh
 = 9800			      C alt_grey_up             EQU 09800h
 = A000			      C alt_grey_down           EQU 0a000h
 = 9B00			      C alt_grey_left           EQU 09b00h
 = 9D00			      C alt_grey_right          EQU 09d00h
 = 9900			      C alt_grey_pgup           EQU 09900h
 = A100			      C alt_grey_pgdn           EQU 0a100h
 = A200			      C alt_grey_insert         EQU 0a200h
 = A300			      C alt_grey_delete         EQU 0a300h
 = 9700			      C alt_grey_home           EQU 09700h
 = 9F00			      C alt_grey_end            EQU 09f00h
 = A600			      C alt_grey_enter          EQU 0a600h
 = 8DE0			      C ctrl_grey_up            EQU 08de0h
 = 91E0			      C ctrl_grey_down          EQU 091e0h
 = 73E0			      C ctrl_grey_left          EQU 073e0h
 = 74E0			      C ctrl_grey_right         EQU 074e0h
 = 84E0			      C ctrl_grey_pgup          EQU 084e0h
 = 76E0			      C ctrl_grey_pgdn          EQU 076e0h
 = 92E0			      C ctrl_grey_insert        EQU 092e0h
 = 93E0			      C ctrl_grey_delete        EQU 093e0h
 = 77E0			      C ctrl_grey_home          EQU 077e0h
 = 75E0			      C ctrl_grey_end           EQU 075e0h
 = E00A			      C ctrl_grey_enter         EQU 0e00ah
 = 48E0			      C shift_grey_up           EQU 048e0h
 = 50E0			      C shift_grey_down         EQU 050e0h
 = 4BE0			      C shift_grey_left         EQU 04be0h
 = 4DE0			      C shift_grey_right        EQU 04de0h
 = 49E0			      C shift_grey_pgup         EQU 049e0h
 = 51E0			      C shift_grey_pgdn         EQU 051e0h
 = 52E0			      C shift_grey_insert       EQU 052e0h
 = 53E0			      C shift_grey_delete       EQU 053e0h
 = 47E0			      C shift_grey_home         EQU 047e0h
 = 4FE0			      C shift_grey_end          EQU 04fe0h
 = E00D			      C shift_grey_enter        EQU 0e00dh
 = 4800			      C up                      EQU 04800h
 = 5000			      C down                    EQU 05000h
 = 4B00			      C left                    EQU 04b00h
 = 4D00			      C right                   EQU 04d00h
 = 4900			      C pgup                    EQU 04900h
 = 5100			      C pgdn                    EQU 05100h
 = 5200			      C insert                  EQU 05200h
 = 5300			      C delete                  EQU 05300h
 = 4700			      C home                    EQU 04700h
 = 4F00			      C end_key                 EQU 04f00h
 = 4C00			      C center                  EQU 04c00h
 = 0E08			      C backspace               EQU 00e08h
 = 0F09			      C tab                     EQU 00f09h
 = 011B			      C escape                  EQU 0011bh
 = 1C0D			      C enter_key               EQU 01c0dh
 = A500			      C alt_tab                 EQU 0a500h
 = 0100			      C alt_escape              EQU 00100h
 = 8D00			      C ctrl_up                 EQU 08d00h
 = 9100			      C ctrl_down               EQU 09100h
 = 7300			      C ctrl_left               EQU 07300h
 = 7400			      C ctrl_right              EQU 07400h
 = 8400			      C ctrl_pgup               EQU 08400h
 = 7600			      C ctrl_pgdn               EQU 07600h
 = 9200			      C ctrl_insert             EQU 09200h
 = 9300			      C ctrl_delete             EQU 09300h
 = 7700			      C ctrl_home               EQU 07700h
 = 7500			      C ctrl_end                EQU 07500h
 = 8F00			      C ctrl_center             EQU 08f00h
 = 9400			      C ctrl_tab                EQU 09400h
 = 011B			      C ctrl_escape             EQU 0011bh
 = 1C0A			      C ctrl_enter              EQU 01c0ah
 = 0F00			      C shift_tab               EQU 00f00h
 = 011B			      C shift_escape            EQU 0011bh
 = 1E00			      C alt_a                   EQU 01e00h
 = 3000			      C alt_b                   EQU 03000h
 = 2E00			      C alt_c                   EQU 02e00h
 = 2000			      C alt_d                   EQU 02000h
 = 1200			      C alt_e                   EQU 01200h
 = 2100			      C alt_f                   EQU 02100h
 = 2200			      C alt_g                   EQU 02200h
 = 2300			      C alt_h                   EQU 02300h
 = 1700			      C alt_i                   EQU 01700h
 = 2400			      C alt_j                   EQU 02400h
 = 2500			      C alt_k                   EQU 02500h
 = 2600			      C alt_l                   EQU 02600h
 = 3200			      C alt_m                   EQU 03200h
 = 3100			      C alt_n                   EQU 03100h
 = 1800			      C alt_o                   EQU 01800h
 = 1900			      C alt_p                   EQU 01900h
 = 1000			      C alt_q                   EQU 01000h
 = 1300			      C alt_r                   EQU 01300h
 = 1F00			      C alt_s                   EQU 01f00h
 = 1400			      C alt_t                   EQU 01400h
 = 1600			      C alt_u                   EQU 01600h
 = 2F00			      C alt_v                   EQU 02f00h
 = 1100			      C alt_w                   EQU 01100h
 = 2D00			      C alt_x                   EQU 02d00h
 = 1500			      C alt_y                   EQU 01500h
 = 2C00			      C alt_z                   EQU 02c00h
 = 7800			      C alt_1                   EQU 07800h
 = 7900			      C alt_2                   EQU 07900h
 = 7A00			      C alt_3                   EQU 07a00h
 = 7B00			      C alt_4                   EQU 07b00h
 = 7C00			      C alt_5                   EQU 07c00h
 = 7D00			      C alt_6                   EQU 07d00h
 = 7E00			      C alt_7                   EQU 07e00h
 = 7F00			      C alt_8                   EQU 07f00h
 = 8000			      C alt_9                   EQU 08000h
 = 8100			      C alt_0                   EQU 08100h
 = 8200			      C alt_hyphen              EQU 08200h
 = 8300			      C alt_equal               EQU 08300h
 = 2B00			      C alt_backslash           EQU 02b00h
 = 3300			      C alt_comma               EQU 03300h
 = 3400			      C alt_period              EQU 03400h
 = 3500			      C alt_slash               EQU 03500h
 = 2900			      C alt_tilda               EQU 02900h
 = 1E00			      C ctrl_a                  EQU 01e00h
 = 3002			      C ctrl_b                  EQU 03002h
 = 2E03			      C ctrl_c                  EQU 02e03h
 = 2004			      C ctrl_d                  EQU 02004h
 = 1205			      C ctrl_e                  EQU 01205h
 = 2106			      C ctrl_f                  EQU 02106h
 = 2207			      C ctrl_g                  EQU 02207h
 = 2308			      C ctrl_h                  EQU 02308h
 = 1709			      C ctrl_i                  EQU 01709h
 = 240A			      C ctrl_j                  EQU 0240ah
 = 250B			      C ctrl_k                  EQU 0250bh
 = 260C			      C ctrl_l                  EQU 0260ch
 = 320D			      C ctrl_m                  EQU 0320dh
 = 310E			      C ctrl_n                  EQU 0310eh
 = 180F			      C ctrl_o                  EQU 0180fh
 = 1910			      C ctrl_p                  EQU 01910h
 = 1011			      C ctrl_q                  EQU 01011h
 = 1312			      C ctrl_r                  EQU 01312h
 = 1F13			      C ctrl_s                  EQU 01f13h
 = 1414			      C ctrl_t                  EQU 01414h
 = 1615			      C ctrl_u                  EQU 01615h
 = 2F16			      C ctrl_v                  EQU 02f16h
 = 1117			      C ctrl_w                  EQU 01117h
 = 2D18			      C ctrl_x                  EQU 02d18h
 = 1519			      C ctrl_y                  EQU 01519h
 = 2C1A			      C ctrl_z                  EQU 02c1ah
 = 0300			      C ctrl_2                  EQU 00300h
 = 071E			      C ctrl_6                  EQU 0071eh
 = 0C1F			      C ctrl_hyphen             EQU 00c1fh
 = 2B1C			      C ctrl_backslash          EQU 02b1ch
 = FFFF			      C ctrl_1                  EQU 0ffffh
 = FFFF			      C ctrl_comma              EQU 0ffffh
 = FFFF			      C ctrl_period             EQU 0ffffh
 = FFFF			      C ctrl_slash              EQU 0ffffh
 = FFFF			      C ctrl_tilda              EQU 0ffffh
 = FFFF			      C ctrl_equal              EQU 0ffffh
 = FFFF			      C ctrl_7                  EQU 0ffffh
 = FFFF			      C ctrl_8                  EQU 0ffffh
 = FFFF			      C ctrl_9                  EQU 0ffffh
 = FFFF			      C ctrl_0                  EQU 0ffffh
 = FFFF			      C ctrl_3                  EQU 0ffffh
 = FFFF			      C ctrl_4                  EQU 0ffffh
 = FFFF			      C ctrl_5                  EQU 0ffffh
			      C 
				INCLUDE \exodus\source\common\equates.asp
			      C ; equates.asp
			      C ;
			      C ; Exodus constants.  These are used at various places.
			      C ; This file provides a common area to modify constant values, rather than sifting through programs, etc.
			      C ;
			      C 
			      C 
			      C 
			      C INCLUDE x86_eq.asp
			      C ; x86_eq.asp
			      C ;
			      C ; Constants specific to the Intel architecture
			      C ;
			      C 
			      C 
			      C 
 = 0000			      C _TSS_BACK_LINK              EQU 0
 = 0004			      C _TSS_ESP0                   EQU 4
 = 0008			      C _TSS_SS0                    EQU 8
 = 000C			      C _TSS_ESP1                   EQU 12
 = 0010			      C _TSS_SS1                    EQU 16
 = 0014			      C _TSS_ESP2                   EQU 20
 = 0018			      C _TSS_SS2                    EQU 24
 = 001C			      C _TSS_CR3                    EQU 28
 = 0020			      C _TSS_EIP                    EQU 32
 = 0024			      C _TSS_EFLAGS                 EQU 36
 = 0028			      C _TSS_EAX                    EQU 40
 = 002C			      C _TSS_ECX                    EQU 44
 = 0030			      C _TSS_EDX                    EQU 48
 = 0034			      C _TSS_EBX                    EQU 52
 = 0038			      C _TSS_ESP                    EQU 56
 = 003C			      C _TSS_EBP                    EQU 60
 = 0040			      C _TSS_ESI                    EQU 64
 = 0044			      C _TSS_EDI                    EQU 68
 = 0048			      C _TSS_ES                     EQU 72
 = 004C			      C _TSS_CS                     EQU 76
 = 0050			      C _TSS_SS                     EQU 80
 = 0054			      C _TSS_DS                     EQU 84
 = 0058			      C _TSS_FS                     EQU 88
 = 005C			      C _TSS_GS                     EQU 92
 = 0060			      C _TSS_LDT                    EQU 96
 = 0064			      C _TSS_TRAP_BIT               EQU 100
 = 0001			      C _TSS_TRAP_BIT_MASK          EQU 1b
 = 0066			      C _TSS_IO_MAP                 EQU 102
			      C ; The following area is used by Exodus.  It appears immediate after the TSS in memory
 = 0068			      C _TSS_FPU_SAVE_AREA          EQU 104
			      C 
			      C 
			      C ; EFLAGS register constants to access individual flags
 = 0000			      C _EFLAGS_CF                  EQU 0
 = 0002			      C _EFLAGS_PF                  EQU 2
 = 0004			      C _EFLAGS_ACF                 EQU 4
 = 0006			      C _EFLAGS_ZF                  EQU 6
 = 0007			      C _EFLAGS_SF                  EQU 7
 = 0008			      C _EFLAGS_TF                  EQU 8
 = 0009			      C _EFLAGS_IF                  EQU 9
 = 000A			      C _EFLAGS_DF                  EQU 10
 = 000B			      C _EFLAGS_OF                  EQU 11
 = 000C			      C _EFLAGS_IOPL                EQU 12
 = 000E			      C _EFLAGS_NT                  EQU 14
 = 0010			      C _EFLAGS_RF                  EQU 16
 = 0011			      C _EFLAGS_VM                  EQU 17
			      C ; Masks to access specific bits
 = 0001			      C _EFLAGS_CF_MASK             EQU  1b SHL _EFLAGS_CF
 = 0004			      C _EFLAGS_PF_MASK             EQU  1b SHL _EFLAGS_PF
 = 0010			      C _EFLAGS_ACF_MASK            EQU  1b SHL _EFLAGS_ACF
 = 0040			      C _EFLAGS_ZF_MASK             EQU  1b SHL _EFLAGS_ZF
 = 0080			      C _EFLAGS_SF_MASK             EQU  1b SHL _EFLAGS_SF
 = 0100			      C _EFLAGS_TF_MASK             EQU  1b SHL _EFLAGS_TF
 = 0200			      C _EFLAGS_IF_MASK             EQU  1b SHL _EFLAGS_IF
 = 0400			      C _EFLAGS_DF_MASK             EQU  1b SHL _EFLAGS_DF
 = 0800			      C _EFLAGS_OF_MASK             EQU  1b SHL _EFLAGS_OF
 = 3000			      C _EFLAGS_IOPL_MASK           EQU 11b SHL _EFLAGS_IOPL
 = 4000			      C _EFLAGS_NT_MASK             EQU  1b SHL _EFLAGS_NT
 = 00010000		      C _EFLAGS_RF_MASK             EQU  1b SHL _EFLAGS_RF
 = 00020000		      C _EFLAGS_VM_MASK             EQU  1b SHL _EFLAGS_VM
			      C 
 = 1000			      C _CW_INFINITY                EQU 1000000000000b
 = 0C00			      C _CW_ROUNDING                EQU  110000000000b
 = 0000			      C _CW_ROUNDING_00             EQU  000000000000b
 = 0400			      C _CW_ROUNDING_01             EQU  010000000000b
 = 0800			      C _CW_ROUNDING_10             EQU  100000000000b
 = 0C00			      C _CW_ROUNDING_11             EQU  110000000000b
 = 0300			      C _CW_PRECISION               EQU    1100000000b
 = 0000			      C _CW_PRECISION_00            EQU    0000000000b
 = 0100			      C _CW_PRECISION_01            EQU    0100000000b
 = 0200			      C _CW_PRECISION_10            EQU    1000000000b
 = 0300			      C _CW_PRECISION_11            EQU    1100000000b
 = 0020			      C _CW_PM                      EQU        100000b
 = 0010			      C _CW_UM                      EQU         10000b
 = 0008			      C _CW_OM                      EQU          1000b
 = 0004			      C _CW_ZM                      EQU           100b
 = 0002			      C _CW_DM                      EQU            10b
 = 0001			      C _CW_IM                      EQU             1b
			      C 
 = 8000			      C _SW_BUSY                    EQU 1000000000000000b
 = 4000			      C _SW_C3                      EQU  100000000000000b
 = 3800			      C _SW_TOS                     EQU   11100000000000b
 = 0400			      C _SW_C2                      EQU      10000000000b
 = 0200			      C _SW_C1                      EQU       1000000000b
 = 0100			      C _SW_C0                      EQU        100000000b
 = 0080			      C _SW_ERROR_SUMMARY           EQU         10000000b
 = 0040			      C _SW_STACK_FAULT             EQU          1000000b
 = 0020			      C _SW_PE                      EQU           100000b
 = 0010			      C _SW_UE                      EQU            10000b
 = 0008			      C _SW_OE                      EQU             1000b
 = 0004			      C _SW_ZE                      EQU              100b
 = 0002			      C _SW_DE                      EQU               10b
 = 0001			      C _SW_IE                      EQU                1b
			      C 
			      C 
			      C 
			      C ; ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒø
			      C ; ≥ GDT ENTRIES ≥
			      C ; ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒŸ
 = 0008			      C     _sIDT                       EQU 1 * 8       ; IDT
 = 0010			      C     _sGDT                       EQU 2 * 8       ; GDT
 = 0018			      C     _sSTACK                     EQU 3 * 8       ; STACK
 = 0020			      C     _sCODE                      EQU 4 * 8       ; kernel CODE for kernel code
 = 0048			      C     _sDATA                      EQU 9 * 8       ; kernel DATA selector for kernel data
 = 0028			      C     _sGRAPHICS                  EQU 5 * 8       ; Graphics video (0a0000h)
 = 0030			      C     _sMONO                      EQU 6 * 8       ; Mono video (0b0000h)
 = 0038			      C     _sVGA                       EQU 7 * 8       ; VGA video (0b8000h)
 = 0040			      C     _sALL_MEM                   EQU 8 * 8       ; All memory (for debugging)
			      C     ; 9 is above, _sDATA
 = 0050			      C     _sEXODUS_MEM                EQU 10 * 8      ; Exodus assigned memory
 = 0058			      C     _sEXODUS_PORTS              EQU 11 * 8      ; Exodus assigned ports
 = 0060			      C     _sEXODUS_INTS               EQU 12 * 8      ; Exodus assigned ints
			      C     ;_sNOT_USED                                 ; available
 = 0070			      C     _sEXODUS_TSS                EQU 14 * 8      ; Exodus TSS
 = 0078			      C     _sEXODUS_TASK_GATE          EQU 15 * 8      ; Exodus kernel task gate (points to _sEXODUS_TSS)
 = 0080			      C     _sEXODUS_SLAVE_TSS          EQU 16 * 8      ; Exodus Slave TSS
 = 0088			      C     _sEXODUS_SLAVE_TASK_GATE    EQU 17 * 8      ; Exodus kernel slave task gate (points to _sEXODUS_SLAVE_TSS)
			      C     ;_sNOT USED
 = 0098			      C     _sPRIMATIVES                EQU 19 * 8      ; Primative structure for natives
 = 00A0			      C     _sPRIMATIVE_LOAD_INFO       EQU 20 * 8      ; Primative load information (for reporting on each driver)
 = 00A8			      C     _sSYSTEM                    EQU 21 * 8      ; Exodus system memory
 = 00B0			      C     _sEXODUS_REQUESTOR          EQU 22 * 8      ; Call gate to Exodus's requestor() function
 = 00B8			      C     _sSYSTEM_RING1              EQU 23 * 8      ; Exodus system memory for ring-1 apps
 = 00C0			      C     _sSYSTEM_RING2              EQU 24 * 8      ; Exodus system memory for ring-2 apps
 = 00C8			      C     _sSYSTEM_RING3              EQU 25 * 8      ; Exodus system memory for ring-3 apps
 = 00D0			      C     _sDEBI_screen               EQU 26 * 8      ; low-level DEBI debugger's save screen buffer
 = 00D8			      C     _sDEBI_memory               EQU 27 * 8      ; low-level DEBI debugger's memory
 = 00E0			      C     _sFLOPPY_TRACK              EQU 28 * 8      ; Floppy disk data I/O for one full track
 = 00E8			      C     _sVGA_BACKUP                EQU 29 * 8      ; VGA video (060000h, used when in a graphics mode so writes
			      C                                                 ;  to the text screen are still valid)
 = 00F0			      C     _sDEBI_screen2              EQU 30 * 8      ; low-level DEBI debugger's save screen buffer2 (for popups and menus)
 = 00F8			      C     _sDEBI_temp                 EQU 31 * 8      ; low-level DEBI debugger's temporary selector (used for various things)
 = 0100			      C     _sEXODUS_OBJECTS            EQU 32 * 8      ; Exodus objects
 = 0108			      C     _sTASK_SWITCH_TSS           EQU 33 * 8      ; Task Manager's switch_task() function
 = 0110			      C     _sTASK_SWITCH_TASK_GATE     EQU 34 * 8      ; Task Manager's task gate (points to _sTASK_SWITCH_TSS)
 = 0118			      C     _sTASK_STACK                EQU 35 * 8      ; Task Manger task's stack
 = 0120			      C     _sSTACK0                    EQU 36 * 8      ; Exodus Stack 0
 = 0128			      C     _sSTACK1                    EQU 37 * 8      ; Exodus Stack 1
 = 0130			      C     _sSTACK2                    EQU 38 * 8      ; Exodus Stack 2
 = 0138			      C     _sDEBI_dt                   EQU 39 * 8      ; low-level DEBI debugger's DT storage
 = 0140			      C     _sDEBI_np                   EQU 40 * 8      ; low-level DEBI debugger's NP storage
 = 0148			      C     _sDEBI_rp                   EQU 41 * 8      ; low-level DEBI debugger's RP storage
			      C 
			      C   ; Variable base/limit GDT slots setup in INIT32.ASP
 = 0190			      C     _sEXODUS_INI                EQU 50 * 8      ; Holds the parsed EXODUS.INI sructure
 = 0198			      C     _sEXODUS_INI_ERRORS         EQU 51 * 8      ; Holds any errors found while parsing EXODUS.INI
 = 01A0			      C     _sTASK_SYSTEM               EQU 52 * 8      ; Holds all tasks
			      C 
 = 5DA0			      C     _cgTEMP_PRIMATIVE_MAIN      EQU 2996 * 8
 = 5DA8			      C     _cgTEMP_PRIMATIVE_REQUESTOR EQU 2997 * 8
 = 5DB0			      C     _csTEMP_PRIMATIVE           EQU 2998 * 8
 = 5DB8			      C     _dsTEMP_PRIMATIVE           EQU 2999 * 8
			      C 
			      C 
			      C 
			      C ; ⁄ƒƒƒƒƒƒƒƒƒƒƒø
			      C ; ≥ CONSTANTS ≥
			      C ; ¿ƒƒƒƒƒƒƒƒƒƒƒŸ
 = 00C8			      C     _MIN_PRIMATIVE              EQU 200                             ; Start of the primatives
 = 0BB3			      C     _MAX_PRIMATIVE              EQU 2995                            ; End of the primatives
 = 0FFF			      C     _lastGDT                    EQU 4095                            ; Last valid GDT in the GDT
 = 0032			      C     _firstASSIGNMENT            EQU 50                              ; The first Exodus assigned GDT entry for various items
 = 00C7			      C     _lastASSIGNMENT             EQU 199                             ; The last Exodus assigned GDT entry for various items
 = 0BB8			      C     _firstUSER_ASSIGNMENT       EQU 3000
 = 0FFF			      C     _lastUSER_ASSIGNMENT        EQU 4095
 = 00C7			      C     _sGDT_init                  EQU 199                             ; Only initialize the first 199 GDT entries
			      C 
			      C 
			      C   ; Required memory structures for Exodus
			      C   ; Refer to Bootup(internal) document for definitive memory locations
 = 0008A000		      C     _sIDT_base                  EQU 8a000h
 = 0800			      C     _sIDT_limit                 EQU 800h
 = 0800			      C     _sGDT_base                  EQU 0800h
 = 8000			      C     _sGDT_limit                 EQU 8000h
 = 00098000		      C     _sSTACK_base                EQU 98000h
 = 8000			      C     _sSTACK_limit               EQU 8000h
 = 00010000		      C     _sCODE_base                 EQU 10000h
 = 00040000		      C     _sCODE_limit                EQU 40000h
 = 00010000		      C     _sDATA_base                 EQU 10000h
 = 00030000		      C     _sDATA_limit                EQU 30000h
 = 000A0000		      C     _sGRAPHICS_base             EQU 0a0000h
 = 00010000		      C     _sGRAPHICS_limit            EQU 10000h
 = 000B0000		      C     _sMONO_base                 EQU 0b0000h
 = 8000			      C     _sMONO_limit                EQU 8000h
 = 000B8000		      C     _sVGA_base                  EQU 0b8000h     ; Also, see _sVGA_BACKUP_ below
 = 8000			      C     _sVGA_limit                 EQU 8000h
 = 0000			      C     _sALL_MEM_base              EQU 0
 = FFFFFFFF		      C     _sALL_MEM_limit             EQU 0ffffffffh
 = 00070C00		      C     _sEXODUS_MEM_base           EQU 70c00h
 = 4000			      C     _sEXODUS_MEM_limit          EQU 4000h
 = 0006CC00		      C     _sEXODUS_PORTS_base         EQU 6cc00h
 = 4000			      C     _sEXODUS_PORTS_limit        EQU 4000h
 = 00097E00		      C     _sEXODUS_INTS_base          EQU 97e00h
 = 0200			      C     _sEXODUS_INTS_limit         EQU 200h
 = 00068100		      C     _sEXODUS_TSS_base           EQU 68100h
 = 0100			      C     _sEXODUS_TSS_limit          EQU 100h        ; 256 bytes
			      C    ;_sEXODUS_TASK_GATE          EQU task gate pointing to _sEXODUS_TSS
 = 00068200		      C     _sEXODUS_SLAVE_TSS_base     EQU 68200h
 = 0100			      C     _sEXODUS_SLAVE_TSS_limit    EQU 100h        ; 256 bytes
 = 0008D380		      C     _sPRIMATIVES_base           EQU 8d380h
 = 4000			      C     _sPRIMATIVES_limit          EQU 4000h       ; 16k
 = 0008C380		      C     _sPRIMATIVE_LOAD_INFO_base  EQU 8c380h
 = 1000			      C     _sPRIMATIVE_LOAD_INFO_limit EQU 1000h       ; 4k
 = 00089400		      C     _sSYSTEM_base               EQU 89400h
 = 0C00			      C     _sSYSTEM_limit              EQU 0c00h       ; 3k
 = 0800			      C     _sSYSTEM_USER_limit         EQU 0800h       ; 2k
 = 00281400		      C     _sDEBI_screen_base          EQU 281400h                         ; ; ; ; ; Added 2 MB, 02/26/2009 - RCH
 = 8000			      C     _sDEBI_screen_limit         EQU 8000h       ; 32k
 = 00279400		      C     _sDEBI_memory_base          EQU 279400h                         ; ; ; ; ; Added 2 MB, 02/26/2009 - RCH
 = 8000			      C     _sDEBI_memory_limit         EQU 8000h       ; 32k
 = 00074C00		      C     _sFLOPPY_TRACK_base         EQU 74c00h
 = 4800			      C     _sFLOPPY_TRACK_limit        EQU 4800h       ; 512 bytes per sector * 18 sectors * 2 sides = 18k
 = 00060000		      C     _sVGA_BACKUP_base           EQU 60000h      ; Note, the backup area is used when in graphics modes that use a0000h
 = 8000			      C     _sVGA_BACKUP_limit          EQU 8000h       ; so all video writes to the text window are still saved
 = 00258000		      C     _sDEBI_screen2_base         EQU 258000h
 = 00028000		      C     _sDEBI_screen2_limit        EQU 28000h       ; 32k
 = 00068000		      C     _sTASK_SWITCH_TSS_base      EQU 68000h
 = 0100			      C     _sTASK_SWITCH_TSS_limit     EQU 100h        ; 256 bytes
 = 00220000		      C     _sTASK_STACK_base           EQU 220000h                         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 8000			      C     _sTASK_STACK_limit          EQU 8000h       ; 32k
 = 00095380		      C     _sSTACK0_base               EQU 95380h
 = 2000			      C     _sSTACK0_limit              EQU 2000h       ; 8k
 = 00093380		      C     _sSTACK1_base               EQU 93380h
 = 2000			      C     _sSTACK1_limit              EQU 2000h       ; 8k
 = 00091380		      C     _sSTACK2_base               EQU 91380h
 = 2000			      C     _sSTACK2_limit              EQU 2000h       ; 8k
 = 00240000		      C     _sDEBI_dt_base              EQU 240000h                         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 8000			      C     _sDEBI_dt_limit             EQU 8000h       ; 32k
 = 00248000		      C     _sDEBI_np_base              EQU 248000h                         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 8000			      C     _sDEBI_np_limit             EQU 8000h       ; 32k
 = 00250000		      C     _sDEBI_rp_base              EQU 250000h                         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 8000			      C     _sDEBI_rp_limit             EQU 8000h       ; 32k
			      C 
 = 00050000		      C     _sEXODUS_OBJECTS_base       EQU 50000h
 = 8000			      C     _sEXODUS_OBJECTS_limit      EQU 8000h       ; 32k
 = 00200000		      C     _sEXODUS_INI_base           EQU 200000h     ; 1MB               ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 00010000		      C     _sEXODUS_INI_limit          EQU 10000h      ; 64k
 = 00210000		      C     _sEXODUS_INI_ERRORS_base    EQU 210000h     ; 1MB + 64k         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 4000			      C     _sEXODUS_INI_ERRORS_limit   EQU 4000h       ; 16k
 = 00210000		      C     _sTASK_SYSTEM_base          EQU 210000h     ; 1MB + 64k         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 00010000		      C     _sTASK_SYSTEM_limit         EQU 010000h     ; 64k
			      C 
			      C 
			      C ; ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
			      C ; ≥ BOOT DT STRUCTURE ≥
			      C ; ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ
 = 0000			      C     _BOOT_DT_object_type        EQU 0
 = 0001			      C     _BOOT_DT_days               EQU 1
 = 0005			      C     _BOOT_DT_seconds            EQU 5
 = 0008			      C     _BOOT_DT_rp_offset          EQU 8
 = 000A			      C     _BOOT_DT_entry_type         EQU 10
 = 000B			      C     _BOOT_DT_np_offset          EQU 11
			      C 
			      C 
			      C 
			      C 
			      C 
			      C ; ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
			      C ; ≥ BOOT PARAMETER BLOCK STRUCTURE ≥
			      C ; ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ
 = 0000			      C     _BOOT_PB_size               EQU 0
 = 0004			      C     _BOOT_PB_main               EQU 4
 = 0008			      C     _BOOT_PB_requestor          EQU 8
 = 000C			      C     _BOOT_PB_start_head         EQU 12
 = 000D			      C     _BOOT_PB_start_track        EQU 13
 = 000E			      C     _BOOT_PB_start_sector       EQU 14
 = 0010			      C     _BOOT_PB_end_head           EQU 16
 = 0011			      C     _BOOT_PB_end_track          EQU 17
 = 0012			      C     _BOOT_PB_end_sector         EQU 18
 = 0014			      C     _BOOT_PB_entry_type         EQU 20
 = 0016			      C     _BOOT_PB_linear_offset      EQU 22
 = 001A			      C     _BOOT_PB_dt_offset          EQU 26
 = 001C			      C     _BOOT_PB_crc16              EQU 28
 = 0020			      C     _BOOT_PB_structure_size     EQU 32
			      C 
			      C 
			      C 
			      C 
			      C ; ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
			      C ; ≥ EXODUS.INI STRUCTURES ≥
			      C ; ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ
 = 0000			      C     _EXODUS_INI_FIRST_BRACKET       EQU 0
 = 0004			      C     _EXODUS_INI_TOTAL_BYTES         EQU 4
 = 0008			      C     _EXODUS_INI_TOTAL_BRACKET_GROUPS EQU 8
 = 000C			      C     _EXODUS_INI_TOTAL_PAREN_CASKS   EQU 12
 = 0010			      C     _EXODUS_INI_HEADER_LENGTH       EQU 16
			      C 
 = 0000			      C     _EXODUS_BRACKET_NEXT            EQU 0
 = 0004			      C     _EXODUS_BRACKET_PAREN_CASKS     EQU 4
 = 0008			      C     _EXODUS_BRACKET_TOTAL_PARENS    EQU 8
 = 000C			      C     _EXODUS_BRACKET_NAME            EQU 12
 = 0010			      C     _EXODUS_BRACKET_HANDLE          EQU 16
 = 0014			      C     _EXODUS_BRACKET_REQUESTOR       EQU 20
 = 0016			      C     _EXODUS_BRACKET_REQUESTOR_FUNC  EQU 22
 = 001A			      C     _EXODUS_BRACKET_SCRATCH_AREA    EQU 26
 = 001E			      C     _EXODUS_BRACKET_LENGTH          EQU 30
			      C 
 = 0000			      C     _EXODUS_PAREN_NEXT              EQU 0
 = 0004			      C     _EXODUS_PAREN_NEXT_SAME_LINE    EQU 4
 = 0008			      C     _EXODUS_PAREN_DATA_ITEMS        EQU 8
 = 000C			      C     _EXODUS_PAREN_TOTAL_DATA_ITEMS  EQU 12
 = 0010			      C     _EXODUS_PAREN_SOURCE_LINE       EQU 16
 = 0014			      C     _EXODUS_PAREN_SOURCE_LINE_LENGTH EQU 20
 = 0018			      C     _EXODUS_PAREN_HANDLE            EQU 24
 = 001A			      C     _EXODUS_PAREN_REQUESTOR         EQU 26
 = 001E			      C     _EXODUS_PAREN_REQUESTOR_FUNC    EQU 30
 = 0022			      C     _EXODUS_PAREN_SCRATCH_AREA      EQU 34
 = 0026			      C     _EXODUS_PAREN_LENGTH            EQU 38
			      C 
 = 0000			      C     _EXODUS_DATA_NEXT               EQU 0
 = 0004			      C     _EXODUS_DATA_DATA_ITEM_SOURCE   EQU 4
 = 0008			      C     _EXODUS_DATA_DATA_ITEM_LENGTH   EQU 8
 = 000C			      C     _EXODUS_DATA_LENGTH             EQU 12
			      C 
			      C 
			      C 
			      C 
			      C ; ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
			      C ; ≥ EXODUS xxx STRUCTURES ≥
			      C ; ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ
 = 0000			      C     _EXODUS_MEM_type                EQU 0
 = 0004			      C     _EXODUS_MEM_base                EQU 4
 = 0008			      C     _EXODUS_MEM_limit               EQU 8
 = 000C			      C     _EXODUS_MEM_gdt                 EQU 12
 = 000E			      C     _EXODUS_MEM_ldt                 EQU 14
 = 0010			      C     _EXODUS_MEM_size                EQU 16
			      C 
 = 0010			      C     _EXODUS_PORTS_size              EQU 16
			      C 
 = 0002			      C     _EXODUS_INTS_size               EQU 2
			      C 
			      C 
			      C 
			      C 
			      C ; ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
			      C ; ≥ EXODUS SYSTEM MEMORY ≥
			      C ; ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ
			      C ; Note, when updates are made here they need to be reflected in INF\SYSTEM.INF
			      C ; Note, when updates are made here and INF\SYSTEM.INF, the "Exodus Quick Reference" manual needs to be updated
 = 0000			      C     _SYSTEM_SECONDS_SINCE_BOOTUP    EQU 0                           ; dword
 = 0004			      C     _SYSTEM_SECONDS_SINCE_MIDNIGHT  EQU 4                           ; dword
 = 0008			      C     _SYSTEM_HOURS                   EQU 8                           ; byte
 = 0009			      C     _SYSTEM_MINUTES                 EQU 9                           ; byte
 = 000A			      C     _SYSTEM_SECONDS                 EQU 10                          ; byte
 = 000B			      C     _SYSTEM_182S_OF_A_SECOND        EQU 11                          ; byte
 = 000C			      C     _SYSTEM_DAY                     EQU 12                          ; byte
 = 000D			      C     _SYSTEM_MONTH                   EQU 13                          ; byte
 = 000E			      C     _SYSTEM_YEAR                    EQU 14                          ; word
 = 0010			      C     _SYSTEM_DAY_OF_YEAR             EQU 16                          ; word
 = 0012			      C     _SYSTEM_BUILD                   EQU 18                          ; 10-byte string in the format: "mm.dd.yyyy"
 = 001C			      C     _SYSTEM_TOTAL_MEMORY            EQU 28                          ; dword, total ram in bytes
 = 0020			      C     _SYSTEM_VGA_HORIZONTAL          EQU 32                          ; word (pixels-graphics, or columns-text)
 = 0022			      C     _SYSTEM_VGA_VERTICAL            EQU 34                          ; word (pixels-graphics, or rows-text)
 = 0024			      C     _SYSTEM_VGA_VIDEO_MODE          EQU 36                          ; byte (0-graphics, 1-text)
 = 0025			      C     _SYSTEM_MONO_VIDEO_MODE         EQU 37                          ; byte (0-graphics, 1-text, 0ffh-Unknown)
			      C 
			      C   ; Non-user accessible system memory areas (Exodus internal, hence the use of the _i_)
 = 0800			      C     _SYSTEM_i_FATAL                 EQU 2048                        ; dword
 = 0804			      C     _SYSTEM_i_TASKS_CREATED         EQU 2052                        ; dword
 = 0808			      C     _SYSTEM_i_TASKS_BY_USER         EQU 2056                        ; dword
 = 080C			      C     _SYSTEM_i_TASKS_BY_ERROR        EQU 2060                        ; dword
 = 0810			      C     _SYSTEM_i_IRQ6_INDICATOR        EQU 2064                        ; byte, IRQ6 indicator (changes each time an IRQ6 is signaled)
 = 0811			      C     _SYSTEM_i_IRQ6_INDICATOR_LAST   EQU 2065                        ; byte, IRQ6 indicator previous, used to see when an IRQ6 is signaled
 = 0812			      C     _SYSTEM_i_BASE                  EQU 2066                        ; dword
 = 0816			      C     _SYSTEM_i_LIMIT                 EQU 2070                        ; dword
 = 081A			      C     _SYSTEM_i_DWORD_TO_COPY         EQU 2074                        ; word
 = 081C			      C     _SYSTEM_i_LAST_GDT_REFERENCED   EQU 2076                        ; qword
 = 0824			      C     _SYSTEM_i_CODE_GDT_OFFSET       EQU 2084                        ; dword (used temporarily during native primative install)
 = 0828			      C     _SYSTEM_i_DATA_GDT_OFFSET       EQU 2088                        ; dword (used temporarily during native primative install)
 = 082C			      C     _SYSTEM_i_MAIN_GDT_OFFSET       EQU 2092                        ; dword (used temporarily during native primative install)
 = 0830			      C     _SYSTEM_i_REQUESTOR_GDT_OFFSET  EQU 2096                        ; dword (used temporarily during native primative install)
 = 0834			      C     _SYSTEM_i_GDT_TO_ASSIGN         EQU 2100                        ; word (used various places to assign GDT entries)
 = 0836			      C     _SYSTEM_i_USER_GDT_TO_ASSIGN    EQU 2102                        ; word (used various places to assign USER Program GDTs)
			      C   ; Next offset is 2104
			      C 
			      C 
			      C   ; These scratch items exist from end of memory down
 = 0BF8			      C     _SYSTEM_i_SCRATCH_DWORD2        EQU 3064                        ; dword (used various places as a scratch buffer)
 = 0BFC			      C     _SYSTEM_i_SCRATCH_DWORD1        EQU 3068                        ; dword (used various places as a scratch buffer)
			      C 
			      C 
			      C 
			      C 
			      C ; ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
			      C ; ≥ BOCHS SUPPORT ≥
			      C ; ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ
			      C ; These equates are used to communicate via INT 0FFh
			      C ; Values here are in ecx, with edx being used for data information.
			      C ; Values in eax must be
 = 12345678		      C     _BOCHS1                         EQU 12345678h
 = 87654321		      C     _BOCHS2                         EQU 87654321h
 = 0000			      C     _BOCHS_GET_MONO_MOUSE_XY        EQU 0
 = 0001			      C     _BOCHS_GET_MONO_CURSOR          EQU 1
			      C 
				INCLUDE \exodus\source\common\macros.asp
			      C ; macros.asp
			      C ;
			      C ; Exodus macros, used various places
			      C ;
			      C 
			      C 
			      C 
			      C callfp     MACRO   _seg:REQ, _offset:REQ
			      C ; This macro:   callfp  _code_seg, _offset
			      C ;
			      C     db  9ah
			      C     dd  _offset
			      C     dw  _seg
			      C ENDM
			      C 
			      C 
			      C 
			      C 
			      C callg      MACRO   _seg:REQ
			      C ; This macro:   callg   _call_gate
			      C     db  9ah
			      C     dd  0
			      C     dw  _seg
			      C ENDM
			      C 
			      C 
			      C 
			      C 
			      C jmpg       MACRO   _seg:REQ
			      C ; This macro:   jmpg    _call_gate
			      C     db  0eah
			      C     dd  0
			      C     dw  _seg
			      C ENDM
			      C 
			      C 
			      C 
			      C 
			      C callf      MACRO   _func:REQ
			      C ; This macro:   callf   function_name
			      C     push    cs
			      C     call    _func
			      C ENDM
			      C 
			      C 
			      C 
			      C 
			      C @IO_pause   MACRO
			      C     jmp     $+2
			      C ENDM
			      C 
				INCLUDE debi_mac.asp                                                ; Macros used for DEBI
			      C ; debi_mac.asp
			      C ;
			      C ; Low-Level Debi Debugger defined macros
			      C ;
			      C ; This file consists of these groupings:
			      C ;   a)  common macros
			      C ;   b)  screen object macros
			      C ;   c)  mouse object macros
			      C ;
			      C 
			      C 
			      C 
			      C 
			      C ;; Macros common to all items
			      C @Start      MACRO
			      C     db  _START
			      C   ; Total = 1
			      C ENDM
			      C 
			      C @End    MACRO
			      C     db  _END
			      C   ; Total = 1
			      C ENDM
			      C 
			      C 
			      C 
			      C 
			      C ;;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
			      C ;;
			      C ;; Screen Object Macros
			      C ;;
			      C ;;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
			      C 
			      C ; * Note:  The constants are defined in debi_eq.asp
			      C @DrawWindow     MACRO   name:req
			      C ; Draws the window for whatever item is specified
			      C     db  _DRAW_WINDOW
			      C     dd  offset name
			      C   ; Total = 5
			      C ENDM
			      C 
			      C @AlwaysDrawWindow     MACRO   name:req
			      C ; Always draws the window for whatever item is specified
			      C     db  _DRAW_WINDOW_ALWAYS
			      C     dd  offset name
			      C   ; Total = 5
			      C ENDM
			      C 
			      C @DrawDebiLogo_at_pixel      MACRO   x:req, y:req
			      C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
			      C     db  _DRAW_DEBI_LOGO
			      C     dd  x
			      C     dd  y
			      C   ; Total = 9
			      C ENDM
			      C 
			      C @ObjectMemSize  MACRO   size:req
			      C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
			      C     db  _OBJECT_MEM_SIZE
			      C     db  size
			      C   ; Total = 2
			      C ENDM
			      C 
			      C ;@ObjectMemDefault   MACRO   type:req, parm1:REQ, parm2
			      C ;; Indicates a default condition
			      C ;    db  _OBJECT_MEM_DEFAULT
			      C ;    db  type
			      C ;    dd  parm1
			      C ;    IFNB <parm2>
			      C ;        dd  parm2
			      C ;    ELSE
			      C ;        dd  0ffffffffh
			      C ;    ENDIF
			      C ;  ; Total = 10
			      C ;ENDM
			      C 
			      C @LoadTemp   MACRO   type:REQ, loffset:REQ
			      C ; Loads a temporary value from this item's portion of _sDEBI_objects memory
			      C ;
			      C ;       TYPE - indicates what type of temporary variable is being loaded
			      C ;    LOFFSET - offset in local memory where the pointer is taken from (usually 0 indicating the first item in temp space)
			      C ;
			      C     db  _LOAD_TEMP
			      C     db  type
			      C     dd  loffset
			      C   ; Total = 6
			      C ENDM
			      C 
			      C @DisplayTemp_relative     MACRO   type:REQ, tempoffset:REQ, loffset:REQ, x:REQ, y:REQ
			      C ; Used to display some data from a temporary value.  Prior to use an @LoadTemp must've been issued to setup the far pointer to
			      C ; access the memory.
			      C ;
			      C ;       TYPE - indicates what type of variable is being displayed
			      C ; TEMPOFFSET - offset relative to the @LoadTemp far ptr
			      C ;    LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			      C ;          X - X coordinate (in characters) relative to upper-left corner of window
			      C ;          Y - Y coordinate (in characters) relative to upper-left corner of window
			      C ;
			      C     db  _DISPLAY
			      C     db  _TEMP_RELATIVE
			      C     db  type
			      C     dw  tempoffset
			      C     db  loffset
			      C     dd  x * FONT_X
			      C     dd  y * FONT_Y
			      C     dw  0               ; Nuserved
			      C   ; Total = 16
			      C ENDM
			      C 
			      C @DisplayEBP_relative    MACRO   type:REQ, ebpoffset:REQ, loffset:REQ, x:REQ, y:REQ
			      C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			      C ;
			      C ;      TYPE - indicates what type of variable is being displayed
			      C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			      C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			      C ;         X - X coordinate (in characters) relative to upper-left corner of window
			      C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			      C ;
			      C     db  _DISPLAY            ; +0
			      C     db  _EBP_RELATIVE       ; +1
			      C     db  type                ; +2
			      C     dw  ebpoffset           ; +3
			      C     db  loffset             ; +5
			      C     dd  x * FONT_X          ; +6
			      C     dd  y * FONT_Y          ; +10
			      C     dw  0                   ; +14, Nuserved
			      C   ; Total = 16
			      C ENDM
			      C 
			      C @DisplayEBP_through_EBP_relative    MACRO   type:REQ, ebpoffset:REQ, loffset:REQ, x:REQ, y:REQ
			      C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			      C ;
			      C ;      TYPE - indicates what type of variable is being displayed
			      C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			      C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			      C ;         X - X coordinate (in characters) relative to upper-left corner of window
			      C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			      C ;
			      C     db  _DISPLAY
			      C     db  _EBP_THROUGH_EBP_RELATIVE
			      C     db  type
			      C     dw  ebpoffset
			      C     db  loffset
			      C     dd  x * FONT_X
			      C     dd  y * FONT_Y
			      C     dw  0               ; Nuserved
			      C   ; Total = 16
			      C ENDM
			      C 
			      C @DisplayESP_through_EBP_relative    MACRO   type:REQ, ebpoffset:REQ, loffset:REQ, x:REQ, y:REQ
			      C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			      C ;
			      C ;      TYPE - indicates what type of variable is being displayed
			      C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			      C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			      C ;         X - X coordinate (in characters) relative to upper-left corner of window
			      C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			      C ;
			      C     db  _DISPLAY
			      C     db  _ESP_THROUGH_EBP_RELATIVE
			      C     db  type
			      C     dw  ebpoffset
			      C     db  loffset
			      C     dd  x * FONT_X
			      C     dd  y * FONT_Y
			      C     dw  0               ; Nuserved
			      C   ; Total = 16
			      C ENDM
			      C 
			      C @DisplayEBP_flag    MACRO   ebpoffset:REQ, loffset:REQ, use_bit:REQ, x:REQ, y:REQ, string:REQ
			      C ; Used to display a flag.  Note that the EBP reference is an offset on the stack, the use_bit represents the bit pattern for the flag
			      C ;
			      C ;      TYPE - indicates what type of variable is being displayed
			      C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			      C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			      C ;   USE_BIT - Indicates which bit in the DWORD quantity is to be examined
			      C ;         X - X coordinate (in characters) relative to upper-left corner of window
			      C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			      C ;    STRING - The string to display, note the last character is used to inidcate whether the flag is up  or down 
			      C ;
			      C     db  _DISPLAY
			      C     db  _EBP_RELATIVE_EFLAG
			      C     dw  ebpoffset
			      C     db  loffset
			      C     dd  1 SHL use_bit           ; Get the bit pattern to extract this one bit
			      C     dd  x * FONT_X
			      C     dd  y * FONT_Y
			      C     db  @SizeStr(string) - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
			      C     db  string
			      C     db  0                       ; Null terminate the string (for display purposes)
			      C   ; Total = <varies per item>
			      C ENDM
			      C 
			      C @ObjectPostDisplay      MACRO   type:REQ, x:REQ, y:REQ, string:REQ
			      C ; Used to display an object after all of the objects have been displayed.  This is done because this object references something
			      C ; that is calculated in another window.  The data item is identified by name (string) and may or may not be displayed once the
			      C ; entire processing has been completed.
			      C ;
			      C ;      TYPE - indicates what type of variable is being displayed
			      C ;         X - X coordinate (in characters) relative to upper-left corner of window
			      C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			      C ;    STRING - The string to look for.  Other windows will issue @ObjectPostObject that will be searched
			      C ;
			      C     db  _POST_DISPLAY
			      C     db  type
			      C     dd  x * FONT_X
			      C     dd  y * FONT_Y
			      C     db  @SizeStr(string) - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
			      C     db  string
			      C   ; Total = <varies per item>
			      C ENDM
			      C 
			      C @FunctionHandlesObject      MACRO   func:REQ
			      C     db  _FUNCTION
			      C     dd  offset func
			      C   ; Total = 5
			      C ENDM
			      C 
			      C 
			      C 
			      C 
			      C ;;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
			      C ;;
			      C ;; Mouse Object Macros
			      C ;;
			      C ;;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
			      C @Immediate  MACRO   type:REQ, x1:REQ, y1:REQ, x2:REQ, y2:REQ, func:REQ, datum
			      C ; Used when any click is recognized on these coordinates
			      C ;
			      C ;       X1 - X coordinate (in characters relative to upper-left corner of window) of the upper-left object
			      C ;       Y1 - Y coordinate (in characters relative to upper-left corner of window) of the upper-left object
			      C ;       X2 - X coordinate (in characters relative to upper-left corner of window) of the lower-right object
			      C ;       Y2 - Y coordinate (in characters relative to upper-left corner of window) of the lower-right object
			      C ;     FUNC - Function to call when this event is recognized
			      C ;
			      C     db  _IMMEDIATE                  ; +0
			      C     dd  x1 * FONT_X                 ; +1
			      C     dd  y1 * FONT_Y                 ; +5
			      C     dd  (x2 * FONT_X) + FONT_X - 1  ; +9
			      C     dd  (y2 * FONT_Y) + FONT_Y - 1  ; +13
			      C     dd  func                        ; +17
			      C     dw  0ffffh                      ; +21
			      C     IFNB <datum>
			      C         dw  datum                   ; +23
			      C         db  2 dup(0ffh)             ; +25
			      C     ELSE
			      C         db  4 dup(0ffh)             ; +23
			      C     ENDIF
			      C     db  type                        ; +27
			      C   ; Total = 28
			      C ENDM
			      C 
			      C @Any_click      MACRO   x1:REQ, y1:REQ, x2:REQ, y2:REQ, func:REQ, data1, data2, data3
			      C ; Used when any click is recognized on these coordinates
			      C ;
			      C ;       X1 - X coordinate (in characters relative to upper-left corner of window) of the upper-left object
			      C ;       Y1 - Y coordinate (in characters relative to upper-left corner of window) of the upper-left object
			      C ;       X2 - X coordinate (in characters relative to upper-left corner of window) of the lower-right object
			      C ;       Y2 - Y coordinate (in characters relative to upper-left corner of window) of the lower-right object
			      C ;     FUNC - Function to call when this event is recognized
			      C ;
			      C     db  _ANY_CLICK                  ; +0
			      C     dd  x1 * FONT_X                 ; +1
			      C     dd  y1 * FONT_Y                 ; +5
			      C     dd  (x2 * FONT_X) + FONT_X - 1  ; +9
			      C     dd  (y2 * FONT_Y) + FONT_Y - 1  ; +13
			      C     dd  func                        ; +17
			      C     IFNB <data1>
			      C         dd  data1                   ; +21
			      C     ELSE
			      C         dd  0ffffffffh
			      C     ENDIF
			      C     IFNB <data2>
			      C         dw  data2                   ; +25
			      C     ELSE
			      C         dw  0ffffh
			      C     ENDIF
			      C     IFNB <data3>
			      C         db  data3                   ; +27
			      C     ELSE
			      C         db  0ffh
			      C     ENDIF
			      C   ; Total = 28
			      C ENDM
			      C 
			      C @Left_single_click  MACRO   x1:REQ, y1:REQ, x2:REQ, y2:REQ, func:REQ, data1, data2, data3
			      C ; Used when a left single-click is recognized on these coordinates
			      C     db  _LEFT_SINGLE_CLICK          ; +0
			      C     dd  x1 * FONT_X                 ; +1
			      C     dd  y1 * FONT_Y                 ; +5
			      C     dd  (x2 * FONT_X) + FONT_X - 1  ; +9
			      C     dd  (y2 * FONT_Y) + FONT_Y - 1  ; +13
			      C     dd  func                        ; +17
			      C     IFNB <data1>
			      C         dd  data1                   ; +21
			      C     ELSE
			      C         dd  0ffffffffh
			      C     ENDIF
			      C     IFNB <data2>
			      C         dw  data2                   ; +25
			      C     ELSE
			      C         dw  0ffffh
			      C     ENDIF
			      C     IFNB <data3>
			      C         db  data3                   ; +27
			      C     ELSE
			      C         db  0ffh
			      C     ENDIF
			      C   ; Total = 28
			      C ENDM
			      C 
			      C @Left_double_click  MACRO   x1:REQ, y1:REQ, x2:REQ, y2:REQ, func:REQ, data1, data2, data3
			      C ; Used when a left double-click is recognized on these coordinates
			      C     db  _LEFT_DOUBLE_CLICK          ; +0
			      C     dd  x1 * FONT_X                 ; +1
			      C     dd  y1 * FONT_Y                 ; +5
			      C     dd  (x2 * FONT_X) + FONT_X - 1  ; +9
			      C     dd  (y2 * FONT_Y) + FONT_Y - 1  ; +13
			      C     dd  func                        ; +17
			      C     IFNB <data1>
			      C         dd  data1                   ; +21
			      C     ELSE
			      C         dd  0ffffffffh
			      C     ENDIF
			      C     IFNB <data2>
			      C         dw  data2                   ; +25
			      C     ELSE
			      C         dw  0ffffh
			      C     ENDIF
			      C     IFNB <data3>
			      C         db  data3                   ; +27
			      C     ELSE
			      C         db  0ffh
			      C     ENDIF
			      C   ; Total = 28
			      C ENDM
			      C 
			      C @Right_single_click  MACRO   x1:REQ, y1:REQ, x2:REQ, y2:REQ, func:REQ, data1, data2, data3
			      C ; Used when a right single-click is recognized on these coordinates
			      C     db  _RIGHT_SINGLE_CLICK         ; +0
			      C     dd  x1 * FONT_X                 ; +1
			      C     dd  y1 * FONT_Y                 ; +5
			      C     dd  (x2 * FONT_X) + FONT_X - 1  ; +9
			      C     dd  (y2 * FONT_Y) + FONT_Y - 1  ; +13
			      C     dd  func                        ; +17
			      C     IFNB <data1>
			      C         dd  data1                   ; +21
			      C     ELSE
			      C         dd  0ffffffffh
			      C     ENDIF
			      C     IFNB <data2>
			      C         dw  data2                   ; +25
			      C     ELSE
			      C         dw  0ffffh
			      C     ENDIF
			      C     IFNB <data3>
			      C         db  data3                   ; +27
			      C     ELSE
			      C         db  0ffh
			      C     ENDIF
			      C   ; Total = 28
			      C ENDM
			      C 
			      C @Right_double_click  MACRO   x1:REQ, y1:REQ, x2:REQ, y2:REQ, func:REQ, data1, data2, data3
			      C ; Used when a right double-click is recognized on these coordinates
			      C     db  _RIGHT_DOUBLE_CLICK         ; +0
			      C     dd  x1 * FONT_X                 ; +1
			      C     dd  y1 * FONT_Y                 ; +5
			      C     dd  (x2 * FONT_X) + FONT_X - 1  ; +9
			      C     dd  (y2 * FONT_Y) + FONT_Y - 1  ; +13
			      C     dd  func                        ; +17
			      C     IFNB <data1>
			      C         dd  data1                   ; +21
			      C     ELSE
			      C         dd  0ffffffffh
			      C     ENDIF
			      C     IFNB <data2>
			      C         dw  data2                   ; +25
			      C     ELSE
			      C         dw  0ffffh
			      C     ENDIF
			      C     IFNB <data3>
			      C         db  data3                   ; +27
			      C     ELSE
			      C         db  0ffh
			      C     ENDIF
			      C   ; Total = 28
			      C ENDM
			      C 
			      C @Both_single_click  MACRO   x1:REQ, y1:REQ, x2:REQ, y2:REQ, func:REQ, data1, data2, data3
			      C ; Used when a both single-click is recognized on these coordinates
			      C     db  _BOTH_SINGLE_CLICK          ; +0
			      C     dd  x1 * FONT_X                 ; +1
			      C     dd  y1 * FONT_Y                 ; +5
			      C     dd  (x2 * FONT_X) + FONT_X - 1  ; +9
			      C     dd  (y2 * FONT_Y) + FONT_Y - 1  ; +13
			      C     dd  func                        ; +17
			      C     IFNB <data1>
			      C         dd  data1                   ; +21
			      C     ELSE
			      C         dd  0ffffffffh
			      C     ENDIF
			      C     IFNB <data2>
			      C         dw  data2                   ; +25
			      C     ELSE
			      C         dw  0ffffh
			      C     ENDIF
			      C     IFNB <data3>
			      C         db  data3                   ; +27
			      C     ELSE
			      C         db  0ffh
			      C     ENDIF
			      C   ; Total = 28
			      C ENDM
			      C 
			      C @Both_double_click  MACRO   x1:REQ, y1:REQ, x2:REQ, y2:REQ, func:REQ, data1, data2, data3
			      C ; Used when a both double-click is recognized on these coordinates
			      C     db  _BOTH_DOUBLE_CLICK          ; +0
			      C     dd  x1 * FONT_X                 ; +1
			      C     dd  y1 * FONT_Y                 ; +5
			      C     dd  (x2 * FONT_X) + FONT_X - 1  ; +9
			      C     dd  (y2 * FONT_Y) + FONT_Y - 1  ; +13
			      C     dd  func                        ; +17
			      C     IFNB <data1>
			      C         dd  data1                   ; +21
			      C     ELSE
			      C         dd  0ffffffffh
			      C     ENDIF
			      C     IFNB <data2>
			      C         dw  data2                   ; +25
			      C     ELSE
			      C         dw  0ffffh
			      C     ENDIF
			      C     IFNB <data3>
			      C         db  data3                   ; +27
			      C     ELSE
			      C         db  0ffh
			      C     ENDIF
			      C   ; Total = 28
			      C ENDM
			      C 
			      C @Left_drag_start    MACRO   x1:REQ, y1:REQ, x2:REQ, y2:REQ, func:REQ, data1, data2, data3
			      C ; Used when a left-drag is started in these coordinates
			      C     db  _LEFT_DRAG_START            ; +0
			      C     dd  x1 * FONT_X                 ; +1
			      C     dd  y1 * FONT_Y                 ; +5
			      C     dd  (x2 * FONT_X) + FONT_X - 1  ; +9
			      C     dd  (y2 * FONT_Y) + FONT_Y - 1  ; +13
			      C     dd  func                        ; +17
			      C     IFNB <data1>
			      C         dd  data1                   ; +21
			      C     ELSE
			      C         dd  0ffffffffh
			      C     ENDIF
			      C     IFNB <data2>
			      C         dw  data2                   ; +25
			      C     ELSE
			      C         dw  0ffffh
			      C     ENDIF
			      C     IFNB <data3>
			      C         db  data3                   ; +27
			      C     ELSE
			      C         db  0ffh
			      C     ENDIF
			      C   ; Total = 28
			      C ENDM
			      C 
			      C @Right_drag_start    MACRO   x1:REQ, y1:REQ, x2:REQ, y2:REQ, func:REQ, data1, data2, data3
			      C ; Used when a right-drag is started in these coordinates
			      C     db  _RIGHT_DRAG_START           ; +0
			      C     dd  x1 * FONT_X                 ; +1
			      C     dd  y1 * FONT_Y                 ; +5
			      C     dd  (x2 * FONT_X) + FONT_X - 1  ; +9
			      C     dd  (y2 * FONT_Y) + FONT_Y - 1  ; +13
			      C     dd  func                        ; +17
			      C     IFNB <data1>
			      C         dd  data1                   ; +21
			      C     ELSE
			      C         dd  0ffffffffh
			      C     ENDIF
			      C     IFNB <data2>
			      C         dw  data2                   ; +25
			      C     ELSE
			      C         dw  0ffffh
			      C     ENDIF
			      C     IFNB <data3>
			      C         db  data3                   ; +27
			      C     ELSE
			      C         db  0ffh
			      C     ENDIF
			      C   ; Total = 28
			      C ENDM
			      C 
			      C @Left_drag_stop     MACRO   x1:REQ, y1:REQ, x2:REQ, y2:REQ, func:REQ, data1, data2, data3
			      C ; Used when a left-drag is stopped if it started in these coordinates
			      C     db  _LEFT_DRAG_STOP             ; +0
			      C     dd  x1 * FONT_X                 ; +1
			      C     dd  y1 * FONT_Y                 ; +5
			      C     dd  (x2 * FONT_X) + FONT_X - 1  ; +9
			      C     dd  (y2 * FONT_Y) + FONT_Y - 1  ; +13
			      C     dd  func                        ; +17
			      C     IFNB <data1>
			      C         dd  data1                   ; +21
			      C     ELSE
			      C         dd  0ffffffffh
			      C     ENDIF
			      C     IFNB <data2>
			      C         dw  data2                   ; +25
			      C     ELSE
			      C         dw  0ffffh
			      C     ENDIF
			      C     IFNB <data3>
			      C         db  data3                   ; +27
			      C     ELSE
			      C         db  0ffh
			      C     ENDIF
			      C   ; Total = 28
			      C ENDM
			      C 
			      C @Right_drag_stop    MACRO   x1:REQ, y1:REQ, x2:REQ, y2:REQ, func:REQ, data1, data2, data3
			      C ; Used when a right-drag is stopped if it was started in these coordinates
			      C     db  _RIGHT_DRAG_STOP            ; +0
			      C     dd  x1 * FONT_X                 ; +1
			      C     dd  y1 * FONT_Y                 ; +5
			      C     dd  (x2 * FONT_X) + FONT_X - 1  ; +9
			      C     dd  (y2 * FONT_Y) + FONT_Y - 1  ; +13
			      C     dd  func                        ; +17
			      C     IFNB <data1>
			      C         dd  data1                   ; +21
			      C     ELSE
			      C         dd  0ffffffffh
			      C     ENDIF
			      C     IFNB <data2>
			      C         dw  data2                   ; +25
			      C     ELSE
			      C         dw  0ffffh
			      C     ENDIF
			      C     IFNB <data3>
			      C         db  data3                   ; +27
			      C     ELSE
			      C         db  0ffh
			      C     ENDIF
			      C   ; Total = 28
			      C ENDM
			      C 
			      C @Hover          MACRO   x1:REQ, y1:REQ, x2:REQ, y2:REQ, loffset:REQ, func:REQ, datum
			      C ; Used when the mouse is hovering over these coordinates
			      C     db  _HOVER                      ; +0
			      C     dd  x1 * FONT_X                 ; +1
			      C     dd  y1 * FONT_Y                 ; +5
			      C     dd  (x2 * FONT_X) + FONT_X - 1  ; +9
			      C     dd  (y2 * FONT_Y) + FONT_Y - 1  ; +13
			      C     dd  func                        ; +17
			      C     dw  lowword(offset loffset)     ; +21
			      C     IFNB <datum>
			      C         dw  datum                   ; +23
			      C         db  3 dup(0ffh)             ; +25
			      C     ELSE
			      C         db  5 dup(0ffh)             ; +23
			      C     ENDIF
			      C   ; Total = 28
			      C ENDM
			      C 
			      C @Edit           MACRO   x1:REQ, y1:REQ, x2:REQ, y2:REQ, loffset:REQ, type:REQ, datum
			      C ; Used when a left-click is recognized on an item that can be edited
			      C     db  _EDIT                       ; +0
			      C     dd  x1 * FONT_X                 ; +1
			      C     dd  y1 * FONT_Y                 ; +5
			      C     dd  (x2 * FONT_X) + FONT_X - 1  ; +9
			      C     dd  (y2 * FONT_Y) + FONT_Y - 1  ; +13
			      C     dd  type                        ; +17
			      C     dw  lowword(offset loffset)     ; +21
			      C     IFNB <datum>
			      C         dw  datum                   ; +23
			      C         db  3 dup(0ffh)             ; +25
			      C     ELSE
			      C         db  5 dup(0ffh)             ; +23
			      C     ENDIF
			      C   ; Total = 28
			      C ENDM
			      C 
			      C @Abandon_if_not     MACRO   x1:REQ, y1:REQ, x2:REQ, y2:REQ
			      C ; Used in a lengthy list.  If the coordinates are not within this range then the rest of the lengthy list is not checked
			      C     db  _ABANDON_IF_NOT             ; +0
			      C     dd  x1 * FONT_X                 ; +1
			      C     dd  y1 * FONT_Y                 ; +5
			      C     dd  (x2 * FONT_X) + FONT_X - 1  ; +9
			      C     dd  (y2 * FONT_Y) + FONT_Y - 1  ; +13
			      C     db  11 dup(0ffh)                ; +17
			      C   ; Total = 28
			      C ENDM
			      C 
			      C 
			      C 
			      C 
			      C 
			      C ;;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
			      C ;;
			      C ;; Menu Item Macros
			      C ;;
			      C ;;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
			      C 
			      C @MenuItem       MACRO   text:REQ
			      C     db  _MENU_ITEM
			      C     db  @SizeStr(text) - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
			      C     db  text
			      C ENDM
			      C 
			      C @MenuItemEvent      MACRO   type:REQ, var:REQ
			      C     db  _MENU_ITEM_EVENT
			      C     db  type
			      C     dd  offset var
			      C ENDM
			      C 
			      C @MenuBar        MACRO
			      C     db  _MENU_BAR
			      C ENDM
			      C 
			      C 
			      C 
			      C 
			      C 
			      C ;;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
			      C ;;
			      C ;; Input Item Macros
			      C ;;
			      C ;;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
			      C 
			      C ; Offsets for these items are in called _DEBI_* and are in DEBI_MAC.ASP
			      C @DEBI_textbox       MACRO   x:REQ, y:REQ, len:REQ, var:REQ
			      C     db  _KO_TEXTBOX             ; +0
			      C     dd  x * FONT_X              ; +1
			      C     dd  y * FONT_Y              ; +5
			      C     dd  len                     ; +9
			      C     dd  offset var              ; +13
			      C     db  7 dup(0ffh)             ; +21
			      C   ; Total = 24
			      C ENDM
			      C 
			      C @DEBI_checkbox      MACRO   x:REQ, y:REQ, len:REQ, var:REQ, x_offset:REQ
			      C     db  _KO_CHECKBOX            ; +0
			      C     dd  x * FONT_X              ; +1
			      C     dd  y * FONT_Y              ; +5
			      C     dd  len                     ; +9
			      C     dd  offset var              ; +13
			      C     db  x_offset                ; +17
			      C     db  6 dup(0ffh)             ; +18
			      C   ; Total = 24
			      C ENDM
			      C 
			      C @DEBI_button        MACRO   x:REQ, y:REQ, len:REQ, func:REQ, x_offset:REQ
			      C     db  _KO_BUTTON              ; +0
			      C     dd  x * FONT_X              ; +1
			      C     dd  y * FONT_Y              ; +5
			      C     dd  len                     ; +9
			      C     dd  func                    ; +13
			      C     db  x_offset                ; +17
			      C     db  6 dup(0ffh)             ; +18
			      C   ; Total = 24
			      C ENDM
			      C 
			      C @DEBI_function      MACRO   x:REQ, y:REQ, func_mouse:REQ, func_kbd:REQ, func_refresh:REQ, func_activate:REQ
			      C     db  _KO_FUNCTION            ; +0
			      C     dw  x * FONT_X              ; +1
			      C     dw  y * FONT_Y              ; +3
			      C     dd  offset func_mouse       ; +5,  * Note:  This function is called to process a mouse request
			      C     dd  offset func_kbd         ; +9,  * Note:  This function is entirely custom and is called for all screen updating
			      C     dd  offset func_refresh     ; +13, * Note:  This function is entirely custom and is called for all screen updating
			      C     dd  offset func_activate    ; +17, * Note:  This function is entirely custom and is called for all screen updating
			      C     db  3 dup(0ffh)             ; +21
			      C   ; Total = 24
			      C ENDM
			      C 
				INCLUDE debi_eq.asp                                                 ; Equates used for DEBI
			      C ; debi_eq.asp
			      C ;
			      C ; Low-Level Debi Debugger constant equates
			      C ;
			      C ;
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
 = 0000			      C OFF                         EQU 0
 =-0001			      C ON                          EQU -1
			      C 
 = 0000			      C _NO                         EQU 0
 = 0001			      C _YES                        EQU 1
			      C 
			      C ; Used by invDEBI_parse_expression()
 = 0000			      C _SEGMENT                    EQU 0
 = 0001			      C _OFFSET                     EQU 1
 = 0002			      C _DISP                       EQU 2
			      C ; Last encountered operators
 = 0000			      C _NONE                       EQU 0
 = 0001			      C _ADDITION                   EQU 1
 = 0002			      C _MULTIPLICATION             EQU 2
 = 0003			      C _DIVISION                   EQU 3
 = 0004			      C _SUBTRACTION                EQU 4
 = 0005			      C _SHIFT_RIGHT                EQU 5
 = 0006			      C _SHIFT_LEFT                 EQU 6
			      C 
			      C 
			      C ; Pixel equates
 = 0008			      C FONT_X                      EQU 8                                   ; pixels per character horizontally
 = 0006			      C FONT_Y                      EQU 6                                   ; pixels per character vertically
 = 0002			      C _IMMEDIATE_COUNT            EQU 2
			      C 
			      C 
			      C ; Constant structure lengths
 =-0004			      C _ST_OBJECT_SCREEN_WIDTH     EQU -4                                  ; These two were added later.  They represent the size of a
 =-0002			      C _ST_OBJECT_SCREEN_HEIGHT    EQU -2                                  ; window (used when dragging to pick up the whole window)
 = 0000			      C _ST_OBJECT_ALTERABLE        EQU 0                                   ; Can item be moved/deleted on screen?
 = 0001			      C _ST_OBJECT_ACTIVE           EQU 1
			      C ;                           EQU 2                                   ; +--Nuserved,2
 = 0004			      C _ST_OBJECT_UL_HORIZONTAL    EQU 4                                   ; +_ST_OBJECT_UL_HORIZONTAL, ul-Horizontal
 = 0008			      C _ST_OBJECT_UL_VERTICAL      EQU 8                                   ; +_ST_OBJECT_UL_VERTICAL,   ul-Vertical
 = 000C			      C _ST_MEMVAR_OFFSET           EQU 12                                  ; +_ST_MEMVAR_OFFSET,        offsets to memory variables used
 = 0010			      C _ST_OBJECT_KBD_OFFSET       EQU 16                                  ; +_ST_OBJECT_KBD_OFFSET,    object's keyboard objects
 = 0014			      C _ST_OBJECT_MEMORY_OFFSET    EQU 20                                  ; +_ST_OBJECT_MEMORY_OFFSET, Starting offset in DEBI mem space
 = 0018			      C _ST_OBJECT_MOUSE_OFFSET     EQU 24                                  ; +_ST_OBJECT_MOUSE_OFFSET,  object's mouse objects
 = 001C			      C _ST_OBJECT_SCREEN_OFFSET    EQU 28                                  ; +_ST_OBJECT_SCREEN_OFFSET, object's screen objects
 = 0020			      C _ST_LENGTH                  EQU 32
			      C 
			      C ; Used only on menu items
 = 000C			      C _ST_OBJECT_WIDTH            EQU 12
 = 0010			      C _ST_OBJECT_HEIGHT           EQU 16
			      C 
			      C 
			      C ; MEMVAR structure offsets
 = 0000			      C _MEMVAR_MEMORY_VARIABLE     EQU 0
 = 0004			      C _MEMVAR_LENGTH              EQU 4
 = 0008			      C _MEMVAR_STRUCT_LENGTH       EQU 8
			      C 
			      C 
			      C ; Mouse object structure offsets
 = 0000			      C _MO_OBJECT_TYPE             EQU 0
 = 0001			      C _MO_X1                      EQU 1
 = 0005			      C _MO_Y1                      EQU 5
 = 0009			      C _MO_X2                      EQU 9
 = 000D			      C _MO_Y2                      EQU 13
 = 0011			      C _MO_FUNC                    EQU 17
 = 0015			      C _MO_DATA                    EQU 21
 = 0015			      C _MO_DATA1                   EQU 21
 = 0019			      C _MO_DATA2                   EQU 25
 = 001B			      C _MO_DATA3                   EQU 27
 = 001B			      C _MO_TYPE                    EQU 27
 = 001C			      C _MO_LENGTH                  EQU 28
			      C 
			      C ; Keyboard object structure offsets
 = 0000			      C _KO_OBJECT_TYPE             EQU 0
 = 0001			      C _KO_X                       EQU 1
 = 0005			      C _KO_Y                       EQU 5
 = 0009			      C _KO_LEN                     EQU 9
 = 0018			      C _KO_LENGTH                  EQU 24
			      C 
			      C ; Textbox and checkbox specific
 = 000D			      C _KO_VAR                     EQU 13
			      C 
			      C ; Checkbox and button specific
 = 0011			      C _KO_X_OFFSET                EQU 17
			      C 
			      C ; Button specific
 = 000D			      C _KO_FUNC                    EQU 13
			      C 
			      C ; Function specific
 = 0001			      C _KO_X_FUNCTION              EQU 1
 = 0003			      C _KO_Y_FUNCTION              EQU 3
 = 0005			      C _KO_MOUSE_FUNCTION          EQU 5
 = 0009			      C _KO_KBD_FUNCTION            EQU 9
 = 000D			      C _KO_REFRESH_FUNCTION        EQU 13
 = 0011			      C _KO_ACTIVATE_FUNCTION       EQU 17
			      C 
			      C ; Object types for keyboard objects
 = 0000			      C _KO_TEXTBOX                 EQU 0
 = 0001			      C _KO_CHECKBOX                EQU 1
 = 0002			      C _KO_BUTTON                  EQU 2
 = 00FE			      C _KO_FUNCTION                EQU 254
			      C 
			      C 
			      C ; Object types for menu objects
 = 0000			      C _MENU_ITEM                  EQU 0
 = 0001			      C _MENU_ITEM_EVENT            EQU 1
 = 0002			      C _MENU_BAR                   EQU 2
			      C 
			      C 
			      C ; Object offsets for DEBI keyboard objects (These are the offsets to the @DEBI_* macros in DEBI_MAC.ASP)
 = 0000			      C _DEBI_ID                    EQU 0
 = 0001			      C _DEBI_X                     EQU 1
 = 0005			      C _DEBI_Y                     EQU 5
 = 0009			      C _DEBI_LEN                   EQU 9
 = 000D			      C _DEBI_VAR                   EQU 13
 = 0011			      C _DEBI_FUNC                  EQU 17
 = 0015			      C _DEBI_RESERVED              EQU 21
			      C 
			      C ; Object types for mouse objects
 = 0000			      C _LEFT_SINGLE_CLICK          EQU 0
 = 0001			      C _LEFT_DOUBLE_CLICK          EQU 1
 = 0002			      C _LEFT_DRAG_START            EQU 2
 = 0003			      C _LEFT_DRAG_STOP             EQU 3
 = 0004			      C _RIGHT_SINGLE_CLICK         EQU 4
 = 0005			      C _RIGHT_DOUBLE_CLICK         EQU 5
 = 0006			      C _RIGHT_DRAG_START           EQU 6
 = 0007			      C _RIGHT_DRAG_STOP            EQU 7
 = 0008			      C _BOTH_SINGLE_CLICK          EQU 8
 = 0009			      C _BOTH_DOUBLE_CLICK          EQU 9
 = 000A			      C _HOVER                      EQU 10
 = 000B			      C _EDIT                       EQU 11
 = 000C			      C _ABANDON_IF_NOT             EQU 12
 = 000D			      C _ANY_CLICK                  EQU 13
 = 000E			      C _IMMEDIATE                  EQU 14
			      C 
			      C ; Object types for screen objects
 = 0000			      C _OBJECT_MEM_SIZE            EQU 0
 = 0001			      C _OBJECT_MEM_DEFAULT         EQU 1
 = 0002			      C _LOAD_TEMP                  EQU 2
 = 0003			      C _DISPLAY                    EQU 3
 = 0004			      C _INPUT                      EQU 4
 = 0005			      C _POST_DISPLAY               EQU 5
 = 0006			      C _POST_OBJECT                EQU 6
 = 0007			      C _FUNCTION                   EQU 7
 = 00FC			      C _START                      EQU 252
 = 00FD			      C _DRAW_WINDOW                EQU 253
 = 00FE			      C _DRAW_WINDOW_ALWAYS         EQU 254
 = 00FF			      C _END                        EQU 255
			      C 
			      C ; Address defaults
 = 0000			      C _ADDRESS_PARSE              EQU 0               ; Stored as 4 bytes pointing to an expression in input_field_area
			      C ; Offset defaults
 = 0001			      C _OFFSET_LINEAR              EQU 1
			      C 
			      C 
			      C ; _LOAD_TEMP classes
 = 0000			      C _FAR_MEMORY_PTR             EQU 0
			      C 
			      C 
			      C ; _LOAD_TEMP types
 = 0000			      C _RAW_ADDRESS                EQU 0
			      C 
			      C 
			      C ; Parse expression constants
 = 0000			      C _CS                         EQU 0
 = 0001			      C _DS                         EQU 1
 = 0002			      C _ES                         EQU 2
 = 0003			      C _FS                         EQU 3
 = 0004			      C _GS                         EQU 4
 = 0005			      C _SS                         EQU 5
 = 0006			      C _AL                         EQU 6
 = 0007			      C _AH                         EQU 7
 = 0008			      C _AX                         EQU 8
 = 0009			      C _EAX                        EQU 9
 = 000A			      C _BL                         EQU 10
 = 000B			      C _BH                         EQU 11
 = 000C			      C _BX                         EQU 12
 = 000D			      C _EBX                        EQU 13
 = 000E			      C _CL                         EQU 14
 = 000F			      C _CH                         EQU 15
 = 0010			      C _CX                         EQU 16
 = 0011			      C _ECX                        EQU 17
 = 0012			      C _DL                         EQU 18
 = 0013			      C _DH                         EQU 19
 = 0014			      C _DX                         EQU 20
 = 0015			      C _EDX                        EQU 21
 = 0016			      C _SI                         EQU 22
 = 0017			      C _ESI                        EQU 23
 = 0018			      C _DI                         EQU 24
 = 0019			      C _EDI                        EQU 25
 = 001A			      C _IP                         EQU 26
 = 001B			      C _EIP                        EQU 27
 = 001C			      C _BP                         EQU 28
 = 001D			      C _EBP                        EQU 29
 = 001E			      C _SP                         EQU 30
 = 001F			      C _ESP                        EQU 31
 = 0020			      C _EFLAGS                     EQU 32
 = 0021			      C _ECODE                      EQU 33
			      C 
			      C 
			      C ; DEBI_debug() references to interrupted program's values on the stack
 = 003C			      C _STACK_EFLAGS               EQU 60
 = 0038			      C _STACK_CS                   EQU 56
 = 0034			      C _STACK_EIP                  EQU 52
 = 0034			      C _STACK_IP                   EQU 52
 = 0030			      C _STACK_ERROR_CODE           EQU 48
 = 002C			      C _STACK_EAX                  EQU 44
 = 002C			      C _STACK_AX                   EQU 44
 = 002C			      C _STACK_AL                   EQU 44
 = 002D			      C _STACK_AH                   EQU 45
 = 0028			      C _STACK_EBX                  EQU 40
 = 0028			      C _STACK_BX                   EQU 40
 = 0028			      C _STACK_BL                   EQU 40
 = 0029			      C _STACK_BH                   EQU 41
 = 0024			      C _STACK_ECX                  EQU 36
 = 0024			      C _STACK_CX                   EQU 36
 = 0024			      C _STACK_CL                   EQU 36
 = 0025			      C _STACK_CH                   EQU 37
 = 0020			      C _STACK_EDX                  EQU 32
 = 0020			      C _STACK_DX                   EQU 32
 = 0020			      C _STACK_DL                   EQU 32
 = 0021			      C _STACK_DH                   EQU 33
 = 001C			      C _STACK_ESI                  EQU 28
 = 001C			      C _STACK_SI                   EQU 28
 = 0018			      C _STACK_EDI                  EQU 24
 = 0018			      C _STACK_DI                   EQU 24
 = 0014			      C _STACK_DS                   EQU 20
 = 0010			      C _STACK_ES                   EQU 16
 = 000C			      C _STACK_FS                   EQU 12
 = 0008			      C _STACK_GS                   EQU 08
 = 0004			      C _STACK_SS                   EQU 04
 = 0000			      C _STACK_EBP                  EQU 00
 = 0000			      C _STACK_BP                   EQU 00
 =-0004			      C _STACK_ESP                  EQU -4
 =-0004			      C _STACK_SP                   EQU -4
			      C 
			      C 
			      C ; _DISPLAY classes
 = 0000			      C _TEMP_RELATIVE              EQU 0
 = 0001			      C _EBP_RELATIVE               EQU 1
 = 0002			      C _EBP_THROUGH_EBP_RELATIVE   EQU 2
 = 0003			      C _ESP_THROUGH_EBP_RELATIVE   EQU 3
 = 0004			      C _EBP_RELATIVE_EFLAG         EQU 4
			      C 
			      C 
			      C ; _DISPLAY types
 = 0000			      C _UPPER_NIBBLE               EQU 0               ; upper nibble
 = 0001			      C _LOWER_NIBBLE               EQU 1               ; lower nibble
 = 0002			      C _LOWER_NIBBLE3              EQU 2               ; least significant 3 bits of lower nibble
 = 0003			      C _8                          EQU 3               ; 8-bit value in xx form
 = 0004			      C _16                         EQU 4               ; 16-bit value in xxxx form
 = 0005			      C _32                         EQU 5               ; 32-bit value in xxxxxxxx form
 = 0006			      C _BINARY8                    EQU 6
 = 0007			      C _BINARY11                   EQU 7
 = 0008			      C _BINARY16                   EQU 8
 = 0009			      C _BINARY32                   EQU 9
 = 000A			      C _IEEE_80                    EQU 10
 = 000B			      C _TBYTE                      EQU 11
 = 000C			      C _ADJ_FLOAT14                EQU 12
 = 000D			      C _ADJ_FLOAT20                EQU 13
 = 000E			      C _ADJ_FLOAT21                EQU 14
 = 000F			      C _FPU_OPCODE                 EQU 15
			      C 

				    .386P

 00000000			_TEXT32 SEGMENT BYTE 'CODE' USE32
				    ASSUME NOTHING

				; These are required to be the first 2 dwords in the file
 00000000  00000087 R		dd  offset main
 00000004  00000008 R		dd  offset requestor



 00000008			    requestor   PROC
				    ; This routine is called by Exodus.  When this function is called multi-tasking is not installed.  This is a linear function.
				    ;
				    ; Upon entry:   eax - requested function
				    ;                ds - temporary ORG 0h data segment for use with these requestor() functions
				    ;
				    ; Upon exit:    results vary based on value of eax
				    ;
				        .IF (eax == 'info')
 00000008  3D 696E666F	   *	    cmp    eax, 'info'
 0000000D  75 26	   *	    jne    @C0001
				          ; Program information
 0000000F  B8 6E617469		            mov     eax,'nati'                              ; Identifying this program as a native primative
 00000014  B9 0000D7B8 R	            mov     ecx,offset end_of_required_data         ; The maximum number of bytes to retain after loading

 00000019  BE 0000D7B8 R	            mov     esi,offset driver_primatives            ; Offset to the native primatives structure
 0000001E  BF 0000B43C R	            mov     edi,offset driver_name
 00000023  BB 0000B466 R	            mov     ebx,offset version
 00000028  BA 0000B476 R	            mov     edx,offset copyright
 0000002D  BD 0000B496 R	            mov     ebp,offset author
 00000032  F8			            clc
				        .ELSEIF (eax == 'prim')
 00000033  EB 51	   *	    jmp    @C0003
 00000035		   *@C0001:
 00000035  3D 7072696D	   *	    cmp    eax, 'prim'
 0000003A  75 14	   *	    jne    @C0004
				          ; Native primatives this program will use
 0000003C  66| 8C 1D		            mov     ds:data_segment,ds
	   0000B77F R
 00000043  BE 0000D11B R	            mov     esi,offset required_primatives          ; This primative requires these functions
 00000048  BF 0000D0D9 R	            mov     edi,offset primative_call_gates
 0000004D  F8			            clc
				        .ELSEIF (eax == 'id  ')
 0000004E  EB 36	   *	    jmp    @C0006
 00000050		   *@C0004:
 00000050  3D 69642020	   *	    cmp    eax, 'id  '
 00000055  75 0F	   *	    jne    @C0007
				          ; Display this program's ID on the VGA monitor
 00000057  BE 0000B43C R	            mov     esi,offset driver_name
 0000005C  2E: FF 1D		            call    fword ptr cs:_VID_display_string_nr_vga
	   0000D0DB R
 00000063  F8			            clc
				        .ELSEIF (eax == 'note')
 00000064  EB 20	   *	    jmp    @C0009
 00000066		   *@C0007:
 00000066  3D 6E6F7465	   *	    cmp    eax, 'note'
 0000006B  75 18	   *	    jne    @C000A
 0000006D  B8 73746F70		            mov     eax,'stop'
 00000072  BB 6C6F6164		            mov     ebx,'load'
 00000077  BE 0000B43C R	            mov     esi,offset driver_name
 0000007C  2E: FF 1D		            call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
				        .ELSE
 00000083  EB 01	   *	    jmp    @C000C
 00000085		   *@C000A:
 00000085  F9			            stc
				        .ENDIF
 00000086		   *@C000C:
 00000086		   *@C0009:
 00000086		   *@C0006:
 00000086		   *@C0003:
 00000086  CB			        retf
 00000087			    requestor   ENDP




 00000087			    main    PROC
				    ; This routine is called once by Exodus once initialization is complete (all calls to requestor() are finished)
				    ; It is used by Exodus to allow this driver to properly initialize itself.
				    ; When this function is called multi-tasking is not installed.  This is a linear function.
				    ;
				    ; Upon entry:   Nothing
				    ;
				    ; Upon exit:    A "continued status of execution" is expected by Exodus.  This indicates whether or not everything
				    ;               initialized ok or is available.  If everything is OK the carry? flag is CLEAR.  If there is an error
				    ;               and this driver cannot continue then the carry? should be SET.
				    ;               carry? - CLEAR=Ok to continue
				    ;                          SET=Error initializing
				    ;
 00000087  66| 2E: 8E 1D	        mov     ds,cs:data_segment
	   0000B77F R
 0000008F  C6 05 0000B4CE R	        mov     ds:bootup,0
	   00
 00000096  E8 00000001		        call    initialize_driver
				      ; Right now, carry? is SET or CLEAR indicating status of driver
 0000009B  CB			        retf
 0000009C			    main    ENDP




 0000009C			    initialize_driver   PROC
				    ; This routine is used to initialize the driver
				    ; We trap all interrupts that are generated by the CPU during an error condition
 0000009C  06			        push    es

				      ; Take ownership of the VID_g subsystem in the video driver (DEBI requires monochrome graphics mode)
 0000009D  2E: FF 1D		        call    fword ptr cs:_VID_g_claim_ownership
	   0000D105 R
 000000A4  2E: FF 1D		        call    fword ptr cs:_VID_g_mono_enter_graphics_mode
	   0000D109 R

				      ; INT0 - Divide error
 000000AB  B9 00000001		        mov     ecx,1                                               ; We only allocate one interrupt at a time (used on all)
 000000B0  B8 62696E74		        mov     eax,'bint'
 000000B5  B3 00		        mov     bl,0
 000000B7  BA 00005395 R	        mov     edx,offset invDEBI_int0_handler
 000000BC  2E: FF 1D		        call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
 000000C3  0F 82 000001E2	        jc      init_failed

				      ; INT1 - Single-step (or debug exception)
 000000C9  B8 62696E74		        mov     eax,'bint'
 000000CE  B3 01		        mov     bl,1
 000000D0  BA 000053A6 R	        mov     edx,offset invDEBI_int1_handler
 000000D5  2E: FF 1D		        call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
 000000DC  0F 82 000001C9	        jc      init_failed

				      ; INT2 - No description
 000000E2  B8 62696E74		        mov     eax,'bint'
 000000E7  B3 02		        mov     bl,2
 000000E9  BA 000053B7 R	        mov     edx,offset invDEBI_int2_handler
 000000EE  2E: FF 1D		        call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
 000000F5  0F 82 000001B0	        jc      init_failed

				      ; INT3 - Breakpoint exception
 000000FB  B8 62696E74		        mov     eax,'bint'
 00000100  B3 03		        mov     bl,3
 00000102  BA 000053C8 R	        mov     edx,offset invDEBI_int3_handler
 00000107  2E: FF 1D		        call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
 0000010E  0F 82 00000197	        jc      init_failed

				      ; INT4 - Overflow exception
 00000114  B8 62696E74		        mov     eax,'bint'
 00000119  B3 04		        mov     bl,4
 0000011B  BA 000053D9 R	        mov     edx,offset invDEBI_int4_handler
 00000120  2E: FF 1D		        call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
 00000127  0F 82 0000017E	        jc      init_failed

				      ; INT5 - BOUND range exceeded exception
 0000012D  B8 62696E74		        mov     eax,'bint'
 00000132  B3 05		        mov     bl,5
 00000134  BA 000053EA R	        mov     edx,offset invDEBI_int5_handler
 00000139  2E: FF 1D		        call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
 00000140  0F 82 00000165	        jc      init_failed

				      ; INT6 - Invalid opcode exception
 00000146  B8 62696E74		        mov     eax,'bint'
 0000014B  B3 06		        mov     bl,6
 0000014D  BA 000053FB R	        mov     edx,offset invDEBI_int6_handler
 00000152  2E: FF 1D		        call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
 00000159  0F 82 0000014C	        jc      init_failed

				      ; INT7 - Device not available exception
 0000015F  B8 62696E74		        mov     eax,'bint'
 00000164  B3 07		        mov     bl,7
 00000166  BA 0000540C R	        mov     edx,offset invDEBI_int7_handler
 0000016B  2E: FF 1D		        call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
 00000172  0F 82 00000133	        jc      init_failed

				      ; INT8 - Double fault exception
 00000178  B8 62696E74		        mov     eax,'bint'
 0000017D  B3 08		        mov     bl,8
 0000017F  BA 00005415 R	        mov     edx,offset invDEBI_int8_handler
 00000184  2E: FF 1D		        call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
 0000018B  0F 82 0000011A	        jc      init_failed

				      ; INT9 - Coprocessor segment overrun
 00000191  B8 62696E74		        mov     eax,'bint'
 00000196  B3 09		        mov     bl,9
 00000198  BA 00005424 R	        mov     edx,offset invDEBI_int9_handler
 0000019D  2E: FF 1D		        call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
 000001A4  0F 82 00000101	        jc      init_failed

				      ; INT10 - Invalid TSS exception
 000001AA  B8 62696E74		        mov     eax,'bint'
 000001AF  B3 0A		        mov     bl,10
 000001B1  BA 00005435 R	        mov     edx,offset invDEBI_int10_handler
 000001B6  2E: FF 1D		        call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
 000001BD  0F 82 000000E8	        jc      init_failed

				      ; INT11 - Segment not present
 000001C3  B8 62696E74		        mov     eax,'bint'
 000001C8  B3 0B		        mov     bl,11
 000001CA  BA 00005444 R	        mov     edx,offset invDEBI_int11_handler
 000001CF  2E: FF 1D		        call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
 000001D6  0F 82 000000CF	        jc      init_failed

				      ; INT12 - Stack fault exception
 000001DC  B8 62696E74		        mov     eax,'bint'
 000001E1  B3 0C		        mov     bl,12
 000001E3  BA 00005453 R	        mov     edx,offset invDEBI_int12_handler
 000001E8  2E: FF 1D		        call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
 000001EF  0F 82 000000B6	        jc      init_failed

				      ; INT13 - General protection fault
 000001F5  B8 62696E74		        mov     eax,'bint'
 000001FA  B3 0D		        mov     bl,13
 000001FC  BA 00005462 R	        mov     edx,offset invDEBI_int13_handler
 00000201  2E: FF 1D		        call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
 00000208  0F 82 0000009D	        jc      init_failed

				      ; INT14 - Page fault exception
 0000020E  B8 62696E74		        mov     eax,'bint'
 00000213  B3 0E		        mov     bl,14
 00000215  BA 00005471 R	        mov     edx,offset invDEBI_int14_handler
 0000021A  2E: FF 1D		        call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
 00000221  0F 82 00000084	        jc      init_failed

				      ; INT15 - Because it might be implemented in future Intel cpus
 00000227  B8 62696E74		        mov     eax,'bint'
 0000022C  B3 0F		        mov     bl,15
 0000022E  BA 00005480 R	        mov     edx,offset invDEBI_int15_handler
 00000233  2E: FF 1D		        call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
 0000023A  72 6F		        jc      init_failed

				      ; INT16 - Floating point error
 0000023C  B8 62696E74		        mov     eax,'bint'
 00000241  B3 10		        mov     bl,16
 00000243  BA 00005491 R	        mov     edx,offset invDEBI_int16_handler
 00000248  2E: FF 1D		        call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
 0000024F  72 5A		        jc      init_failed

				      ; INT17 - Alignment check exception
 00000251  B8 62696E74		        mov     eax,'bint'
 00000256  B3 11		        mov     bl,17
 00000258  BA 000054A2 R	        mov     edx,offset invDEBI_int17_handler
 0000025D  2E: FF 1D		        call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
 00000264  72 45		        jc      init_failed

				      ; INT18 - Machine check exception
 00000266  B8 62696E74		        mov     eax,'bint'
 0000026B  B3 12		        mov     bl,18
 0000026D  BA 000054B1 R	        mov     edx,offset invDEBI_int18_handler
 00000272  2E: FF 1D		        call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
 00000279  72 30		        jc      init_failed

				      ; Initialize the memory area
 0000027B  B8 000000D8		        mov     eax,_sDEBI_memory
 00000280  66| 8E C0		        mov     es,ax
 00000283  67& 26: C7 06	        mov     dword ptr es:[0],4                                  ; Indicate the starting offset for the next data item
	   0000 00000004
 0000028D  BF 00000004		        mov     edi,4
 00000292  B9 00007FFC		        mov     ecx,_sDEBI_memory_limit - 4                         ; Reset everything in the memory area to 0ffh
 00000297  B0 FF		        mov     al,0ffh
 00000299  FC			        cld
 0000029A  F3/ AA		        rep     stosb

 0000029C			      init_ok:
 0000029C  BE 0000D414 R	        mov     esi,offset debi_boot_logo
 000002A1  2E: FF 1D		        call    fword ptr cs:_VID_draw_logo
	   0000D0D9 R
 000002A8  F8			        clc
 000002A9  EB 01		        jmp     init_quit

 000002AB			      init_failed:
 000002AB  F9			        stc

 000002AC			      init_quit:
 000002AC  07			        pop     es
 000002AD  C3			        ret
 000002AE			    initialize_driver   ENDP





 000002AE			    DEBI_debug   PROC
				    ; This procedure is called during a fatal error.  The system will be halted.
				    ;
				    ; Upon entry:   Stack is arranged as below
				    ;               eax - ptr to the type of error encountered
				    ;
				    ; Upon exit:    The errant program continues
				    ;
				      ; * Note that esp = current value of ebp+60
				      ; [ebp+60] - eflags
				      ; [ebp+56] - cs
				      ; [ebp+52] - eip
				      ; [ebp+48] - <error code>
				      ; [ebp+44] - eax
				      ; [ebp+40] - ebx
				      ; [ebp+36] - ecx
				      ; [ebp+32] - edx
				      ; [ebp+28] - esi
				      ; [ebp+24] - edi
				      ; [ebp+20] - ds
				      ; [ebp+16] - es
				      ; [ebp+12] - fs
				      ; [ebp+08] - gs
				      ; [ebp+04] - ss
				      ; [ebp+00] - ebp
				      ; [ebp-04] - esp
 000002AE  53			        push    ebx
 000002AF  51			        push    ecx
 000002B0  52			        push    edx
 000002B1  56			        push    esi
 000002B2  57			        push    edi
 000002B3  1E			        push    ds
 000002B4  06			        push    es
 000002B5  0F A0		        push    fs
 000002B7  0F A8		        push    gs
 000002B9  16			        push    ss
 000002BA  C8 00C8 00		        enter   200,0
 000002BE  89 6D FC		        mov     dword ptr ss:[ebp-04],ebp
 000002C1  83 45 FC 40		        add     dword ptr ss:[ebp-04],64                            ; Make this value of ESP be what it was originally
				      ; [ebp-004] - (see above)
				      ; [ebp-008] -  dword,  Current font increment
				      ; * Note:  This public stack frame is used by all routines in Debi.
				      ;          It cannot be changed without the express written permission of Major League Baseball
				      ;------
				      ; invDEBI_draw_objects
				      ; [ebp-092] -  dword,  Temporary variable used in
				      ;------
				      ; invDEBI_populate_debug_screen
				      ; [ebp-080] - offset into _sDEBI_memory for next item
				      ; [ebp-084] - segment of temp far address
				      ; [ebp-088] - offset of temp far address
				      ; [ebp-092] - (temp) used as a temporary holder for processing
				      ;------
				      ; [ebp-200] - 108 bytes, FPU save state
 000002C5  9B DD B5		        fsave   ss:[ebp-200]
	   FFFFFF38
 000002CC  9B DB E3		        finit

 000002CF  66| 2E: 8E 1D	        mov     ds,cs:data_segment
	   0000B77F R
				      ; See if we're in a step-over condition
				        .IF (ds:step_over == 1)
 000002D7  80 3D 0000B778 R
	   01		   *	    cmp    ds : step_over, 001h
 000002DE  75 33	   *	    jne    @C000D
				          ; We have to replace the byte that was updated
 000002E0  60			            pushad
 000002E1  C6 05 0000B778 R	            mov     ds:step_over,0
	   00
 000002E8  A0 0000B77D R	            mov     al,ds:step_replaced_byte
 000002ED  8B 1D 0000B779 R	            mov     ebx,ds:step_offset
 000002F3  0F A0		            push    fs
 000002F5  BA 000000F8		            mov     edx,_sDEBI_temp
 000002FA  8E E2		            mov     fs,edx
 000002FC  64: 88 03		            mov     byte ptr fs:[ebx],al
 000002FF  0F A1		            pop     fs
 00000301  43			            inc     ebx
				            .IF (dword ptr ss:[ebp+52] == ebx)
 00000302  39 5D 34	   *	    cmp    dword ptr ss : [ebp + 034h], ebx
 00000305  75 0B	   *	    jne    @C000F
 00000307  FF 4D 34		                dec     dword ptr ss:[ebp+52]
 0000030A  C7 44 24 1C		                mov     dword ptr ss:[esp+28],offset step_over_text
	   0000B4CF R
				            .ENDIF
 00000312		   *@C000F:
 00000312  61			            popad
				        .ENDIF
 00000313		   *@C000D:

				      ; Right now ds:[eax] - far ptr to the error string (identified by the error trapping functions below)
 00000313  8B F0		        mov     esi,eax
 00000315  E8 00000152		        call    invDEBI_update_message
				      ; Right now, ds:[edi] - far ptr to the end of the error string in the query window
				      ;                 ecx - number of bytes written
				      ; Try to find out what procedure caused the problem
 0000031A  8B 5D 34		        mov     ebx,dword ptr ss:[ebp+52]
 0000031D  8B 55 38		        mov     edx,dword ptr ss:[ebp+56]
 00000320  B9 0000002D		        mov     ecx,45
 00000325  8B F7		        mov     esi,edi
				      ; Right now:   edx - code segment
				      ;              ebx - instruction pointer
				      ;         ds:[esi] - far ptr where to store
				      ;              ecx - maximum # of bytes to store
 00000327  B8 66696E64		        mov     eax,'find'
 0000032C  BF 66756E63		        mov     edi,'func'
 00000331  FF 1D 0000D0D7 R	        call    fword ptr ds:_EXODUS_requestor

				      ; Draw the DEBI screen
 00000337  FF 1D 0000D0EF R	        call    fword ptr ds:_VID_g_set_font_8x6                    ; Set font at 8x6
 0000033D  C7 45 F8		        mov     dword ptr ss:[ebp-08],6
	   00000006
 00000344  FE 05 0000B784 R	        inc     ds:debug_levels
 0000034A  E8 000001B2		        call    invDEBI_populate_debug_screen
 0000034F  C6 05 0000B785 R	        mov     ds:debug_screen_shown,1
	   01
 00000356  C7 05 0000B802 R	        mov     ds:mouse_status,0                                   ; Indicate that the mouse is not currently being displayed
	   00000000
				                                                                    ; Note, it's not displayed until they move or click
				      ; Intercept what we need from the keyboard/mouse
 00000360  FF 1D 0000D0E5 R	        call    fword ptr ds:_iKBD_activate_DEBI_intercept
 00000366  FF 1D 0000D0E9 R	        call    fword ptr ds:_iMOUSE_activate_DEBI_intercept
 0000036C  FF 1D 0000D0F7 R	        call    fword ptr ds:_iTIMER_activate_DEBI_timer_feed
 00000372  E8 0000133D		        call    invDEBI_show_mouse_pointer

				      ; Now, we wait.  This is an object oriented system.
				      ; When interrupts (mouse or keyboard) are triggered they will be acted on accordingly by the procedures below.
				      ; The only thing we have to look for is our exit code when it's available
 00000377  C6 05 0000B787 R	        mov     ds:debi_ok_to_quit,0
	   00
 0000037E  FB			        sti                                                         ; Allow interrupts (they're needed for mouse/keyboard)
 0000037F			      @@:
 0000037F  F4			        hlt
				        .IF (ds:debi_ok_to_quit == 1)
 00000380  80 3D 0000B787 R
	   01		   *	    cmp    ds : debi_ok_to_quit, 001h
 00000387  75 73	   *	    jne    @C0011
				          ; They're single stepping
 00000389  8E 5D 38		            mov     ds,dword ptr ss:[ebp+56]
 0000038C  8B 75 34		            mov     esi,dword ptr ss:[ebp+52]
 0000038F  8A 06		            mov     al,byte ptr ds:[esi]
				            .IF (al == 0eah || al == 09ah)
 00000391  3C EA	   *	    cmp    al, 0EAh
 00000393  74 04	   *	    je     @C0014
 00000395  3C 9A	   *	    cmp    al, 09Ah
 00000397  75 52	   *	    jne    @C0013
 00000399		   *@C0014:
				              ; They're issuing an explicit JMP FAR or CALL FAR
				              ; We have to see if it's going to a CALL GATE
 00000399  0F B7 56 05		                movzx   edx,word ptr ds:[esi+5]
 0000039D  F7 C2 00000007	                test    edx,111b
				                .IF (zero?)
 000003A3  75 46	   *	    jne    @C0016
 000003A5  C1 EA 03		                    shr     edx,3                                   ; Divide by 8 (to get slot)
 000003A8  B8 67657420		                    mov     eax,'get '
 000003AD  BB 67647420		                    mov     ebx,'gdt '
 000003B2  2E: FF 1D		                    call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
				                    .IF (!carry?)
 000003B9  72 30	   *	    jb     @C0018
				                      ; Right now, ebx - upper dword
				                      ;            edx - lower dword
 000003BB  80 E7 1F		                        and     bh,11111b
				                        .IF (bh == 00101b)
 000003BE  80 FF 05	   *	    cmp    bh, 005h
 000003C1  75 28	   *	    jne    @C001A
				                          ; It is a call gate
 000003C3  0F B7 56 05		                            movzx   edx,word ptr ds:[esi+5]
 000003C7  C1 EA 03		                            shr     edx,3
 000003CA  B8 67657420		                            mov     eax,'get '
 000003CF  BB 74737320		                            mov     ebx,'tss '
 000003D4  2E: FF 1D		                            call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
 000003DB  B8 00000040		                            mov     eax,_sALL_MEM
 000003E0  8E D8		                            mov     ds,eax
				;                            or      byte ptr ds:[ebx+_TSS_TRAP_BIT],_TSS_TRAP_BIT_MASK
 000003E2  81 4B 24		                            or      dword ptr ds:[ebx+_TSS_EFLAGS],100000000b
	   00000100
				;mov ds,cs:data_segment
				;mov ds:hlt_now,1
 000003E9  EB 07		                            jmp     bypass_our_eflags
				                        .ENDIF
				                    .ENDIF
 000003EB		   *@C001A:
				                .ENDIF
 000003EB		   *@C0018:
				            .ENDIF
 000003EB		   *@C0016:
 000003EB		   *@C0013:
 000003EB  81 4D 3C		            or      dword ptr ss:[ebp+60],100000000b
	   00000100
 000003F2			          bypass_our_eflags:
 000003F2  66| 2E: 8E 1D	            mov     ds,cs:data_segment
	   0000B77F R
				        .ELSEIF (ds:debi_ok_to_quit == 2)
 000003FA  EB 2E	   *	    jmp    @C001C
 000003FC		   *@C0011:
 000003FC  80 3D 0000B787 R
	   02		   *	    cmp    ds : debi_ok_to_quit, 002h
 00000403  75 0E	   *	    jne    @C001D
				          ; They're continuing on from here
 00000405  C7 05 0000B940 R	            mov     ds:single_step_history,-1
	   FFFFFFFF
 0000040F  EB 0B		            jmp     no_single_step
				        .ELSEIF (ds:debi_ok_to_quit == 3)
 00000411  EB 17	   *	    jmp    @C001F
 00000413		   *@C001D:
 00000413  80 3D 0000B787 R
	   03		   *	    cmp    ds : debi_ok_to_quit, 003h
 0000041A  75 09	   *	    jne    @C0020
				          ; They're stepping over this one
 0000041C			          no_single_step:
 0000041C  81 65 3C		            and     dword ptr ss:[ebp+60],not 100000000b
	   FFFFFEFF
				        .ELSE
 00000423  EB 05	   *	    jmp    @C0022
 00000425		   *@C0020:
				          ; Nope, we're still waiting... :)
 00000425  E9 FFFFFF55		            jmp     @B
				        .ENDIF
 0000042A		   *@C0022:
 0000042A		   *@C001F:
 0000042A		   *@C001C:

				      ; Note, the code will only get here if they've done something to modify the status of debi_ok_to_quit
				      ;       This happens when they press key combinations or click on step/go/etc.
 0000042A  E8 0000125A		        call    invDEBI_hide_mouse_pointer
 0000042F  FF 1D 0000D0F9 R	        call    fword ptr ds:_iTIMER_deactivate_DEBI_timer_feed
 00000435  FF 1D 0000D0EB R	        call    fword ptr ds:_iMOUSE_deactivate_DEBI_intercept
 0000043B  FF 1D 0000D0E7 R	        call    fword ptr ds:_iKBD_deactivate_DEBI_intercept
 00000441  C6 05 0000B8B1 R	        mov     ds:force_cursor_off,1
	   01
 00000448  E8 00001392		        call    invDEBI_turn_cursor_off
 0000044D  FE 0D 0000B784 R	        dec     ds:debug_levels
 00000453  DD A5 FFFFFF38	        frstor  ss:[ebp-200]
 00000459  C9			        leave
 0000045A  17			        pop     ss
 0000045B  0F A9		        pop     gs
 0000045D  0F A1		        pop     fs
 0000045F  07			        pop     es
 00000460  1F			        pop     ds
 00000461  5F			        pop     edi
 00000462  5E			        pop     esi
 00000463  5A			        pop     edx
 00000464  59			        pop     ecx
 00000465  5B			        pop     ebx
 00000466  58			        pop     eax
 00000467  83 C4 04		        add     esp,4                                               ; Get past the error code
 0000046A  CF			        iretd
 0000046B			    DEBI_debug   ENDP




 0000046B			    invDEBI_null        PROC
				    ; This routine does nothing except return to the calling program
 0000046B  C3			        ret
 0000046C			    invDEBI_null        ENDP









				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; 00000 - Window Supportive Algorithms/Handlers
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 0000046C			    invDEBI_update_message      PROC
				    ; This routine is used to update the error message on screen (so we can see what error it was/is)
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to error string
				    ;
				    ; Upon exit:    ds:[edi] - far ptr to where next bit of information would go on the current line
				    ;                    ecx - how many character were copied so far
				    ;
 0000046C  06			        push    es
 0000046D  66| 8E 05		        mov     es,ds:data_segment
	   0000B77F R

 00000474  FC			        cld
 00000475  56			        push    esi
				      ; Scroll line 2 to 3
 00000476  BF 000083B5 R	        mov     edi,offset query_3
 0000047B  BE 00008410 R	        mov     esi,offset query_2
 00000480  B9 00000059		        mov     ecx,sizeof query_2-2
 00000485  F3/ A4		        rep     movsb
				      ; Scroll line 1 to 2
 00000487  BF 00008410 R	        mov     edi,offset query_2
 0000048C  BE 0000846B R	        mov     esi,offset query_1
 00000491  B9 00000059		        mov     ecx,sizeof query_1-2
 00000496  F3/ A4		        rep     movsb
				      ; Reset line 1 to spaces
 00000498  BF 0000846B R	        mov     edi,offset query_1
 0000049D  B0 20		        mov     al,32
 0000049F  B9 00000059		        mov     ecx,sizeof query_1-2
 000004A4  F3/ AA		        rep     stosb
				      ; Copy the source string to line 1
 000004A6  5E			        pop     esi
 000004A7  BF 0000846B R	        mov     edi,offset query_1
 000004AC  33 C9		        xor     ecx,ecx
				        .WHILE (byte ptr ds:[esi] != 0 && ecx < (sizeof query_1-2))
 000004AE  EB 03	   *	    jmp    @C0023
 000004B0		   *@C0024:
 000004B0  AC			            lodsb
 000004B1  AA			            stosb
 000004B2  41			            inc     ecx
				        .ENDW
 000004B3		   *@C0023:
 000004B3  80 3E 00	   *	    cmp    byte ptr ds : [esi], 000h
 000004B6  74 05	   *	    je     @C0025
 000004B8  83 F9 59	   *	    cmp    ecx, sizeof query_1 - 002h
 000004BB  72 F3	   *	    jb     @C0024
 000004BD		   *@C0025:

 000004BD  07			        pop     es
 000004BE  C3			        ret
 000004BF			    invDEBI_update_message      ENDP




 000004BF			    invDEBI_clear_screen_and_redraw_windows     PROC
				    ; This routine is called to clear the screen and then redraw all windows
				    ;
				      ; Clear the whole screen
 000004BF  68 00000000		        push    dword ptr 0
 000004C4  68 00000000		        push    dword ptr 0
 000004C9  68 000002D0		        push    dword ptr 720
 000004CE  68 0000015C		        push    dword ptr 348
 000004D3  68 00000002		        push    dword ptr 2                                         ; Clear
 000004D8  68 00000000		        push    dword ptr 0                                         ; Not used here, but required for spacer
 000004DD  2E: FF 1D		        call    fword ptr cs:_VID_g_mono_window_function
	   0000D0FD R
				        ; Note, this line is not executed because program flow will just fall right through
				        ;jmp     invDEBI_redraw_windows
 000004E4			    invDEBI_clear_screen_and_redraw_windows     ENDP




 000004E4			    invDEBI_redraw_windows      PROC
				    ; This routine forces a redraw of all windows
 000004E4  50			        push    eax
 000004E5  0F B6 05		        movzx   eax,ds:force_screen_redraw
	   0000B786 R
 000004EC  50			        push    eax

 000004ED  C6 05 0000B786 R	        mov     ds:force_screen_redraw,_YES
	   01
 000004F4  E8 00000008		        call    invDEBI_populate_debug_screen

 000004F9  58			        pop     eax
 000004FA  A2 0000B786 R	        mov     ds:force_screen_redraw,al
 000004FF  58			        pop     eax
 00000500  C3			        ret
 00000501			    invDEBI_redraw_windows      ENDP




 00000501			    invDEBI_populate_debug_screen       PROC
				    ; This routine is used to put the relevent information on the screen
				    ;
				    ; Upon entry:   The stack arrangement is provided directly from DEBI_debug()'s stack frame
				    ;               * Changes here must be reflected and made compatible with that algorithm
				    ;
				    ; Upon exit:    The various screens are populated
				    ;
				      ; [ebp-080] - offset into _sDEBI_memory (memory area) for next item
				      ; [ebp-084] - segment of temp far address
				      ; [ebp-088] - offset of temp far address
				      ; [ebp-092] - (temp) used as a temporary holder for processing
 00000501  C7 45 B0		        mov     dword ptr ss:[ebp-080],0                            ; Start at the beginning
	   00000000
 00000508  C7 45 AC		        mov     dword ptr ss:[ebp-084],-1                           ; Force an invalid address at the outset
	   FFFFFFFF
 0000050F  C7 45 A8		        mov     dword ptr ss:[ebp-088],-1
	   FFFFFFFF

 00000516  BE 000054C2 R	        mov     esi,offset DEBI_screen_table
 0000051B  33 C9		        xor     ecx,ecx
				        .WHILE (ecx < 15)
 0000051D  EB 16	   *	    jmp    @C0027
 0000051F		   *@C0028:
				            .IF (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _YES)
 0000051F  80 7E 01 01	   *	    cmp    byte ptr ds : [esi + _ST_OBJECT_ACTIVE], _YES
 00000523  75 0C	   *	    jne    @C0029
 00000525  56			                push    esi
 00000526  51			                push    ecx

				              ; After this, ds:[esi] - pointer to this screen table structure
				              ;             ds:[edi] - pointer to this item's objects
 00000527  8B 7E 1C		                mov     edi,dword ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]     ; Get the offset to the objects
 0000052A  E8 0000000C		                call    invDEBI_draw_objects

 0000052F  59			                pop     ecx
 00000530  5E			                pop     esi
				            .ENDIF
 00000531		   *@C0029:
 00000531  41			            inc     ecx
 00000532  83 C6 20		            add     esi,_ST_LENGTH
				        .ENDW
 00000535		   *@C0027:
 00000535  83 F9 0F	   *	    cmp    ecx, 00Fh
 00000538  72 E5	   *	    jb     @C0028
 0000053A  C3			        ret
 0000053B			    invDEBI_populate_debug_screen       ENDP




 0000053B			    invDEBI_draw_objects    PROC
				    ; This routine is called to update some objects on the screen
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to screen table structure
				    ;               ds:[edi] - far ptr to objects
				    ;               ss:[ebp] - space is available indicated in DEBI_debug()
				    ;
				    ; Upon exit:    The object is drawn/redrawn
				    ;
 0000053B  06			        push    es
 0000053C  60			        pushad
 0000053D  B8 000000D8		        mov     eax,_sDEBI_memory                                   ; All DEBI windows store memory here.   Well, at least those
 00000542  8E C0		        mov     es,eax                                              ; not handled by _FUNCTION (and even they still might hehehe)
				      ; Right now, es:[0] - far ptr to the _sDEBI_memory structure
				        .WHILE (byte ptr ds:[edi] != _END)
 00000544  E9 0000047B	   *	    jmp    @C002C
 00000549		   *@C002D:
 00000549  8A 07		            mov     al,byte ptr ds:[edi]
				            .IF (al == _OBJECT_MEM_SIZE)
 0000054B  0A C0	   *	    or	al, al
 0000054D  75 34	   *	    jne    @C002E
				              ; They're specifying how big this window's memory size is in the buffer
				                .IF (dword ptr ds:[esi+_ST_OBJECT_MEMORY_OFFSET] == -1 && byte ptr ds:[edi+1] != 0)
 0000054F  83 7E 14 FF	   *	    cmp    dword ptr ds : [esi + _ST_OBJECT_MEMORY_OFFSET], - 001h
 00000553  75 26	   *	    jne    @C0030
 00000555  80 7F 01 00	   *	    cmp    byte ptr ds : [edi + 001h], 000h
 00000559  74 20	   *	    je     @C0030
				                  ; It hasn't already been allocated, so let's allocate some memory for this bad boy
 0000055B  67& 26: A1		                    mov     eax,dword ptr es:[0]
	   0000
				                  ; Right now, eax - offset into temp space where this item will go
 00000560  89 46 14		                    mov     dword ptr ds:[esi+_ST_OBJECT_MEMORY_OFFSET],eax
 00000563  0F B6 5F 01		                    movzx   ebx,byte ptr ds:[edi+1]                 ; Indicate where the next one will go
 00000567  67& 26: 01 1E	                    add     dword ptr es:[0],ebx
	   0000

				                    .WHILE (ebx > 0)                                ; Initialize the memory area to 0ffh's
 0000056D  EB 07	   *	    jmp    @C0033
 0000056F		   *@C0034:
 0000056F  26: C6 44 03		                        mov     byte ptr es:[eax+ebx-1],0ffh
	   FF FF
 00000575  4B			                        dec     ebx
				                    .ENDW
 00000576		   *@C0033:
 00000576  83 FB 00	   *	    cmp    ebx, 000h
 00000579  77 F4	   *	    ja     @C0034
				                .ENDIF
				              ; Finished, we skip past this fixed 2-byte structure (db _OBJECT_MEM_SIZE, <size>)
 0000057B		   *@C0030:
 0000057B  83 C7 02		                add     edi,2
				            .ELSEIF (al == _LOAD_TEMP)
 0000057E  E9 00000441	   *	    jmp    @C0036
 00000583		   *@C002E:
 00000583  3C 02	   *	    cmp    al, _LOAD_TEMP
 00000585  75 47	   *	    jne    @C0037
				              ; They want to indicate where to load a temporary variable
 00000587  8A 47 01		                mov     al,byte ptr ds:[edi+1]
				                .IF (al == _FAR_MEMORY_PTR)
 0000058A  0A C0	   *	    or	al, al
 0000058C  75 36	   *	    jne    @C0039
 0000058E  8B 46 14		                    mov     eax,dword ptr ds:[esi+_ST_OBJECT_MEMORY_OFFSET]
				                    .IF (eax == -1)
 00000591  83 F8 FF	   *	    cmp    eax, - 001h
 00000594  75 0A	   *	    jne    @C003B
				                      ; It hasn't yet been initialized, so we can't do anything
 00000596  E9 00000432		                        jmp     next_window
				                    .ELSE
 0000059B  E9 00000424	   *	    jmp    @C003D
 000005A0		   *@C003B:
				                      ; It's valid
 000005A0  26: 8A 10		                        mov     dl,byte ptr es:[eax]
				                        .IF (dl == _RAW_ADDRESS)
 000005A3  0A D2	   *	    or	dl, dl
 000005A5  75 13	   *	    jne    @C003E
				                          ; Ok, the raw address they're working with is here
 000005A7  26: 8B 50 01		                            mov     edx,dword ptr es:[eax+1]
 000005AB  89 55 AC		                            mov     dword ptr ss:[ebp-084],edx
 000005AE  26: 8B 50 05		                            mov     edx,dword ptr es:[eax+5]
 000005B2  89 55 A8		                            mov     dword ptr ss:[ebp-088],edx
 000005B5  83 C7 03		                            add     edi,3
				                        .ELSE
 000005B8  EB 05	   *	    jmp    @C0040
 000005BA		   *@C003E:
				                          ; Unsupported option (or invalid data)
 000005BA  E9 0000040E		                            jmp     next_window
				                        .ENDIF
				                    .ENDIF
 000005BF		   *@C0040:
				                .ELSE
 000005BF  E9 00000400	   *	    jmp    @C0041
 000005C4		   *@C0039:
				                  ; Unknown item
 000005C4  E9 00000404		                    jmp     next_window
				                .ENDIF
				            .ELSEIF (al == _DISPLAY)
 000005C9  E9 000003F6	   *	    jmp    @C0042
 000005CE		   *@C0037:
 000005CE  3C 03	   *	    cmp    al, _DISPLAY
 000005D0  0F 85 0000037C  *	    jne    @C0043
				              ; They want to display something
 000005D6  8A 47 01		                mov     al,byte ptr ds:[edi+1]
				                .IF (al == _TEMP_RELATIVE)
 000005D9  0A C0	   *	    or	al, al
 000005DB  75 0D	   *	    jne    @C0045
				                  ; They're specifying an address relative to the previously loaded temporary address
 000005DD  83 C7 10		                    add     edi,16
 000005E0  E9 000003DF		                    jmp     next_object

				                .ELSEIF (al == _EBP_RELATIVE)
 000005E5  E9 000003DA	   *	    jmp    @C0047
 000005EA		   *@C0045:
 000005EA  3C 01	   *	    cmp    al, _EBP_RELATIVE
 000005EC  0F 85 00000220  *	    jne    @C0048
				                  ; They're specifying that it's EBP relative (our EBP, not theirs)
 000005F2  0F BF 5F 03		                    movsx   ebx,word ptr ds:[edi+3]
 000005F6  36: 8B 14 2B		                    mov     edx,dword ptr ss:[ebp+ebx]
 000005FA  8A 47 02		                    mov     al,byte ptr ds:[edi+2]
				                    .IF (al == _UPPER_NIBBLE)
 000005FD  0A C0	   *	    or	al, al
 000005FF  75 18	   *	    jne    @C004A
 00000601  81 E2 000000F0	                        and     edx,0f0h
 00000607  C1 EA 04		                        shr     edx,4
 0000060A  BB 00000002		                        mov     ebx,2
 0000060F  B9 00000004		                        mov     ecx,4
				                    .ELSEIF (al == _LOWER_NIBBLE)
 00000614  E9 000001D5	   *	    jmp    @C004C
 00000619		   *@C004A:
 00000619  3C 01	   *	    cmp    al, _LOWER_NIBBLE
 0000061B  75 12	   *	    jne    @C004D
 0000061D  83 E2 0F		                        and     edx,00fh
 00000620  BB 00000002		                        mov     ebx,2
 00000625  B9 00000004		                        mov     ecx,4
				                    .ELSEIF (al == _8)
 0000062A  E9 000001BF	   *	    jmp    @C004F
 0000062F		   *@C004D:
 0000062F  3C 03	   *	    cmp    al, _8
 00000631  75 15	   *	    jne    @C0050
 00000633  81 E2 000000FF	                        and     edx,0ffh
 00000639  BB 00000010		                        mov     ebx,16
 0000063E  B9 00000002		                        mov     ecx,2
				                    .ELSEIF (al == _16)
 00000643  E9 000001A6	   *	    jmp    @C0052
 00000648		   *@C0050:
 00000648  3C 04	   *	    cmp    al, _16
 0000064A  75 15	   *	    jne    @C0053
 0000064C  81 E2 0000FFFF	                        and     edx,0ffffh
 00000652  BB 00000010		                        mov     ebx,16
 00000657  B9 00000004		                        mov     ecx,4
				                    .ELSEIF (al == _FPU_OPCODE)
 0000065C  E9 0000018D	   *	    jmp    @C0055
 00000661		   *@C0053:
 00000661  3C 0F	   *	    cmp    al, _FPU_OPCODE
 00000663  75 1B	   *	    jne    @C0056
 00000665  81 E2 000007FF	                        and     edx,0000011111111111b
 0000066B  81 CA 0000D800	                        or      edx,1101100000000000b
 00000671  BB 00000010		                        mov     ebx,16
 00000676  B9 00000004		                        mov     ecx,4
				                    .ELSEIF (al == _32)
 0000067B  E9 0000016E	   *	    jmp    @C0058
 00000680		   *@C0056:
 00000680  3C 05	   *	    cmp    al, _32
 00000682  75 0F	   *	    jne    @C0059
 00000684  B9 00000008		                        mov     ecx,8
 00000689  BB 00000010		                        mov     ebx,16
				                    .ELSEIF (al == _LOWER_NIBBLE3)
 0000068E  E9 0000015B	   *	    jmp    @C005B
 00000693		   *@C0059:
 00000693  3C 02	   *	    cmp    al, _LOWER_NIBBLE3
 00000695  75 12	   *	    jne    @C005C
 00000697  83 E2 07		                        and     edx,7
 0000069A  BB 00000002		                        mov     ebx,2
 0000069F  B9 00000003		                        mov     ecx,3
				                    .ELSEIF (al == _BINARY8)
 000006A4  E9 00000145	   *	    jmp    @C005E
 000006A9		   *@C005C:
 000006A9  3C 06	   *	    cmp    al, _BINARY8
 000006AB  75 0F	   *	    jne    @C005F
 000006AD  BB 00000002		                        mov     ebx,2
 000006B2  B9 00000008		                        mov     ecx,8
				                    .ELSEIF (al == _BINARY11)
 000006B7  E9 00000132	   *	    jmp    @C0061
 000006BC		   *@C005F:
 000006BC  3C 07	   *	    cmp    al, _BINARY11
 000006BE  75 0F	   *	    jne    @C0062
 000006C0  BB 00000002		                        mov     ebx,2
 000006C5  B9 0000000B		                        mov     ecx,11
				                    .ELSEIF (al == _BINARY16)
 000006CA  E9 0000011F	   *	    jmp    @C0064
 000006CF		   *@C0062:
 000006CF  3C 08	   *	    cmp    al, _BINARY16
 000006D1  75 0F	   *	    jne    @C0065
 000006D3  BB 00000002		                        mov     ebx,2
 000006D8  B9 00000010		                        mov     ecx,16
				                    .ELSEIF (al == _BINARY32)
 000006DD  E9 0000010C	   *	    jmp    @C0067
 000006E2		   *@C0065:
 000006E2  3C 09	   *	    cmp    al, _BINARY32
 000006E4  75 0F	   *	    jne    @C0068
 000006E6  BB 00000002		                        mov     ebx,2
 000006EB  B9 00000020		                        mov     ecx,32
				                    .ELSE
 000006F0  E9 000000F9	   *	    jmp    @C006A
 000006F5		   *@C0068:
				                      ; These are handled as text operations
				                        .IF (al == _TBYTE || al == _IEEE_80)
 000006F5  3C 0B	   *	    cmp    al, _TBYTE
 000006F7  74 04	   *	    je     @C006C
 000006F9  3C 0A	   *	    cmp    al, _IEEE_80
 000006FB  75 43	   *	    jne    @C006B
 000006FD		   *@C006C:
				                          ; It is a floating point real to be displayed in hex format
 000006FD  BA 0000B9B4 R	                            mov     edx,offset trash_string
 00000702  B9 0000000A		                            mov     ecx,10
				                            .WHILE (ecx > 0)
 00000707  EB 2A	   *	    jmp    @C006E
 00000709		   *@C006F:
 00000709  36: 8A 04 2B		                                mov     al,byte ptr ss:[ebp+ebx]
 0000070D  8A E0		                                mov     ah,al
 0000070F  24 0F		                                and     al,0fh
				                                .IF (al > 9)
 00000711  3C 09	   *	    cmp    al, 009h
 00000713  76 04	   *	    jbe    @C0070
				                                  ; It gets a letter
 00000715  04 57		                                    add     al,'a'-10
				                                .ELSE
 00000717  EB 02	   *	    jmp    @C0072
 00000719		   *@C0070:
				                                  ; It gets a number
 00000719  04 30		                                    add     al,'0'
				                                .ENDIF
 0000071B		   *@C0072:
 0000071B  88 02		                                mov     byte ptr ds:[edx],al
 0000071D  42			                                inc     edx
 0000071E  80 E4 0F		                                and     ah,0fh
				                                .IF (ah > 9)
 00000721  80 FC 09	   *	    cmp    ah, 009h
 00000724  76 05	   *	    jbe    @C0073
				                                  ; It gets a letter
 00000726  80 C4 57		                                    add     ah,'a'-10
				                                .ELSE
 00000729  EB 03	   *	    jmp    @C0075
 0000072B		   *@C0073:
				                                  ; It gets a number
 0000072B  80 C4 30		                                    add     ah,'0'
				                                .ENDIF
 0000072E		   *@C0075:
 0000072E  88 02		                                mov     byte ptr ds:[edx],al
 00000730  42			                                inc     edx
 00000731  49			                                dec     ecx
 00000732  43			                                inc     ebx
				                            .ENDW
 00000733		   *@C006E:
 00000733  83 F9 00	   *	    cmp    ecx, 000h
 00000736  77 D1	   *	    ja     @C006F
 00000738  C6 02 00		                            mov     byte ptr ds:[edx],0
				                          ; Right now the string is created and null-terminated

				                        .ELSEIF (al == _ADJ_FLOAT14)
 0000073B  E9 00000086	   *	    jmp    @C0077
 00000740		   *@C006B:
 00000740  3C 0C	   *	    cmp    al, _ADJ_FLOAT14
 00000742  75 27	   *	    jne    @C0078
				                          ; This is an abbreviated version of the floating point data, only 14 chars wide total
 00000744  57			                            push    edi
 00000745  B9 0000000E		                            mov     ecx,14
 0000074A  BF 0000B9B4 R	                            mov     edi,offset trash_string
 0000074F  E8 0000031A		                            call    invDEBI_check_stx_from_fpu_save_state
				                            .IF (!carry?)
 00000754  72 12	   *	    jb     @C007A
 00000756  9B DB E3		                                finit
 00000759  E8 000002A8		                                call    invDEBI_load_stx_from_ebx
				                              ; Right now, st(0) - the value we need to display
 0000075E  E8 000003E7		                                call    invDEBI_convert_st0_to_string
 00000763  E8 00000646		                                call    invDEBI_align_floating_point_string
				                            .ENDIF
 00000768		   *@C007A:
 00000768  5F			                            pop     edi
				                        .ELSEIF (al == _ADJ_FLOAT20)
 00000769  EB 5B	   *	    jmp    @C007C
 0000076B		   *@C0078:
 0000076B  3C 0D	   *	    cmp    al, _ADJ_FLOAT20
 0000076D  75 27	   *	    jne    @C007D
				                          ; This is a full width floating point data
 0000076F  57			                            push    edi
 00000770  B9 00000014		                            mov     ecx,20
 00000775  BF 0000B9B4 R	                            mov     edi,offset trash_string
 0000077A  E8 000002EF		                            call    invDEBI_check_stx_from_fpu_save_state
				                            .IF (!carry?)
 0000077F  72 12	   *	    jb     @C007F
 00000781  9B DB E3		                                finit
 00000784  E8 0000027D		                                call    invDEBI_load_stx_from_ebx
				                              ; Right now, st(0) - the value we need to display
 00000789  E8 000003BC		                                call    invDEBI_convert_st0_to_string
 0000078E  E8 0000061B		                                call    invDEBI_align_floating_point_string
				                            .ENDIF
 00000793		   *@C007F:
 00000793  5F			                            pop     edi
				                        .ELSEIF (al == _ADJ_FLOAT21)
 00000794  EB 30	   *	    jmp    @C0081
 00000796		   *@C007D:
 00000796  3C 0E	   *	    cmp    al, _ADJ_FLOAT21
 00000798  75 27	   *	    jne    @C0082
				                          ; This is a full width floating point data
 0000079A  57			                            push    edi
 0000079B  B9 00000015		                            mov     ecx,21
 000007A0  BF 0000B9B4 R	                            mov     edi,offset trash_string
 000007A5  E8 000002C4		                            call    invDEBI_check_stx_from_fpu_save_state
				                            .IF (!carry?)
 000007AA  72 12	   *	    jb     @C0084
 000007AC  9B DB E3		                                finit
 000007AF  E8 00000252		                                call    invDEBI_load_stx_from_ebx
				                              ; Right now, st(0) - the value we need to display
 000007B4  E8 00000391		                                call    invDEBI_convert_st0_to_string
 000007B9  E8 000005F0		                                call    invDEBI_align_floating_point_string
				                            .ENDIF
 000007BE		   *@C0084:
 000007BE  5F			                            pop     edi
				                        .ELSE
 000007BF  EB 05	   *	    jmp    @C0086
 000007C1		   *@C0082:
				                          ; Unknown type
 000007C1  E9 00000207		                            jmp     next_window
				                        .ENDIF
 000007C6		   *@C0086:
 000007C6		   *@C0081:
 000007C6		   *@C007C:
 000007C6		   *@C0077:
 000007C6  9C			                        pushfd
 000007C7  6A 00		                        push    0                           ; write operation (0-overlay)
 000007C9  8B 47 06		                        mov     eax,dword ptr ds:[edi+6]
 000007CC  03 46 04		                        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 000007CF  50			                        push    eax
				                      ; Y coordinate
 000007D0  8B 47 0A		                        mov     eax,dword ptr ds:[edi+10]
 000007D3  03 46 08		                        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 000007D6  50			                        push    eax
 000007D7  6A 00		                        push    0                           ; display mode (0-normal)
 000007D9  68 0000B9B4 R	                        push    dword ptr offset trash_string
 000007DE  FA			                        cli
 000007DF  FF 1D 0000D0E1 R	                        call    fword ptr ds:_VID_g_mono_display_text_mode
 000007E5  9D			                        popfd
 000007E6  83 C7 10		                        add     edi,16
 000007E9  E9 000001D6		                        jmp     next_object
				                    .ENDIF
				                  ; Right now, edx - lower nibble contains the upper nibble specified
				                  ;            ebx - 2 (base-2 number, it will be displayed in binary)
				                  ;            ecx - number of digits to display
				                  ; X coordinate
 000007EE		   *@C006A:
 000007EE		   *@C0067:
 000007EE		   *@C0064:
 000007EE		   *@C0061:
 000007EE		   *@C005E:
 000007EE		   *@C005B:
 000007EE		   *@C0058:
 000007EE		   *@C0055:
 000007EE		   *@C0052:
 000007EE		   *@C004F:
 000007EE		   *@C004C:
 000007EE  9C			                    pushfd
 000007EF  8B 47 06		                    mov     eax,dword ptr ds:[edi+6]
 000007F2  03 46 04		                    add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 000007F5  50			                    push    eax
				                  ; Y coordinate
 000007F6  8B 47 0A		                    mov     eax,dword ptr ds:[edi+10]
 000007F9  03 46 08		                    add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 000007FC  50			                    push    eax
 000007FD			                  just_display1:
 000007FD  FA			                    cli
 000007FE  FF 1D 0000D101 R	                    call    fword ptr ds:_VID_g_display_radix_in_edx_mono
 00000804  9D			                    popfd
 00000805			                  skip1:
 00000805  83 C7 10		                    add     edi,16
 00000808  E9 000001B7		                    jmp     next_object

				                .ELSEIF (al == _EBP_RELATIVE_EFLAG)
 0000080D  E9 000001B2	   *	    jmp    @C0087
 00000812		   *@C0048:
 00000812  3C 04	   *	    cmp    al, _EBP_RELATIVE_EFLAG
 00000814  75 4F	   *	    jne    @C0088
				                  ; They're specifying that it's EBP relative flag (our EBP, not theirs)
 00000816  0F BF 5F 02		                    movsx   ebx,word ptr ds:[edi+2]             ; Offset in our stack frame
 0000081A  36: 8B 14 2B		                    mov     edx,dword ptr ss:[ebp+ebx]          ; Value stored there
 0000081E  8B 4F 05		                    mov     ecx,dword ptr ds:[edi+5]            ; bit mask to use for flag
 00000821  23 D1		                    and     edx,ecx                             ; mask off the value (used below)
 00000823  8B DF		                    mov     ebx,edi                             ; Get a pointer to the text string to display
 00000825  83 C3 12		                    add     ebx,18
 00000828  0F B6 4B FF		                    movzx   ecx,byte ptr ds:[ebx-1]             ; Length of this string
				                    .IF (edx == 0)
 0000082C  0B D2	   *	    or	edx, edx
 0000082E  75 07	   *	    jne    @C008A
				                      ; FLAG is down
 00000830  C6 44 19 FF 19	                        mov     byte ptr ds:[ebx+ecx-1],''
				                    .ELSE
 00000835  EB 05	   *	    jmp    @C008C
 00000837		   *@C008A:
				                      ; FLAG is up
 00000837  C6 44 19 FF 18	                        mov     byte ptr ds:[ebx+ecx-1],''
				                    .ENDIF
				                  ; X coordinate
 0000083C		   *@C008C:
 0000083C  9C			                    pushfd
 0000083D  51			                    push    ecx
 0000083E  8B 47 09		                    mov     eax,dword ptr ds:[edi+9]
 00000841  03 46 04		                    add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 00000844  50			                    push    eax
				                  ; Y coordinate
 00000845  8B 47 0D		                    mov     eax,dword ptr ds:[edi+13]
 00000848  03 46 08		                    add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 0000084B  50			                    push    eax
 0000084C  53			                    push    ebx                                 ; offset to string
 0000084D  FA			                    cli
 0000084E  FF 1D 0000D0E3 R	                    call    fword ptr ds:_VID_g_mono_display_text
 00000854  59			                    pop     ecx
 00000855  9D			                    popfd
 00000856  03 D9		                    add     ebx,ecx                             ; move past the string
 00000858  43			                    inc     ebx                                 ; for the trailing null
 00000859  8B FB		                    mov     edi,ebx
 0000085B  E9 00000164		                    jmp     next_object

				                .ELSEIF (al == _EBP_THROUGH_EBP_RELATIVE)
 00000860  E9 0000015F	   *	    jmp    @C008D
 00000865		   *@C0088:
 00000865  3C 02	   *	    cmp    al, _EBP_THROUGH_EBP_RELATIVE
 00000867  75 76	   *	    jne    @C008E
				                  ; Something in the user's local variables
 00000869  8B 55 00		                    mov     edx,dword ptr ss:[ebp]              ; Get their original EBP value
 0000086C  0F BF 5F 03		                    movsx   ebx,word ptr ds:[edi+3]             ; Offset in their stack frame
 00000870  03 D3		                    add     edx,ebx
 00000872  F7 45 38		                    test    dword ptr ss:[ebp+56],111b
	   00000007
				                    .IF (zero?)
 00000879  75 07	   *	    jne    @C0090
				                      ; This is an Exodus core algorithm that's being debugged
 0000087B  BB 00008000		                        mov     ebx,08000h
				                    .ELSE
 00000880  EB 05	   *	    jmp    @C0092
 00000882		   *@C0090:
				                      ; It's a user application, we need to find out exactly how big the stack is
				                      ;; REMEMBER, hard-wired stack reference of 8000h ... needs to be dynamic
 00000882  BB 00008000		                        mov     ebx,08000h
				                    .ENDIF
				                    .IF (edx < ebx && edx >= dword ptr ss:[ebp-04])
 00000887		   *@C0092:
 00000887  3B D3	   *	    cmp    edx, ebx
 00000889  73 2B	   *	    jae    @C0093
 0000088B  3B 55 FC	   *	    cmp    edx, dword ptr ss : [ebp - 004h]
 0000088E  72 26	   *	    jb     @C0093
				                      ; The value of EBP is within the first 32k and it's greater than their value of ESP
 00000890  36: 8B 12		                        mov     edx,dword ptr ss:[edx]          ; Value stored there
 00000893  BB 00000010		                        mov     ebx,16
 00000898  B9 FFFFFFF8		                        mov     ecx,-8                          ; The negative sign indicates leading 0's should be ˙'s
				                      ; Right now, edx - lower nibble contains the upper nibble specified
				                      ;            ebx - 16 (base-16 number, it will be displayed in hex)
				                      ;            ecx - number of digits to display
				                      ; X coordinate
 0000089D  9C			                        pushfd
 0000089E  8B 47 06		                        mov     eax,dword ptr ds:[edi+6]
 000008A1  03 46 04		                        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 000008A4  50			                        push    eax
				                      ; Y coordinate
 000008A5  8B 47 0A		                        mov     eax,dword ptr ds:[edi+10]
 000008A8  03 46 08		                        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 000008AB  50			                        push    eax
 000008AC  FA			                        cli
 000008AD  FF 1D 0000D101 R	                        call    fword ptr ds:_VID_g_display_radix_in_edx_mono
 000008B3  9D			                        popfd
				                    .ELSE
 000008B4  EB 1C	   *	    jmp    @C0096
 000008B6		   *@C0093:
				                      ; Just display the empty string notation
 000008B6  9C			                        pushfd
 000008B7  8B 47 06		                        mov     eax,dword ptr ds:[edi+6]
 000008BA  03 46 04		                        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 000008BD  50			                        push    eax
				                      ; Y coordinate
 000008BE  8B 47 0A		                        mov     eax,dword ptr ds:[edi+10]
 000008C1  03 46 08		                        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 000008C4  50			                        push    eax
 000008C5  68 0000BE0C R	                        push    dword ptr offset empty_dword_text
 000008CA  FA			                        cli
 000008CB  FF 1D 0000D0E3 R	                        call    fword ptr ds:_VID_g_mono_display_text
 000008D1  9D			                        popfd
				                    .ENDIF
 000008D2		   *@C0096:
 000008D2  83 C7 10		                    add     edi,16
 000008D5  E9 000000EA		                    jmp     next_object

				                .ELSEIF (al == _ESP_THROUGH_EBP_RELATIVE)
 000008DA  E9 000000E5	   *	    jmp    @C0097
 000008DF		   *@C008E:
 000008DF  3C 03	   *	    cmp    al, _ESP_THROUGH_EBP_RELATIVE
 000008E1  75 6B	   *	    jne    @C0098
				                  ; Something in the user's local variables
 000008E3  8B 55 FC		                    mov     edx,dword ptr ss:[ebp-04]           ; Get their original ESP value
 000008E6  0F BF 5F 03		                    movsx   ebx,word ptr ds:[edi+3]             ; Offset in their stack
 000008EA  03 D3		                    add     edx,ebx
 000008EC  F7 45 38		                    test    dword ptr ss:[ebp+56],111b
	   00000007
				                    .IF (zero?)
 000008F3  75 07	   *	    jne    @C009A
				                      ; This is an Exodus core algorithm that's being debugged
 000008F5  BB 00008000		                        mov     ebx,08000h
				                    .ELSE
 000008FA  EB 05	   *	    jmp    @C009C
 000008FC		   *@C009A:
				                      ; It's a user application, we need to find out exactly how big the stack is
				                      ;; REMEMBER, hard-wired stack reference of 8000h ... needs to be dynamic
 000008FC  BB 00008000		                        mov     ebx,08000h
				                    .ENDIF
				                    .IF (edx < ebx)
 00000901		   *@C009C:
 00000901  3B D3	   *	    cmp    edx, ebx
 00000903  73 26	   *	    jae    @C009D
				                      ; The value of EBP is within the first 32k and it's greater than their value of ESP
 00000905  36: 8B 12		                        mov     edx,dword ptr ss:[edx]          ; Value stored there
 00000908  BB 00000010		                        mov     ebx,16
 0000090D  B9 FFFFFFF8		                        mov     ecx,-8                          ; The -8 indicates leading ˙'s and not 0's
				                      ; Right now, edx - lower nibble contains the upper nibble specified
				                      ;            ebx - 16 (base-16 number, it will be displayed in hex)
				                      ;            ecx - number of digits to display
				                      ; X coordinate
 00000912  9C			                        pushfd
 00000913  8B 47 06		                        mov     eax,dword ptr ds:[edi+6]
 00000916  03 46 04		                        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 00000919  50			                        push    eax
				                      ; Y coordinate
 0000091A  8B 47 0A		                        mov     eax,dword ptr ds:[edi+10]
 0000091D  03 46 08		                        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00000920  50			                        push    eax
 00000921  FA			                        cli
 00000922  FF 1D 0000D101 R	                        call    fword ptr ds:_VID_g_display_radix_in_edx_mono
 00000928  9D			                        popfd
				                    .ELSE
 00000929  EB 1C	   *	    jmp    @C009F
 0000092B		   *@C009D:
				                      ; Just display the empty string notation
 0000092B  9C			                        pushfd
 0000092C  8B 47 06		                        mov     eax,dword ptr ds:[edi+6]
 0000092F  03 46 04		                        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 00000932  50			                        push    eax
				                      ; Y coordinate
 00000933  8B 47 0A		                        mov     eax,dword ptr ds:[edi+10]
 00000936  03 46 08		                        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00000939  50			                        push    eax
 0000093A  68 0000BE0C R	                        push    dword ptr offset empty_dword_text
 0000093F  FA			                        cli
 00000940  FF 1D 0000D0E3 R	                        call    fword ptr ds:_VID_g_mono_display_text
 00000946  9D			                        popfd
				                    .ENDIF
 00000947		   *@C009F:
 00000947  83 C7 10		                    add     edi,16
 0000094A  EB 78		                    jmp     next_object

				                .ELSE
 0000094C  EB 76	   *	    jmp    @C00A0
 0000094E		   *@C0098:
				                  ; Unsupported option (or invalid data)
 0000094E  EB 7D		                    jmp     next_window
				                .ENDIF

				            .ELSEIF (al == _INPUT)
 00000950  EB 72	   *	    jmp    @C00A1
 00000952		   *@C0043:
 00000952  3C 04	   *	    cmp    al, _INPUT
 00000954  75 04	   *	    jne    @C00A2
 00000956  EB 75		                jmp     next_window
				            .ELSEIF (al == _POST_DISPLAY)
 00000958  EB 6A	   *	    jmp    @C00A4
 0000095A		   *@C00A2:
 0000095A  3C 05	   *	    cmp    al, _POST_DISPLAY
 0000095C  75 0B	   *	    jne    @C00A5
 0000095E  83 C7 0A		                add     edi,10
 00000961  0F B6 0F		                movzx   ecx,byte ptr ds:[edi]
 00000964  03 F9		                add     edi,ecx
 00000966  47			                inc     edi
				            .ELSEIF (al == _POST_OBJECT)
 00000967  EB 5B	   *	    jmp    @C00A7
 00000969		   *@C00A5:
 00000969  3C 06	   *	    cmp    al, _POST_OBJECT
 0000096B  75 04	   *	    jne    @C00A8
 0000096D  EB 5E		                jmp     next_window
				            .ELSEIF (al == _FUNCTION)
 0000096F  EB 53	   *	    jmp    @C00AA
 00000971		   *@C00A8:
 00000971  3C 07	   *	    cmp    al, _FUNCTION
 00000973  75 1A	   *	    jne    @C00AB
				              ; They've specified that a function will handle this item
 00000975  8B 5F 01		                mov     ebx,dword ptr ds:[edi+1]
 00000978  60			                pushad
 00000979  9C			                pushfd
 0000097A  1E			                push    ds
 0000097B  06			                push    es
 0000097C  0F A0		                push    fs
 0000097E  0F A8		                push    gs

 00000980  FF D3		                call    ebx

 00000982  0F A9		                pop     gs
 00000984  0F A1		                pop     fs
 00000986  07			                pop     es
 00000987  1F			                pop     ds
 00000988  9D			                popfd
 00000989  61			                popad
 0000098A  83 C7 05		                add     edi,5
				            .ELSEIF (al == _DRAW_WINDOW_ALWAYS)
 0000098D  EB 35	   *	    jmp    @C00AD
 0000098F		   *@C00AB:
 0000098F  3C FE	   *	    cmp    al, _DRAW_WINDOW_ALWAYS
 00000991  75 04	   *	    jne    @C00AE
				              ; Draw a DEBI window, regardless of whether or not the screen is shown
 00000993  EB 18		                jmp     force_draw_window
				            .ELSEIF (al == _DRAW_WINDOW)
 00000995  EB 2D	   *	    jmp    @C00B0
 00000997		   *@C00AE:
 00000997  3C FD	   *	    cmp    al, _DRAW_WINDOW
 00000999  75 27	   *	    jne    @C00B1
				              ; Draw a DEBI window
				                .IF (ds:debug_screen_shown == 0 || ds:force_screen_redraw != 0)
 0000099B  80 3D 0000B785 R
	   00		   *	    cmp    ds : debug_screen_shown, 000h
 000009A2  74 09	   *	    je     @C00B4
 000009A4  80 3D 0000B786 R
	   00		   *	    cmp    ds : force_screen_redraw, 000h
 000009AB  74 10	   *	    je     @C00B3
 000009AD		   *@C00B4:
 000009AD			                  force_draw_window:
 000009AD  60			                    pushad
 000009AE  8B 5E 04		                    mov     ebx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 000009B1  8B 46 08		                    mov     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 000009B4  8B 7F 01		                    mov     edi,dword ptr ds:[edi+1]
				                  ; Right now, ebx - horizontal starting pixel
				                  ;            eax - vertical starting pixel
				                  ;       ds:[edi] - far ptr to screen info
 000009B7  E8 00000014		                    call    invDEBI_draw_window
 000009BC  61			                    popad
				                .ENDIF
 000009BD		   *@C00B3:
 000009BD  83 C7 05		                add     edi,5
				            .ELSE
 000009C0  EB 02	   *	    jmp    @C00B6
 000009C2		   *@C00B1:
				              ; What is it?  Dunno.  Why not?  'Cause I'm stupid.  Oh yeah. :)
 000009C2  EB 09		                jmp     next_window
				            .ENDIF
 000009C4			          next_object:
				        .ENDW
 000009C4		   *@C00B6:
 000009C4		   *@C00B0:
 000009C4		   *@C00AD:
 000009C4		   *@C00AA:
 000009C4		   *@C00A7:
 000009C4		   *@C00A4:
 000009C4		   *@C00A1:
 000009C4		   *@C0042:
 000009C4		   *@C0036:
 000009C4		   *@C0041:
 000009C4		   *@C003D:
 000009C4		   *@C00A0:
 000009C4		   *@C0097:
 000009C4		   *@C008D:
 000009C4		   *@C0087:
 000009C4		   *@C0047:
 000009C4		   *@C002C:
 000009C4  80 3F FF	   *	    cmp    byte ptr ds : [edi], _END
 000009C7  0F 85 FFFFFB7C  *	    jne    @C002D
 000009CD			      next_window:
 000009CD  61			        popad
 000009CE  07			        pop     es
 000009CF  C3			        ret
 000009D0			    invDEBI_draw_objects    ENDP




 000009D0			    invDEBI_draw_window     PROC
				    ; This routine is used draw the contents of a window
				    ;
				    ; Upon entry:   ebx - horizontal starting pixel
				    ;               eax - vertical starting pixel
				    ;             [edi] - far ptr to screen info in current data segment
				    ;                ds - current data segment
				    ;
				    ; Upon exit:    The window is drawn
				    ;
				        .WHILE (byte ptr ds:[edi] != 255)
 000009D0  EB 2E	   *	    jmp    @C00B8
 000009D2		   *@C00B9:
 000009D2  53			            push    ebx                                             ; horizontal
 000009D3  50			            push    eax                                             ; vertical
 000009D4  57			            push    edi                                             ; start of window item
 000009D5  FF 1D 0000D0E3 R	            call    fword ptr ds:_VID_g_mono_display_text           ;

 000009DB  03 F9		            add     edi,ecx
 000009DD  03 45 F8		            add     eax,dword ptr ss:[ebp-08]                       ; Move down to next line

				            .IF (byte ptr ds:[edi] == 254)
 000009E0  80 3F FE	   *	    cmp    byte ptr ds : [edi], 0FEh
 000009E3  75 1B	   *	    jne    @C00BA
				              ; They are specifying that this last line has to repeat a fixed number of times
 000009E5  8B D1		                mov     edx,ecx
 000009E7  33 C9		                xor     ecx,ecx
 000009E9  8A 4F 01		                mov     cl,byte ptr ds:[edi+1]                      ; Get the count
 000009EC  2B FA		                sub     edi,edx
				                .REPEAT
 000009EE		   *@C00BC:
 000009EE  51			                    push    ecx
 000009EF  53			                    push    ebx
 000009F0  50			                    push    eax
 000009F1  57			                    push    edi
 000009F2  FF 1D 0000D0E3 R	                    call    fword ptr ds:_VID_g_mono_display_text
 000009F8  03 45 F8		                    add     eax,dword ptr ss:[ebp-08]               ; Next line
 000009FB  59			                    pop     ecx
				                .UNTILCXZ
 000009FC  E2 F0	   *	    loop   @C00BC
 000009FE  EB 05		                jmp     done_with_window
				            .ENDIF
				        .ENDW
 00000A00		   *@C00BA:
 00000A00		   *@C00B8:
 00000A00  80 3F FF	   *	    cmp    byte ptr ds : [edi], 0FFh
 00000A03  75 CD	   *	    jne    @C00B9
 00000A05			      done_with_window:
 00000A05  C3			        ret
 00000A06			    invDEBI_draw_window     ENDP




 00000A06			    invDEBI_load_stx_from_ebx       PROC
				    ; This routine is used to load a particular ST(x) value from the FPU Save State on the stack
				    ;
				    ; Upon entry:   ss:[ebp-200] - start of FPU save state on the stack
				    ;                        ebx - st(0) value on the FPU save state stack to load
				    ;
				    ; Upon exit:    st(0) is loaded with the value specified (or 0 if ebx is invalid)
				    ;
				        .IF (ebx == 0)
 00000A06  0B DB	   *	    or	ebx, ebx
 00000A08  75 07	   *	    jne    @C00BE
 00000A0A  BB FFFFFF54		            mov     ebx,-200+28
				        .ELSEIF (ebx == 1)
 00000A0F  EB 58	   *	    jmp    @C00C0
 00000A11		   *@C00BE:
 00000A11  83 FB 01	   *	    cmp    ebx, 001h
 00000A14  75 07	   *	    jne    @C00C1
 00000A16  BB FFFFFF5E		            mov     ebx,-200+38
				        .ELSEIF (ebx == 2)
 00000A1B  EB 4C	   *	    jmp    @C00C3
 00000A1D		   *@C00C1:
 00000A1D  83 FB 02	   *	    cmp    ebx, 002h
 00000A20  75 07	   *	    jne    @C00C4
 00000A22  BB FFFFFF68		            mov     ebx,-200+48
				        .ELSEIF (ebx == 3)
 00000A27  EB 40	   *	    jmp    @C00C6
 00000A29		   *@C00C4:
 00000A29  83 FB 03	   *	    cmp    ebx, 003h
 00000A2C  75 07	   *	    jne    @C00C7
 00000A2E  BB FFFFFF72		            mov     ebx,-200+58
				        .ELSEIF (ebx == 4)
 00000A33  EB 34	   *	    jmp    @C00C9
 00000A35		   *@C00C7:
 00000A35  83 FB 04	   *	    cmp    ebx, 004h
 00000A38  75 07	   *	    jne    @C00CA
 00000A3A  BB FFFFFF7C		            mov     ebx,-200+68
				        .ELSEIF (ebx == 5)
 00000A3F  EB 28	   *	    jmp    @C00CC
 00000A41		   *@C00CA:
 00000A41  83 FB 05	   *	    cmp    ebx, 005h
 00000A44  75 07	   *	    jne    @C00CD
 00000A46  BB FFFFFF86		            mov     ebx,-200+78
				        .ELSEIF (ebx == 6)
 00000A4B  EB 1C	   *	    jmp    @C00CF
 00000A4D		   *@C00CD:
 00000A4D  83 FB 06	   *	    cmp    ebx, 006h
 00000A50  75 07	   *	    jne    @C00D0
 00000A52  BB FFFFFF90		            mov     ebx,-200+88
				        .ELSEIF (ebx == 7)
 00000A57  EB 10	   *	    jmp    @C00D2
 00000A59		   *@C00D0:
 00000A59  83 FB 07	   *	    cmp    ebx, 007h
 00000A5C  75 07	   *	    jne    @C00D3
 00000A5E  BB FFFFFF9A		            mov     ebx,-200+98
				        .ELSE
 00000A63  EB 04	   *	    jmp    @C00D5
 00000A65		   *@C00D3:
				          ; It's invalid, load 0
 00000A65  D9 EE		            fldz
 00000A67  EB 04		            jmp     quit
				        .ENDIF
 00000A69		   *@C00D5:
 00000A69		   *@C00D2:
 00000A69		   *@C00CF:
 00000A69		   *@C00CC:
 00000A69		   *@C00C9:
 00000A69		   *@C00C6:
 00000A69		   *@C00C3:
 00000A69		   *@C00C0:
 00000A69  36: DB 2C 2B		        fld     tbyte ptr ss:[ebp+ebx]
 00000A6D			      quit:
 00000A6D  C3			        ret
 00000A6E			    invDEBI_load_stx_from_ebx       ENDP




 00000A6E			    invDEBI_check_stx_from_fpu_save_state   PROC
				    ; This routine is used as a precursor to invDEBI_convert_st0_to_string().  It determines whether or not a particular
				    ; st(x) value stored in the FPU Save State on the stack is valid or not (based on the TAG word).  If it is valid then it
				    ; does nothing.  If it is invalid then it populates the ds:[edi] string with the appropriate text.
				    ;
				    ; Upon entry:   ebx - st(x) value (0-7)
				    ;               ecx - maximum string width
				    ;          ds:[edi] - Where to store the string (if generated)
				    ;
				    ; Upon exit:    ds:[edi] - may be updated with the generated string
				    ;               carry? - CLEAR if not updated, SET if updated
				    ;
 00000A6E  60			        pushad
 00000A6F  0F B7 85		        movzx   eax,word ptr ss:[ebp-200+8]                         ; Load TAG word
	   FFFFFF40
 00000A76  0F B7 95		        movzx   edx,word ptr ss:[ebp-200+4]                         ; Load STATUS word
	   FFFFFF3C
 00000A7D  E8 00000085		        call    invDEBI_adjust_for_fpu_tos                          ; Adjust the current TAG word for top-of-stack
 00000A82  83 FB 00		        cmp     ebx,0                                               ; They want us to examine st(0)
 00000A85  74 3B		        jz      next_part
 00000A87  C1 E8 02		        shr     eax,2
 00000A8A  83 FB 01		        cmp     ebx,1                                               ; st(1)
 00000A8D  74 33		        jz      next_part
 00000A8F  C1 E8 02		        shr     eax,2
 00000A92  83 FB 02		        cmp     ebx,2                                               ; st(2)
 00000A95  74 2B		        jz      next_part
 00000A97  C1 E8 02		        shr     eax,2
 00000A9A  83 FB 03		        cmp     ebx,3                                               ; st(3)
 00000A9D  74 23		        jz      next_part
 00000A9F  C1 E8 02		        shr     eax,2
 00000AA2  83 FB 04		        cmp     ebx,4                                               ; st(4)
 00000AA5  74 1B		        jz      next_part
 00000AA7  C1 E8 02		        shr     eax,2
 00000AAA  83 FB 05		        cmp     ebx,5                                               ; st(5)
 00000AAD  74 13		        jz      next_part
 00000AAF  C1 E8 02		        shr     eax,2
 00000AB2  83 FB 06		        cmp     ebx,6                                               ; st(6)
 00000AB5  74 0B		        jz      next_part
 00000AB7  C1 E8 02		        shr     eax,2
 00000ABA  83 FB 07		        cmp     ebx,7                                               ; st(7)
 00000ABD  74 03		        jz      next_part
				      ; If we're here it wasn't found
				      ; It's an error so we go ahead and display the value numerically (which will catch NaN's and the like)
 00000ABF  F8			        clc
 00000AC0  EB 43		        jmp     quit

 00000AC2			      next_part:
 00000AC2  83 E0 03		        and     eax,11b
				        .IF (eax != 11b)
 00000AC5  83 F8 03	   *	    cmp    eax, 003h
 00000AC8  74 03	   *	    je     @C00D6
				          ; It's something that needs to be represented numerically
 00000ACA  F8			            clc                                                     ; Clear the flag (we didn't copy anything)
 00000ACB  EB 38		            jmp     quit
				        .ENDIF
 00000ACD		   *@C00D6:

				      ; It's empty, so we copy the string
 00000ACD  BE 0000BAEA R	        mov     esi,offset number_empty
 00000AD2  8B D9		        mov     ebx,ecx
 00000AD4  33 C9		        xor     ecx,ecx
				        .WHILE (byte ptr ds:[esi+ecx] != 0 && ebx > 0)
 00000AD6  EB 10	   *	    jmp    @C00D8
 00000AD8		   *@C00D9:
 00000AD8  8A 04 31		            mov     al,byte ptr ds:[esi+ecx]
 00000ADB  88 04 39		            mov     byte ptr ds:[edi+ecx],al
 00000ADE  41			            inc     ecx
				            .IF (al != 'Æ' && al != 'Ø')
 00000ADF  3C AE	   *	    cmp    al, 'Æ'
 00000AE1  74 05	   *	    je     @C00DA
 00000AE3  3C AF	   *	    cmp    al, 'Ø'
 00000AE5  74 01	   *	    je     @C00DA
 00000AE7  4B			                dec     ebx
				            .ENDIF
				        .ENDW
 00000AE8		   *@C00DA:
 00000AE8		   *@C00D8:
 00000AE8  80 3C 31 00	   *	    cmp    byte ptr ds : [esi + ecx], 000h
 00000AEC  74 05	   *	    je     @C00DD
 00000AEE  83 FB 00	   *	    cmp    ebx, 000h
 00000AF1  77 E5	   *	    ja     @C00D9
 00000AF3		   *@C00DD:
				        .WHILE (ebx > 0)
 00000AF3  EB 06	   *	    jmp    @C00DF
 00000AF5		   *@C00E0:
 00000AF5  C6 04 39 20		            mov     byte ptr ds:[edi+ecx],' '
 00000AF9  41			            inc     ecx
 00000AFA  4B			            dec     ebx
				        .ENDW
 00000AFB		   *@C00DF:
 00000AFB  83 FB 00	   *	    cmp    ebx, 000h
 00000AFE  77 F5	   *	    ja     @C00E0
 00000B00  C6 04 39 00		        mov     byte ptr ds:[edi+ecx],0
 00000B04  F9			        stc                                                         ; Set the flag (indicating we copied something)

 00000B05			      quit:
 00000B05  61			        popad
 00000B06  C3			        ret
 00000B07			    invDEBI_check_stx_from_fpu_save_state   ENDP




 00000B07			    invDEBI_adjust_for_fpu_tos      PROC
				    ; This algorithm is used to adjust the currently requested
				    ;
				    ; Upon entry:  eax - TAG word
				    ;              ebx - st(x) value they're desiring
				    ;              edx - STATUS word
				    ;
				    ; Upon exit:   eax - adjusted properly for current TOS pointer
				    ;
 00000B07  C1 EA 0B		        shr     edx,11                                              ; Shift it over 11 bits (to get TOS down to the lower 3 bits)
 00000B0A  83 FA 00		        cmp     edx,00
 00000B0D  74 3A		        jz      quit                                                ; if branch we're good to go (TOS is already at 0)
 00000B0F  66| C1 C0 02		        rol     ax,2
 00000B13  83 FA 07		        cmp     edx,7
 00000B16  74 31		        jz      quit                                                ; in branch it was at 7
 00000B18  66| C1 C0 02		        rol     ax,2
 00000B1C  83 FA 06		        cmp     edx,6
 00000B1F  74 28		        jz      quit                                                ; in branch it was at 6
 00000B21  66| C1 C0 02		        rol     ax,2
 00000B25  83 FA 05		        cmp     edx,5
 00000B28  74 1F		        jz      quit                                                ; in branch it was at 5
 00000B2A  66| C1 C0 02		        rol     ax,2
 00000B2E  83 FA 04		        cmp     edx,4
 00000B31  74 16		        jz      quit                                                ; in branch it was at 4
 00000B33  66| C1 C0 02		        rol     ax,2
 00000B37  83 FA 03		        cmp     edx,3
 00000B3A  74 0D		        jz      quit                                                ; in branch it was at 3
 00000B3C  66| C1 C0 02		        rol     ax,2
 00000B40  83 FA 02		        cmp     edx,2
 00000B43  74 04		        jz      quit                                                ; in branch it was at 2
 00000B45  66| C1 C0 02		        rol     ax,2
				      ; If we get all the way to here then it was 1

 00000B49			      quit:
 00000B49  C3			        ret
 00000B4A			    invDEBI_adjust_for_fpu_tos      ENDP




 00000B4A			    invDEBI_convert_st0_to_string       PROC
				    ; This routine is used to convert the value currently stored in ST0 to it's standard numeric equivalent
				    ;
				    ; Upon entry:   st0 - IEEE 80-bit to convert to string
				    ;               ecx - maximum string width
				    ;          ds:[edi] - where to store the trash string
				    ;
				    ; Upon exit:    ds:[edi] is updated with the string to display
				    ;
 00000B4A  60			        pushad
 00000B4B  06			        push    es
 00000B4C  66| 2E: 8E 05	        mov     es,cs:data_segment
	   0000B77F R

 00000B54  26: C7 05		        mov     es:exponent,0
	   0000BA43 R
	   00000000
 00000B5F  D9 E5		        fxam                                                        ; Examine the # for weird values
 00000B61  9B 26: DD 3D		        fstsw   es:FPStat
	   0000BA41 R
 00000B69  66| 26: 8B 1D	        mov     bx,es:FPStat
	   0000BA41 R

				      ; Copy high bits to low.
 00000B71  8A DF		        mov     bl,bh
 00000B73  C0 EF 03		        shr     bh,3
 00000B76  80 E7 08		        and     bh,008h
 00000B79  80 E3 07		        and     bl,007h
 00000B7C  0A DF		        or      bl,bh
				      ; bl now has C3, C2, C1 and C0 in low 4 bits

				        .IF (bl != 4 && bl != 6)
 00000B7E  80 FB 04	   *	    cmp    bl, 004h
 00000B81  0F 84 000000F6  *	    je     @C00E2
 00000B87  80 FB 06	   *	    cmp    bl, 006h
 00000B8A  0F 84 000000ED  *	    je     @C00E2
				            .IF (bl == 0)
 00000B90  0A DB	   *	    or	bl, bl
 00000B92  75 0A	   *	    jne    @C00E5
 00000B94  BE 0000BA53 R	                mov     esi,offset bad_number0
				            .ELSEIF (bl == 1)
 00000B99  E9 000000AD	   *	    jmp    @C00E7
 00000B9E		   *@C00E5:
 00000B9E  80 FB 01	   *	    cmp    bl, 001h
 00000BA1  75 0A	   *	    jne    @C00E8
 00000BA3  BE 0000BA64 R	                mov     esi,offset bad_number1
				            .ELSEIF (bl == 2)
 00000BA8  E9 0000009E	   *	    jmp    @C00EA
 00000BAD		   *@C00E8:
 00000BAD  80 FB 02	   *	    cmp    bl, 002h
 00000BB0  75 0A	   *	    jne    @C00EB
 00000BB2  BE 0000BA6D R	                mov     esi,offset bad_number2
				            .ELSEIF (bl == 3)
 00000BB7  E9 0000008F	   *	    jmp    @C00ED
 00000BBC		   *@C00EB:
 00000BBC  80 FB 03	   *	    cmp    bl, 003h
 00000BBF  75 0A	   *	    jne    @C00EE
 00000BC1  BE 0000BA7F R	                mov     esi,offset bad_number3
				            .ELSEIF (bl == 5)
 00000BC6  E9 00000080	   *	    jmp    @C00F0
 00000BCB		   *@C00EE:
 00000BCB  80 FB 05	   *	    cmp    bl, 005h
 00000BCE  75 07	   *	    jne    @C00F1
 00000BD0  BE 0000BA89 R	                mov     esi,offset bad_number5
				            .ELSEIF (bl == 7)
 00000BD5  EB 74	   *	    jmp    @C00F3
 00000BD7		   *@C00F1:
 00000BD7  80 FB 07	   *	    cmp    bl, 007h
 00000BDA  75 07	   *	    jne    @C00F4
 00000BDC  BE 0000BA98 R	                mov     esi,offset bad_number7
				            .ELSEIF (bl == 8)
 00000BE1  EB 68	   *	    jmp    @C00F6
 00000BE3		   *@C00F4:
 00000BE3  80 FB 08	   *	    cmp    bl, 008h
 00000BE6  75 09	   *	    jne    @C00F7
 00000BE8  B0 2B		                mov     al,'+'
 00000BEA  E9 000000E2		                jmp     skip_alignment
				            .ELSEIF (bl == 9)
 00000BEF  EB 5A	   *	    jmp    @C00F9
 00000BF1		   *@C00F7:
 00000BF1  80 FB 09	   *	    cmp    bl, 009h
 00000BF4  75 07	   *	    jne    @C00FA
 00000BF6  BE 0000BAA7 R	                mov     esi,offset bad_number9
				            .ELSEIF (bl == 10)
 00000BFB  EB 4E	   *	    jmp    @C00FC
 00000BFD		   *@C00FA:
 00000BFD  80 FB 0A	   *	    cmp    bl, 00Ah
 00000C00  75 0B	   *	    jne    @C00FD
 00000C02  B0 2D		                mov     al,'-'
 00000C04  D9 E0		                fchs
 00000C06  E9 000000C6		                jmp     skip_alignment
				            .ELSEIF (bl == 11)
 00000C0B  EB 3E	   *	    jmp    @C00FF
 00000C0D		   *@C00FD:
 00000C0D  80 FB 0B	   *	    cmp    bl, 00Bh
 00000C10  75 07	   *	    jne    @C0100
 00000C12  BE 0000BAB2 R	                mov     esi,offset bad_number11
				            .ELSEIF (bl == 12)
 00000C17  EB 32	   *	    jmp    @C0102
 00000C19		   *@C0100:
 00000C19  80 FB 0C	   *	    cmp    bl, 00Ch
 00000C1C  75 07	   *	    jne    @C0103
 00000C1E  BE 0000BABE R	                mov     esi,offset bad_number12
				            .ELSEIF (bl == 13)
 00000C23  EB 26	   *	    jmp    @C0105
 00000C25		   *@C0103:
 00000C25  80 FB 0D	   *	    cmp    bl, 00Dh
 00000C28  75 07	   *	    jne    @C0106
 00000C2A  BE 0000BACD R	                mov     esi,offset bad_number13
				            .ELSEIF (bl == 14)
 00000C2F  EB 1A	   *	    jmp    @C0108
 00000C31		   *@C0106:
 00000C31  80 FB 0E	   *	    cmp    bl, 00Eh
 00000C34  75 07	   *	    jne    @C0109
 00000C36  BE 0000BADA R	                mov     esi,offset bad_number14
				            .ELSEIF (bl == 15)
 00000C3B  EB 0E	   *	    jmp    @C010B
 00000C3D		   *@C0109:
 00000C3D  80 FB 0F	   *	    cmp    bl, 00Fh
 00000C40  75 07	   *	    jne    @C010C
 00000C42  BE 0000BACD R	                mov     esi,offset bad_number13
				            .ELSE
 00000C47  EB 02	   *	    jmp    @C010E
 00000C49		   *@C010C:
 00000C49  EB 32		                jmp     do_the_number
				            .ENDIF

				          ; Note, this bit of code is duplicated in the invDEBI_check_stx() algorithm
 00000C4B		   *@C010E:
 00000C4B		   *@C010B:
 00000C4B		   *@C0108:
 00000C4B		   *@C0105:
 00000C4B		   *@C0102:
 00000C4B		   *@C00FF:
 00000C4B		   *@C00FC:
 00000C4B		   *@C00F9:
 00000C4B		   *@C00F6:
 00000C4B		   *@C00F3:
 00000C4B		   *@C00F0:
 00000C4B		   *@C00ED:
 00000C4B		   *@C00EA:
 00000C4B		   *@C00E7:
 00000C4B  8B D9		            mov     ebx,ecx
 00000C4D  33 C9		            xor     ecx,ecx
				            .WHILE (byte ptr es:[esi+ecx] != 0 && ebx > 0)
 00000C4F  EB 09	   *	    jmp    @C010F
 00000C51		   *@C0110:
 00000C51  26: 8A 04 31		                mov     al,byte ptr es:[esi+ecx]
 00000C55  88 04 39		                mov     byte ptr ds:[edi+ecx],al
 00000C58  41			                inc     ecx
 00000C59  4B			                dec     ebx
				            .ENDW
 00000C5A		   *@C010F:
 00000C5A  26: 80 3C 31
	   00		   *	    cmp    byte ptr es : [esi + ecx], 000h
 00000C5F  74 05	   *	    je     @C0111
 00000C61  83 FB 00	   *	    cmp    ebx, 000h
 00000C64  77 EB	   *	    ja     @C0110

 00000C66		   *@C0111:
 00000C66  43			            inc     ebx
				            .WHILE (ebx > 0)
 00000C67  EB 06	   *	    jmp    @C0113
 00000C69		   *@C0114:
 00000C69  C6 04 39 20		                mov     byte ptr ds:[edi+ecx],' '
 00000C6D  41			                inc     ecx
 00000C6E  4B			                dec     ebx
				            .ENDW
 00000C6F		   *@C0113:
 00000C6F  83 FB 00	   *	    cmp    ebx, 000h
 00000C72  77 F5	   *	    ja     @C0114
 00000C74  C6 04 39 00		            mov     byte ptr ds:[edi+ecx],0
 00000C78  E9 000000AB		            jmp     quit
				        .ENDIF
 00000C7D		   *@C00E2:

 00000C7D			      do_the_number:
				      ; Is it greater than zero?
 00000C7D  D9 E4		        ftst
 00000C7F  9B DF E0		        fstsw   ax
 00000C82  66| 26: A3		        mov     es:FPStat,ax
	   0000BA41 R
 00000C89  9E			        sahf
				        .IF (carry?)
 00000C8A  73 06	   *	    jae    @C0116
				          ; It is < than zero...Put a minus sign
 00000C8C  B0 2D		            mov     al,"-"
 00000C8E  D9 E0		            fchs
				        .ELSE
 00000C90  EB 02	   *	    jmp    @C0118
 00000C92		   *@C0116:
				          ; It is > than zero...Put a plus sign
 00000C92  B0 2B		            mov     al,"+"
				        .ENDIF
 00000C94		   *@C0118:

				      ; While the number is less than 1 multiply by 10 and decrement exponent
 00000C94  50			        push    eax
 00000C95			      @@:
 00000C95  D9 E8		        fld1
 00000C97  D8 D9		        fcomp
 00000C99  9B DF E0		        fstsw   ax
 00000C9C  9E			        sahf
 00000C9D  72 12		        jc      @F
 00000C9F  26: FF 0D		        dec     es:exponent
	   0000BA43 R
 00000CA6  26: DB 05		        fild    es:number10
	   0000BA4B R
 00000CAD  DE C9		        fmul
 00000CAF  EB E4		        jmp     @B
 00000CB1			      @@:

				      ; While the number is greater than or equal to 10, divide it by 10 and increment the exponent
 00000CB1			      @@:
 00000CB1  26: DA 15		        ficom   es:number10
	   0000BA4B R
 00000CB8  9B DF E0		        fstsw   ax
 00000CBB  9E			        sahf
 00000CBC  72 12		        jc      @F
 00000CBE  26: FF 05		        inc     es:exponent
	   0000BA43 R
 00000CC5  26: DB 05		        fild    es:number10
	   0000BA4B R
 00000CCC  DE F9		        fdivp   st(1),st
 00000CCE  EB E1		        jmp     @B
 00000CD0			      @@:
				      ; The value is now a number in the range of 1.0<=Number<10
 00000CD0  58			        pop     eax

 00000CD1			      skip_alignment:
 00000CD1  88 07		        mov     byte ptr ds:[edi],al
 00000CD3  47			        inc     edi
				      ; Now set up rounding by chopping
 00000CD4  9B 26: D9 3D		        fstcw   es:FPCtrl
	   0000BA3F R
 00000CDC  26: 0F B7 05		        movzx   eax,es:FPCtrl
	   0000BA3F R
 00000CE4  25 0000F3FF		        and     eax,0f3ffh
 00000CE9  0D 00000C00		        or      eax,0c00h
 00000CEE  66| 26: A3		        mov     es:FPCtrl,ax
	   0000BA3F R
 00000CF5  26: D9 2D		        fldcw   es:FPCtrl
	   0000BA3F R

 00000CFC  E8 00000031		        call    invDEBI_extract_digit
 00000D01  88 07		        mov     byte ptr ds:[edi],al
 00000D03  47			        inc     edi
 00000D04  B0 2E		        mov     al,"."
 00000D06  88 07		        mov     byte ptr ds:[edi],al
 00000D08  47			        inc     edi

				      ; Now get 18 decimals
 00000D09  B9 00000012		        mov     ecx,18
				        .REPEAT
 00000D0E		   *@C0119:
 00000D0E  E8 0000001F		            call    invDEBI_extract_digit
 00000D13  88 07		            mov     byte ptr ds:[edi],al
 00000D15  47			            inc     edi
				        .UNTILCXZ
 00000D16  E2 F6	   *	    loop   @C0119

				      ; Now write the exponent
 00000D18  C6 07 65		        mov     byte ptr ds:[edi],'e'
 00000D1B  47			        inc     edi
 00000D1C  26: 8B 15		        mov     edx,es:exponent
	   0000BA43 R
 00000D23  E8 00000029		        call    invDEBI_signed_convert_dword_to_decimal         ; Store the exponent as signed text

 00000D28			      quit:
 00000D28  26: DB 1D		        fistp   es:trash_dword
	   0000BA0F R
 00000D2F  07			        pop     es
 00000D30  61			        popad
 00000D31  C3			        ret
 00000D32			    invDEBI_convert_st0_to_string       ENDP




 00000D32			    invDEBI_extract_digit   PROC    NEAR
				    ; This routine is called to extract the left-most digit from a number in the format of #.######
				    ;
				    ; Upon entry:   the value is in st(0)
				    ;
				    ; Upon exit:    al - extracted digit
				    ;
 00000D32  D9 C0		        fld     st(0)                                               ; Duplicate st(0)
 00000D34  D9 FC		        frndint                                                     ; Convert this value to an int
 00000D36  DC E9		        fsub    st(1),st(0)                                         ; Get the "remainder" portion
 00000D38  26: DB 1D		        fistp   es:digit                                            ; Store it
	   0000BA4F R
 00000D3F  26: DB 05		        fild    es:number10                                         ; Now update our the value by our multiplier
	   0000BA4B R
 00000D46  DE C9		        fmulp   st(1),st(0)

				      ; Get the digit and convert it and write it
 00000D48  26: A1		        mov     eax,es:digit
	   0000BA4F R
 00000D4E  04 30		        add     al,"0"
 00000D50  C3			        ret
 00000D51			    invDEBI_extract_digit   ENDP




 00000D51			    invDEBI_signed_convert_dword_to_decimal     PROC
				    ; This routine takes the value in edx and outputs it to ds:[edi]
				    ;
				    ; Upon entry:   edx - value to convert
				    ;          ds:[edi] - where to store the signed quantity
				    ;
				    ; Upon exit:    The value is converted
				    ;               edi - pointer to end of string
				    ;
 00000D51  C8 000A 00		        enter   10,0
 00000D55  60			        pushad
 00000D56  8B F5		        mov     esi,ebp
 00000D58  83 EE 0A		        sub     esi,10
				      ; Right now, ss:[esi] - far ptr to string to build
 00000D5B  36: C6 06 00		        mov     byte ptr ss:[esi],0
 00000D5F  46			        inc     esi

				        .IF (edx > 7fffffffh)
 00000D60  81 FA 7FFFFFFF  *	    cmp    edx, 07FFFFFFFh
 00000D66  76 06	   *	    jbe    @C011A
 00000D68  B0 2D		            mov     al,"-"
 00000D6A  F7 DA		            neg     edx
				        .ELSE
 00000D6C  EB 02	   *	    jmp    @C011C
 00000D6E		   *@C011A:
 00000D6E  B0 2B		            mov     al,"+"
				        .ENDIF
 00000D70		   *@C011C:
 00000D70  AA			        stosb

 00000D71  8B C2		        mov     eax,edx
 00000D73  BB 0000000A		        mov     ebx,10
 00000D78			      @@:
 00000D78  33 D2		        xor     edx,edx
 00000D7A  F7 F3		        div     ebx
 00000D7C  80 C2 30		        add     dl,'0'
 00000D7F  36: 88 16		        mov     byte ptr ss:[esi],dl
 00000D82  46			        inc     esi
 00000D83  83 F8 00		        cmp     eax,0
 00000D86  75 F0		        jnz     @B

				      ; Right now we've extracted all of the values
 00000D88  B9 00000002		        mov     ecx,2                                               ; Default to 2, one for +/- above, one for trailing NULL
 00000D8D  4E			        dec     esi
				        .WHILE (byte ptr ss:[esi] != 0)
 00000D8E  EB 08	   *	    jmp    @C011D
 00000D90		   *@C011E:
 00000D90  36: 8A 16		            mov     dl,byte ptr ss:[esi]
 00000D93  88 17		            mov     byte ptr ds:[edi],dl
 00000D95  47			            inc     edi
 00000D96  4E			            dec     esi
 00000D97  41			            inc     ecx
				        .ENDW
 00000D98		   *@C011D:
 00000D98  36: 80 3E 00	   *	    cmp    byte ptr ss : [esi], 000h
 00000D9C  75 F2	   *	    jne    @C011E
 00000D9E  C6 07 00		        mov     byte ptr ds:[edi],0                                 ; NULL terminate

 00000DA1  26: 89 0D		        mov     es:signed_digits,ecx                                ; Indicate how many digits were written in the exponent
	   0000BA47 R
 00000DA8  01 0C 24		        add     dword ptr ss:[esp+00],ecx                           ; Update edi on the stack

 00000DAB  61			        popad
 00000DAC  C9			        leave
 00000DAD  C3			        ret
 00000DAE			    invDEBI_signed_convert_dword_to_decimal     ENDP




 00000DAE			    invDEBI_align_floating_point_string     PROC
				    ; This routine is used to adjust a floating pointer string that was just created
				    ;
				    ; Upon entry:   cs:exponent - # of digits in the exponent portion
				    ;               ds:[edi] - far ptr to string to adjust
				    ;                    ecx - maximum width for value
				    ;
				    ; Upon exit:    String at ds:[edi] is adjusted (if possible) to represent it in the number of digits specified in ecx
				    ;               * Note:  If the string cannot be represented in the specified length then it will appear in +1.234e+289 form
				    ;
 00000DAE  C8 0004 00		        enter   4,0
				      ; [ebp-04] - dword, used to hold the NEG exponent value for a negative exponent (this gives it the positive appearance)
 00000DB2  60			        pushad
 00000DB3  06			        push    es
 00000DB4  66| 2E: 8E 05	        mov     es,cs:data_segment
	   0000B77F R
				        .IF (es:exponent == 0)
 00000DBC  26: 83 3D
	   0000BA43 R 00   *	    cmp    es : exponent, 000h
 00000DC4  75 6D	   *	    jne    @C0120
				          ; The number is already adjusted properly for decimal alignment
				          ; All we have to worry about is the width
 00000DC6			          truncate_as_necessary:
 00000DC6  33 DB		            xor     ebx,ebx
				            .WHILE (ebx < ecx && byte ptr ds:[edi+ebx] != 'e' && byte ptr ds:[edi+ebx] != '<')
 00000DC8  EB 0E	   *	    jmp    @C0122
 00000DCA		   *@C0123:
				                .IF (byte ptr ds:[edi+ebx] == 'Æ' || byte ptr ds:[edi+ebx] == 'Ø')
 00000DCA  80 3C 3B AE	   *	    cmp    byte ptr ds : [edi + ebx], 'Æ'
 00000DCE  74 06	   *	    je     @C0125
 00000DD0  80 3C 3B AF	   *	    cmp    byte ptr ds : [edi + ebx], 'Ø'
 00000DD4  75 01	   *	    jne    @C0124
 00000DD6		   *@C0125:
 00000DD6  41			                    inc     ecx
				                .ENDIF
 00000DD7		   *@C0124:
 00000DD7  43			                inc     ebx
				            .ENDW
 00000DD8		   *@C0122:
 00000DD8  3B D9	   *	    cmp    ebx, ecx
 00000DDA  73 0C	   *	    jae    @C0127
 00000DDC  80 3C 3B 65	   *	    cmp    byte ptr ds : [edi + ebx], 'e'
 00000DE0  74 06	   *	    je     @C0127
 00000DE2  80 3C 3B 3C	   *	    cmp    byte ptr ds : [edi + ebx], '<'
 00000DE6  75 E2	   *	    jne    @C0123
				            .IF (byte ptr ds:[edi+ebx] == '<')
 00000DE8		   *@C0127:
 00000DE8  80 3C 3B 3C	   *	    cmp    byte ptr ds : [edi + ebx], '<'
 00000DEC  75 20	   *	    jne    @C012A
				              ; This is one of the conditions, it's not a number
				                .WHILE (ebx < ecx)
 00000DEE  EB 18	   *	    jmp    @C012C
 00000DF0		   *@C012D:
				                    .IF (byte ptr ds:[edi+ebx] == 'Æ' || byte ptr ds:[edi+ebx] == 'Ø')
 00000DF0  80 3C 3B AE	   *	    cmp    byte ptr ds : [edi + ebx], 'Æ'
 00000DF4  74 06	   *	    je     @C012F
 00000DF6  80 3C 3B AF	   *	    cmp    byte ptr ds : [edi + ebx], 'Ø'
 00000DFA  75 01	   *	    jne    @C012E
 00000DFC		   *@C012F:
 00000DFC  41			                        inc     ecx
				                    .ENDIF
				                    .IF (byte ptr ds:[edi+ebx] == 0)
 00000DFD		   *@C012E:
 00000DFD  80 3C 3B 00	   *	    cmp    byte ptr ds : [edi + ebx], 000h
 00000E01  75 04	   *	    jne    @C0131
 00000E03  C6 04 3B 20		                        mov     byte ptr ds:[edi+ebx],32
				                    .ENDIF
 00000E07		   *@C0131:
 00000E07  43			                    inc     ebx
				                .ENDW
 00000E08		   *@C012C:
 00000E08  3B D9	   *	    cmp    ebx, ecx
 00000E0A  72 E4	   *	    jb     @C012D
				            .ELSE
 00000E0C  EB 1C	   *	    jmp    @C0134
 00000E0E		   *@C012A:
				                .IF (ebx < ecx)
 00000E0E  3B D9	   *	    cmp    ebx, ecx
 00000E10  73 18	   *	    jae    @C0135
				                  ; We need to pad with spaces
				                    .WHILE (ebx < ecx)
 00000E12  EB 12	   *	    jmp    @C0137
 00000E14		   *@C0138:
				                        .IF (byte ptr ds:[edi+ebx] == 'Æ' || byte ptr ds:[edi+ebx] == 'Ø')
 00000E14  80 3C 3B AE	   *	    cmp    byte ptr ds : [edi + ebx], 'Æ'
 00000E18  74 06	   *	    je     @C013A
 00000E1A  80 3C 3B AF	   *	    cmp    byte ptr ds : [edi + ebx], 'Ø'
 00000E1E  75 01	   *	    jne    @C0139
 00000E20		   *@C013A:
 00000E20  41			                            inc     ecx
				                        .ENDIF
 00000E21		   *@C0139:
 00000E21  C6 04 3B 20		                        mov     byte ptr ds:[edi+ebx],' '
 00000E25  43			                        inc     ebx
				                    .ENDW
 00000E26		   *@C0137:
 00000E26  3B D9	   *	    cmp    ebx, ecx
 00000E28  72 EA	   *	    jb     @C0138
				                .ENDIF
				            .ENDIF
 00000E2A		   *@C0135:
 00000E2A		   *@C0134:
 00000E2A  C6 04 3B 00		            mov     byte ptr ds:[edi+ebx],0
				        .ELSEIF (es:exponent > 80000000h)
 00000E2E  E9 0000008F	   *	    jmp    @C013D
 00000E33		   *@C0120:
 00000E33  26: 81 3D
	   0000BA43 R
	   80000000	   *	    cmp    es : exponent, 080000000h
 00000E3E  76 57	   *	    jbe    @C013E
				          ; It's negative
 00000E40  26: 8B 1D		            mov     ebx,es:exponent
	   0000BA43 R
 00000E47  F7 DB		            neg     ebx
 00000E49  89 5D FC		            mov     dword ptr ss:[ebp-04],ebx
				            .IF (ebx < ecx)
 00000E4C  3B D9	   *	    cmp    ebx, ecx
 00000E4E  73 72	   *	    jae    @C0140
				              ; We an adjust it
				              ; Exchange the first digit and its decimal point
 00000E50  8A 47 01		                mov     al,byte ptr ds:[edi+1]
 00000E53  86 47 02		                xchg    al,byte ptr ds:[edi+2]
 00000E56  88 47 01		                mov     byte ptr ds:[edi+1],al
 00000E59  BA 00000014		                mov     edx,20
 00000E5E  2B D3		                sub     edx,ebx
 00000E60  8B F7		                mov     esi,edi
 00000E62  53			                push    ebx
				                .WHILE (edx > 1)
 00000E63  EB 08	   *	    jmp    @C0142
 00000E65		   *@C0143:
 00000E65  8A 04 3A		                    mov     al,byte ptr ds:[edi+edx]
 00000E68  88 46 14		                    mov     byte ptr ds:[esi+20],al
 00000E6B  4E			                    dec     esi
 00000E6C  4A			                    dec     edx
				                .ENDW
 00000E6D		   *@C0142:
 00000E6D  83 FA 01	   *	    cmp    edx, 001h
 00000E70  77 F3	   *	    ja     @C0143
 00000E72  5B			                pop     ebx
 00000E73  8B 5D FC		                mov     ebx,dword ptr ss:[ebp-04]
				                .WHILE (ebx > 1)
 00000E76  EB 06	   *	    jmp    @C0145
 00000E78		   *@C0146:
 00000E78  C6 46 14 30		                    mov     byte ptr ds:[esi+20],'0'
 00000E7C  4E			                    dec     esi
 00000E7D  4B			                    dec     ebx
				                .ENDW
 00000E7E		   *@C0145:
 00000E7E  83 FB 01	   *	    cmp    ebx, 001h
 00000E81  77 F5	   *	    ja     @C0146
				              ; Now, put the first 2 characters back where they're supposed to be
 00000E83  66| C7 47 01		                mov     word ptr ds:[edi+1],'.0'
	   2E30
 00000E89  C7 47 15		                mov     dword ptr ds:[edi+21],' 0+e'                ; Note, there's a NULL embedded on this line '<null>0+e'
	   00302B65
 00000E90  E9 FFFFFF31		                jmp     truncate_as_necessary
				            .ENDIF
				        .ELSE
 00000E95  EB 2B	   *	    jmp    @C0148
 00000E97		   *@C013E:
				          ; It's positive
				            .IF (es:exponent < ecx)
 00000E97  26: 39 0D
	   0000BA43 R	   *	    cmp    es : exponent, ecx
 00000E9E  73 22	   *	    jae    @C0149
				              ; We can adjust it
 00000EA0  26: 8B 1D		                mov     ebx,es:exponent
	   0000BA43 R
 00000EA7  8B F7		                mov     esi,edi
				                .WHILE (ebx > 0)
 00000EA9  EB 09	   *	    jmp    @C014B
 00000EAB		   *@C014C:
 00000EAB  8A 46 03		                    mov     al,byte ptr ds:[esi+3]                  ; Move to the "1" in "+2.1234567890"
 00000EAE  88 46 02		                    mov     byte ptr ds:[esi+2],al                  ; Move to the "." in same
 00000EB1  46			                    inc     esi
 00000EB2  66| 4B		                    dec     bx
				                .ENDW
 00000EB4		   *@C014B:
 00000EB4  83 FB 00	   *	    cmp    ebx, 000h
 00000EB7  77 F2	   *	    ja     @C014C
 00000EB9  C6 46 02 2E		                mov     byte ptr ds:[esi+2],'.'
 00000EBD  E9 FFFFFF04		                jmp     truncate_as_necessary
				            .ENDIF
				        .ENDIF
 00000EC2		   *@C0149:
 00000EC2		   *@C0148:
 00000EC2		   *@C013D:
 00000EC2		   *@C0140:

 00000EC2			      quit:
 00000EC2  07			        pop     es
 00000EC3  61			        popad
 00000EC4  C9			        leave
 00000EC5  C3			        ret
 00000EC6			    invDEBI_align_floating_point_string     ENDP




 00000EC6			    invDEBI_quick_watch_add_item    PROC
				    ; This routine is used to add a line item to the quick watch window
				    ;
				    ; Upon entry:   ds:[esi] - ptr to item to add
				    ;               cs:[edi] - ptr to text to preceed item to add
				    ;                          * Note:  If edi = -1, then only ds:[esi] is used
				    ;
				    ; Upon exit:    Item is added and the quick watch window is updated
				    ;
 00000EC6  9C			        pushfd
 00000EC7  06			        push    es
 00000EC8  1E			        push    ds
 00000EC9  60			        pushad

 00000ECA  66| 2E: 8E 05	        mov     es,cs:data_segment
	   0000B77F R
				        .IF (edi == -1)
 00000ED2  83 FF FF	   *	    cmp    edi, - 001h
 00000ED5  75 02	   *	    jne    @C014E
 00000ED7  EB 44		            jmp     doing_ds_esi_only
				        .ENDIF
 00000ED9		   *@C014E:
 00000ED9			      do_again_cs_edi:
 00000ED9  E8 0000019D		        call    invDEBI_quick_watch_scroll_data
 00000EDE  BB 000082F0 R	        mov     ebx,offset quick_1
 00000EE3  B9 0000001D		        mov     ecx,sizeof quick_1 - 2
				        .WHILE (ecx > 0 && byte ptr es:[edi] != 0)
 00000EE8  EB 09	   *	    jmp    @C0150
 00000EEA		   *@C0151:
 00000EEA  26: 8A 07		            mov     al,byte ptr es:[edi]
 00000EED  47			            inc     edi
 00000EEE  26: 88 03		            mov     byte ptr es:[ebx],al
 00000EF1  43			            inc     ebx
 00000EF2  49			            dec     ecx
				        .ENDW
 00000EF3		   *@C0150:
 00000EF3  83 F9 00	   *	    cmp    ecx, 000h
 00000EF6  76 06	   *	    jbe    @C0152
 00000EF8  26: 80 3F 00	   *	    cmp    byte ptr es : [edi], 000h
 00000EFC  75 EC	   *	    jne    @C0151
 00000EFE		   *@C0152:
				        .IF (byte ptr es:[edi] != 0)
 00000EFE  26: 80 3F 00	   *	    cmp    byte ptr es : [edi], 000h
 00000F02  74 02	   *	    je     @C0154
				          ; Still more to do
 00000F04  EB D3		            jmp     do_again_cs_edi
				        .ENDIF
 00000F06		   *@C0154:

 00000F06			      do_again_ds_esi:
				        .WHILE (byte ptr ds:[esi] != 0 && ecx > 0)
 00000F06  EB 06	   *	    jmp    @C0156
 00000F08		   *@C0157:
 00000F08  AC			            lodsb
 00000F09  26: 88 03		            mov     byte ptr es:[ebx],al
 00000F0C  43			            inc     ebx
 00000F0D  49			            dec     ecx
				        .ENDW
 00000F0E		   *@C0156:
 00000F0E  80 3E 00	   *	    cmp    byte ptr ds : [esi], 000h
 00000F11  74 05	   *	    je     @C0158
 00000F13  83 F9 00	   *	    cmp    ecx, 000h
 00000F16  77 F0	   *	    ja     @C0157
 00000F18		   *@C0158:
				        .IF (byte ptr ds:[esi] != 0)
 00000F18  80 3E 00	   *	    cmp    byte ptr ds : [esi], 000h
 00000F1B  74 11	   *	    je     @C015A
				          ; Still more to do
 00000F1D			          doing_ds_esi_only:
 00000F1D  E8 00000159		            call    invDEBI_quick_watch_scroll_data
 00000F22  BB 000082F0 R	            mov     ebx,offset quick_1
 00000F27  B9 0000001D		            mov     ecx,sizeof quick_1 - 2
 00000F2C  EB D8		            jmp     do_again_ds_esi
				        .ENDIF
 00000F2E		   *@C015A:
 00000F2E  E8 00000077		        call    invDEBI_quick_watch_refresh_window

 00000F33  61			        popad
 00000F34  1F			        pop     ds
 00000F35  07			        pop     es
 00000F36  9D			        popfd
 00000F37  C3			        ret
 00000F38			    invDEBI_quick_watch_add_item    ENDP




 00000F38			    invDEBI_quick_watch_add_item_ecx        PROC
				    ; This routine is used to add a line item to the quick watch window
				    ;
				    ; Upon entry:   ds:[esi] - ptr to item to add
				    ;               cs:[edi] - ptr to text to preceed item to add
				    ;
				    ; Upon exit:    Item is added and the quick watch window is updated
				    ;
 00000F38  9C			        pushfd
 00000F39  06			        push    es
 00000F3A  1E			        push    ds
 00000F3B  60			        pushad

 00000F3C  66| 2E: 8E 05	        mov     es,cs:data_segment
	   0000B77F R
				        .IF (edi == -1)
 00000F44  83 FF FF	   *	    cmp    edi, - 001h
 00000F47  75 02	   *	    jne    @C015C
 00000F49  EB 44		            jmp     doing_ds_esi_only
				        .ENDIF
 00000F4B		   *@C015C:
 00000F4B			      do_again_cs_edi:
 00000F4B  E8 0000012B		        call    invDEBI_quick_watch_scroll_data
 00000F50  BB 000082F0 R	        mov     ebx,offset quick_1
 00000F55  BA 0000001D		        mov     edx,sizeof quick_1 - 2
				        .WHILE (byte ptr es:[edi] != 0 && edx > 0)
 00000F5A  EB 09	   *	    jmp    @C015E
 00000F5C		   *@C015F:
 00000F5C  26: 8A 07		            mov     al,byte ptr es:[edi]
 00000F5F  47			            inc     edi
 00000F60  26: 88 03		            mov     byte ptr es:[ebx],al
 00000F63  43			            inc     ebx
 00000F64  4A			            dec     edx
				        .ENDW
 00000F65		   *@C015E:
 00000F65  26: 80 3F 00	   *	    cmp    byte ptr es : [edi], 000h
 00000F69  74 05	   *	    je     @C0160
 00000F6B  83 FA 00	   *	    cmp    edx, 000h
 00000F6E  77 EC	   *	    ja     @C015F
 00000F70		   *@C0160:
				        .IF (byte ptr es:[edi] != 0)
 00000F70  26: 80 3F 00	   *	    cmp    byte ptr es : [edi], 000h
 00000F74  74 02	   *	    je     @C0162
				          ; Still more to do
 00000F76  EB D3		            jmp     do_again_cs_edi
				        .ENDIF
 00000F78		   *@C0162:

 00000F78			      do_again_ds_esi:
				        .WHILE (byte ptr ds:[esi] != 0 && ecx > 0)
 00000F78  EB 06	   *	    jmp    @C0164
 00000F7A		   *@C0165:
 00000F7A  AC			            lodsb
 00000F7B  26: 88 03		            mov     byte ptr es:[ebx],al
 00000F7E  43			            inc     ebx
 00000F7F  49			            dec     ecx
				        .ENDW
 00000F80		   *@C0164:
 00000F80  80 3E 00	   *	    cmp    byte ptr ds : [esi], 000h
 00000F83  74 05	   *	    je     @C0166
 00000F85  83 F9 00	   *	    cmp    ecx, 000h
 00000F88  77 F0	   *	    ja     @C0165
 00000F8A		   *@C0166:
				        .IF (byte ptr ds:[esi] != 0)
 00000F8A  80 3E 00	   *	    cmp    byte ptr ds : [esi], 000h
 00000F8D  74 11	   *	    je     @C0168
				          ; Still more to do
 00000F8F			          doing_ds_esi_only:
 00000F8F  E8 000000E7		            call    invDEBI_quick_watch_scroll_data
 00000F94  BB 000082F0 R	            mov     ebx,offset quick_1
 00000F99  B9 0000001D		            mov     ecx,sizeof quick_1 - 2
 00000F9E  EB D8		            jmp     do_again_ds_esi
				        .ENDIF
 00000FA0		   *@C0168:
 00000FA0  E8 00000005		        call    invDEBI_quick_watch_refresh_window

 00000FA5  61			        popad
 00000FA6  1F			        pop     ds
 00000FA7  07			        pop     es
 00000FA8  9D			        popfd
 00000FA9  C3			        ret
 00000FAA			    invDEBI_quick_watch_add_item_ecx        ENDP




 00000FAA			    invDEBI_quick_watch_refresh_window      PROC
				    ; This routine physically redraws the quick watch window
				    ;
				    ; Upon entry:   Nothing
				    ;
				    ; Upon exit:    The window is redrawn
				    ;
 00000FAA  9C			        pushfd
 00000FAB  60			        pushad
 00000FAC  1E			        push    ds

				      ; Now, physically draw the window (update it)
 00000FAD  66| 2E: 8E 1D	        mov     ds,cs:data_segment
	   0000B77F R
 00000FB5  BE 00005642 R	        mov     esi,offset quick_watch_screen_object
 00000FBA  8B 5E 04		        mov     ebx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 00000FBD  8B 46 08		        mov     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00000FC0  BF 0000817C R	        mov     edi,offset DEBI_j_window

				      ; Right now, ebx - horizontal starting pixel
				      ;            eax - vertical starting pixel
				      ;       ds:[edi] - far ptr to screen info
 00000FC5  FA			        cli
 00000FC6  E8 000006BE		        call    invDEBI_hide_mouse_pointer
 00000FCB  E8 0000080F		        call    invDEBI_turn_cursor_off
 00000FD0  E8 FFFFF9FB		        call    invDEBI_draw_window
 00000FD5  E8 000006DA		        call    invDEBI_show_mouse_pointer

 00000FDA  1F			        pop     ds
 00000FDB  61			        popad
 00000FDC  9D			        popfd
 00000FDD  C3			        ret
 00000FDE			    invDEBI_quick_watch_refresh_window      ENDP




 00000FDE			    invDEBI_quick_watch_add_radix_in_edx        PROC
				    ; This routine is used to display the value in edx in a radix in ebx
				    ;
				    ; Upon entry:   edx - value to display
				    ;               ebx - radix to display in
				    ;               edi - ptr to text to add, or -1 if none
				    ;
				    ; Upon exit:    The value is displayed
				    ;
 00000FDE  1E			        push    ds
 00000FDF  60			        pushad
 00000FE0  83 EC 24		        sub     esp,36                                                  ; Assume a maximum length of 32 chars (4 extra for boundary)
 00000FE3  8B EC		        mov     ebp,esp

 00000FE5  C6 45 20 00		        mov     byte ptr [ebp+32],0                                     ; NULL terminate the string we're building
 00000FE9  8B F5		        mov     esi,ebp
 00000FEB  83 C6 1F		        add     esi,31
 00000FEE  8B C2		        mov     eax,edx
 00000FF0  81 E3 0000FFFF	        and     ebx,0ffffh
				        .IF (ebx <= 1)
 00000FF6  83 FB 01	   *	    cmp    ebx, 001h
 00000FF9  77 05	   *	    ja     @C016A
				          ; They've forgotten to set the value, so we correct their little blunder
 00000FFB  BB 00000010		            mov     ebx,16
				        .ENDIF
 00001000		   *@C016A:
 00001000			      @@:
 00001000  33 D2		        xor     edx,edx
 00001002  F7 F3		        div     ebx
				        .IF (dl > 9)
 00001004  80 FA 09	   *	    cmp    dl, 009h
 00001007  76 05	   *	    jbe    @C016C
 00001009  80 C2 57		            add     dl,'a'-10                                           ; Make it a letter if it's above 9 (10+ cannot be represented in 1 digit)
				        .ELSE
 0000100C  EB 03	   *	    jmp    @C016E
 0000100E		   *@C016C:
 0000100E  80 C2 30		            add     dl,'0'                                              ; Make it a number
				        .ENDIF
 00001011		   *@C016E:
 00001011  36: 88 16		        mov     byte ptr ss:[esi],dl
 00001014  4E			        dec     esi                                                     ; Decrement (move to next position to store data)
 00001015  3B F5		        cmp     esi,ebp
 00001017  74 05		        jz      @F
 00001019  83 F8 00		        cmp     eax,0
 0000101C  75 E2		        jnz     @B
 0000101E			      @@:
 0000101E  16			        push    ss
 0000101F  1F			        pop     ds
 00001020  46			        inc     esi                                                     ; Add back for the one we decremented above
				      ; Right now, ds:[esi] - ptr to the value to display
				      ;            cs:[edi] - ptr to text to preceed this item
 00001021  8B 6C 24 2C		        mov     ebp,dword ptr ss:[esp+08+36]
 00001025  E8 FFFFFE9C		        call    invDEBI_quick_watch_add_item

 0000102A  83 C4 24		        add     esp,36
 0000102D  61			        popad
 0000102E  1F			        pop     ds
 0000102F  C3			        ret
 00001030			    invDEBI_quick_watch_add_radix_in_edx        ENDP




 00001030			    invDEBI_quick_watch_add_real4_in_edx        PROC
				    ; This routine is used to display the value in edx in a radix in ebx
				    ;
				    ; Upon entry:   edx - REAL4 value to display
				    ;               edi - ptr to text to add, or -1 if none
				    ;
				    ; Upon exit:    The value is displayed
				    ;
 00001030  60			        pushad
 00001031  1E			        push    ds
 00001032  83 EC 2C		        sub     esp,44                                                  ; Allow for plenty of space

 00001035  16			        push    ss
 00001036  1F			        pop     ds
 00001037  89 3C 24		        mov     dword ptr ss:[esp],edi
 0000103A  8B FC		        mov     edi,esp
 0000103C  83 C7 04		        add     edi,4
 0000103F  8B F7		        mov     esi,edi
 00001041  B9 00000012		        mov     ecx,18
				      ; Right now, ds:[esi] - ptr to the value to display
				      ;            cs:[edi] - ptr to text to preceed this item
 00001046  89 17		        mov     dword ptr ds:[edi],edx
 00001048  D9 07		        fld     real4 ptr ds:[edi]
 0000104A  E8 FFFFFAFB		        call    invDEBI_convert_st0_to_string
 0000104F  8B 3C 24		        mov     edi,dword ptr ss:[esp]
 00001052  E8 FFFFFE6F		        call    invDEBI_quick_watch_add_item

 00001057  83 C4 2C		        add     esp,44
 0000105A  1F			        pop     ds
 0000105B  61			        popad
 0000105C  C3			        ret
 0000105D			    invDEBI_quick_watch_add_real4_in_edx        ENDP




 0000105D			    invDEBI_quick_watch_add_divider     PROC
				    ; This routine is called to put a divider up between items in the quickwatch window
				    ;
				    ; Upon entry:   Nothing
				    ;
				    ; Upon exit:    The divider bar is displayed
				    ;
 0000105D  1E			        push    ds
 0000105E  56			        push    esi
 0000105F  57			        push    edi

 00001060  66| 2E: 8E 1D	        mov     ds,cs:data_segment
	   0000B77F R
 00001068  BE 0000B67B R	        mov     esi,offset quick_watch_divider
 0000106D  BF FFFFFFFF		        mov     edi,-1
 00001072  E8 FFFFFE4F		        call    invDEBI_quick_watch_add_item

 00001077  5F			        pop     edi
 00001078  5E			        pop     esi
 00001079  1F			        pop     ds
 0000107A  C3			        ret
 0000107B			    invDEBI_quick_watch_add_divider     ENDP




 0000107B			    invDEBI_quick_watch_scroll_data     PROC
				    ; This routine physically copies the data in the watch window up one line
				    ;
				    ; Upon entry:   Nothing
				    ;
				    ; Upon exit:    Data is scrolled
				    ;
 0000107B  9C			        pushfd
 0000107C  1E			        push    ds
 0000107D  06			        push    es
 0000107E  56			        push    esi
 0000107F  57			        push    edi
 00001080  51			        push    ecx
 00001081  50			        push    eax

 00001082  66| 2E: 8E 1D	        mov     ds,cs:data_segment
	   0000B77F R
 0000108A  66| 2E: 8E 05	        mov     es,cs:data_segment
	   0000B77F R

 00001092  FC			        cld
 00001093  BE 000081BA R	        mov     esi,offset quick_11
 00001098  BF 0000819B R	        mov     edi,offset quick_12
 0000109D  B9 0000001D		        mov     ecx,sizeof quick_12 - 2
 000010A2  F3/ A4		        rep     movsb
 000010A4  BE 000081D9 R	        mov     esi,offset quick_10
 000010A9  BF 000081BA R	        mov     edi,offset quick_11
 000010AE  B9 0000001D		        mov     ecx,sizeof quick_11 - 2
 000010B3  F3/ A4		        rep     movsb
 000010B5  BE 000081F8 R	        mov     esi,offset quick_9
 000010BA  BF 000081D9 R	        mov     edi,offset quick_10
 000010BF  B9 0000001D		        mov     ecx,sizeof quick_10 - 2
 000010C4  F3/ A4		        rep     movsb
 000010C6  BE 00008217 R	        mov     esi,offset quick_8
 000010CB  BF 000081F8 R	        mov     edi,offset quick_9
 000010D0  B9 0000001D		        mov     ecx,sizeof quick_9 - 2
 000010D5  F3/ A4		        rep     movsb
 000010D7  BE 00008236 R	        mov     esi,offset quick_7
 000010DC  BF 00008217 R	        mov     edi,offset quick_8
 000010E1  B9 0000001D		        mov     ecx,sizeof quick_8 - 2
 000010E6  F3/ A4		        rep     movsb
 000010E8  BE 00008255 R	        mov     esi,offset quick_6
 000010ED  BF 00008236 R	        mov     edi,offset quick_7
 000010F2  B9 0000001D		        mov     ecx,sizeof quick_7 - 2
 000010F7  F3/ A4		        rep     movsb
 000010F9  BE 00008274 R	        mov     esi,offset quick_5
 000010FE  BF 00008255 R	        mov     edi,offset quick_6
 00001103  B9 0000001D		        mov     ecx,sizeof quick_6 - 2
 00001108  F3/ A4		        rep     movsb
 0000110A  BE 00008293 R	        mov     esi,offset quick_4
 0000110F  BF 00008274 R	        mov     edi,offset quick_5
 00001114  B9 0000001D		        mov     ecx,sizeof quick_5 - 2
 00001119  F3/ A4		        rep     movsb
 0000111B  BE 000082B2 R	        mov     esi,offset quick_3
 00001120  BF 00008293 R	        mov     edi,offset quick_4
 00001125  B9 0000001D		        mov     ecx,sizeof quick_4 - 2
 0000112A  F3/ A4		        rep     movsb
 0000112C  BE 000082D1 R	        mov     esi,offset quick_2
 00001131  BF 000082B2 R	        mov     edi,offset quick_3
 00001136  B9 0000001D		        mov     ecx,sizeof quick_3 - 2
 0000113B  F3/ A4		        rep     movsb
 0000113D  BE 000082F0 R	        mov     esi,offset quick_1
 00001142  BF 000082D1 R	        mov     edi,offset quick_2
 00001147  B9 0000001D		        mov     ecx,sizeof quick_2 - 2
 0000114C  F3/ A4		        rep     movsb
				      ; Reset the bottom line to spaces
 0000114E  BF 000082F0 R	        mov     edi,offset quick_1
 00001153  B9 0000001D		        mov     ecx,sizeof quick_1 - 2
 00001158  B0 20		        mov     al,32
 0000115A  F3/ AA		        rep     stosb

 0000115C  58			        pop     eax
 0000115D  59			        pop     ecx
 0000115E  5F			        pop     edi
 0000115F  5E			        pop     esi
 00001160  07			        pop     es
 00001161  1F			        pop     ds
 00001162  9D			        popfd
 00001163  C3			        ret
 00001164			    invDEBI_quick_watch_scroll_data     ENDP




 00001164			    invDEBI_query_window            PROC
				    ; This routine is called when updating the screen (it handles query window objects)
				    ;
				    ; Upon entry:   The stack is arranged as below
				    ;               ds:[esi] - ptr to screen table structure
				    ;               ds:[edi] - ptr to this item's objects
				    ;
				    ; Upon exit:    The window is populated or not
				    ;
				      ; [ebp-080] - offset into _sDEBI_memory for next item
				      ; [ebp-084] - segment of temp far address
				      ; [ebp-088] - offset of temp far address
				      ; [ebp-092] - (temp) used as a temporary holder for processing
 00001164  C3			        ret
 00001165			    invDEBI_query_window            ENDP
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; END - 00000 - Window Supportive Algorithms/Handlers
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; 11111 - External interfaces (Timer, Mouse, Kbd)
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 00001165			    iDEBI_kbd_interface     PROC
				    ; This routine is called when the user presses a key after iKBD_activate_DEBI_intercept() has been called
				    ;
				    ; Upon entry:   eax - key
				    ;               ebx - keyboard flags
				    ;
				    ; Upon exit:    Nothing
				    ;
				        .IF (cs:disable_kbd == 1)
 00001165  2E: 80 3D
	   0000B782 R 01   *	    cmp    cs : disable_kbd, 001h
 0000116D  75 01	   *	    jne    @C016F
 0000116F  CB			            retf
				        .ENDIF
 00001170		   *@C016F:

				      ; Cancel the screen saver (if it's activated)
 00001170  1E			        push    ds
 00001171  66| 2E: 8E 1D	        mov     ds,cs:data_segment
	   0000B77F R
 00001179  E8 000006C1		        call    invDEBI_cancel_screen_saver
 0000117E  C7 05 0000B89F R	        mov     ds:screen_saver_count,0
	   00000000

				      ; Process the key with whatever routine is receiving keyboard input
				        .IF (cs:kbd_focus == -1)
 00001188  2E: 83 3D
	   0000B794 R FF   *	    cmp    cs : kbd_focus, - 001h
 00001190  75 07	   *	    jne    @C0171
				          ; No handler is seutp, use DEBI generic
 00001192  E8 000040C9		            call    invDEBI_kbd_handler
				        .ELSE
 00001197  EB 14	   *	    jmp    @C0173
 00001199		   *@C0171:
 00001199  06			            push    es
 0000119A  0F A0		            push    fs
 0000119C  0F A8		            push    gs
 0000119E  60			            pushad

 0000119F  8B 15 0000B794 R	            mov     edx,ds:kbd_focus
 000011A5  FF D2		            call    edx

 000011A7  61			            popad
 000011A8  0F A9		            pop     gs
 000011AA  0F A1		            pop     fs
 000011AC  07			            pop     es
				        .ENDIF
 000011AD		   *@C0173:

 000011AD  1F			        pop     ds
 000011AE  CB			        retf
 000011AF			    iDEBI_kbd_interface     ENDP




 000011AF			    iDEBI_mouse_interface       PROC
				    ; This routine is called when the mouse status changes after iMOUSE_activate_DEBI_intercept() has been called
				    ;
				    ; Upon entry:   eax - X delta
				    ;               edx - Y delta
				    ;               ebx - button status
				    ;
				    ; Upon exit:    Nothing
				    ;
				        .IF (cs:disable_mouse == 1)
 000011AF  2E: 80 3D
	   0000B781 R 01   *	    cmp    cs : disable_mouse, 001h
 000011B7  75 01	   *	    jne    @C0174
 000011B9  CB			            retf
				        .ENDIF
 000011BA		   *@C0174:
 000011BA  1E			        push    ds
 000011BB  60			        pushad
 000011BC  66| 2E: 8E 1D	        mov     ds,cs:data_segment
	   0000B77F R

				      ;; Cancel screen saver if it's active
 000011C4  E8 00000676		        call    invDEBI_cancel_screen_saver
 000011C9  C7 05 0000B89F R	        mov     ds:screen_saver_count,0
	   00000000

				      ;; Remove the mouse pointer that's already displayed
				        .IF (ds:mouse_processing == 0 && ds:mouse_status == 1)
 000011D3  83 3D 0000B806 R
	   00		   *	    cmp    ds : mouse_processing, 000h
 000011DA  75 0E	   *	    jne    @C0176
 000011DC  83 3D 0000B802 R
	   01		   *	    cmp    ds : mouse_status, 001h
 000011E3  75 05	   *	    jne    @C0176
 000011E5  E8 0000049F		            call    invDEBI_hide_mouse_pointer
				        .ENDIF
 000011EA		   *@C0176:

				      ;; Update the coordinates based on the signed displacement information sent to us from the mouse driver
 000011EA  E8 00000295		        call    invDEBI_update_mouse_coordinates

				      ;; Process the mouse
				        .IF (ds:mouse_processing == 0)
 000011EF  83 3D 0000B806 R
	   00		   *	    cmp    ds : mouse_processing, 000h
 000011F6  0F 85 0000020C  *	    jne    @C0179
				          ; No button status, just moving the mouse around. :)
 000011FC  C7 05 0000B806 R	            mov     ds:mouse_processing,1
	   00000001
				            .IF (ds:dragging_something != 0)
 00001206  83 3D 0000B7A9 R
	   00		   *	    cmp    ds : dragging_something, 000h
 0000120D  0F 84 000001A0  *	    je     @C017B
 00001213  60			                pushad
 00001214  9C			                pushfd
 00001215  1E			                push    ds

				              ; Put the image back on the screen where it was
 00001216  FA			                cli
				                .IF (ds:dragging_something != 1)
 00001217  83 3D 0000B7A9 R
	   01		   *	    cmp    ds : dragging_something, 001h
 0000121E  0F 84 000000BD  *	    je     @C017D
 00001224  FF 35 0000B7AD R	                    push    dword ptr ds:dragging_x
 0000122A  8B 15 0000B7BD R	                    mov     edx,ds:dragging_offset_x
 00001230  29 14 24		                    sub     dword ptr ss:[esp],edx
 00001233  E8 000001FA		                    call    invDEBI_dragging_snap_x

 00001238  FF 35 0000B7B1 R	                    push    dword ptr ds:dragging_y
 0000123E  8B 15 0000B7C1 R	                    mov     edx,ds:dragging_offset_y
 00001244  29 14 24		                    sub     dword ptr ss:[esp],edx
 00001247  E8 0000020F		                    call    invDEBI_dragging_snap_y

 0000124C  8B 15 0000B7CD R	                    mov     edx,ds:dragging_last_x
 00001252  8B 1D 0000B7D1 R	                    mov     ebx,ds:dragging_last_y
				                    .IF (dword ptr ss:[esp+4] == edx && dword ptr ss:[esp] == ebx)
 00001258  39 54 24 04	   *	    cmp    dword ptr ss : [esp + 004h], edx
 0000125C  75 19	   *	    jne    @C017F
 0000125E  39 1C 24	   *	    cmp    dword ptr ss : [esp], ebx
 00001261  75 14	   *	    jne    @C017F
				                      ; This will only be the case if they're using a dragging_snap_x and/or dragging_snap_y value
 00001263  C7 05 0000B7D5 R	                        mov     ds:dragging_skipped,1
	   00000001
 0000126D  83 C4 08		                        add     esp,8
 00001270  E9 00000123		                        jmp     skip_dragging_redraw
				                    .ELSE
 00001275  EB 3B	   *	    jmp    @C0182
 00001277		   *@C017F:
 00001277  8B 54 24 04		                        mov     edx,dword ptr ss:[esp+4]
 0000127B  8B 1C 24		                        mov     ebx,dword ptr ss:[esp+0]
				                        .IF (ds:dragging_skipped != 0)
 0000127E  83 3D 0000B7D5 R
	   00		   *	    cmp    ds : dragging_skipped, 000h
 00001285  74 1F	   *	    je     @C0183
 00001287  C7 05 0000B7D5 R	                            mov     ds:dragging_skipped,0
	   00000000
 00001291  8B 15 0000B7CD R	                            mov     edx,ds:dragging_last_x
 00001297  8B 1D 0000B7D1 R	                            mov     ebx,ds:dragging_last_y
 0000129D  89 54 24 04		                            mov     dword ptr ss:[esp+4],edx
 000012A1  89 1C 24		                            mov     dword ptr ss:[esp+0],ebx
				                        .ELSE
 000012A4  EB 0C	   *	    jmp    @C0185
 000012A6		   *@C0183:
 000012A6  89 15 0000B7CD R	                            mov     ds:dragging_last_x,edx
 000012AC  89 1D 0000B7D1 R	                            mov     ds:dragging_last_y,ebx
				                        .ENDIF
				                    .ENDIF
 000012B2		   *@C0185:

 000012B2		   *@C0182:
 000012B2  FF 74 24 04		                    push    dword ptr ss:[esp+4]
 000012B6  8B 15 0000B7B9 R	                    mov     edx,ds:dragging_width
 000012BC  01 14 24		                    add     dword ptr ss:[esp],edx

 000012BF  FF 74 24 04		                    push    dword ptr ss:[esp+4]
 000012C3  8B 15 0000B7B5 R	                    mov     edx,ds:dragging_height
 000012C9  01 14 24		                    add     dword ptr ss:[esp],edx

 000012CC  6A 00		                    push    0
 000012CE  6A 00		                    push    0
 000012D0  B8 000000D0		                    mov     eax,_sDEBI_screen
 000012D5  66| 8E D8		                    mov     ds,ax
 000012D8  2E: FF 1D		                    call    fword ptr cs:_VID_g_mono_window_function
	   0000D0FD R
				                .ELSE
 000012DF  EB 0E	   *	    jmp    @C0186
 000012E1		   *@C017D:
 000012E1  FF 05 0000B7A9 R	                    inc     ds:dragging_something
 000012E7  B8 000000D0		                    mov     eax,_sDEBI_screen
 000012EC  66| 8E D8		                    mov     ds,ax
				                .ENDIF

				              ; Get the image at the new location
 000012EF		   *@C0186:
 000012EF  2E: FF 35		                push    dword ptr cs:mouse_current_x
	   0000B7E5 R
 000012F6  2E: 8B 15		                mov     edx,cs:dragging_offset_x
	   0000B7BD R
 000012FD  29 14 24		                sub     dword ptr ss:[esp],edx
 00001300  E8 0000012D		                call    invDEBI_dragging_snap_x

 00001305  2E: FF 35		                push    dword ptr cs:mouse_current_y
	   0000B7E9 R
 0000130C  2E: 8B 15		                mov     edx,cs:dragging_offset_y
	   0000B7C1 R
 00001313  29 14 24		                sub     dword ptr ss:[esp],edx
 00001316  E8 00000140		                call    invDEBI_dragging_snap_y

 0000131B  FF 74 24 04		                push    dword ptr ss:[esp+4]
 0000131F  2E: 8B 15		                mov     edx,cs:dragging_width
	   0000B7B9 R
 00001326  01 14 24		                add     dword ptr ss:[esp],edx

 00001329  FF 74 24 04		                push    dword ptr ss:[esp+4]
 0000132D  2E: 8B 15		                mov     edx,cs:dragging_height
	   0000B7B5 R
 00001334  01 14 24		                add     dword ptr ss:[esp],edx

 00001337  6A 01		                push    1
 00001339  6A 00		                push    0
 0000133B  2E: FF 1D		                call    fword ptr cs:_VID_g_mono_window_function
	   0000D0FD R

				              ; Draw it at its new location
 00001342  2E: FF 35		                push    dword ptr cs:mouse_current_x
	   0000B7E5 R
 00001349  2E: 8B 15		                mov     edx,cs:dragging_offset_x
	   0000B7BD R
 00001350  29 14 24		                sub     dword ptr ss:[esp],edx
 00001353  E8 000000DA		                call    invDEBI_dragging_snap_x

 00001358  2E: FF 35		                push    dword ptr cs:mouse_current_y
	   0000B7E9 R
 0000135F  2E: 8B 15		                mov     edx,cs:dragging_offset_y
	   0000B7C1 R
 00001366  29 14 24		                sub     dword ptr ss:[esp],edx
 00001369  E8 000000ED		                call    invDEBI_dragging_snap_y

 0000136E  FF 74 24 04		                push    dword ptr ss:[esp+4]
 00001372  2E: 8B 15		                mov     edx,cs:dragging_width
	   0000B7B9 R
 00001379  01 14 24		                add     dword ptr ss:[esp],edx

 0000137C  FF 74 24 04		                push    dword ptr ss:[esp+4]
 00001380  2E: 8B 15		                mov     edx,cs:dragging_height
	   0000B7B5 R
 00001387  01 14 24		                add     dword ptr ss:[esp],edx

 0000138A  6A 00		                push    0
 0000138C  68 00004000		                push    dword ptr 4000h
 00001391  2E: FF 1D		                call    fword ptr cs:_VID_g_mono_window_function
	   0000D0FD R

				              ; Update the dragging_coordinates
 00001398			              skip_dragging_redraw:
 00001398  1F			                pop     ds
 00001399  9D			                popfd
 0000139A  8B 15 0000B7E5 R	                mov     edx,ds:mouse_current_x
 000013A0  89 15 0000B7AD R	                mov     ds:dragging_x,edx
 000013A6  8B 15 0000B7E9 R	                mov     edx,ds:mouse_current_y
 000013AC  89 15 0000B7B1 R	                mov     ds:dragging_y,edx
 000013B2  61			                popad
				            .ENDIF
				            .IF (ebx != 0 || ebx != ds:mouse_last_buttons)
 000013B3		   *@C017B:
 000013B3  0B DB	   *	    or	ebx, ebx
 000013B5  75 08	   *	    jne    @C0188
 000013B7  3B 1D 0000B80A R *	    cmp    ebx, ds : mouse_last_buttons
 000013BD  74 07	   *	    je     @C0187
 000013BF		   *@C0188:
				              ; There is button activity
				              ; This process might take a bit of time to complete so we indicate we're processing thereby removing
				              ; the possibility of attempted processing in the future until such time as all the processing we're about
				              ; to start gets completed.
 000013BF  E8 000004CB		                call    invDEBI_mouse_button_activity
				            .ELSE
 000013C4  EB 38	   *	    jmp    @C018A
 000013C6		   *@C0187:
				              ; No button activity
				              ; We still have to see if we're over anything that needs to be updated because we also display information about
				              ; certain things in the Quick Watch window.  Isn't it great? :)
 000013C6  8B 15 0000B7E5 R	                mov     edx,ds:mouse_current_x
 000013CC  89 15 0000B7ED R	                mov     ds:mouse_hovering_x,edx
 000013D2  8B 15 0000B7E9 R	                mov     edx,ds:mouse_current_y
 000013D8  89 15 0000B7F1 R	                mov     ds:mouse_hovering_y,edx
 000013DE  C7 05 0000B7F5 R	                mov     ds:mouse_hovering_count,91
	   0000005B
 000013E8  C6 05 0000B801 R	                mov     ds:mouse_last_event,_HOVER
	   0A
 000013EF  C7 05 0000B7FD R	                mov     ds:mouse_immediate_count,_IMMEDIATE_COUNT
	   00000002
 000013F9  E8 000002B6		                call    invDEBI_show_mouse_pointer
				            .ENDIF
 000013FE		   *@C018A:
 000013FE  C7 05 0000B806 R	            mov     ds:mouse_processing,0
	   00000000
				        .ENDIF
 00001408		   *@C0179:

 00001408  61			        popad
 00001409  1F			        pop     ds
 0000140A  CB			        retf
 0000140B			    iDEBI_mouse_interface       ENDP




				;; Bochs hack
 0000140B			    iDEBI_bochs_mouse_interface     PROC
				    ; Called from the mouse handler, simulates mouse input as though it came from a real mouse.
				    ; When working with Bochs, the MoMo maintains mouse pointer position, which is fed here.
				    ;
				    ; Upon entry:   eax - X delta
				    ;               ebx - Y delta
				    ;               ecx - button status
				    ;
				    ; Upon exit:    Nothing
				    ;
 0000140B  1E			        push    ds
 0000140C  60			        pushad
 0000140D  66| 2E: 8E 1D	        mov     ds,cs:data_segment
	   0000B77F R

				        ; See if anything's changed
				        .IF (eax != ds:mouse_current_x && ebx != ds:mouse_current_y)
 00001415  3B 05 0000B7E5 R *	    cmp    eax, ds : mouse_current_x
 0000141B  74 12	   *	    je     @C018B
 0000141D  3B 1D 0000B7E9 R *	    cmp    ebx, ds : mouse_current_y
 00001423  74 0A	   *	    je     @C018B
				            ; It has
 00001425  8B D3		            mov     edx,ebx         ; Update Y coord for iDEBI_mouse_interface
 00001427  8B D9		            mov     ebx,ecx         ; Update button for iDEBI_mouse_interface
 00001429  0E			            push    cs
 0000142A  E8 FFFFFD80		            call    iDEBI_mouse_interface
				        .ENDIF
 0000142F		   *@C018B:

 0000142F  61			        popad
 00001430  1F			        pop     ds
 00001431  CB			        retf
 00001432			    iDEBI_bochs_mouse_interface     ENDP
				;; Bochs hack




 00001432			    invDEBI_dragging_snap_x         PROC
				    ; This routine is called to adjust the snap-to coordinates of the mouse movement
				    ;
				    ; Upon entry:   ss:[esp+4] - value to snap
				    ;               ds:dragging_snap_x - value to snap to
				    ;
				    ; Upon exit:    Value on stack is updated to upper-most region
				    ;
				      ; [esp+8] - X coord to snap
				      ; [esp+4] - calling EIP
				      ; [esp+0] - ds
				        .IF (cs:dragging_snap_x != 0)
 00001432  2E: 83 3D
	   0000B7C5 R 00   *	    cmp    cs : dragging_snap_x, 000h
 0000143A  74 1E	   *	    je     @C018E
 0000143C  1E			            push    ds
 0000143D  66| 2E: 8E 1D	            mov     ds,cs:data_segment
	   0000B77F R
 00001445  8B 44 24 08		            mov     eax,dword ptr ss:[esp+8]
 00001449  8B 1D 0000B7C5 R	            mov     ebx,ds:dragging_snap_x
 0000144F  33 D2		            xor     edx,edx
 00001451  F7 F3		            div     ebx
 00001453  F7 E3		            mul     ebx
 00001455  89 44 24 08		            mov     dword ptr ss:[esp+8],eax
 00001459  1F			            pop     ds
				        .ENDIF
 0000145A		   *@C018E:
 0000145A  C3			        ret
 0000145B			    invDEBI_dragging_snap_x         ENDP




 0000145B			    invDEBI_dragging_snap_y         PROC
				    ; This routine is called to adjust the snap-to coordinates of the mouse movement
				    ;
				    ; Upon entry:   ss:[esp+4] - value to snap
				    ;               ds:dragging_snap_y - value to snap to
				    ;
				    ; Upon exit:    Value on stack is updated to left-most region
				    ;
				      ; [esp+8] - Y coord to snap
				      ; [esp+4] - calling EIP
				      ; [esp+0] - ds
				        .IF (cs:dragging_snap_y != 0)
 0000145B  2E: 83 3D
	   0000B7C9 R 00   *	    cmp    cs : dragging_snap_y, 000h
 00001463  74 1E	   *	    je     @C0190
 00001465  1E			            push    ds
 00001466  66| 2E: 8E 1D	            mov     ds,cs:data_segment
	   0000B77F R
 0000146E  8B 44 24 08		            mov     eax,dword ptr ss:[esp+8]
 00001472  8B 1D 0000B7C9 R	            mov     ebx,ds:dragging_snap_y
 00001478  33 D2		            xor     edx,edx
 0000147A  F7 F3		            div     ebx
 0000147C  F7 E3		            mul     ebx
 0000147E  89 44 24 08		            mov     dword ptr ss:[esp+8],eax
 00001482  1F			            pop     ds
				        .ENDIF
 00001483		   *@C0190:
 00001483  C3			        ret
 00001484			    invDEBI_dragging_snap_y         ENDP




 00001484			    invDEBI_update_mouse_coordinates    PROC
				    ; This routine is used to update the mouse coordinates
				    ;
				    ; Upon entry:   eax - change in X
				    ;               edx - change in Y
				    ;
				    ; Upon exit:    values are updated
				    ;
				;; Bochs hack
				;;        shl     eax,1                                               ; We multiply the X-coordinate by 2 because the
				;;                                                                    ; monochrome display is 720x348 (x is twice as big)
				;;        add     ds:mouse_current_x,eax
				;;        add     ds:mouse_current_y,edx
 00001484  A3 0000B7E5 R	        mov     ds:mouse_current_x,eax
 00001489  89 15 0000B7E9 R	        mov     ds:mouse_current_y,edx
				;; Bochs hack
				        .IF (ds:dragging_something == 0)
 0000148F  83 3D 0000B7A9 R
	   00		   *	    cmp    ds : dragging_something, 000h
 00001496  75 7A	   *	    jne    @C0192
				          ; Verify X
				            .IF (ds:mouse_current_x > 7fffffffh || ds:mouse_current_x == 0)
 00001498  81 3D 0000B7E5 R
	   7FFFFFFF	   *	    cmp    ds : mouse_current_x, 07FFFFFFFh
 000014A2  77 09	   *	    ja     @C0195
 000014A4  83 3D 0000B7E5 R
	   00		   *	    cmp    ds : mouse_current_x, 000h
 000014AB  75 0C	   *	    jne    @C0194
 000014AD		   *@C0195:
				              ; It's negative (it's off the left of the screen or it's at the very left of the screen)
 000014AD  C7 05 0000B7E5 R	                mov     ds:mouse_current_x,1
	   00000001
				            .ELSEIF (ds:mouse_current_x > 718)
 000014B7  EB 16	   *	    jmp    @C0197
 000014B9		   *@C0194:
 000014B9  81 3D 0000B7E5 R
	   000002CE	   *	    cmp    ds : mouse_current_x, 002CEh
 000014C3  76 0A	   *	    jbe    @C0198
				              ; It's heading off the right side of the screen
 000014C5  C7 05 0000B7E5 R	                mov     ds:mouse_current_x,718
	   000002CE
				            .ENDIF

				          ; Verify Y
				            .IF (ds:mouse_current_y > 7fffffffh || ds:mouse_current_y == 0)
 000014CF		   *@C0198:
 000014CF		   *@C0197:
 000014CF  81 3D 0000B7E9 R
	   7FFFFFFF	   *	    cmp    ds : mouse_current_y, 07FFFFFFFh
 000014D9  77 09	   *	    ja     @C019B
 000014DB  83 3D 0000B7E9 R
	   00		   *	    cmp    ds : mouse_current_y, 000h
 000014E2  75 0F	   *	    jne    @C019A
 000014E4		   *@C019B:
				              ; It's negative (it's above the top of the screen or it's at the very top of the screen)
 000014E4  C7 05 0000B7E9 R	                mov     ds:mouse_current_y,1
	   00000001
				            .ELSEIF (ds:mouse_current_y > 346)
 000014EE  E9 000000C1	   *	    jmp    @C019D
 000014F3		   *@C019A:
 000014F3  81 3D 0000B7E9 R
	   0000015A	   *	    cmp    ds : mouse_current_y, 0015Ah
 000014FD  0F 86 000000B1  *	    jbe    @C019E
				              ; It's heading off the bottom of the screen
 00001503  C7 05 0000B7E9 R	                mov     ds:mouse_current_y,346
	   0000015A
				            .ENDIF
				        .ELSE
 0000150D  E9 000000A2	   *	    jmp    @C01A0
 00001512		   *@C0192:
				          ; The mouse is only allowed to move in certain areas when something is being dragged
				          ; This logic is a little more complex than the above no-drag logic

				          ; Make sure they're not negative
				            .IF (ds:mouse_current_x > 7fffffffh)
 00001512  81 3D 0000B7E5 R
	   7FFFFFFF	   *	    cmp    ds : mouse_current_x, 07FFFFFFFh
 0000151C  76 06	   *	    jbe    @C01A1
 0000151E  F7 1D 0000B7E5 R	                neg     ds:mouse_current_x
				            .ENDIF
				            .IF (ds:mouse_current_y > 7fffffffh)
 00001524		   *@C01A1:
 00001524  81 3D 0000B7E9 R
	   7FFFFFFF	   *	    cmp    ds : mouse_current_y, 07FFFFFFFh
 0000152E  76 06	   *	    jbe    @C01A3
 00001530  F7 1D 0000B7E9 R	                neg     ds:mouse_current_y
				            .ENDIF

				          ; Verify X
 00001536		   *@C01A3:
 00001536  53			            push    ebx
 00001537  8B 1D 0000B7E5 R	            mov     ebx,ds:mouse_current_x
 0000153D  2B 1D 0000B7BD R	            sub     ebx,ds:dragging_offset_x
				            .IF (carry?)
 00001543  73 0A	   *	    jae    @C01A5
				              ; We're less than zero
 00001545  F7 DB		                neg     ebx
 00001547  01 1D 0000B7E5 R	                add     ds:mouse_current_x,ebx
				            .ELSE
 0000154D  EB 26	   *	    jmp    @C01A7
 0000154F		   *@C01A5:
				              ; We're good on the left-side.  Now, how about the right?
 0000154F  8B 1D 0000B7E5 R	                mov     ebx,ds:mouse_current_x
 00001555  2B 1D 0000B7BD R	                sub     ebx,ds:dragging_offset_x
 0000155B  03 1D 0000B7B9 R	                add     ebx,ds:dragging_width
				                .IF (ebx > 720)
 00001561  81 FB 000002D0  *	    cmp    ebx, 002D0h
 00001567  76 0C	   *	    jbe    @C01A8
				                  ; We're to far
 00001569  81 EB 000002D0	                    sub     ebx,720
 0000156F  29 1D 0000B7E5 R	                    sub     ds:mouse_current_x,ebx
				                .ENDIF
				            .ENDIF
 00001575		   *@C01A8:

				          ; Verify Y
 00001575		   *@C01A7:
 00001575  8B 1D 0000B7E9 R	            mov     ebx,ds:mouse_current_y
 0000157B  2B 1D 0000B7C1 R	            sub     ebx,ds:dragging_offset_y
				            .IF (carry?)
 00001581  73 0A	   *	    jae    @C01AA
				              ; We're less than zero
 00001583  F7 DB		                neg     ebx
 00001585  01 1D 0000B7E9 R	                add     ds:mouse_current_y,ebx
				            .ELSE
 0000158B  EB 26	   *	    jmp    @C01AC
 0000158D		   *@C01AA:
				              ; We're good on the top.  Now, how about the bottom?
 0000158D  8B 1D 0000B7E9 R	                mov     ebx,ds:mouse_current_y
 00001593  2B 1D 0000B7C1 R	                sub     ebx,ds:dragging_offset_y
 00001599  03 1D 0000B7B5 R	                add     ebx,ds:dragging_height
				                .IF (ebx > 348)
 0000159F  81 FB 0000015C  *	    cmp    ebx, 0015Ch
 000015A5  76 0C	   *	    jbe    @C01AD
				                  ; We're to far
 000015A7  81 EB 0000015C	                    sub     ebx,348
 000015AD  29 1D 0000B7E9 R	                    sub     ds:mouse_current_y,ebx
				                .ENDIF
				            .ENDIF
 000015B3		   *@C01AD:
 000015B3		   *@C01AC:
 000015B3  5B			            pop     ebx
				        .ENDIF
 000015B4		   *@C01A0:
 000015B4		   *@C019E:
 000015B4		   *@C019D:
 000015B4  C3			        ret
 000015B5			    invDEBI_update_mouse_coordinates    ENDP




 000015B5			    iDEBI_timer_interface       PROC
				    ; This routine is called 182 times per second from the timer handler.  It is used to determine how long objects
				    ; have been displayed, how long a mouse has been hovering over an object prior to display, etc.  It's very handy. :)
				    ;
				    ; Upon entry:   Nothing
				    ;
				    ; Upon exit:    Nothing
				    ;
				        .IF (cs:disable_timer == 1)
 000015B5  2E: 80 3D
	   0000B783 R 01   *	    cmp    cs : disable_timer, 001h
 000015BD  75 01	   *	    jne    @C01AF
 000015BF  CB			            retf
				        .ENDIF
 000015C0		   *@C01AF:
 000015C0  1E			        push    ds
 000015C1  66| 2E: 8E 1D	        mov     ds,cs:data_segment
	   0000B77F R
 000015C9  FF 05 0000B89B R	        inc     ds:timer_interface_count
 000015CF  FF 05 0000B89F R	        inc     ds:screen_saver_count
				        .IF (ds:screen_saver_count > 18200 && ds:screen_saver == 0)
 000015D5  81 3D 0000B89F R
	   00004718	   *	    cmp    ds : screen_saver_count, 04718h
 000015DF  76 09	   *	    jbe    @C01B1
 000015E1  80 3D 0000B8A3 R
	   00		   *	    cmp    ds : screen_saver, 000h
 000015E8  75 00	   *	    jne    @C01B1
				          ; This is 100 seconds
				            ;call    invDEBI_activate_screen_saver
				        .ENDIF
 000015EA		   *@C01B1:

				;; Bochs hack
				        .IF (ds:screen_saver_count > 10)
 000015EA  83 3D 0000B89F R
	   0A		   *	    cmp    ds : screen_saver_count, 00Ah
 000015F1  76 10	   *	    jbe    @C01B4
 000015F3  C7 05 0000B89F R	            mov     ds:screen_saver_count,0
	   00000000
 000015FD  FF 1D 0000D115 R	            call    fword ptr ds:_iMOUSE_bochs_DEBI_intercept
				        .ENDIF
 00001603		   *@C01B4:
				;; Bochs hack


 00001603  FF 05 0000B8AC R	        inc     ds:cursor_count
				        .IF (ds:force_cursor_off == 0 && ds:cursor_count > 60 && ds:screen_saver == 0)
 00001609  80 3D 0000B8B1 R
	   00		   *	    cmp    ds : force_cursor_off, 000h
 00001610  75 17	   *	    jne    @C01B6
 00001612  83 3D 0000B8AC R
	   3C		   *	    cmp    ds : cursor_count, 03Ch
 00001619  76 0E	   *	    jbe    @C01B6
 0000161B  80 3D 0000B8A3 R
	   00		   *	    cmp    ds : screen_saver, 000h
 00001622  75 05	   *	    jne    @C01B6
				          ; About every 182/60 second the cursor toggles
 00001624  E8 00000156		            call    invDEBI_toggle_cursor
				        .ENDIF
 00001629		   *@C01B6:

				        .IF (ds:draw_menu != 0)
 00001629  83 3D 0000B7A0 R
	   00		   *	    cmp    ds : draw_menu, 000h
 00001630  74 23	   *	    je     @C01BA
				          ;; Draw the menu
 00001632  C7 05 0000B7A0 R	            mov     ds:draw_menu,0
	   00000000
 0000163C  60			            pushad
 0000163D  9C			            pushfd
 0000163E  FA			            cli
 0000163F  E8 00000045		            call    invDEBI_hide_mouse_pointer
 00001644  E8 00000196		            call    invDEBI_turn_cursor_off
 00001649  E8 000000EB		            call    invDEBI_save_screen2
 0000164E  9D			            popfd
 0000164F  61			            popad
 00001650  E8 00000E78		            call    invDEBI_menu_refresh
				        .ENDIF
 00001655		   *@C01BA:

 00001655  83 2D 0000B7FD R	        sub     ds:mouse_immediate_count,1
	   01
				        .IF (carry?)
 0000165C  73 0D	   *	    jae    @C01BC
 0000165E  52			            push    edx
 0000165F  8A 15 0000B801 R	            mov     dl,ds:mouse_last_event
 00001665  E8 00000735		            call    invDEBI_check_immediate
 0000166A  5A			            pop     edx
				        .ENDIF
 0000166B		   *@C01BC:

 0000166B  83 2D 0000B7F5 R	        sub     ds:mouse_hovering_count,1
	   01
				        .IF (carry?)
 00001672  73 05	   *	    jae    @C01BE
				          ; We've rolled over (which means our countdown has completed)
 00001674  E8 0000055D		            call    invDEBI_check_hovering
				        .ENDIF
 00001679		   *@C01BE:

 00001679  83 2D 0000B7F9 R	        sub     ds:mouse_clicking_count,1
	   01
				        .IF (carry?)
 00001680  73 05	   *	    jae    @C01C0
				          ; We've rolled over (which means our countdown has completed)
 00001682  E8 000008FB		            call    invDEBI_check_objects_click
				        .ENDIF
 00001687		   *@C01C0:
 00001687  1F			        pop     ds
 00001688  CB			        retf
 00001689			    iDEBI_timer_interface       ENDP
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; END - 11111 - External interfaces (Timer, Mouse, Kbd)
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; 22222 - Screen related functions
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 00001689			    invDEBI_hide_mouse_pointer      PROC
				    ; This routine is used to hide the mouse pointer
				    ;
				    ; Upon entry:   ds:mouse_current_x - current x coord
				    ;               ds:mouse_current_y - current y coord
				    ;
				    ; Upon exit:    The mouse pointer is hidden
				    ;
				        .IF (cs:mouse_status == 1 && cs:mouse_allowed == 1)
 00001689  2E: 83 3D
	   0000B802 R 01   *	    cmp    cs : mouse_status, 001h
 00001691  75 20	   *	    jne    @C01C2
 00001693  2E: 80 3D
	   0000B85A R 01   *	    cmp    cs : mouse_allowed, 001h
 0000169B  75 16	   *	    jne    @C01C2
 0000169D  1E			            push    ds
 0000169E  9C			            pushfd
				;            cli
 0000169F  66| 2E: 8E 1D	            mov     ds,cs:data_segment
	   0000B77F R
				;            push    dword ptr ds:mouse_current_x
				;            sub     dword ptr ss:[esp],1                            ; hot-spot on mouse is at 1,1
				;            push    dword ptr ds:mouse_current_y
				;            sub     dword ptr ss:[esp],1
				;            push    dword ptr 0                                     ; Hide the mouse
				;            push    dword ptr offset mouse_save_area
				;            call    fword ptr ds:_VID_g_mono_mouse_pointer
 000016A7  C7 05 0000B802 R	            mov     ds:mouse_status,0
	   00000000
 000016B1  9D			            popfd
 000016B2  1F			            pop     ds
				        .ENDIF
 000016B3		   *@C01C2:
 000016B3  C3			        ret
 000016B4			    invDEBI_hide_mouse_pointer      ENDP




 000016B4			    invDEBI_show_mouse_pointer      PROC
				    ; This routine is used to display the mouse pointer
				    ;
				    ; Upon entry:   ds:mouse_current_x - current x coord
				    ;               ds:mouse_current_y - current y coord
				    ;
				    ; Upon exit:    The mouse pointer is displayed
				    ;
				        .IF (cs:mouse_status == 0 && cs:mouse_allowed == 1)
 000016B4  2E: 83 3D
	   0000B802 R 00   *	    cmp    cs : mouse_status, 000h
 000016BC  75 20	   *	    jne    @C01C5
 000016BE  2E: 80 3D
	   0000B85A R 01   *	    cmp    cs : mouse_allowed, 001h
 000016C6  75 16	   *	    jne    @C01C5
 000016C8  1E			            push    ds
 000016C9  9C			            pushfd
				;            cli
 000016CA  66| 2E: 8E 1D	            mov     ds,cs:data_segment
	   0000B77F R
				;            push    dword ptr ds:mouse_current_x
				;            sub     dword ptr ss:[esp],1                            ; hot-spot on mouse is at 1,1
				;            push    dword ptr ds:mouse_current_y
				;            sub     dword ptr ss:[esp],1
				;            push    dword ptr 1                                     ; Show the mouse
				;            push    dword ptr offset mouse_save_area
				;            call    fword ptr ds:_VID_g_mono_mouse_pointer
 000016D2  C7 05 0000B802 R	            mov     ds:mouse_status,1
	   00000001
 000016DC  9D			            popfd
 000016DD  1F			            pop     ds
				        .ENDIF
 000016DE		   *@C01C5:
 000016DE  C3			        ret
 000016DF			    invDEBI_show_mouse_pointer      ENDP




 000016DF			    invDEBI_activate_screen_saver       PROC
				    ; This routine is used to activate the screen saver.  It copies the screen buffer to a save area and then clear it off
				    ;
				    ; Upon entry:   ds - DEBI's data segment
				    ;
				    ; Upon exit:    The screen is blanked and the screen_saver variable is set to 1
				    ;
				        .IF (ds:screen_saver == 0)
 000016DF  80 3D 0000B8A3 R
	   00		   *	    cmp    ds : screen_saver, 000h
 000016E6  75 50	   *	    jne    @C01C8
 000016E8  9C			            pushfd
 000016E9  FA			            cli
 000016EA  60			            pushad
 000016EB  1E			            push    ds
 000016EC  06			            push    es

 000016ED  C6 05 0000B8A3 R	            mov     ds:screen_saver,1                               ; Turn on screen saver indicator
	   01
 000016F4  E8 FFFFFF90		            call    invDEBI_hide_mouse_pointer
 000016F9  E8 000000E1		            call    invDEBI_turn_cursor_off
 000016FE  C6 05 0000B85A R	            mov     ds:mouse_allowed,0                              ; Indicate the mouse cannot be drawn
	   00

				          ; Copy the screen to the save buffer
 00001705  B8 000000D0		            mov     eax,_sDEBI_screen                               ; Copy from the MONO screen to the _sDEBI_screen buffer
 0000170A  66| 8E C0		            mov     es,ax
 0000170D  33 FF		            xor     edi,edi
 0000170F  B8 00000030		            mov     eax,_sMONO
 00001714  66| 8E D8		            mov     ds,ax
 00001717  33 F6		            xor     esi,esi
 00001719  B9 00007FFF		            mov     ecx,7fffh                                       ; Copy 32k
 0000171E  FC			            cld
 0000171F  F3/ A4		            rep     movsb
				          ; Clear off the screen
 00001721  B8 00000030		            mov     eax,_sMONO
 00001726  66| 8E C0		            mov     es,ax
 00001729  33 FF		            xor     edi,edi
 0000172B  B0 00		            mov     al,0
 0000172D  B9 00007FFF		            mov     ecx,7fffh
 00001732  F3/ AA		            rep     stosb

 00001734  07			            pop     es
 00001735  1F			            pop     ds
 00001736  61			            popad
 00001737  9D			            popfd
				        .ENDIF
 00001738		   *@C01C8:
 00001738  C3			        ret
 00001739			    invDEBI_activate_screen_saver       ENDP




 00001739			    invDEBI_save_screen2    PROC
				    ; This routine is used to save the current screen contents to a save area during a popup dialogue, menu or other item
				    ;
				    ; Upon entry:   Nothing
				    ;
				    ; Upon exit:    The screen is saved
				    ;
 00001739  60			        pushad
 0000173A  1E			        push    ds
 0000173B  06			        push    es

				      ; Copy the screen to the save buffer
 0000173C  B8 000000F0		        mov     eax,_sDEBI_screen2                                  ; Copy from the MONO screen to the _sDEBI_screen2 buffer
 00001741  66| 8E C0		        mov     es,ax
 00001744  33 FF		        xor     edi,edi
 00001746  B8 00000030		        mov     eax,_sMONO
 0000174B  66| 8E D8		        mov     ds,ax
 0000174E  33 F6		        xor     esi,esi
 00001750  B9 00007FFF		        mov     ecx,7fffh                                           ; Copy 32k
 00001755  FC			        cld
 00001756  F3/ A4		        rep     movsb

 00001758  07			        pop     es
 00001759  1F			        pop     ds
 0000175A  61			        popad
 0000175B  C3			        ret
 0000175C			    invDEBI_save_screen2    ENDP




 0000175C			    invDEBI_restore_screen2     PROC
				    ; This routine is used to save the current screen contents to a save area during a popup dialogue, menu or other item
				    ;
				    ; Upon entry:   Nothing
				    ;
				    ; Upon exit:    The screen is saved
				    ;
 0000175C  60			        pushad
 0000175D  1E			        push    ds
 0000175E  06			        push    es

				      ; Copy the screen to the save buffer
 0000175F  B8 000000F0		        mov     eax,_sDEBI_screen2                                  ; Copy from the _sDEBI_screen buffer to the MONO screen
 00001764  66| 8E D8		        mov     ds,ax
 00001767  33 F6		        xor     esi,esi
 00001769  B8 00000030		        mov     eax,_sMONO
 0000176E  66| 8E C0		        mov     es,ax
 00001771  33 FF		        xor     edi,edi
 00001773  B9 00007FFF		        mov     ecx,7fffh                                           ; Copy 32k
 00001778  FC			        cld
 00001779  F3/ A4		        rep     movsb

 0000177B  07			        pop     es
 0000177C  1F			        pop     ds
 0000177D  61			        popad
 0000177E  C3			        ret
 0000177F			    invDEBI_restore_screen2     ENDP




 0000177F			    invDEBI_toggle_cursor   PROC
				    ; This routine is used to toggle the cursor
				    ;
				    ; Upon entry:   ds - DEBI's data segment
				    ;
				    ; Upon exit:    The cursor may be updated
				    ;
				        .IF (cs:force_cursor_off == 0)
 0000177F  2E: 80 3D
	   0000B8B1 R 00   *	    cmp    cs : force_cursor_off, 000h
 00001787  75 55	   *	    jne    @C01CA
				          ; We need to toggle the cursor
 00001789  1E			            push    ds
 0000178A  60			            pushad
 0000178B  9C			            pushfd
 0000178C  FA			            cli
 0000178D  66| 2E: 8E 1D	            mov     ds,cs:data_segment
	   0000B77F R
 00001795  A1 0000B802 R	            mov     eax,ds:mouse_status
 0000179A  E8 FFFFFEEA		            call    invDEBI_hide_mouse_pointer
 0000179F  FF 35 0000B8A4 R	            push    dword ptr ds:cursor_x
 000017A5  FF 35 0000B8A8 R	            push    dword ptr ds:cursor_y
				            .IF (ds:insert_mode == ON)
 000017AB  83 3D 0000B93C R
	   FF		   *	    cmp    ds : insert_mode, ON
 000017B2  75 08	   *	    jne    @C01CC
 000017B4  FF 1D 0000D103 R	                call    fword ptr ds:_VID_g_mono_cursor
				            .ELSE
 000017BA  EB 06	   *	    jmp    @C01CE
 000017BC		   *@C01CC:
 000017BC  FF 1D 0000D113 R	                call    fword ptr ds:_VID_g_mono_cursor_no_insert
				            .ENDIF
 000017C2		   *@C01CE:
 000017C2  F6 15 0000B8B0 R	            not     ds:cursor
				            .IF (eax != 0)
 000017C8  0B C0	   *	    or	eax, eax
 000017CA  74 05	   *	    je     @C01CF
 000017CC  E8 FFFFFEE3		                call    invDEBI_show_mouse_pointer
				            .ENDIF
 000017D1		   *@C01CF:
 000017D1  C7 05 0000B8AC R	            mov     ds:cursor_count,0
	   00000000
 000017DB  9D			            popfd
 000017DC  61			            popad
 000017DD  1F			            pop     ds
				        .ENDIF
 000017DE		   *@C01CA:
 000017DE  C3			        ret
 000017DF			    invDEBI_toggle_cursor   ENDP




 000017DF			    invDEBI_turn_cursor_off     PROC
				    ; This routine is used to toggle the cursor
				    ;
				    ; Upon entry:   ds - DEBI's data segment
				    ;
				    ; Upon exit:    The cursor may be updated
				    ;
				        .IF (cs:force_cursor_off == 0 && cs:cursor != 0)
 000017DF  2E: 80 3D
	   0000B8B1 R 00   *	    cmp    cs : force_cursor_off, 000h
 000017E7  75 25	   *	    jne    @C01D1
 000017E9  2E: 80 3D
	   0000B8B0 R 00   *	    cmp    cs : cursor, 000h
 000017F1  74 1B	   *	    je     @C01D1
				          ; We need to turn the cursor off
 000017F3  1E			            push    ds
 000017F4  50			            push    eax
 000017F5  66| 2E: 8E 1D	            mov     ds,cs:data_segment
	   0000B77F R
 000017FD  A1 0000B8AC R	            mov     eax,ds:cursor_count
 00001802  E8 FFFFFF78		            call    invDEBI_toggle_cursor
 00001807  A3 0000B8AC R	            mov     ds:cursor_count,eax
 0000180C  58			            pop     eax
 0000180D  1F			            pop     ds
				        .ENDIF
 0000180E		   *@C01D1:
 0000180E  C3			        ret
 0000180F			    invDEBI_turn_cursor_off     ENDP




 0000180F			    invDEBI_turn_cursor_on      PROC
				    ; This routine is used to toggle the cursor
				    ;
				    ; Upon entry:   ds - DEBI's data segment
				    ;
				    ; Upon exit:    The cursor may be updated
				    ;
				        .IF (cs:force_cursor_off == 0 && cs:cursor == 0)
 0000180F  2E: 80 3D
	   0000B8B1 R 00   *	    cmp    cs : force_cursor_off, 000h
 00001817  75 25	   *	    jne    @C01D4
 00001819  2E: 80 3D
	   0000B8B0 R 00   *	    cmp    cs : cursor, 000h
 00001821  75 1B	   *	    jne    @C01D4
				          ; We need to turn the cursor on
 00001823  1E			            push    ds
 00001824  50			            push    eax
 00001825  66| 2E: 8E 1D	            mov     ds,cs:data_segment
	   0000B77F R
 0000182D  A1 0000B8AC R	            mov     eax,ds:cursor_count
 00001832  E8 FFFFFF48		            call    invDEBI_toggle_cursor
 00001837  A3 0000B8AC R	            mov     ds:cursor_count,eax
 0000183C  58			            pop     eax
 0000183D  1F			            pop     ds
				        .ENDIF
 0000183E		   *@C01D4:
 0000183E  C3			        ret
 0000183F			    invDEBI_turn_cursor_on      ENDP




 0000183F			    invDEBI_cancel_screen_saver     PROC
				    ; This routine is used to cancel a previous screen saver.  It restores the screen from the previously saved buffer
				    ;
				    ; Upon entry:   ds - DEBI's data segment
				    ;
				    ; Upon exit:    The screen is blanked and the screen_saver variable is set to 1
				    ;
				        .IF (cs:screen_saver == 1)
 0000183F  2E: 80 3D
	   0000B8A3 R 01   *	    cmp    cs : screen_saver, 001h
 00001847  75 45	   *	    jne    @C01D7
 00001849  9C			            pushfd
 0000184A  60			            pushad
 0000184B  1E			            push    ds
 0000184C  06			            push    es

 0000184D  FA			            cli
 0000184E  66| 2E: 8E 1D	            mov     ds,cs:data_segment
	   0000B77F R
 00001856  C6 05 0000B8A3 R	            mov     ds:screen_saver,0                               ; Turn off screen saver indicator
	   00
 0000185D  C7 05 0000B89F R	            mov     ds:screen_saver_count,0
	   00000000
 00001867  C6 05 0000B85A R	            mov     ds:mouse_allowed,1                              ; Indicate the mouse can once again be drawn
	   01

 0000186E  B8 000000D0		            mov     eax,_sDEBI_screen                               ; Copy from the _sDEBI_screen buffer to the MONO screen
 00001873  66| 8E D8		            mov     ds,ax
 00001876  33 F6		            xor     esi,esi
 00001878  B8 00000030		            mov     eax,_sMONO
 0000187D  66| 8E C0		            mov     es,ax
 00001880  33 FF		            xor     edi,edi
 00001882  B9 00007FFF		            mov     ecx,7fffh                                       ; Copy 32k
 00001887  FC			            cld
 00001888  F3/ A4		            rep     movsb

 0000188A  07			            pop     es
 0000188B  1F			            pop     ds
 0000188C  61			            popad
 0000188D  9D			            popfd
				        .ENDIF
 0000188E		   *@C01D7:
 0000188E  C3			        ret
 0000188F			    invDEBI_cancel_screen_saver     ENDP
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; END - 22222 - Screen related functions
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; 33333 - MOUSE Events
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 0000188F			    invDEBI_mouse_button_activity       PROC
				    ; This routine is used to check for objects the mouse is currently hovering over (without anything being clicked)
				    ;
				    ; Upon entry:   ds:mouse_current_x - current x coord
				    ;               ds:mouse_current_y - current y coord
				    ;            ds:mouse_last_buttons - previous button status
				    ;                              ebx - new button status (from mouse driver)
				    ;                                    * Note:  Bits 2,1,0 are set depending on button status (2-middle, 1-right, 0-left)
				    ;
				    ; Upon exit:    Some items may be deselected or selected for display
				    ;
 0000188F  60			        pushad
				        .IF (ds:mouse_last_button_left == 0)
 00001890  83 3D 0000B80E R
	   00		   *	    cmp    ds : mouse_last_button_left, 000h
 00001897  75 4D	   *	    jne    @C01D9
				          ; The left mouse button was previously UP (not pressed)
 00001899  F7 C3 00000001	            test    ebx,01b
				            .IF (!zero?)
 0000189F  0F 84 00000145  *	    je     @C01DB
				              ; The left button has changed
 000018A5  FF 05 0000B816 R	                inc     ds:mouse_button_left
 000018AB  C7 05 0000B7F9 R	                mov     ds:mouse_clicking_count,-1
	   FFFFFFFF
 000018B5  C7 05 0000B80E R	                mov     ds:mouse_last_button_left,1
	   00000001
 000018BF  8B 15 0000B7E5 R	                mov     edx,ds:mouse_current_x
 000018C5  89 15 0000B82E R	                mov     ds:mouse_left_click_x_start,edx
 000018CB  8B 15 0000B7E9 R	                mov     edx,ds:mouse_current_y
 000018D1  89 15 0000B832 R	                mov     ds:mouse_left_click_y_start,edx
 000018D7  C7 05 0000B7F5 R	                mov     ds:mouse_hovering_count,-1
	   FFFFFFFF
				            .ENDIF
				        .ELSE
 000018E1  E9 00000104	   *	    jmp    @C01DD
 000018E6		   *@C01D9:
				          ; The left mouse button was previously DOWN (pressed)
 000018E6  F7 C3 00000001	            test    ebx,01b
				            .IF (zero?)
 000018EC  75 7A	   *	    jne    @C01DE
				              ; The left buton has changed
 000018EE  F7 C3 00000002	                test    ebx,10b
				                .IF (zero?)
 000018F4  75 1B	   *	    jne    @C01E0
				                  ; The other button isn't down, so we're good to go
 000018F6  C7 05 0000B7F9 R	                    mov     ds:mouse_clicking_count,30
	   0000001E
 00001900  C7 05 0000B7FD R	                    mov     ds:mouse_immediate_count,_IMMEDIATE_COUNT
	   00000002
 0000190A  C6 05 0000B801 R	                    mov     ds:mouse_last_event,_LEFT_SINGLE_CLICK
	   00
				                .ENDIF
 00001911		   *@C01E0:
 00001911  C7 05 0000B80E R	                mov     ds:mouse_last_button_left,0
	   00000000
 0000191B  8B 15 0000B7E5 R	                mov     edx,ds:mouse_current_x
 00001921  89 15 0000B83E R	                mov     ds:mouse_left_click_x_stop,edx
 00001927  8B 15 0000B7E9 R	                mov     edx,ds:mouse_current_y
 0000192D  89 15 0000B842 R	                mov     ds:mouse_left_click_y_stop,edx
				                .IF (ds:mouse_left_dragging != 0)
 00001933  83 3D 0000B81E R
	   00		   *	    cmp    ds : mouse_left_dragging, 000h
 0000193A  0F 84 000000AA  *	    je     @C01E2
 00001940  E8 0000024D		                    call    invDEBI_check_drag_stop
 00001945  C7 05 0000B81E R	                    mov     ds:mouse_left_dragging,0
	   00000000
 0000194F  C7 05 0000B816 R	                    mov     ds:mouse_button_left,0
	   00000000
 00001959  C7 05 0000B7F9 R	                    mov     ds:mouse_clicking_count,-1
	   FFFFFFFF
				                .ENDIF
				            .ELSEIF (ds:mouse_left_dragging == 0)
 00001963  E9 00000082	   *	    jmp    @C01E4
 00001968		   *@C01DE:
 00001968  83 3D 0000B81E R
	   00		   *	    cmp    ds : mouse_left_dragging, 000h
 0000196F  75 4D	   *	    jne    @C01E5
				              ; We need to check to see if the delta-x and delta-y are far enough that something is being dragged
 00001971  F7 C3 00000002	                test    ebx,10b
				                .IF (zero?)
 00001977  75 71	   *	    jne    @C01E7
				                  ; The other button isn't down, so we're good to go
 00001979  8B 15 0000B7E5 R	                    mov     edx,ds:mouse_current_x
 0000197F  2B 15 0000B82E R	                    sub     edx,ds:mouse_left_click_x_start
 00001985  E8 000001C2		                    call    invDEBI_absolute_edx
 0000198A  8B C2		                    mov     eax,edx
 0000198C  8B 15 0000B7E9 R	                    mov     edx,ds:mouse_current_y
 00001992  2B 15 0000B832 R	                    sub     edx,ds:mouse_left_click_y_start
 00001998  E8 000001AF		                    call    invDEBI_absolute_edx
				                    .IF (edx > ds:vertical_dragging_threshold || eax > ds:horizontal_dragging_threshold)
 0000199D  3B 15 0000B852 R *	    cmp    edx, ds : vertical_dragging_threshold
 000019A3  77 08	   *	    ja     @C01EA
 000019A5  3B 05 0000B856 R *	    cmp    eax, ds : horizontal_dragging_threshold
 000019AB  76 0F	   *	    jbe    @C01E9
 000019AD		   *@C01EA:
				                      ; They're dragging
 000019AD  C7 05 0000B81E R	                        mov     ds:mouse_left_dragging,1
	   00000001
 000019B7  E8 0000019B		                        call    invDEBI_check_drag_start
				                    .ENDIF
				                .ENDIF
 000019BC		   *@C01E9:
				            .ELSEIF (ds:mouse_left_dragging != 0)
 000019BC  EB 2C	   *	    jmp    @C01EC
 000019BE		   *@C01E5:
 000019BE  83 3D 0000B81E R
	   00		   *	    cmp    ds : mouse_left_dragging, 000h
 000019C5  74 23	   *	    je     @C01ED
				              ; A button is down, so they're dragging something
 000019C7  C7 05 0000B7ED R	                mov     ds:mouse_hovering_x,-1
	   FFFFFFFF
 000019D1  C7 05 0000B7F1 R	                mov     ds:mouse_hovering_y,-1
	   FFFFFFFF
 000019DB  C7 05 0000B7F5 R	                mov     ds:mouse_hovering_count,-1
	   FFFFFFFF
 000019E5  E8 0000016D		                call    invDEBI_check_drag_start
				            .ENDIF
				        .ENDIF
 000019EA		   *@C01ED:
 000019EA		   *@C01EC:
 000019EA		   *@C01E4:
 000019EA		   *@C01E2:
 000019EA		   *@C01E7:
 000019EA		   *@C01DD:
 000019EA		   *@C01DB:

				        .IF (ds:mouse_last_button_right == 0)
 000019EA  83 3D 0000B812 R
	   00		   *	    cmp    ds : mouse_last_button_right, 000h
 000019F1  75 4D	   *	    jne    @C01EF
				          ; The right mouse button was previously UP
 000019F3  F7 C3 00000002	            test    ebx,10b
				            .IF (!zero?)
 000019F9  0F 84 00000145  *	    je     @C01F1
				              ; The right buton has changed
 000019FF  FF 05 0000B81A R	                inc     ds:mouse_button_right
 00001A05  C7 05 0000B7F9 R	                mov     ds:mouse_clicking_count,-1
	   FFFFFFFF
 00001A0F  C7 05 0000B812 R	                mov     ds:mouse_last_button_right,1
	   00000001
 00001A19  8B 15 0000B7E5 R	                mov     edx,ds:mouse_current_x
 00001A1F  89 15 0000B826 R	                mov     ds:mouse_right_click_x_start,edx
 00001A25  8B 15 0000B7E9 R	                mov     edx,ds:mouse_current_y
 00001A2B  89 15 0000B82A R	                mov     ds:mouse_right_click_y_start,edx
 00001A31  C7 05 0000B7F5 R	                mov     ds:mouse_hovering_count,-1
	   FFFFFFFF
				            .ENDIF
				        .ELSE
 00001A3B  E9 00000104	   *	    jmp    @C01F3
 00001A40		   *@C01EF:
				          ; The right mouse button was previously DOWN
 00001A40  F7 C3 00000002	            test    ebx,10b
				            .IF (zero?)
 00001A46  75 7A	   *	    jne    @C01F4
				              ; The right buton has changed
 00001A48  F7 C3 00000001	                test    ebx,01b
				                .IF (zero?)
 00001A4E  75 1B	   *	    jne    @C01F6
				                  ; The other button isn't down, so we're good to go
 00001A50  C7 05 0000B7F9 R	                    mov     ds:mouse_clicking_count,30
	   0000001E
 00001A5A  C7 05 0000B7FD R	                    mov     ds:mouse_immediate_count,_IMMEDIATE_COUNT
	   00000002
 00001A64  C6 05 0000B801 R	                    mov     ds:mouse_last_event,_RIGHT_SINGLE_CLICK
	   04
				                .ENDIF
 00001A6B		   *@C01F6:
 00001A6B  C7 05 0000B812 R	                mov     ds:mouse_last_button_right,0
	   00000000
 00001A75  8B 15 0000B7E5 R	                mov     edx,ds:mouse_current_x
 00001A7B  89 15 0000B836 R	                mov     ds:mouse_right_click_x_stop,edx
 00001A81  8B 15 0000B7E9 R	                mov     edx,ds:mouse_current_y
 00001A87  89 15 0000B83A R	                mov     ds:mouse_right_click_y_stop,edx
				                .IF (ds:mouse_right_dragging != 0)
 00001A8D  83 3D 0000B822 R
	   00		   *	    cmp    ds : mouse_right_dragging, 000h
 00001A94  0F 84 000000AA  *	    je     @C01F8
 00001A9A  E8 000000F3		                    call    invDEBI_check_drag_stop
 00001A9F  C7 05 0000B822 R	                    mov     ds:mouse_right_dragging,0
	   00000000
 00001AA9  C7 05 0000B81A R	                    mov     ds:mouse_button_right,0
	   00000000
 00001AB3  C7 05 0000B7F9 R	                    mov     ds:mouse_clicking_count,-1
	   FFFFFFFF
				                .ENDIF
				            .ELSEIF (ds:mouse_right_dragging == 0)
 00001ABD  E9 00000082	   *	    jmp    @C01FA
 00001AC2		   *@C01F4:
 00001AC2  83 3D 0000B822 R
	   00		   *	    cmp    ds : mouse_right_dragging, 000h
 00001AC9  75 4D	   *	    jne    @C01FB
				              ; We need to check to see if the delta-x and delta-y are far enough that something is being dragged
 00001ACB  F7 C3 00000001	                test    ebx,01b
				                .IF (zero?)
 00001AD1  75 71	   *	    jne    @C01FD
				                  ; The other button isn't down, so we're good to go
 00001AD3  8B 15 0000B7E5 R	                    mov     edx,ds:mouse_current_x
 00001AD9  2B 15 0000B826 R	                    sub     edx,ds:mouse_right_click_x_start
 00001ADF  E8 00000068		                    call    invDEBI_absolute_edx
 00001AE4  8B C2		                    mov     eax,edx
 00001AE6  8B 15 0000B7E9 R	                    mov     edx,ds:mouse_current_y
 00001AEC  2B 15 0000B82A R	                    sub     edx,ds:mouse_right_click_y_start
 00001AF2  E8 00000055		                    call    invDEBI_absolute_edx
				                    .IF (edx > ds:vertical_dragging_threshold || eax > ds:horizontal_dragging_threshold)
 00001AF7  3B 15 0000B852 R *	    cmp    edx, ds : vertical_dragging_threshold
 00001AFD  77 08	   *	    ja     @C0200
 00001AFF  3B 05 0000B856 R *	    cmp    eax, ds : horizontal_dragging_threshold
 00001B05  76 0F	   *	    jbe    @C01FF
 00001B07		   *@C0200:
				                      ; They're dragging
 00001B07  C7 05 0000B822 R	                        mov     ds:mouse_right_dragging,1
	   00000001
 00001B11  E8 00000041		                        call    invDEBI_check_drag_start
				                    .ENDIF
				                .ENDIF
 00001B16		   *@C01FF:
				            .ELSEIF (ds:mouse_right_dragging != 0)
 00001B16  EB 2C	   *	    jmp    @C0202
 00001B18		   *@C01FB:
 00001B18  83 3D 0000B822 R
	   00		   *	    cmp    ds : mouse_right_dragging, 000h
 00001B1F  74 23	   *	    je     @C0203
				              ; A button is down, so they're dragging something
 00001B21  C7 05 0000B7ED R	                mov     ds:mouse_hovering_x,-1
	   FFFFFFFF
 00001B2B  C7 05 0000B7F1 R	                mov     ds:mouse_hovering_y,-1
	   FFFFFFFF
 00001B35  C7 05 0000B7F5 R	                mov     ds:mouse_hovering_count,-1
	   FFFFFFFF
 00001B3F  E8 00000013		                call    invDEBI_check_drag_start
				            .ENDIF
				        .ENDIF
 00001B44		   *@C0203:
 00001B44		   *@C0202:
 00001B44		   *@C01FA:
 00001B44		   *@C01F8:
 00001B44		   *@C01FD:
 00001B44		   *@C01F3:
 00001B44		   *@C01F1:
 00001B44  89 1D 0000B80A R	        mov     ds:mouse_last_buttons,ebx

 00001B4A			      quit:
 00001B4A  61			        popad
 00001B4B  C3			        ret
 00001B4C			    invDEBI_mouse_button_activity       ENDP




 00001B4C			    invDEBI_absolute_edx        PROC
				    ; This routine is used to compute the absolute value of the value in edx
				    ;
				    ; Upon entry:   edx - value to compute absolute value
				    ;
				    ; Upon exit:    edx - abs(edx)
				    ;
				        .IF (edx > 7fffffffh)
 00001B4C  81 FA 7FFFFFFF  *	    cmp    edx, 07FFFFFFFh
 00001B52  76 02	   *	    jbe    @C0205
				          ; It's negative
 00001B54  F7 DA		            neg     edx
				        .ENDIF
 00001B56		   *@C0205:
 00001B56  C3			        ret
 00001B57			    invDEBI_absolute_edx        ENDP




 00001B57			    invDEBI_check_drag_start        PROC
				    ; This routine is used to check to see what object they're trying to drag
				    ;
				    ; Upon enry:    ds:mouse_current_x - current mouse X coordinate
				    ;               ds:mouse_current_y - current mouse Y coordinate
				    ;               ds:mouse_right_click_x_start - starting mouse X coordinate if right dragging
				    ;               ds:mouse_right_click_y_start - starting mouse Y coordinate if right dragging
				    ;               ds:mouse_left_click_x_start - starting mouse X coordinate if left dragging
				    ;               ds:mouse_left_click_y_start - starting mouse Y coordinate if left dragging
				    ;
				    ; Upon exit:    If dragging some object, it is currently underway
				    ;
				        .IF (ds:mouse_left_dragging == 1)
 00001B57  83 3D 0000B81E R
	   01		   *	    cmp    ds : mouse_left_dragging, 001h
 00001B5E  75 14	   *	    jne    @C0207
 00001B60  FF 05 0000B81E R	            inc     ds:mouse_left_dragging
 00001B66  C6 05 0000B801 R	            mov     ds:mouse_last_event,_LEFT_DRAG_START
	   02
 00001B6D  B2 02		            mov     dl,_LEFT_DRAG_START
 00001B6F  E8 00000112		            call    invDEBI_check_mouse_event
				        .ENDIF
 00001B74		   *@C0207:
				        .IF (ds:mouse_right_dragging == 1)
 00001B74  83 3D 0000B822 R
	   01		   *	    cmp    ds : mouse_right_dragging, 001h
 00001B7B  75 14	   *	    jne    @C0209
 00001B7D  FF 05 0000B822 R	            inc     ds:mouse_right_dragging
 00001B83  C6 05 0000B801 R	            mov     ds:mouse_last_event,_RIGHT_DRAG_START
	   06
 00001B8A  B2 06		            mov     dl,_RIGHT_DRAG_START
 00001B8C  E8 000000F5		            call    invDEBI_check_mouse_event
				        .ENDIF
 00001B91		   *@C0209:

 00001B91  C3			        ret
 00001B92			    invDEBI_check_drag_start        ENDP




 00001B92			    invDEBI_check_drag_stop     PROC
				    ; This routine is called when an object being dragged is released
				    ;
				    ; Upon entry:
				    ;
				    ; Upon exit:    The object is released
				    ;
				        .IF (ds:mouse_left_dragging != 0)
 00001B92  83 3D 0000B81E R
	   00		   *	    cmp    ds : mouse_left_dragging, 000h
 00001B99  74 0E	   *	    je     @C020B
 00001B9B  C6 05 0000B801 R	            mov     ds:mouse_last_event,_LEFT_DRAG_STOP
	   03
 00001BA2  B2 03		            mov     dl,_LEFT_DRAG_STOP
 00001BA4  E8 000000DD		            call    invDEBI_check_mouse_event
				        .ENDIF
 00001BA9		   *@C020B:
				        .IF (ds:mouse_right_dragging != 0)
 00001BA9  83 3D 0000B822 R
	   00		   *	    cmp    ds : mouse_right_dragging, 000h
 00001BB0  74 0E	   *	    je     @C020D
 00001BB2  C6 05 0000B801 R	            mov     ds:mouse_last_event,_RIGHT_DRAG_STOP
	   07
 00001BB9  B2 07		            mov     dl,_RIGHT_DRAG_STOP
 00001BBB  E8 000000C6		            call    invDEBI_check_mouse_event
				        .ENDIF
 00001BC0		   *@C020D:
				        .IF (ds:dragging_something != 0)
 00001BC0  83 3D 0000B7A9 R
	   00		   *	    cmp    ds : dragging_something, 000h
 00001BC7  74 05	   *	    je     @C020F
				          ; No event was at the release point, so we just call the default handler to cancel the drag
 00001BC9  E8 000024F7		            call    invDEBI_drag_stop
				        .ENDIF
 00001BCE		   *@C020F:
 00001BCE  C6 05 0000B801 R	        mov     ds:mouse_last_event,_HOVER
	   0A

 00001BD5  C3			        ret
 00001BD6			    invDEBI_check_drag_stop     ENDP




 00001BD6			    invDEBI_check_hovering      PROC
				    ; This routine is used to check for objects the mouse is currently hovering over (without anything being clicked)
				    ;
				    ; Upon entry:   ds:mouse_hovering_x - current x coord
				    ;               ds:mouse_hovering_y - current y coord
				    ;
				    ; Upon exit:    The quick watch window may be updated
				    ;
 00001BD6  60			        pushad

				        .IF (ds:object_mode == 0)
 00001BD7  83 3D 0000B788 R
	   00		   *	    cmp    ds : object_mode, 000h
 00001BDE  75 5D	   *	    jne    @C0211
				          ; We're in root object mode (meaning they're the default Debi objects, not a pop-up or dialogue box)
 00001BE0  BE 00005682 R	            mov     esi,offset DEBI_screen_table_end - _ST_LENGTH
 00001BE5  33 C9		            xor     ecx,ecx
				            .WHILE (ecx < 15)
 00001BE7  EB 4D	   *	    jmp    @C0213
 00001BE9		   *@C0214:
				                .IF (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _YES)
 00001BE9  80 7E 01 01	   *	    cmp    byte ptr ds : [esi + _ST_OBJECT_ACTIVE], _YES
 00001BED  75 43	   *	    jne    @C0215
 00001BEF  8B 7E 18		                    mov     edi,dword ptr ds:[esi+_ST_OBJECT_MOUSE_OFFSET]
				                    .IF (edi != -1)
 00001BF2  83 FF FF	   *	    cmp    edi, - 001h
 00001BF5  74 3B	   *	    je     @C0217
				                        .WHILE (byte ptr ds:[edi] != _END)
 00001BF7  EB 34	   *	    jmp    @C0219
 00001BF9		   *@C021A:
 00001BF9  8A 07		                            mov     al,byte ptr ds:[edi]
				                            .IF (al == _ABANDON_IF_NOT)
 00001BFB  3C 0C	   *	    cmp    al, _ABANDON_IF_NOT
 00001BFD  75 09	   *	    jne    @C021B
				                              ; We are to abandon this item if the mouse isn't within its data area
 00001BFF  E8 00000243		                                call    invDEBI_check_mouse_object_coordinate
 00001C04  72 2C		                                jc      next_screen_object
				                            .ELSEIF (al == _HOVER)
 00001C06  EB 22	   *	    jmp    @C021D
 00001C08		   *@C021B:
 00001C08  3C 0A	   *	    cmp    al, _HOVER
 00001C0A  75 1E	   *	    jne    @C021E
				                              ; This is a hover item, we need to check the coordinates to see if it's the one!
 00001C0C  E8 00000236		                                call    invDEBI_check_mouse_object_coordinate
 00001C11  72 17		                                jc      next_mouse_object1

				                              ; This is a match
 00001C13  8B 5F 11		                                mov     ebx,dword ptr ds:[edi+_MO_FUNC]
 00001C16  60			                                pushad
 00001C17  9C			                                pushfd
 00001C18  1E			                                push    ds
 00001C19  06			                                push    es
 00001C1A  0F A0		                                push    fs
 00001C1C  0F A8		                                push    gs

 00001C1E  FF D3		                                call    ebx

 00001C20  0F A9		                                pop     gs
 00001C22  0F A1		                                pop     fs
 00001C24  07			                                pop     es
 00001C25  1F			                                pop     ds
 00001C26  9D			                                popfd
 00001C27  61			                                popad
 00001C28  72 5A		                                jc      quit
				                            .ENDIF

 00001C2A			                          next_mouse_object1:
 00001C2A		   *@C021E:
 00001C2A		   *@C021D:
 00001C2A  83 C7 1C		                            add     edi,_MO_LENGTH
				                        .ENDW
 00001C2D		   *@C0219:
 00001C2D  80 3F FF	   *	    cmp    byte ptr ds : [edi], _END
 00001C30  75 C7	   *	    jne    @C021A
				                    .ENDIF
				                .ENDIF
 00001C32		   *@C0217:

 00001C32			              next_screen_object:
 00001C32		   *@C0215:
 00001C32  83 EE 20		                sub     esi,_ST_LENGTH
 00001C35  41			                inc     ecx
				            .ENDW
 00001C36		   *@C0213:
 00001C36  83 F9 0F	   *	    cmp    ecx, 00Fh
 00001C39  72 AE	   *	    jb     @C0214
				        .ELSE
 00001C3B  EB 47	   *	    jmp    @C0222
 00001C3D		   *@C0211:
				          ; We're currently on one of the pop-up objects
 00001C3D  8B 3D 0000B798 R	            mov     edi,ds:mouse_objects
 00001C43  8B 35 0000B79C R	            mov     esi,ds:screen_object
				            .WHILE (byte ptr ds:[edi] != _END)
 00001C49  EB 34	   *	    jmp    @C0223
 00001C4B		   *@C0224:
 00001C4B  8A 07		                mov     al,byte ptr ds:[edi]
				                .IF (al == _ABANDON_IF_NOT)
 00001C4D  3C 0C	   *	    cmp    al, _ABANDON_IF_NOT
 00001C4F  75 09	   *	    jne    @C0225
				                  ; We are to abandon this item if the mouse isn't within its data area
 00001C51  E8 000001F1		                    call    invDEBI_check_mouse_object_coordinate
 00001C56  72 2C		                    jc      quit
				                .ELSEIF (al == _HOVER)
 00001C58  EB 22	   *	    jmp    @C0227
 00001C5A		   *@C0225:
 00001C5A  3C 0A	   *	    cmp    al, _HOVER
 00001C5C  75 1E	   *	    jne    @C0228
				                  ; This is the correct thing, we need to check the coordinates to see if it's the one!
 00001C5E  E8 000001E4		                    call    invDEBI_check_mouse_object_coordinate
 00001C63  72 17		                    jc      next_mouse_object2

				                  ; This is a match
 00001C65  8B 5F 11		                    mov     ebx,dword ptr ds:[edi+_MO_FUNC]
 00001C68  60			                    pushad
 00001C69  9C			                    pushfd
 00001C6A  1E			                    push    ds
 00001C6B  06			                    push    es
 00001C6C  0F A0		                    push    fs
 00001C6E  0F A8		                    push    gs

 00001C70  FF D3		                    call    ebx

 00001C72  0F A9		                    pop     gs
 00001C74  0F A1		                    pop     fs
 00001C76  07			                    pop     es
 00001C77  1F			                    pop     ds
 00001C78  9D			                    popfd
 00001C79  61			                    popad
 00001C7A  72 08		                    jc      quit
				                .ENDIF

 00001C7C			              next_mouse_object2:
 00001C7C		   *@C0228:
 00001C7C		   *@C0227:
 00001C7C  83 C7 1C		                add     edi,_MO_LENGTH
				            .ENDW
 00001C7F		   *@C0223:
 00001C7F  80 3F FF	   *	    cmp    byte ptr ds : [edi], _END
 00001C82  75 C7	   *	    jne    @C0224
				        .ENDIF
 00001C84		   *@C0222:

 00001C84			      quit:
 00001C84  61			        popad
 00001C85  C3			        ret
 00001C86			    invDEBI_check_hovering      ENDP




 00001C86			    invDEBI_check_mouse_event       PROC
				    ; This routine is used to check for objects the mouse has done something on/near
				    ;
				    ; Upon entry:   ds:mouse_current_x - current x coord
				    ;               ds:mouse_current_y - current y coord
				    ;                               dl - mouse activity to search for
				    ;
				    ; Upon exit:    The quick watch window may be updated
				    ;
 00001C86  60			        pushad

				        .IF (ds:object_mode == 0)
 00001C87  83 3D 0000B788 R
	   00		   *	    cmp    ds : object_mode, 000h
 00001C8E  0F 85 000000A8  *	    jne    @C022B
				          ; We're in root object mode (meaning they're the default Debi objects, not a pop-up or dialogue box)
 00001C94  BE 00005682 R	            mov     esi,offset DEBI_screen_table_end - _ST_LENGTH
 00001C99  33 C9		            xor     ecx,ecx
				            .WHILE (ecx < 15)
 00001C9B  E9 00000091	   *	    jmp    @C022D
 00001CA0		   *@C022E:
				                .IF (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _YES)
 00001CA0  80 7E 01 01	   *	    cmp    byte ptr ds : [esi + _ST_OBJECT_ACTIVE], _YES
 00001CA4  0F 85 00000083  *	    jne    @C022F
 00001CAA  8B 7E 18		                    mov     edi,dword ptr ds:[esi+_ST_OBJECT_MOUSE_OFFSET]
				                    .IF (edi != -1)
 00001CAD  83 FF FF	   *	    cmp    edi, - 001h
 00001CB0  74 7B	   *	    je     @C0231
				                        .WHILE (byte ptr ds:[edi] != _END)
 00001CB2  EB 74	   *	    jmp    @C0233
 00001CB4		   *@C0234:
 00001CB4  8A 07		                            mov     al,byte ptr ds:[edi]
				                            .IF (al == _ABANDON_IF_NOT)
 00001CB6  3C 0C	   *	    cmp    al, _ABANDON_IF_NOT
 00001CB8  75 09	   *	    jne    @C0235
				                              ; We are to abandon this item if the mouse isn't within its data area
 00001CBA  E8 00000188		                                call    invDEBI_check_mouse_object_coordinate
 00001CBF  72 6C		                                jc      next_screen_object

				                            .ELSEIF (al == dl || al == _ANY_CLICK)
 00001CC1  EB 62	   *	    jmp    @C0237
 00001CC3		   *@C0235:
 00001CC3  38 D0	   *	    cmp    al, dl
 00001CC5  74 04	   *	    je     @C0239
 00001CC7  3C 0D	   *	    cmp    al, _ANY_CLICK
 00001CC9  75 46	   *	    jne    @C0238
 00001CCB		   *@C0239:
				                              ; This is the correct thing, we need to check the coordinates to see if it's the one!
				                                .IF (dl == _LEFT_DRAG_START || dl == _RIGHT_DRAG_START)
 00001CCB  80 FA 02	   *	    cmp    dl, _LEFT_DRAG_START
 00001CCE  74 05	   *	    je     @C023C
 00001CD0  80 FA 06	   *	    cmp    dl, _RIGHT_DRAG_START
 00001CD3  75 07	   *	    jne    @C023B
 00001CD5		   *@C023C:
 00001CD5  E8 000001AC		                                    call    invDEBI_check_mouse_object_coordinate_drag_start
				                                .ELSEIF (dl == _LEFT_DRAG_STOP || dl == _RIGHT_DRAG_STOP)
 00001CDA  EB 16	   *	    jmp    @C023E
 00001CDC		   *@C023B:
 00001CDC  80 FA 03	   *	    cmp    dl, _LEFT_DRAG_STOP
 00001CDF  74 05	   *	    je     @C0240
 00001CE1  80 FA 07	   *	    cmp    dl, _RIGHT_DRAG_STOP
 00001CE4  75 07	   *	    jne    @C023F
 00001CE6		   *@C0240:
 00001CE6  E8 00000219		                                    call    invDEBI_check_mouse_object_coordinate_drag_stop
				                                .ELSE
 00001CEB  EB 05	   *	    jmp    @C0242
 00001CED		   *@C023F:
 00001CED  E8 00000155		                                    call    invDEBI_check_mouse_object_coordinate
				                                .ENDIF
 00001CF2		   *@C0242:
 00001CF2		   *@C023E:
 00001CF2  72 31		                                jc      next_mouse_object1

				                              ; This is a match
 00001CF4  8B 5F 11		                                mov     ebx,dword ptr ds:[edi+_MO_FUNC]
 00001CF7  60			                                pushad
 00001CF8  9C			                                pushfd
 00001CF9  1E			                                push    ds
 00001CFA  06			                                push    es
 00001CFB  0F A0		                                push    fs
 00001CFD  0F A8		                                push    gs

 00001CFF  FF D3		                                call    ebx

 00001D01  0F A9		                                pop     gs
 00001D03  0F A1		                                pop     fs
 00001D05  07			                                pop     es
 00001D06  1F			                                pop     ds
 00001D07  9D			                                popfd
 00001D08  61			                                popad
 00001D09  0F 82 0000008E	                                jc      quit

				                            .ELSEIF (dl == _LEFT_SINGLE_CLICK && al == _EDIT)
 00001D0F  EB 14	   *	    jmp    @C0243
 00001D11		   *@C0238:
 00001D11  0A D2	   *	    or	dl, dl
 00001D13  75 10	   *	    jne    @C0244
 00001D15  3C 0B	   *	    cmp    al, _EDIT
 00001D17  75 0C	   *	    jne    @C0244
				                              ; This is an edit item, they might be wanting to edit something possibly?
 00001D19  E8 00000129		                                call    invDEBI_check_mouse_object_coordinate
 00001D1E  72 05		                                jc      next_mouse_object1

				                              ; This is a match
 00001D20  E8 0000353A		                                call    invDEBI_edit_variable
				                            .ENDIF

 00001D25			                          next_mouse_object1:
 00001D25		   *@C0244:
 00001D25		   *@C0243:
 00001D25		   *@C0237:
 00001D25  83 C7 1C		                            add     edi,_MO_LENGTH
				                        .ENDW
 00001D28		   *@C0233:
 00001D28  80 3F FF	   *	    cmp    byte ptr ds : [edi], _END
 00001D2B  75 87	   *	    jne    @C0234
				                    .ENDIF
				                .ENDIF
 00001D2D		   *@C0231:

 00001D2D			              next_screen_object:
 00001D2D		   *@C022F:
 00001D2D  83 EE 20		                sub     esi,_ST_LENGTH
 00001D30  41			                inc     ecx
				            .ENDW
 00001D31		   *@C022D:
 00001D31  83 F9 0F	   *	    cmp    ecx, 00Fh
 00001D34  0F 82 FFFFFF66  *	    jb     @C022E
				        .ELSE
 00001D3A  EB 61	   *	    jmp    @C0249
 00001D3C		   *@C022B:
				          ; We're currently on one of the pop-up objects
 00001D3C  8B 3D 0000B798 R	            mov     edi,ds:mouse_objects
 00001D42  8B 35 0000B79C R	            mov     esi,ds:screen_object
				            .WHILE (byte ptr ds:[edi] != _END)
 00001D48  EB 4E	   *	    jmp    @C024A
 00001D4A		   *@C024B:
 00001D4A  8A 07		                mov     al,byte ptr ds:[edi]
				                .IF (al == _ABANDON_IF_NOT)
 00001D4C  3C 0C	   *	    cmp    al, _ABANDON_IF_NOT
 00001D4E  75 09	   *	    jne    @C024C
				                  ; We are to abandon this item if the mouse isn't within its data area
 00001D50  E8 000000F2		                    call    invDEBI_check_mouse_object_coordinate
 00001D55  72 46		                    jc      quit

				                .ELSEIF (al == dl || al == _ANY_CLICK)
 00001D57  EB 3C	   *	    jmp    @C024E
 00001D59		   *@C024C:
 00001D59  38 D0	   *	    cmp    al, dl
 00001D5B  74 04	   *	    je     @C0250
 00001D5D  3C 0D	   *	    cmp    al, _ANY_CLICK
 00001D5F  75 20	   *	    jne    @C024F
 00001D61		   *@C0250:
				                  ; This is the correct thing, we need to check the coordinates to see if it's the one!
 00001D61  E8 000000E1		                    call    invDEBI_check_mouse_object_coordinate
 00001D66  72 2D		                    jc      next_mouse_object2                      ; If branch, the mouse isn't over this item

				                  ; This is a match
 00001D68  8B 5F 11		                    mov     ebx,dword ptr ds:[edi+_MO_FUNC]
 00001D6B  60			                    pushad
 00001D6C  9C			                    pushfd
 00001D6D  1E			                    push    ds
 00001D6E  06			                    push    es
 00001D6F  0F A0		                    push    fs
 00001D71  0F A8		                    push    gs

 00001D73  FF D3		                    call    ebx

 00001D75  0F A9		                    pop     gs
 00001D77  0F A1		                    pop     fs
 00001D79  07			                    pop     es
 00001D7A  1F			                    pop     ds
 00001D7B  9D			                    popfd
 00001D7C  61			                    popad
 00001D7D  72 1E		                    jc      quit

				                .ELSEIF (dl == _LEFT_SINGLE_CLICK && al == _EDIT)
 00001D7F  EB 14	   *	    jmp    @C0252
 00001D81		   *@C024F:
 00001D81  0A D2	   *	    or	dl, dl
 00001D83  75 10	   *	    jne    @C0253
 00001D85  3C 0B	   *	    cmp    al, _EDIT
 00001D87  75 0C	   *	    jne    @C0253
				                  ; This is an edit item, they might be wanting to edit something possibly?
 00001D89  E8 000000B9		                    call    invDEBI_check_mouse_object_coordinate
 00001D8E  72 05		                    jc      next_mouse_object2

				                  ; This is a match
 00001D90  E8 000034CA		                    call    invDEBI_edit_variable
				                .ENDIF

 00001D95			              next_mouse_object2:
 00001D95		   *@C0253:
 00001D95		   *@C0252:
 00001D95		   *@C024E:
 00001D95  83 C7 1C		                add     edi,_MO_LENGTH
				            .ENDW
 00001D98		   *@C024A:
 00001D98  80 3F FF	   *	    cmp    byte ptr ds : [edi], _END
 00001D9B  75 AD	   *	    jne    @C024B
				        .ENDIF
 00001D9D		   *@C0249:

 00001D9D			      quit:
 00001D9D  61			        popad
 00001D9E  C3			        ret
 00001D9F			    invDEBI_check_mouse_event       ENDP




 00001D9F			    invDEBI_check_immediate     PROC
				    ; This routine is used to check for objects the mouse has done something on/near
				    ;
				    ; Upon entry:   ds:mouse_current_x - current x coord
				    ;               ds:mouse_current_y - current y coord
				    ;                               dl - mouse activity to search for
				    ;
				    ; Upon exit:    The quick watch window may be updated
				    ;
 00001D9F  60			        pushad

				        .IF (ds:object_mode == 0)
 00001DA0  83 3D 0000B788 R
	   00		   *	    cmp    ds : object_mode, 000h
 00001DA7  75 59	   *	    jne    @C0257
				          ; We're in root object mode (meaning they're the default Debi objects, not a pop-up or dialogue box)
 00001DA9  BE 00005682 R	            mov     esi,offset DEBI_screen_table_end - _ST_LENGTH
 00001DAE  33 C9		            xor     ecx,ecx
				            .WHILE (ecx < 15)
 00001DB0  EB 49	   *	    jmp    @C0259
 00001DB2		   *@C025A:
				                .IF (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _YES)
 00001DB2  80 7E 01 01	   *	    cmp    byte ptr ds : [esi + _ST_OBJECT_ACTIVE], _YES
 00001DB6  75 3F	   *	    jne    @C025B
 00001DB8  8B 7E 18		                    mov     edi,dword ptr ds:[esi+_ST_OBJECT_MOUSE_OFFSET]
				                    .IF (edi != -1)
 00001DBB  83 FF FF	   *	    cmp    edi, - 001h
 00001DBE  74 37	   *	    je     @C025D
				                        .WHILE (byte ptr ds:[edi] != _END)
 00001DC0  EB 30	   *	    jmp    @C025F
 00001DC2		   *@C0260:
 00001DC2  8A 07		                            mov     al,byte ptr ds:[edi]
				                            .IF (al == _IMMEDIATE)
 00001DC4  3C 0E	   *	    cmp    al, _IMMEDIATE
 00001DC6  75 25	   *	    jne    @C0261
				                              ; We know now that there are immediates, so we will setup the count for continued use
				                                .IF (byte ptr ds:[edi+_MO_TYPE] == dl)
 00001DC8  38 57 1B	   *	    cmp    byte ptr ds : [edi + _MO_TYPE], dl
 00001DCB  75 22	   *	    jne    @C0263
				                                  ; This is the correct thing, we need to check the coordinates to see if it's the one!
 00001DCD  E8 00000075		                                    call    invDEBI_check_mouse_object_coordinate
 00001DD2  72 1B		                                    jc      next_mouse_object1

				                                  ; This is a match
 00001DD4  8B 5F 11		                                    mov     ebx,dword ptr ds:[edi+_MO_FUNC]
 00001DD7  60			                                    pushad
 00001DD8  9C			                                    pushfd
 00001DD9  1E			                                    push    ds
 00001DDA  06			                                    push    es
 00001DDB  0F A0		                                    push    fs
 00001DDD  0F A8		                                    push    gs

 00001DDF  FF D3		                                    call    ebx

 00001DE1  0F A9		                                    pop     gs
 00001DE3  0F A1		                                    pop     fs
 00001DE5  07			                                    pop     es
 00001DE6  1F			                                    pop     ds
 00001DE7  9D			                                    popfd
 00001DE8  61			                                    popad
 00001DE9  72 5A		                                    jc      quit
				                                .ENDIF
				                            .ELSE
 00001DEB  EB 02	   *	    jmp    @C0265
 00001DED		   *@C0261:
 00001DED  EB 08		                                jmp     next_screen_object
				                            .ENDIF

 00001DEF			                          next_mouse_object1:
 00001DEF		   *@C0265:
 00001DEF		   *@C0263:
 00001DEF  83 C7 1C		                            add     edi,_MO_LENGTH
				                        .ENDW
 00001DF2		   *@C025F:
 00001DF2  80 3F FF	   *	    cmp    byte ptr ds : [edi], _END
 00001DF5  75 CB	   *	    jne    @C0260
				                    .ENDIF
				                .ENDIF
 00001DF7		   *@C025D:

 00001DF7			              next_screen_object:
 00001DF7		   *@C025B:
 00001DF7  83 EE 20		                sub     esi,_ST_LENGTH
 00001DFA  41			                inc     ecx
				            .ENDW
 00001DFB		   *@C0259:
 00001DFB  83 F9 0F	   *	    cmp    ecx, 00Fh
 00001DFE  72 B2	   *	    jb     @C025A
				        .ELSE
 00001E00  EB 43	   *	    jmp    @C0268
 00001E02		   *@C0257:
				          ; We're currently on one of the pop-up objects
 00001E02  8B 3D 0000B798 R	            mov     edi,ds:mouse_objects
 00001E08  8B 35 0000B79C R	            mov     esi,ds:screen_object
				            .WHILE (byte ptr ds:[edi] != _END)
 00001E0E  EB 30	   *	    jmp    @C0269
 00001E10		   *@C026A:
 00001E10  8A 07		                mov     al,byte ptr ds:[edi]
				                .IF (al == _IMMEDIATE)
 00001E12  3C 0E	   *	    cmp    al, _IMMEDIATE
 00001E14  75 25	   *	    jne    @C026B
				                  ; We know now that there are immediates, so we will setup the count for continued use
				                    .IF (byte ptr ds:[edi+_MO_TYPE] == dl)
 00001E16  38 57 1B	   *	    cmp    byte ptr ds : [edi + _MO_TYPE], dl
 00001E19  75 22	   *	    jne    @C026D
				                      ; This is the correct thing, we need to check the coordinates to see if it's the one!
 00001E1B  E8 00000027		                        call    invDEBI_check_mouse_object_coordinate
 00001E20  72 1B		                        jc      next_mouse_object2

				                      ; This is a match
 00001E22  8B 5F 11		                        mov     ebx,dword ptr ds:[edi+_MO_FUNC]
 00001E25  60			                        pushad
 00001E26  9C			                        pushfd
 00001E27  1E			                        push    ds
 00001E28  06			                        push    es
 00001E29  0F A0		                        push    fs
 00001E2B  0F A8		                        push    gs

 00001E2D  FF D3		                        call    ebx

 00001E2F  0F A9		                        pop     gs
 00001E31  0F A1		                        pop     fs
 00001E33  07			                        pop     es
 00001E34  1F			                        pop     ds
 00001E35  9D			                        popfd
 00001E36  61			                        popad
 00001E37  72 0C		                        jc      quit
				                    .ENDIF
				                .ELSE
 00001E39  EB 02	   *	    jmp    @C026F
 00001E3B		   *@C026B:
 00001E3B  EB 08		                    jmp     quit
				                .ENDIF

 00001E3D			              next_mouse_object2:
 00001E3D		   *@C026F:
 00001E3D		   *@C026D:
 00001E3D  83 C7 1C		                add     edi,_MO_LENGTH
				            .ENDW
 00001E40		   *@C0269:
 00001E40  80 3F FF	   *	    cmp    byte ptr ds : [edi], _END
 00001E43  75 CB	   *	    jne    @C026A
				        .ENDIF
 00001E45		   *@C0268:

 00001E45			      quit:
 00001E45  61			        popad
 00001E46  C3			        ret
 00001E47			    invDEBI_check_immediate     ENDP




 00001E47			    invDEBI_check_mouse_object_coordinate       PROC
				    ; This routine is used to check the current mouse coordinate against the screen object coordinate plus the mouse object
				    ; relative displacement
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to screen object
				    ;               ds:[edi] - far ptr to mouse object
				    ;
				    ; Upon exit:    carry? - SET if mouse not in this object's coordinates, CLEAR if it is within
				    ;
 00001E47  52			        push    edx

 00001E48  8B 56 04		        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 00001E4B  03 57 01		        add     edx,dword ptr ds:[edi+_MO_X1]
 00001E4E  39 15 0000B7E5 R	        cmp     ds:mouse_current_x,edx
 00001E54  72 2D		        jb      fail
				      ; We're >= the left-most X coordinate

 00001E56  8B 56 04		        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 00001E59  03 57 09		        add     edx,dword ptr ds:[edi+_MO_X2]
 00001E5C  39 15 0000B7E5 R	        cmp     ds:mouse_current_x,edx
 00001E62  77 1F		        ja      fail
				      ; We're <= the right-most X coordinate

 00001E64  8B 56 08		        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00001E67  03 57 05		        add     edx,dword ptr ds:[edi+_MO_Y1]
 00001E6A  39 15 0000B7E9 R	        cmp     ds:mouse_current_y,edx
 00001E70  72 11		        jb      fail
				      ; We're >= the top-most Y coordinate

 00001E72  8B 56 08		        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00001E75  03 57 0D		        add     edx,dword ptr ds:[edi+_MO_Y2]
 00001E78  39 15 0000B7E9 R	        cmp     ds:mouse_current_y,edx
 00001E7E  77 03		        ja      fail
				      ; We're <= the bottom-most Y coordinate

				      ; This is it!
 00001E80  F8			        clc
 00001E81  EB 01		        jmp     quit

 00001E83			      fail:
 00001E83  F9			        stc

 00001E84			      quit:
 00001E84  5A			        pop     edx
 00001E85  C3			        ret
 00001E86			    invDEBI_check_mouse_object_coordinate       ENDP




 00001E86			    invDEBI_check_mouse_object_coordinate_drag_start        PROC
				    ; This routine is used to check the current mouse coordinate against the starting object coordinate plus the mouse object
				    ; relative displacement
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to screen object
				    ;               ds:[edi] - far ptr to mouse object
				    ;                     dl - drag start type
				    ;
				    ; Upon exit:    carry? - SET if mouse not in this object's coordinates, CLEAR if it is within
				    ;
 00001E86  52			        push    edx

				        .IF (dl == _LEFT_DRAG_START)
 00001E87  80 FA 02	   *	    cmp    dl, _LEFT_DRAG_START
 00001E8A  75 3A	   *	    jne    @C0271
				          ; It's a left-drag start
 00001E8C  8B 56 04		            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 00001E8F  03 57 01		            add     edx,dword ptr ds:[edi+_MO_X1]
 00001E92  39 15 0000B82E R	            cmp     ds:mouse_left_click_x_start,edx
 00001E98  72 67		            jb      fail
				          ; We're >= the left-most X coordinate

 00001E9A  8B 56 04		            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 00001E9D  03 57 09		            add     edx,dword ptr ds:[edi+_MO_X2]
 00001EA0  39 15 0000B82E R	            cmp     ds:mouse_left_click_x_start,edx
 00001EA6  77 59		            ja      fail
				          ; We're <= the right-most X coordinate

 00001EA8  8B 56 08		            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00001EAB  03 57 05		            add     edx,dword ptr ds:[edi+_MO_Y1]
 00001EAE  39 15 0000B832 R	            cmp     ds:mouse_left_click_y_start,edx
 00001EB4  72 4B		            jb      fail
				          ; We're >= the top-most Y coordinate

 00001EB6  8B 56 08		            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00001EB9  03 57 0D		            add     edx,dword ptr ds:[edi+_MO_Y2]
 00001EBC  39 15 0000B832 R	            cmp     ds:mouse_left_click_y_start,edx
 00001EC2  77 3D		            ja      fail
				          ; We're <= the bottom-most Y coordinate
				        .ELSE
 00001EC4  EB 38	   *	    jmp    @C0273
 00001EC6		   *@C0271:
				          ; It's a right-drag start
 00001EC6  8B 56 04		            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 00001EC9  03 57 01		            add     edx,dword ptr ds:[edi+_MO_X1]
 00001ECC  39 15 0000B826 R	            cmp     ds:mouse_right_click_x_start,edx
 00001ED2  72 2D		            jb      fail
				          ; We're >= the left-most X coordinate

 00001ED4  8B 56 04		            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 00001ED7  03 57 09		            add     edx,dword ptr ds:[edi+_MO_X2]
 00001EDA  39 15 0000B826 R	            cmp     ds:mouse_right_click_x_start,edx
 00001EE0  77 1F		            ja      fail
				          ; We're <= the right-most X coordinate

 00001EE2  8B 56 08		            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00001EE5  03 57 05		            add     edx,dword ptr ds:[edi+_MO_Y1]
 00001EE8  39 15 0000B82A R	            cmp     ds:mouse_right_click_y_start,edx
 00001EEE  72 11		            jb      fail
				          ; We're >= the top-most Y coordinate

 00001EF0  8B 56 08		            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00001EF3  03 57 0D		            add     edx,dword ptr ds:[edi+_MO_Y2]
 00001EF6  39 15 0000B82A R	            cmp     ds:mouse_right_click_y_start,edx
 00001EFC  77 03		            ja      fail
				        .ENDIF
 00001EFE		   *@C0273:

				      ; This is it!
 00001EFE  F8			        clc
 00001EFF  EB 01		        jmp     quit

 00001F01			      fail:
 00001F01  F9			        stc

 00001F02			      quit:
 00001F02  5A			        pop     edx
 00001F03  C3			        ret
 00001F04			    invDEBI_check_mouse_object_coordinate_drag_start        ENDP




 00001F04			    invDEBI_check_mouse_object_coordinate_drag_stop         PROC
				    ; This routine is used to check the current mouse coordinate against the starting object coordinate plus the mouse object
				    ; relative displacement
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to screen object
				    ;               ds:[edi] - far ptr to mouse object
				    ;                     dl - drag start type
				    ;
				    ; Upon exit:    carry? - SET if mouse not in this object's coordinates, CLEAR if it is within
				    ;
 00001F04  52			        push    edx

				        .IF (dl == _LEFT_DRAG_STOP)
 00001F05  80 FA 03	   *	    cmp    dl, _LEFT_DRAG_STOP
 00001F08  75 3A	   *	    jne    @C0274
				          ; It's a left-drag start
 00001F0A  8B 56 04		            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 00001F0D  03 57 01		            add     edx,dword ptr ds:[edi+_MO_X1]
 00001F10  39 15 0000B83E R	            cmp     ds:mouse_left_click_x_stop,edx
 00001F16  72 67		            jb      fail
				          ; We're >= the left-most X coordinate

 00001F18  8B 56 04		            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 00001F1B  03 57 09		            add     edx,dword ptr ds:[edi+_MO_X2]
 00001F1E  39 15 0000B83E R	            cmp     ds:mouse_left_click_x_stop,edx
 00001F24  77 59		            ja      fail
				          ; We're <= the right-most X coordinate

 00001F26  8B 56 08		            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00001F29  03 57 05		            add     edx,dword ptr ds:[edi+_MO_Y1]
 00001F2C  39 15 0000B842 R	            cmp     ds:mouse_left_click_y_stop,edx
 00001F32  72 4B		            jb      fail
				          ; We're >= the top-most Y coordinate

 00001F34  8B 56 08		            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00001F37  03 57 0D		            add     edx,dword ptr ds:[edi+_MO_Y2]
 00001F3A  39 15 0000B842 R	            cmp     ds:mouse_left_click_y_stop,edx
 00001F40  77 3D		            ja      fail
				          ; We're <= the bottom-most Y coordinate
				        .ELSE
 00001F42  EB 38	   *	    jmp    @C0276
 00001F44		   *@C0274:
				          ; It's a right-drag start
 00001F44  8B 56 04		            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 00001F47  03 57 01		            add     edx,dword ptr ds:[edi+_MO_X1]
 00001F4A  39 15 0000B836 R	            cmp     ds:mouse_right_click_x_stop,edx
 00001F50  72 2D		            jb      fail
				          ; We're >= the left-most X coordinate

 00001F52  8B 56 04		            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 00001F55  03 57 09		            add     edx,dword ptr ds:[edi+_MO_X2]
 00001F58  39 15 0000B836 R	            cmp     ds:mouse_right_click_x_stop,edx
 00001F5E  77 1F		            ja      fail
				          ; We're <= the right-most X coordinate

 00001F60  8B 56 08		            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00001F63  03 57 05		            add     edx,dword ptr ds:[edi+_MO_Y1]
 00001F66  39 15 0000B83A R	            cmp     ds:mouse_right_click_y_stop,edx
 00001F6C  72 11		            jb      fail
				          ; We're >= the top-most Y coordinate

 00001F6E  8B 56 08		            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00001F71  03 57 0D		            add     edx,dword ptr ds:[edi+_MO_Y2]
 00001F74  39 15 0000B83A R	            cmp     ds:mouse_right_click_y_stop,edx
 00001F7A  77 03		            ja      fail
				        .ENDIF
 00001F7C		   *@C0276:

				      ; This is it!
 00001F7C  F8			        clc
 00001F7D  EB 01		        jmp     quit

 00001F7F			      fail:
 00001F7F  F9			        stc

 00001F80			      quit:
 00001F80  5A			        pop     edx
 00001F81  C3			        ret
 00001F82			    invDEBI_check_mouse_object_coordinate_drag_stop         ENDP




 00001F82			    invDEBI_check_objects_click     PROC
				    ; This routine is used to check for objects the mouse is currently hovering over (without anything being clicked)
				    ;
				    ; Upon entry:   ds:mouse_hovering_x - current x coord
				    ;               ds:mouse_hovering_y - current y coord
				    ;
				    ; Upon exit:    Some items may be deselected or selected for display
				    ;
 00001F82  60			        pushad

				      ; See what the left button has done
 00001F83  C7 05 0000B84A R	        mov     ds:mouse_left_click,0
	   00000000
				        .IF (ds:mouse_button_left == 1)
 00001F8D  83 3D 0000B816 R
	   01		   *	    cmp    ds : mouse_button_left, 001h
 00001F94  75 0C	   *	    jne    @C0277
				          ; Single click
 00001F96  C7 05 0000B84A R	            mov     ds:mouse_left_click,1
	   00000001
				        .ELSEIF (ds:mouse_button_left == 2)
 00001FA0  EB 13	   *	    jmp    @C0279
 00001FA2		   *@C0277:
 00001FA2  83 3D 0000B816 R
	   02		   *	    cmp    ds : mouse_button_left, 002h
 00001FA9  75 0A	   *	    jne    @C027A
				          ; Double-click
 00001FAB  C7 05 0000B84A R	            mov     ds:mouse_left_click,2
	   00000002
				        .ENDIF
 00001FB5		   *@C027A:
 00001FB5		   *@C0279:
 00001FB5  C7 05 0000B816 R	        mov     ds:mouse_button_left,0
	   00000000

				      ; See what the right button has done
 00001FBF  C7 05 0000B846 R	        mov     ds:mouse_right_click,0
	   00000000
				        .IF (ds:mouse_button_right == 1)
 00001FC9  83 3D 0000B81A R
	   01		   *	    cmp    ds : mouse_button_right, 001h
 00001FD0  75 0C	   *	    jne    @C027C
				          ; Single click
 00001FD2  C7 05 0000B846 R	            mov     ds:mouse_right_click,1
	   00000001
				        .ELSEIF (ds:mouse_button_right == 2)
 00001FDC  EB 13	   *	    jmp    @C027E
 00001FDE		   *@C027C:
 00001FDE  83 3D 0000B81A R
	   02		   *	    cmp    ds : mouse_button_right, 002h
 00001FE5  75 0A	   *	    jne    @C027F
				          ; Double-click
 00001FE7  C7 05 0000B846 R	            mov     ds:mouse_right_click,2
	   00000002
				        .ENDIF
 00001FF1		   *@C027F:
 00001FF1		   *@C027E:
 00001FF1  C7 05 0000B81A R	        mov     ds:mouse_button_right,0
	   00000000

				      ; If no activity, quit
				        .IF (ds:mouse_left_click == 0 && ds:mouse_right_click == 0)
 00001FFB  83 3D 0000B84A R
	   00		   *	    cmp    ds : mouse_left_click, 000h
 00002002  75 0E	   *	    jne    @C0281
 00002004  83 3D 0000B846 R
	   00		   *	    cmp    ds : mouse_right_click, 000h
 0000200B  75 05	   *	    jne    @C0281
 0000200D  E9 000000A8		            jmp     quit
				        .ENDIF
 00002012		   *@C0281:

				      ; See if it was a both-button action
 00002012  8B 15 0000B84A R	        mov     edx,ds:mouse_left_click
				        .IF (ds:mouse_right_click == edx)
 00002018  39 15 0000B846 R *	    cmp    ds : mouse_right_click, edx
 0000201E  75 2F	   *	    jne    @C0284
				          ; Both buttons were pressed the same number of times
				            .IF (edx == 1)
 00002020  83 FA 01	   *	    cmp    edx, 001h
 00002023  75 0C	   *	    jne    @C0286
				              ; It's a both_single_click
 00002025  C7 05 0000B84E R	                mov     ds:mouse_both_click,1
	   00000001
				            .ELSE
 0000202F  EB 0A	   *	    jmp    @C0288
 00002031		   *@C0286:
				              ; It's a both_double_click
 00002031  C7 05 0000B84E R	                mov     ds:mouse_both_click,2
	   00000002
				            .ENDIF
 0000203B		   *@C0288:
 0000203B  C7 05 0000B84A R	            mov     ds:mouse_left_click,0
	   00000000
 00002045  C7 05 0000B846 R	            mov     ds:mouse_right_click,0
	   00000000
				        .ENDIF
 0000204F		   *@C0284:

				      ; Now, call the invDEBI_check_mouse_event with the appropriate activity to search for
				        .IF (ds:mouse_both_click != 0)
 0000204F  83 3D 0000B84E R
	   00		   *	    cmp    ds : mouse_both_click, 000h
 00002056  74 14	   *	    je     @C0289
				            .IF (ds:mouse_both_click == 1)
 00002058  83 3D 0000B84E R
	   01		   *	    cmp    ds : mouse_both_click, 001h
 0000205F  75 04	   *	    jne    @C028B
 00002061  B2 08		                mov     dl,_BOTH_SINGLE_CLICK
				            .ELSE
 00002063  EB 02	   *	    jmp    @C028D
 00002065		   *@C028B:
 00002065  B2 09		                mov     dl,_BOTH_DOUBLE_CLICK
				            .ENDIF
 00002067		   *@C028D:
 00002067  E8 FFFFFC1A		            call    invDEBI_check_mouse_event
				        .ENDIF
 0000206C		   *@C0289:

				        .IF (ds:mouse_left_click != 0)
 0000206C  83 3D 0000B84A R
	   00		   *	    cmp    ds : mouse_left_click, 000h
 00002073  74 14	   *	    je     @C028E
				            .IF (ds:mouse_left_click == 1)
 00002075  83 3D 0000B84A R
	   01		   *	    cmp    ds : mouse_left_click, 001h
 0000207C  75 04	   *	    jne    @C0290
 0000207E  B2 00		                mov     dl,_LEFT_SINGLE_CLICK
				            .ELSE
 00002080  EB 02	   *	    jmp    @C0292
 00002082		   *@C0290:
 00002082  B2 01		                mov     dl,_LEFT_DOUBLE_CLICK
				            .ENDIF
 00002084		   *@C0292:
 00002084  E8 FFFFFBFD		            call    invDEBI_check_mouse_event
				        .ENDIF
 00002089		   *@C028E:

				        .IF (ds:mouse_right_click != 0)
 00002089  83 3D 0000B846 R
	   00		   *	    cmp    ds : mouse_right_click, 000h
 00002090  74 14	   *	    je     @C0293
				            .IF (ds:mouse_right_click == 1)
 00002092  83 3D 0000B846 R
	   01		   *	    cmp    ds : mouse_right_click, 001h
 00002099  75 04	   *	    jne    @C0295
 0000209B  B2 04                mov     dl,_RIGHT_SINGLE_CLICK
				            .ELSE
 0000209D  EB 02	   *	    jmp    @C0297
 0000209F		   *@C0295:
 0000209F  B2 05		                mov     dl,_RIGHT_DOUBLE_CLICK
				            .ENDIF
 000020A1		   *@C0297:
 000020A1  E8 FFFFFBE0		            call    invDEBI_check_mouse_event
				        .ENDIF
 000020A6		   *@C0293:

				      ; Now, reset the mouse variables
 000020A6  C7 05 0000B84A R	        mov     ds:mouse_left_click,0
	   00000000
 000020B0  C7 05 0000B846 R	        mov     ds:mouse_right_click,0
	   00000000
 000020BA			      quit:
 000020BA  C7 05 0000B84E R	        mov     ds:mouse_both_click,0
	   00000000
 000020C4  C6 05 0000B801 R	        mov     ds:mouse_last_event,_HOVER
	   0A

 000020CB  61			        popad
 000020CC  C3			        ret
 000020CD			    invDEBI_check_objects_click     ENDP
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; END - 33333 - MOUSE Events
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; 44444 - MENU system
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 000020CD			    invDEBI_menu    PROC
				    ; This function is called when a menu needs to be displayed
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to the screen object
				    ;               ds:[edi] - far ptr to the mouse object
				    ;               ds:[ebx] - far ptr to the start of the menu objects
				    ;
				    ; Upon exit:    The menu is displayed and internal variables are setup for mouse menu processing
				    ;
 000020CD  C8 0028 00		        enter   40,0
 000020D1  60			        pushad
 000020D2  9C			        pushfd
 000020D3  06			        push    es
				      ; [ebp-04] - [ebx]
				      ; [ebp-08] - [edi]
				      ; [ebp-12] - [esi]
				      ; [ebp-16] - widest item
				      ; [ebp-20] - number of items
				      ; [ebp-24] - Y distance
				      ; [ebp-28] - temp storage
				      ; [ebp-32] - temp storage
				      ; [ebp-36] - build mouse listing Y
				      ; [ebp-40] - Maximum size of menu area
 000020D4  89 5D FC		        mov     dword ptr ss:[ebp-04],ebx
 000020D7  89 7D F8		        mov     dword ptr ss:[ebp-08],edi
 000020DA  89 75 F4		        mov     dword ptr ss:[ebp-12],esi
 000020DD  C7 45 F0		        mov     dword ptr ss:[ebp-16],0
	   00000000
 000020E4  C7 45 EC		        mov     dword ptr ss:[ebp-20],0
	   00000000
 000020EB  C7 45 E8		        mov     dword ptr ss:[ebp-24],16                            ; For top and bottom parts
	   00000010
 000020F2  C7 45 E0		        mov     dword ptr ss:[ebp-32],0
	   00000000
 000020F9  66| 8E 05		        mov     es,ds:data_segment
	   0000B77F R
 00002100  C6 05 0000B8BB R	        mov     ds:menu_restore_screen_after,_YES
	   01


				      ;; Perform a preliminary pass to determine the longest menu items
 00002107  8B F3		        mov     esi,ebx
				        .WHILE (byte ptr ds:[esi] != _END)
 00002109  EB 35	   *	    jmp    @C0298
 0000210B		   *@C0299:
 0000210B  8A 06		            mov     al,byte ptr ds:[esi]
				            .IF (al == _MENU_ITEM)
 0000210D  0A C0	   *	    or	al, al
 0000210F  75 1A	   *	    jne    @C029A
				              ; Find out how long this item is
 00002111  0F B6 4E 01		                movzx   ecx,byte ptr ds:[esi+1]
				                .IF (ecx > dword ptr ss:[ebp-16])
 00002115  3B 4D F0	   *	    cmp    ecx, dword ptr ss : [ebp - 010h]
 00002118  76 03	   *	    jbe    @C029C
 0000211A  89 4D F0		                    mov     dword ptr ss:[ebp-16],ecx
				                .ENDIF
 0000211D		   *@C029C:
 0000211D  03 F1		                add     esi,ecx
 0000211F  83 C6 02		                add     esi,2
 00002122  FF 45 EC		                inc     dword ptr ss:[ebp-20]
 00002125  83 45 E8 08		                add     dword ptr ss:[ebp-24],8
				            .ELSEIF (al == _MENU_ITEM_EVENT)
 00002129  EB 15	   *	    jmp    @C029E
 0000212B		   *@C029A:
 0000212B  3C 01	   *	    cmp    al, _MENU_ITEM_EVENT
 0000212D  75 05	   *	    jne    @C029F
 0000212F  83 C6 06		                add     esi,6
				            .ELSEIF (al == _MENU_BAR)
 00002132  EB 0C	   *	    jmp    @C02A1
 00002134		   *@C029F:
 00002134  3C 02	   *	    cmp    al, _MENU_BAR
 00002136  75 03	   *	    jne    @C02A2
 00002138  46			                inc     esi
				            .ELSE
 00002139  EB 05	   *	    jmp    @C02A4
 0000213B		   *@C02A2:
				              ; unknown option, we can't process this menu
 0000213B  E9 0000026B		                jmp     quit
				            .ENDIF
				        .ENDW
 00002140		   *@C02A4:
 00002140		   *@C02A1:
 00002140		   *@C029E:
 00002140		   *@C0298:
 00002140  80 3E FF	   *	    cmp    byte ptr ds : [esi], _END
 00002143  75 C6	   *	    jne    @C0299
				      ; Right now, [ebp-16] - widest item
				      ;            [ebp-20] - number of items
 00002145  83 45 F0 02		        add     dword ptr ss:[ebp-16],2
 00002149  8B 4D F0		        mov     ecx,dword ptr ss:[ebp-16]
				        .IF (ecx == 0 || ecx > 74 || dword ptr ss:[ebp-20] > 60)
 0000214C  0B C9	   *	    or	ecx, ecx
 0000214E  74 0B	   *	    je     @C02A7
 00002150  83 F9 4A	   *	    cmp    ecx, 04Ah
 00002153  77 06	   *	    ja     @C02A7
 00002155  83 7D EC 3C	   *	    cmp    dword ptr ss : [ebp - 014h], 03Ch
 00002159  76 05	   *	    jbe    @C02A6
 0000215B		   *@C02A7:
 0000215B  E9 0000024B		            jmp     quit
				        .ENDIF
 00002160		   *@C02A6:


				      ;; Initialize our menu area
 00002160  BF 0000BE47 R	        mov     edi,offset menu_area
 00002165  B9 00000300		        mov     ecx,sizeof menu_area / 4
 0000216A  FC			        cld
 0000216B  B8 FFFFFFFF		        mov     eax,-1
 00002170  F3/ AB		        rep     stosd

				      ;; Initialize our mouse object area
 00002172  BF 0000CA47 R	        mov     edi,offset menu_mouse_objects
 00002177  B9 000001A4		        mov     ecx,sizeof menu_mouse_objects / 4
 0000217C  FC			        cld
 0000217D  B8 FFFFFFFF		        mov     eax,-1
 00002182  F3/ AB		        rep     stosd


				      ;; Initialize the top line
 00002184  BF 0000BE47 R	        mov     edi,offset menu_area
 00002189  89 7D D8		        mov     dword ptr ss:[ebp-40],edi
 0000218C  81 45 D8		        add     dword ptr ss:[ebp-40],sizeof menu_area
	   00000C00
 00002193  8B 4D F0		        mov     ecx,dword ptr ss:[ebp-16]
 00002196  B0 F4		        mov     al,'Ù'
 00002198  AA			        stosb
 00002199  B0 DA		        mov     al,'⁄'                                              ; UL corner char
 0000219B  AA			        stosb
 0000219C  B0 F4		        mov     al,'Ù'
 0000219E  AA			        stosb
 0000219F  B0 C4		        mov     al,'ƒ'                                              ; top char
 000021A1  F3/ AA		        rep     stosb
 000021A3  B0 F4		        mov     al,'Ù'
 000021A5  AA			        stosb
 000021A6  B0 BF		        mov     al,'ø'                                              ; UR corner
 000021A8  AA			        stosb
 000021A9  32 C0		        xor     al,al
 000021AB  AA			        stosb


				      ;; Build the menu text and mouse objects
 000021AC  8B 75 FC		        mov     esi,dword ptr ss:[ebp-04]
 000021AF  33 D2		        xor     edx,edx
 000021B1  BB 0000CA83 R	        mov     ebx,offset menu_mouse_objects + _ST_LENGTH + _MO_LENGTH
 000021B6  C7 45 DC		        mov     dword ptr ss:[ebp-36],0
	   00000000
				        .WHILE (byte ptr ds:[esi] != _END && edi < dword ptr ss:[ebp-40])
 000021BD  E9 00000092	   *	    jmp    @C02AA
 000021C2		   *@C02AB:
 000021C2  8A 06		            mov     al,byte ptr ds:[esi]
				            .IF (al == _MENU_ITEM)
 000021C4  0A C0	   *	    or	al, al
 000021C6  75 3A	   *	    jne    @C02AC
 000021C8  83 45 DC 06		                add     dword ptr ss:[ebp-36],FONT_Y
 000021CC  89 7D E4		                mov     dword ptr ss:[ebp-28],edi
 000021CF  8B 4D F0		                mov     ecx,dword ptr ss:[ebp-16]
 000021D2  B0 F4		                mov     al,'Ù'
 000021D4  AA			                stosb
 000021D5  B0 B4		                mov     al,'¥'                                      ; left side char
 000021D7  AA			                stosb
 000021D8  B0 F4		                mov     al,'Ù'
 000021DA  AA			                stosb
 000021DB  B0 20		                mov     al,' '
 000021DD  F3/ AA		                rep     stosb
 000021DF  B0 F4		                mov     al,'Ù'
 000021E1  AA			                stosb
 000021E2  B0 B3		                mov     al,'≥'                                      ; right side char
 000021E4  AA			                stosb
 000021E5  32 C0		                xor     al,al
 000021E7  AA			                stosb

 000021E8  8B 7D E4		                mov     edi,dword ptr ss:[ebp-28]
 000021EB  83 C7 04		                add     edi,4
 000021EE  0F B6 4E 01		                movzx   ecx,byte ptr ds:[esi+1]
 000021F2  83 C6 02		                add     esi,2
 000021F5  F3/ A4		                rep     movsb

 000021F7  8B 7D E4		                mov     edi,dword ptr ss:[ebp-28]
 000021FA  03 7D F0		                add     edi,dword ptr ss:[ebp-16]
 000021FD  83 C7 06		                add     edi,6                                       ; move past all the extra characters
				            .ELSEIF (al == _MENU_ITEM_EVENT)
 00002200  EB 51	   *	    jmp    @C02AE
 00002202		   *@C02AC:
 00002202  3C 01	   *	    cmp    al, _MENU_ITEM_EVENT
 00002204  75 18	   *	    jne    @C02AF
				              ; Build the activity for this item
 00002206  E8 000001A5		                call    invDEBI_menu_write_common_header
 0000220B  8A 46 01		                mov     al,byte ptr ds:[esi+1]
 0000220E  88 03		                mov     byte ptr ds:[ebx+_MO_OBJECT_TYPE],al
 00002210  8B 46 02		                mov     eax,dword ptr ds:[esi+2]
 00002213  89 43 11		                mov     dword ptr ds:[ebx+_MO_FUNC],eax

 00002216  83 C3 1C		                add     ebx,_MO_LENGTH
 00002219  83 C6 06		                add     esi,6
				            .ELSEIF (al == _MENU_BAR)
 0000221C  EB 35	   *	    jmp    @C02B1
 0000221E		   *@C02AF:
 0000221E  3C 02	   *	    cmp    al, _MENU_BAR
 00002220  75 2C	   *	    jne    @C02B2
 00002222  83 45 DC 06		                add     dword ptr ss:[ebp-36],FONT_Y
 00002226  89 7D E4		                mov     dword ptr ss:[ebp-28],edi
 00002229  8B 4D F0		                mov     ecx,dword ptr ss:[ebp-16]
 0000222C  B0 F4		                mov     al,'Ù'
 0000222E  AA			                stosb
 0000222F  B0 B4		                mov     al,'¥'                                      ; left side char
 00002231  AA			                stosb
 00002232  B0 F4		                mov     al,'Ù'
 00002234  AA			                stosb
 00002235  B0 C4		                mov     al,'ƒ'
 00002237  F3/ AA		                rep     stosb
 00002239  B0 F4		                mov     al,'Ù'
 0000223B  AA			                stosb
 0000223C  B0 B3		                mov     al,'≥'                                      ; right side char
 0000223E  AA			                stosb
 0000223F  32 C0		                xor     al,al
 00002241  AA			                stosb

 00002242  8B 7D E4		                mov     edi,dword ptr ss:[ebp-28]
 00002245  03 7D F0		                add     edi,dword ptr ss:[ebp-16]
 00002248  83 C7 06		                add     edi,6                                       ; move past all the extra characters
 0000224B  46			                inc     esi                                         ; move past the _MENU_BAR character
				            .ELSE
 0000224C  EB 05	   *	    jmp    @C02B4
 0000224E		   *@C02B2:
				              ; unknown option, we can't process this menu
 0000224E  E9 00000158		                jmp     quit
				            .ENDIF
 00002253		   *@C02B4:
 00002253		   *@C02B1:
 00002253		   *@C02AE:
 00002253  42			            inc     edx
				        .ENDW
 00002254		   *@C02AA:
 00002254  80 3E FF	   *	    cmp    byte ptr ds : [esi], _END
 00002257  74 09	   *	    je     @C02B5
 00002259  3B 7D D8	   *	    cmp    edi, dword ptr ss : [ebp - 028h]
 0000225C  0F 82 FFFFFF60  *	    jb     @C02AB
 00002262		   *@C02B5:
				      ; Note, this space is reserved for a final entry that will terminate the menu if they click anywhere on the screen
 00002262  89 5D E4		        mov     dword ptr ss:[ebp-28],ebx
 00002265  83 C3 1C		        add     ebx,_MO_LENGTH
 00002268  C6 03 FF		        mov     byte ptr ds:[ebx],_END


				      ;; Initialize the bottom line
 0000226B  8B 4D F0		        mov     ecx,dword ptr ss:[ebp-16]
 0000226E  B0 F4		        mov     al,'Ù'
 00002270  AA			        stosb
 00002271  B0 C0		        mov     al,'¿'                                              ; bottom left char
 00002273  AA			        stosb
 00002274  B0 F4		        mov     al,'Ù'
 00002276  AA			        stosb
 00002277  B0 C3		        mov     al,'√'                                              ; bottom char
 00002279  F3/ AA		        rep     stosb
 0000227B  B0 F4		        mov     al,'Ù'
 0000227D  AA			        stosb
 0000227E  B0 D9		        mov     al,'Ÿ'                                              ; bottom right char
 00002280  AA			        stosb
 00002281  32 C0		        xor     al,al
 00002283  AA			        stosb
				      ;; Terminate the window
 00002284  F6 D0		        not     al
 00002286  AA			        stosb


				      ;; Determine the maximum height and width of the window (in pixels)
 00002287  83 45 F0 02		        add     dword ptr ss:[ebp-16],2                             ; for border characters
 0000228B  8B 45 F0		        mov     eax,dword ptr ss:[ebp-16]
 0000228E  BB 00000008		        mov     ebx,FONT_X
 00002293  F7 E3		        mul     ebx
 00002295  89 45 F0		        mov     dword ptr ss:[ebp-16],eax                           ; width - multiply by FONT_X
 00002298  83 45 EC 02		        add     dword ptr ss:[ebp-20],2                             ; for top and bottom
 0000229C  8B 45 EC		        mov     eax,dword ptr ss:[ebp-20]
 0000229F  BB 00000006		        mov     ebx,FONT_Y
 000022A4  F7 E3		        mul     ebx
 000022A6  89 45 EC		        mov     dword ptr ss:[ebp-20],eax                           ; height - multiply by FONT_Y

				      ;; Right now, ss:[ebp-32] - free

				      ;; Determine the position of the menu
 000022A9  8B 55 F0		        mov     edx,dword ptr ss:[ebp-16]
 000022AC  89 55 E0		        mov     dword ptr ss:[ebp-32],edx                           ; Save for below
 000022AF  8B 15 0000B7E5 R	        mov     edx,ds:mouse_current_x
 000022B5  03 55 F0		        add     edx,dword ptr ss:[ebp-16]
				        .IF (edx < 720)
 000022B8  81 FA 000002D0  *	    cmp    edx, 002D0h
 000022BE  73 08	   *	    jae    @C02B7
 000022C0  8B 1D 0000B7E5 R	            mov     ebx,ds:mouse_current_x
				        .ELSE
 000022C6  EB 08	   *	    jmp    @C02B9
 000022C8		   *@C02B7:
 000022C8  BB 000002D0		            mov     ebx,720
 000022CD  2B 5D F0		            sub     ebx,dword ptr ss:[ebp-16]
				        .ENDIF
 000022D0		   *@C02B9:
				      ; Now, see if we can position the menu 1/2 way left from the current mouse coordinate
 000022D0  D1 6D F0		        shr     dword ptr ss:[ebp-16],1
 000022D3  8B 0D 0000B7E5 R	        mov     ecx,ds:mouse_current_x
 000022D9  2B 4D F0		        sub     ecx,dword ptr ss:[ebp-16]
				        .IF (carry?)
 000022DC  73 04	   *	    jae    @C02BA
 000022DE  33 DB		            xor     ebx,ebx
				        .ELSE
 000022E0  EB 03	   *	    jmp    @C02BC
 000022E2		   *@C02BA:
 000022E2  2B 5D F0		            sub     ebx,dword ptr ss:[ebp-16]
				        .ENDIF
 000022E5		   *@C02BC:

 000022E5  8B 15 0000B7E9 R	        mov     edx,ds:mouse_current_y
 000022EB  03 55 DC		        add     edx,dword ptr ss:[ebp-36]
 000022EE  83 C2 0C		        add     edx,FONT_Y * 2
				        .IF (edx < 348)
 000022F1  81 FA 0000015C  *	    cmp    edx, 0015Ch
 000022F7  73 07	   *	    jae    @C02BD
 000022F9  A1 0000B7E9 R	            mov     eax,ds:mouse_current_y
				        .ELSE
 000022FE  EB 0D	   *	    jmp    @C02BF
 00002300		   *@C02BD:
 00002300  B8 0000015C		            mov     eax,348
 00002305  2B 45 DC		            sub     eax,dword ptr ss:[ebp-36]
 00002308  83 E8 0C		            sub     eax,FONT_Y * 2
 0000230B  EB 15		            jmp     skip_height_adjustment
				        .ENDIF
 0000230D		   *@C02BF:
				      ; Now, see if we can position the menu 1/2 way up from the current mouse coordinate
 0000230D  D1 6D EC		        shr     dword ptr ss:[ebp-20],1
 00002310  8B 0D 0000B7E9 R	        mov     ecx,ds:mouse_current_y
 00002316  2B 4D EC		        sub     ecx,dword ptr ss:[ebp-20]
				        .IF (carry?)
 00002319  73 04	   *	    jae    @C02C0
 0000231B  33 C0		            xor     eax,eax
				        .ELSE
 0000231D  EB 03	   *	    jmp    @C02C2
 0000231F		   *@C02C0:
				          ; we can
 0000231F  2B 45 EC		            sub     eax,dword ptr ss:[ebp-20]
				        .ENDIF
 00002322		   *@C02C2:

 00002322			      skip_height_adjustment:
				      ; Right now, eax - vertical
				      ;            ebx - horizontal
 00002322  BA 0000CA47 R	        mov     edx,offset menu_mouse_objects
 00002327  C6 02 00		        mov     byte  ptr ds:[edx+_ST_OBJECT_ALTERABLE],0
 0000232A  89 5A 04		        mov     dword ptr ds:[edx+_ST_OBJECT_UL_HORIZONTAL],ebx
 0000232D  89 42 08		        mov     dword ptr ds:[edx+_ST_OBJECT_UL_VERTICAL],eax
 00002330  8B 4D E0		        mov     ecx,dword ptr ss:[ebp-32]
 00002333  89 4A 0C		        mov     dword ptr ds:[edx+_ST_OBJECT_WIDTH],ecx
 00002336  8B 4D DC		        mov     ecx,dword ptr ss:[ebp-36]
 00002339  83 C1 0C		        add     ecx,FONT_Y * 2                                      ; for top and bottom bars around menu
 0000233C  89 4A 10		        mov     dword ptr ds:[edx+_ST_OBJECT_HEIGHT],ecx
 0000233F  C7 42 18		        mov     dword ptr ds:[edx+_ST_OBJECT_MOUSE_OFFSET],offset menu_mouse_objects + _ST_LENGTH
	   0000CA67 R
 00002346  C7 42 1C		        mov     dword ptr ds:[edx+_ST_OBJECT_SCREEN_OFFSET],offset menu_area
	   0000BE47 R
 0000234D  C7 05 0000B7A0 R	        mov     ds:draw_menu,1
	   00000001
 00002357  FF 05 0000B7A4 R	        inc     ds:menu_queue
 0000235D  C6 05 0000B7A8 R	        mov     ds:last_menu_item,0ffh
	   FF

				      ;; Now, add the _ANY_CLICK option that will work outside the range of the mouse window
				      ;; This will call the invDEBI_menu_cancel algorithm if they click anywhere outside the menu
				      ;; And finally, build the mouse-movement activity for this item
 00002364  8B 55 E4		        mov     edx,dword ptr ss:[ebp-28]
 00002367  B9 0000CA67 R	        mov     ecx,offset menu_mouse_objects + _ST_LENGTH
				      ; Right now, edx - far ptr to _ANY_CLICK item
				      ;            ecx - far ptr to _IMMEDIATE/_HOVER item
 0000236C  C6 02 0D		        mov     byte ptr ds:[edx+_MO_OBJECT_TYPE],_ANY_CLICK
 0000236F  F7 D8		        neg     eax
 00002371  F7 DB		        neg     ebx
 00002373  89 5A 01		        mov     dword ptr ds:[edx+_MO_X1],ebx
 00002376  89 42 05		        mov     dword ptr ds:[edx+_MO_Y1],eax
 00002379  89 59 01		        mov     dword ptr ds:[ecx+_MO_X1],ebx
 0000237C  89 41 05		        mov     dword ptr ds:[ecx+_MO_Y1],eax

 0000237F  81 C3 000002D0	        add     ebx,720
 00002385  05 0000015C		        add     eax,348
 0000238A  89 5A 09		        mov     dword ptr ds:[edx+_MO_X2],ebx
 0000238D  89 42 0D		        mov     dword ptr ds:[edx+_MO_Y2],eax
 00002390  C7 42 11		        mov     dword ptr ds:[edx+_MO_FUNC],offset invDEBI_menu_cancel
	   000023D8 R

 00002397  89 59 09		        mov     dword ptr ds:[ecx+_MO_X2],ebx
 0000239A  89 41 0D		        mov     dword ptr ds:[ecx+_MO_Y2],eax
 0000239D  C6 01 0E		        mov     byte  ptr ds:[ecx+_MO_OBJECT_TYPE],_IMMEDIATE
 000023A0  C7 41 11		        mov     dword ptr ds:[ecx+_MO_FUNC],offset invDEBI_menu_change
	   0000240F R
 000023A7  C6 41 1B 0A		        mov     byte  ptr ds:[ecx+_MO_TYPE],_HOVER

 000023AB			      quit:
 000023AB  07			        pop     es
 000023AC  9D			        popfd
 000023AD  61			        popad
 000023AE  C9			        leave
 000023AF  C3			        ret
 000023B0			    invDEBI_menu    ENDP




 000023B0			    invDEBI_menu_write_common_header    PROC
				    ; This routine writes common information for the mouse object headers
 000023B0  C7 43 01		        mov     dword ptr ds:[ebx+_MO_X1],FONT_X
	   00000008
 000023B7  8B 45 DC		        mov     eax,dword ptr ss:[ebp-36]
 000023BA  89 43 05		        mov     dword ptr ds:[ebx+_MO_Y1],eax
 000023BD  83 C0 05		        add     eax,FONT_Y - 1
 000023C0  89 43 0D		        mov     dword ptr ds:[ebx+_MO_Y2],eax

 000023C3  53			        push    ebx
 000023C4  52			        push    edx
 000023C5  8B 45 F0		        mov     eax,dword ptr ss:[ebp-16]
 000023C8  BB 00000008		        mov     ebx,FONT_X
 000023CD  F7 E3		        mul     ebx
 000023CF  5A			        pop     edx
 000023D0  5B			        pop     ebx
 000023D1  83 C0 07		        add     eax,FONT_X - 1                                      ; To encompass all of the last character)
 000023D4  89 43 09		        mov     dword ptr ds:[ebx+_MO_X2],eax
 000023D7  C3			        ret
 000023D8			    invDEBI_menu_write_common_header    ENDP




 000023D8			    invDEBI_menu_cancel     PROC
				    ; This routine is called from the menu itself when the user clicks anywhere except on one of the options
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to screen objects
				    ;               ds:[edi] - far ptr to this mouse object
				    ;
				    ; Upon exit:    The menu is cancelled and the screen is restored
				    ;
				        .IF (ds:menu_queue != 0)
 000023D8  83 3D 0000B7A4 R
	   00		   *	    cmp    ds : menu_queue, 000h
 000023DF  74 2D	   *	    je     @C02C3
 000023E1  FF 0D 0000B7A4 R	            dec     ds:menu_queue
 000023E7  C7 05 0000B788 R	            mov     ds:object_mode,0
	   00000000
				            .IF (ds:menu_restore_screen_after == _YES)
 000023F1  80 3D 0000B8BB R
	   01		   *	    cmp    ds : menu_restore_screen_after, _YES
 000023F8  75 14	   *	    jne    @C02C5
 000023FA  60			                pushad
 000023FB  9C			                pushfd
 000023FC  FA			                cli
 000023FD  E8 FFFFF287		                call    invDEBI_hide_mouse_pointer
 00002402  E8 FFFFF3D8		                call    invDEBI_turn_cursor_off
 00002407  E8 FFFFF350		                call    invDEBI_restore_screen2
 0000240C  9D			                popfd
 0000240D  61			                popad
				            .ENDIF
				        .ENDIF
 0000240E		   *@C02C5:
 0000240E		   *@C02C3:
 0000240E  C3			        ret
 0000240F			    invDEBI_menu_cancel     ENDP




 0000240F			    invDEBI_menu_change     PROC
				    ; This routine is called repeatedly whenever a mouse moves over a menu.  It constantly updates the menu item that's being
				    ; selected based on the location of the mouse pointer
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to screen objects
				    ;               ds:[edi] - far ptr to this mouse object
				    ;               ds:mouse_current_x - X coordinate for mouse
				    ;               ds:mouse_current_y - Y coordinate for mouse
				    ;
				    ; Upon entry:   If the mouse has moved away from the previously displayed item in the menu then the menu is updated
				    ;               Otherwise, nothing happens
				    ;
				        .IF (ds:menu_queue != 0)
 0000240F  83 3D 0000B7A4 R
	   00		   *	    cmp    ds : menu_queue, 000h
 00002416  0F 84 000000B0  *	    je     @C02C7
				          ; See which item needs to be updated
 0000241C  60			            pushad
 0000241D  8B 1D 0000B7E5 R	            mov     ebx,ds:mouse_current_x
 00002423  8B 46 04		            mov     eax,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
				            .IF (ebx < eax)
 00002426  3B D8	   *	    cmp    ebx, eax
 00002428  73 04	   *	    jae    @C02C9
 0000242A  B0 FF		                mov     al,0ffh
 0000242C  EB 4F		                jmp     continue_updating_menu
				            .ENDIF
				          ; We might be on the menu, we could be past the right-side
 0000242E		   *@C02C9:
 0000242E  03 46 0C		            add     eax,dword ptr ds:[esi+_ST_OBJECT_WIDTH]
				            .IF (ebx > eax)
 00002431  3B D8	   *	    cmp    ebx, eax
 00002433  76 04	   *	    jbe    @C02CB
				              ; We are not on the menu
 00002435  B0 FF		                mov     al,0ffh
 00002437  EB 44		                jmp     continue_updating_menu
				            .ENDIF
				          ; We are horizontally on the menu
				          ; See if we're vertically on the menu
 00002439		   *@C02CB:
 00002439  A1 0000B7E9 R	            mov     eax,ds:mouse_current_y
 0000243E  8B 56 08		            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
				            .IF (eax < edx)
 00002441  3B C2	   *	    cmp    eax, edx
 00002443  73 04	   *	    jae    @C02CD
				              ; We're above the menu
 00002445  B0 FF		                mov     al,0ffh
 00002447  EB 34		                jmp     continue_updating_menu
				            .ENDIF
 00002449		   *@C02CD:
 00002449  03 56 10		            add     edx,dword ptr ds:[esi+_ST_OBJECT_HEIGHT]
				            .IF (eax > edx)
 0000244C  3B C2	   *	    cmp    eax, edx
 0000244E  76 04	   *	    jbe    @C02CF
				              ; We're below the menu
 00002450  B0 FF		                mov     al,0ffh
 00002452  EB 29		                jmp     continue_updating_menu
				            .ENDIF

				          ;; Ok, we know for a fact that the mouse poniter is somewhere on the menu
 00002454		   *@C02CF:
 00002454  8B 56 08		            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00002457  2B C2		            sub     eax,edx
 00002459  8B 56 10		            mov     edx,dword ptr ds:[esi+_ST_OBJECT_HEIGHT]
 0000245C  83 EA 06		            sub     edx,FONT_Y
				            .IF (eax >= edx && eax <= ds:[esi+_ST_OBJECT_HEIGHT])
 0000245F  3B C2	   *	    cmp    eax, edx
 00002461  72 09	   *	    jb     @C02D1
 00002463  3B 46 10	   *	    cmp    eax, ds : [esi + _ST_OBJECT_HEIGHT]
 00002466  77 04	   *	    ja     @C02D1
				              ; It's on the bottom-most line (which is actually the border)
 00002468  B0 FF		                mov     al,0ffh
 0000246A  EB 11		                jmp     continue_updating_menu
				            .ENDIF
 0000246C		   *@C02D1:
 0000246C  BB 00000006		            mov     ebx,FONT_Y
 00002471  33 D2		            xor     edx,edx
 00002473  F7 F3		            div     ebx
				            .IF (al == 0)
 00002475  0A C0	   *	    or	al, al
 00002477  75 04	   *	    jne    @C02D4
				              ; It's on the top most line (which is actually the border)
 00002479  B0 FF		                mov     al,0ffh
 0000247B  EB 00		                jmp     continue_updating_menu
				            .ENDIF

 0000247D			          continue_updating_menu:
				            .IF (al != ds:last_menu_item)
 0000247D		   *@C02D4:
 0000247D  3A 05 0000B7A8 R *	    cmp    al, ds : last_menu_item
 00002483  74 46	   *	    je     @C02D6
				              ;; Right now, eax - contains the item number we're on
 00002485  A2 0000B7A8 R	                mov     ds:last_menu_item,al
 0000248A  33 C9		                xor     ecx,ecx
 0000248C  8B 76 1C		                mov     esi,dword ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]
				                .WHILE (byte ptr ds:[esi] != 255)
 0000248F  EB 30	   *	    jmp    @C02D8
 00002491		   *@C02D9:
 00002491  33 D2		                    xor     edx,edx
				                    .WHILE (byte ptr ds:[esi] != 0)
 00002493  EB 25	   *	    jmp    @C02DA
 00002495		   *@C02DB:
 00002495  8A 1E		                        mov     bl,byte ptr ds:[esi]
				                        .IF (bl == 'Ù' || bl == 'ı')
 00002497  80 FB F4	   *	    cmp    bl, 'Ù'
 0000249A  74 05	   *	    je     @C02DD
 0000249C  80 FB F5	   *	    cmp    bl, 'ı'
 0000249F  75 18	   *	    jne    @C02DC
 000024A1		   *@C02DD:
				                            .IF (edx == 1)
 000024A1  83 FA 01	   *	    cmp    edx, 001h
 000024A4  75 12	   *	    jne    @C02DF
				                                .IF (eax == ecx && byte ptr ds:[esi+1] != 'ƒ')
 000024A6  3B C1	   *	    cmp    eax, ecx
 000024A8  75 0B	   *	    jne    @C02E1
 000024AA  80 7E 01 C4	   *	    cmp    byte ptr ds : [esi + 001h], 'ƒ'
 000024AE  74 05	   *	    je     @C02E1
				                                  ; This is the one they're on (and it's not a menu bar)
 000024B0  C6 06 F5		                                    mov     byte ptr ds:[esi],'ı'
				                                .ELSE
 000024B3  EB 03	   *	    jmp    @C02E4
 000024B5		   *@C02E1:
				                                  ; They're not on this one
 000024B5  C6 06 F4		                                    mov     byte ptr ds:[esi],'Ù'
				                                .ENDIF
				                            .ENDIF
 000024B8		   *@C02E4:
 000024B8		   *@C02DF:
 000024B8  42			                            inc     edx
				                        .ENDIF
 000024B9		   *@C02DC:
 000024B9  46			                        inc     esi
				                    .ENDW
 000024BA		   *@C02DA:
 000024BA  80 3E 00	   *	    cmp    byte ptr ds : [esi], 000h
 000024BD  75 D6	   *	    jne    @C02DB
 000024BF  41			                    inc     ecx
 000024C0  46			                    inc     esi
				                .ENDW
 000024C1		   *@C02D8:
 000024C1  80 3E FF	   *	    cmp    byte ptr ds : [esi], 0FFh
 000024C4  75 CB	   *	    jne    @C02D9

				              ;; Right now, the menu has been updated
 000024C6  E8 00000002		                call    invDEBI_menu_refresh
				            .ENDIF

 000024CB		   *@C02D6:
 000024CB  61			            popad
				        .ENDIF
 000024CC		   *@C02C7:
 000024CC  C3			        ret
 000024CD			    invDEBI_menu_change     ENDP




 000024CD			    invDEBI_menu_refresh        PROC
				    ; This routine is used to refresh the menu
				    ;
				    ; Upon entry:   Nothing
				    ;
				    ; Upon exit:    The menu is drawn on the screen
				    ;
				        .IF (ds:draw_menu == 0)
 000024CD  83 3D 0000B7A0 R
	   00		   *	    cmp    ds : draw_menu, 000h
 000024D4  75 5B	   *	    jne    @C02E7
 000024D6  60			            pushad
 000024D7  9C			            pushfd
 000024D8  BF 0000BE47 R	            mov     edi,offset menu_area
 000024DD  BE 0000CA47 R	            mov     esi,offset menu_mouse_objects
 000024E2  8B 5E 04		            mov     ebx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 000024E5  8B 46 08		            mov     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 000024E8  FA			            cli
 000024E9  E8 FFFFF19B		            call    invDEBI_hide_mouse_pointer
 000024EE  E8 FFFFF2EC		            call    invDEBI_turn_cursor_off
 000024F3  E8 FFFFE4D8		            call    invDEBI_draw_window
 000024F8  E8 FFFFF1B7		            call    invDEBI_show_mouse_pointer
 000024FD  C7 05 0000B788 R	            mov     ds:object_mode,1
	   00000001
 00002507  C7 05 0000B798 R	            mov     ds:mouse_objects,offset menu_mouse_objects + _ST_LENGTH
	   0000CA67 R
 00002511  C7 05 0000B79C R	            mov     ds:screen_object,offset menu_mouse_objects
	   0000CA47 R
 0000251B  C7 05 0000B7A0 R	            mov     ds:draw_menu,0
	   00000000
 00002525  C7 05 0000B7FD R	            mov     ds:mouse_immediate_count,0                      ; This will force it to fire immediately (because 0-1 = carry?)
	   00000000
 0000252F  9D			            popfd
 00002530  61			            popad
				        .ENDIF
 00002531		   *@C02E7:
 00002531  C3			        ret
 00002532			    invDEBI_menu_refresh        ENDP
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; END - 44444 - MENU system
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; 55555 - MENUs for screen objects
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				; Upon entry:   ds:[esi] - far ptr to this object's screen table entry
				;               es:[edi] - far ptr to this object's mouse object information
				;
 00002532			    invDEBI_general_menu        PROC
 00002532  89 35 0000B8B3 R	        mov     ds:general_menu_esi,esi
 00002538  89 3D 0000B8B7 R	        mov     ds:general_menu_edi,edi
 0000253E  BB 000056AA R	        mov     ebx,offset DEBI_general_menu
 00002543  E8 FFFFFB85		        call    invDEBI_menu
 00002548  C3			        ret
 00002549			    invDEBI_general_menu        ENDP




 00002549			    invDEBI_cfsca_menu      PROC
 00002549  BB 0000A911 R	        mov     ebx,offset DEBI_cfsca_menu
 0000254E  E8 FFFFFB7A		        call    invDEBI_menu
 00002553  C3			        ret
 00002554			    invDEBI_cfsca_menu      ENDP




 00002554			    invDEBI_fpu_menu        PROC
				    ; This routine is called when a right-click is recognized on one of the stx fields
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to screen object
				    ;               ds:[edi] - far ptr to mouse object
				    ;               ds:mouse_right_click_x_start - X coord where right-click happened
				    ;               ds:mouse_right_click_y_start - Y coord
				    ;
				    ; Upon exit:    The FPU menu is displayed, temporary variables are stored
				    ;
 00002554  89 35 0000B8E4 R	        mov     ds:fpu_esi,esi
 0000255A  89 3D 0000B8E8 R	        mov     ds:fpu_edi,edi
 00002560  A1 0000B826 R	        mov     eax,ds:mouse_right_click_x_start
 00002565  A3 0000B8EC R	        mov     ds:fpu_x,eax
 0000256A  A1 0000B82A R	        mov     eax,ds:mouse_right_click_y_start
 0000256F  A3 0000B8F0 R	        mov     ds:fpu_y,eax
 00002574  BB 00006C39 R	        mov     ebx,offset DEBI_fpu_menu
 00002579  E8 FFFFFB4F		        call    invDEBI_menu
 0000257E  C3			        ret
 0000257F			    invDEBI_fpu_menu        ENDP




 0000257F			    invDEBI_mmx_menu        PROC
				    ; This routine is called when a right-click is recognized on one of the stx fields
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to screen object
				    ;               ds:[edi] - far ptr to mouse object
				    ;               ds:mouse_right_click_x_start - X coord where right-click happened
				    ;               ds:mouse_right_click_y_start - Y coord
				    ;
				    ; Upon exit:    The FPU menu is displayed, temporary variables are stored
				    ;
 0000257F  89 35 0000B8E4 R	        mov     ds:fpu_esi,esi
 00002585  89 3D 0000B8E8 R	        mov     ds:fpu_edi,edi
 0000258B  A1 0000B826 R	        mov     eax,ds:mouse_right_click_x_start
 00002590  A3 0000B8EC R	        mov     ds:fpu_x,eax
 00002595  A1 0000B82A R	        mov     eax,ds:mouse_right_click_y_start
 0000259A  A3 0000B8F0 R	        mov     ds:fpu_y,eax
 0000259F  E8 00001A08		        call    invDEBI_determine_mmx_variable
 000025A4  89 15 0000B8F4 R	        mov     ds:fpu_data,edx
				        .IF (edx != -1)
 000025AA  83 FA FF	   *	    cmp    edx, - 001h
 000025AD  74 0A	   *	    je     @C02E9
 000025AF  BB 00009FD6 R	            mov     ebx,offset DEBI_mmx_menu
 000025B4  E8 FFFFFB14		            call    invDEBI_menu
				        .ENDIF
 000025B9		   *@C02E9:
 000025B9  C3			        ret
 000025BA			    invDEBI_mmx_menu        ENDP
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; END - 55555 - MENUs for screen objects
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; 66666 - Actions taken when various menu items are selected
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 000025BA			    invDEBI_fpu_finit       PROC
 000025BA  E8 FFFFFE19		        call    invDEBI_menu_cancel
 000025BF  9B DB E3		        finit
 000025C2  9B DD B5		        fsave   ss:[ebp-200]
	   FFFFFF38
 000025C9  E8 00000000		        call    invDEBI_FPU_update_display
 000025CE			    invDEBI_fpu_finit       ENDP




 000025CE			    invDEBI_FPU_update_display      PROC
 000025CE  53			        push    ebx

				      ; These are all FPU windows
 000025CF  BB 0000684C R	        mov     ebx,offset DEBI_e_screen_objects
 000025D4  E8 0000002A		        call    invDEBI_update_all_windows_of_type
 000025D9  BB 0000704A R	        mov     ebx,offset DEBI_f_screen_objects
 000025DE  E8 00000020		        call    invDEBI_update_all_windows_of_type
 000025E3  BB 000099A8 R	        mov     ebx,offset DEBI_q_screen_objects
 000025E8  E8 00000016		        call    invDEBI_update_all_windows_of_type
 000025ED  BB 00009CF9 R	        mov     ebx,offset DEBI_r_screen_objects
 000025F2  E8 0000000C		        call    invDEBI_update_all_windows_of_type

				      ; This is an MMX window (but it is also affected)
 000025F7  BB 0000A564 R	        mov     ebx,offset DEBI_s_screen_objects
 000025FC  E8 00000002		        call    invDEBI_update_all_windows_of_type

 00002601  5B			        pop     ebx
 00002602  C3			        ret
 00002603			    invDEBI_FPU_update_display      ENDP




 00002603			    invDEBI_update_all_windows_of_type      PROC
				    ; This routine is used to update all windows of a particular flavor
				    ;
				    ; Upon entry:   ebx - offset of screen_objects variable (such as DEBI_a_screen_objects:) to update
				    ;
				    ; Upon exit:    Those window(s) are updated (if any)
				    ;
 00002603  60			        pushad
 00002604  9C			        pushfd

				      ; Remove any impediments to this process
 00002605  FA			        cli
 00002606  E8 FFFFF07E		        call    invDEBI_hide_mouse_pointer
 0000260B  E8 FFFFF1CF		        call    invDEBI_turn_cursor_off

				      ; And execute the process
 00002610  BE 000054C2 R	        mov     esi,offset DEBI_screen_table
 00002615  33 C9		        xor     ecx,ecx
				        .WHILE (ecx < 15)
 00002617  EB 18	   *	    jmp    @C02EB
 00002619		   *@C02EC:
				            .IF (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _YES)
 00002619  80 7E 01 01	   *	    cmp    byte ptr ds : [esi + _ST_OBJECT_ACTIVE], _YES
 0000261D  75 0E	   *	    jne    @C02ED
 0000261F  8B 7E 1C		                mov     edi,dword ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]     ; Get the offset to the objects
				              ; Right now, ds:[esi] - pointer to this screen table structure
				              ;            ds:[edi] - pointer to this item's objects
				              ; Now, parse the objects and act accordingly
				                .IF (edi == ebx)
 00002622  3B FB	   *	    cmp    edi, ebx
 00002624  75 07	   *	    jne    @C02EF
 00002626  60			                    pushad
 00002627  E8 FFFFDF0F		                    call    invDEBI_draw_objects
 0000262C  61			                    popad
				                .ENDIF
				            .ENDIF
 0000262D		   *@C02EF:

 0000262D		   *@C02ED:
 0000262D  83 C6 20		            add     esi,_ST_LENGTH
 00002630  41			            inc     ecx
				        .ENDW
 00002631		   *@C02EB:
 00002631  83 F9 0F	   *	    cmp    ecx, 00Fh
 00002634  72 E3	   *	    jb     @C02EC

 00002636  9D			        popfd
 00002637  61			        popad
 00002638  C3			        ret
 00002639			    invDEBI_update_all_windows_of_type      ENDP




 00002639			    invDEBI_fpu_force_0     PROC
 00002639  E8 FFFFFD9A		        call    invDEBI_menu_cancel
 0000263E  9B DB E3		        finit
 00002641  D9 EE		        fldz
 00002643  EB 2D		        jmp     invDEBI_stx_store_st0
 00002645			    invDEBI_fpu_force_0     ENDP




 00002645			    invDEBI_fpu_force_1     PROC
 00002645  E8 FFFFFD8E		        call    invDEBI_menu_cancel
 0000264A  9B DB E3		        finit
 0000264D  D9 E8		        fld1
 0000264F  EB 21		        jmp     invDEBI_stx_store_st0
 00002651			    invDEBI_fpu_force_1     ENDP




 00002651			    invDEBI_fpu_force_10    PROC
 00002651  E8 FFFFFD82		        call    invDEBI_menu_cancel
 00002656  9B DB E3		        finit
 00002659  68 0000000A		        push    dword ptr 10
 0000265E  DB 04 24		        fild    dword ptr ss:[esp]
 00002661  83 C4 04		        add     esp,4
 00002664  EB 0C		        jmp     invDEBI_stx_store_st0
 00002666			    invDEBI_fpu_force_10    ENDP




 00002666			    invDEBI_fpu_force_pi        PROC
 00002666  E8 FFFFFD6D		        call    invDEBI_menu_cancel
 0000266B  9B DB E3		        finit
 0000266E  D9 EB		        fldpi
 00002670  EB 00		        jmp     invDEBI_stx_store_st0
 00002672			    invDEBI_fpu_force_pi        ENDP




 00002672			    invDEBI_stx_store_st0       PROC
				    ; This routine is used to store the current value in st0 to the location specified when they right-clicked
				    ;
				    ; Upon entry:   ds:[fpu_esi] - far ptr to screen object
				    ;               ds:[fpu_edi] - far ptr to mouse object
				    ;                   ds:fpu_x - X coordinate where mouse was clicked
				    ;                   ds:fpu_y - Y coordinate where mouse was clicked
				    ;                        st0 - value to store there
				    ;
				    ; Upon exit:    The particular stx value right-clicked on is updated
				    ;
 00002672  60			        pushad
 00002673  E8 00000132		        call    invDEBI_fpu_get_stx_offset_in_ebx
 00002678  36: DB 3C 2B		        fstp    tbyte ptr ss:[ebp+ebx]
 0000267C  E8 FFFFFF4D		        call    invDEBI_FPU_update_display
 00002681  61			        popad
 00002682  C3			        ret
 00002683			    invDEBI_stx_store_st0       ENDP




 00002683			    invDEBI_fpu_swap_sign       PROC
 00002683  E8 FFFFFD50		        call    invDEBI_menu_cancel
 00002688  60			        pushad
 00002689  E8 0000011C		        call    invDEBI_fpu_get_stx_offset_in_ebx
 0000268E  9B DB E3		        finit
 00002691  36: DB 2C 2B		        fld     tbyte ptr ss:[ebp+ebx]
 00002695  D9 E0		        fchs
 00002697  36: DB 3C 2B		        fstp    tbyte ptr ss:[ebp+ebx]
 0000269B  E8 FFFFFF2E		        call    invDEBI_FPU_update_display
 000026A0  61			        popad
 000026A1  C3			        ret
 000026A2			    invDEBI_fpu_swap_sign       ENDP




 000026A2			    invDEBI_fpu_fld_0       PROC
 000026A2  E8 FFFFFD31		        call    invDEBI_menu_cancel
 000026A7  DD A5 FFFFFF38	        frstor  ss:[ebp-200]
 000026AD  D9 EE		        fldz
 000026AF  9B DD B5		        fsave   ss:[ebp-200]
	   FFFFFF38
 000026B6  E8 FFFFFF13		        call    invDEBI_FPU_update_display
 000026BB  C3			        ret
 000026BC			    invDEBI_fpu_fld_0       ENDP




 000026BC			    invDEBI_fpu_fld_1       PROC
 000026BC  E8 FFFFFD17		        call    invDEBI_menu_cancel
 000026C1  DD A5 FFFFFF38	        frstor  ss:[ebp-200]
 000026C7  D9 E8		        fld1
 000026C9  9B DD B5		        fsave   ss:[ebp-200]
	   FFFFFF38
 000026D0  E8 FFFFFEF9		        call    invDEBI_FPU_update_display
 000026D5  C3			        ret
 000026D6			    invDEBI_fpu_fld_1       ENDP




 000026D6			    invDEBI_fpu_fld_10      PROC
 000026D6  E8 FFFFFCFD		        call    invDEBI_menu_cancel
 000026DB  DD A5 FFFFFF38	        frstor  ss:[ebp-200]
 000026E1  68 0000000A		        push    dword ptr 10
 000026E6  DB 04 24		        fild    dword ptr ss:[esp]
 000026E9  83 C4 04		        add     esp,4
 000026EC  9B DD B5		        fsave   ss:[ebp-200]
	   FFFFFF38
 000026F3  E8 FFFFFED6		        call    invDEBI_FPU_update_display
 000026F8  C3			        ret
 000026F9			    invDEBI_fpu_fld_10      ENDP




 000026F9			    invDEBI_fpu_fld_pi      PROC
 000026F9  E8 FFFFFCDA		        call    invDEBI_menu_cancel
 000026FE  DD A5 FFFFFF38	        frstor  ss:[ebp-200]
 00002704  D9 EB		        fldpi
 00002706  9B DD B5		        fsave   ss:[ebp-200]
	   FFFFFF38
 0000270D  E8 FFFFFEBC		        call    invDEBI_FPU_update_display
 00002712  C3			        ret
 00002713			    invDEBI_fpu_fld_pi      ENDP




 00002713			    invDEBI_fpu_ffree       PROC
 00002713  E8 FFFFFCC0		        call    invDEBI_menu_cancel
 00002718  DD A5 FFFFFF38	        frstor  ss:[ebp-200]
 0000271E  DB 1D 0000BA0F R	        fistp   ds:trash_dword
 00002724  9B DD B5		        fsave   ss:[ebp-200]
	   FFFFFF38
 0000272B  E8 FFFFFE9E		        call    invDEBI_FPU_update_display
 00002730  C3			        ret
 00002731			    invDEBI_fpu_ffree       ENDP




 00002731			    invDEBI_fpu_fmulp       PROC
 00002731  E8 FFFFFCA2		        call    invDEBI_menu_cancel
 00002736  DD A5 FFFFFF38	        frstor  ss:[ebp-200]
 0000273C  DE C9		        fmulp   st(1),st(0)
 0000273E  9B DD B5		        fsave   ss:[ebp-200]
	   FFFFFF38
 00002745  E8 FFFFFE84		        call    invDEBI_FPU_update_display
 0000274A  C3			        ret
 0000274B			    invDEBI_fpu_fmulp       ENDP




 0000274B			    invDEBI_fpu_fdivp       PROC
 0000274B  E8 FFFFFC88		        call    invDEBI_menu_cancel
 00002750  DD A5 FFFFFF38	        frstor  ss:[ebp-200]
 00002756  DE F9		        fdivp   st(1),st(0)
 00002758  9B DD B5		        fsave   ss:[ebp-200]
	   FFFFFF38
 0000275F  E8 FFFFFE6A		        call    invDEBI_FPU_update_display
 00002764  C3			        ret
 00002765			    invDEBI_fpu_fdivp       ENDP




 00002765			    invDEBI_fpu_fdivrp      PROC
 00002765  E8 FFFFFC6E		        call    invDEBI_menu_cancel
 0000276A  DD A5 FFFFFF38	        frstor  ss:[ebp-200]
 00002770  DE F1		        fdivrp  st(1),st(0)
 00002772  9B DD B5		        fsave   ss:[ebp-200]
	   FFFFFF38
 00002779  E8 FFFFFE50		        call    invDEBI_FPU_update_display
 0000277E  C3			        ret
 0000277F			    invDEBI_fpu_fdivrp      ENDP




 0000277F			    invDEBI_fpu_save        PROC
 0000277F  E8 FFFFFC54		        call    invDEBI_menu_cancel
 00002784  DD A5 FFFFFF38	        frstor  ss:[ebp-200]
 0000278A  9B DD 35		        fsave   ds:FPU_fsave_scratch
	   0000B94C R
 00002791  C3			        ret
 00002792			    invDEBI_fpu_save        ENDP




 00002792			    invDEBI_fpu_restore     PROC
 00002792  E8 FFFFFC41		        call    invDEBI_menu_cancel
 00002797  DD 25 0000B94C R	        frstor  ds:FPU_fsave_scratch
 0000279D  9B DD B5		        fsave   ss:[ebp-200]
	   FFFFFF38
 000027A4  E8 FFFFFE25		        call    invDEBI_FPU_update_display
 000027A9  C3			        ret
 000027AA			    invDEBI_fpu_restore     ENDP




 000027AA			    invDEBI_fpu_get_stx_offset_in_ebx       PROC
 000027AA  57			        push    edi
 000027AB  56			        push    esi
 000027AC  52			        push    edx
 000027AD  50			        push    eax

 000027AE  8B 35 0000B8E4 R	        mov     esi,ds:fpu_esi
 000027B4  8B 3D 0000B8E8 R	        mov     edi,ds:fpu_edi
 000027BA  A1 0000B8F0 R	        mov     eax,ds:fpu_y
 000027BF  2B 46 08		        sub     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 000027C2  2B 47 05		        sub     eax,dword ptr ds:[edi+_MO_Y1]
 000027C5  33 D2		        xor     edx,edx
 000027C7  BB 00000006		        mov     ebx,FONT_Y
 000027CC  F7 F3		        div     ebx
				      ; Find out which slot to store it in
				        .IF (al == 0)
 000027CE  0A C0	   *	    or	al, al
 000027D0  75 07	   *	    jne    @C02F2
				          ; st7
 000027D2  BB FFFFFF9A		            mov     ebx,-200+98
				        .ELSEIF (al == 1)
 000027D7  EB 47	   *	    jmp    @C02F4
 000027D9		   *@C02F2:
 000027D9  3C 01	   *	    cmp    al, 001h
 000027DB  75 07	   *	    jne    @C02F5
				          ; st6
 000027DD  BB FFFFFF90		            mov     ebx,-200+88
				        .ELSEIF (al == 2)
 000027E2  EB 3C	   *	    jmp    @C02F7
 000027E4		   *@C02F5:
 000027E4  3C 02	   *	    cmp    al, 002h
 000027E6  75 07	   *	    jne    @C02F8
				          ; st5
 000027E8  BB FFFFFF86		            mov     ebx,-200+78
				        .ELSEIF (al == 3)
 000027ED  EB 31	   *	    jmp    @C02FA
 000027EF		   *@C02F8:
 000027EF  3C 03	   *	    cmp    al, 003h
 000027F1  75 07	   *	    jne    @C02FB
				          ; st4
 000027F3  BB FFFFFF7C		            mov     ebx,-200+68
				        .ELSEIF (al == 4)
 000027F8  EB 26	   *	    jmp    @C02FD
 000027FA		   *@C02FB:
 000027FA  3C 04	   *	    cmp    al, 004h
 000027FC  75 07	   *	    jne    @C02FE
				          ; st3
 000027FE  BB FFFFFF72		            mov     ebx,-200+58
				        .ELSEIF (al == 5)
 00002803  EB 1B	   *	    jmp    @C0300
 00002805		   *@C02FE:
 00002805  3C 05	   *	    cmp    al, 005h
 00002807  75 07	   *	    jne    @C0301
				          ; st2
 00002809  BB FFFFFF68		            mov     ebx,-200+48
				        .ELSEIF (al == 6)
 0000280E  EB 10	   *	    jmp    @C0303
 00002810		   *@C0301:
 00002810  3C 06	   *	    cmp    al, 006h
 00002812  75 07	   *	    jne    @C0304
				          ; st1
 00002814  BB FFFFFF5E		            mov     ebx,-200+38
				        .ELSE
 00002819  EB 05	   *	    jmp    @C0306
 0000281B		   *@C0304:
				          ; st0
 0000281B  BB FFFFFF54		            mov     ebx,-200+28
				        .ENDIF
 00002820		   *@C0306:
 00002820		   *@C0303:
 00002820		   *@C0300:
 00002820		   *@C02FD:
 00002820		   *@C02FA:
 00002820		   *@C02F7:
 00002820		   *@C02F4:

 00002820  58			        pop     eax
 00002821  5A			        pop     edx
 00002822  5E			        pop     esi
 00002823  5F			        pop     edi
 00002824  C3			        ret
 00002825			    invDEBI_fpu_get_stx_offset_in_ebx       ENDP




 00002825			    invDEBI_mmx_emms        PROC
 00002825  E8 FFFFFBAE		        call    invDEBI_menu_cancel
 0000282A  0F 77		        db  0fh, 77h    ; emms
 0000282C  9B DB E3		        finit
 0000282F  9B DD B5		        fsave   ss:[ebp-200]
	   FFFFFF38
 00002836  E8 FFFFFD93		        call    invDEBI_FPU_update_display
 0000283B  C3			        ret
 0000283C			    invDEBI_mmx_emms        ENDP




 0000283C			    invDEBI_mmx_emms_zero       PROC
 0000283C  E8 FFFFFB97		        call    invDEBI_menu_cancel
 00002841  0F 77		        db  0fh, 77h    ; emms
 00002843  9B DB E3		        finit
 00002846  9B DD B5		        fsave   ss:[ebp-200]
	   FFFFFF38
 0000284D  9B DB E3		        finit
 00002850  D9 EE		        fldz
 00002852  DF BD FFFFFF54	        fistp   qword ptr ss:[ebp-200+28]
 00002858  D9 EE		        fldz
 0000285A  DF BD FFFFFF5E	        fistp   qword ptr ss:[ebp-200+38]
 00002860  D9 EE		        fldz
 00002862  DF BD FFFFFF68	        fistp   qword ptr ss:[ebp-200+48]
 00002868  D9 EE		        fldz
 0000286A  DF BD FFFFFF72	        fistp   qword ptr ss:[ebp-200+58]
 00002870  D9 EE		        fldz
 00002872  DF BD FFFFFF7C	        fistp   qword ptr ss:[ebp-200+68]
 00002878  D9 EE		        fldz
 0000287A  DF 7D 86		        fistp   qword ptr ss:[ebp-200+78]
 0000287D  D9 EE		        fldz
 0000287F  DF 7D 90		        fistp   qword ptr ss:[ebp-200+88]
 00002882  D9 EE		        fldz
 00002884  DF 7D 9A		        fistp   qword ptr ss:[ebp-200+98]
 00002887  E8 FFFFFD42		        call    invDEBI_FPU_update_display
 0000288C  C3			        ret
 0000288D			    invDEBI_mmx_emms_zero       ENDP




 0000288D			    invDEBI_mmx_pnot        PROC
 0000288D  E8 FFFFFB46		        call    invDEBI_menu_cancel
 00002892  8B 15 0000B8F4 R	        mov     edx,ds:fpu_data
 00002898  36: F7 54 2A		        not     dword ptr ss:[ebp+edx+4]
	   04
 0000289D  36: F7 14 2A		        not     dword ptr ss:[ebp+edx+0]
 000028A1  E8 FFFFFD28		        call    invDEBI_FPU_update_display
 000028A6  C3			        ret
 000028A7			    invDEBI_mmx_pnot        ENDP




 000028A7			    invDEBI_mmx_pror_mmx_32     PROC
 000028A7  E8 FFFFFB2C		        call    invDEBI_menu_cancel
 000028AC  8B 15 0000B8F4 R	        mov     edx,ds:fpu_data
 000028B2  36: 8B 04 2A		        mov     eax,dword ptr ss:[ebp+edx]
 000028B6  36: 8B 5C 2A		        mov     ebx,dword ptr ss:[ebp+edx+4]
	   04
 000028BB  36: 89 44 2A		        mov     dword ptr ss:[ebp+edx+4],eax
	   04
 000028C0  36: 89 1C 2A		        mov     dword ptr ss:[ebp+edx],ebx
 000028C4  E8 FFFFFD05		        call    invDEBI_FPU_update_display
 000028C9  C3			        ret
 000028CA			    invDEBI_mmx_pror_mmx_32     ENDP




 000028CA			    invDEBI_mmx_pror_mmx_16     PROC
 000028CA  E8 FFFFFB09		        call    invDEBI_menu_cancel
 000028CF  8B 15 0000B8F4 R	        mov     edx,ds:fpu_data
 000028D5  66| 36: 8B 04 2A	        mov     ax,word ptr ss:[ebp+edx]

 000028DA  66| 36: 8B 5C 2A	        mov     bx,word ptr ss:[ebp+edx+2]
	   02
 000028E0  66| 36: 89 1C 2A	        mov     word ptr ss:[ebp+edx],bx

 000028E5  66| 36: 8B 5C 2A	        mov     bx,word ptr ss:[ebp+edx+4]
	   04
 000028EB  66| 36: 89 5C 2A	        mov     word ptr ss:[ebp+edx+2],bx
	   02

 000028F1  66| 36: 8B 5C 2A	        mov     bx,word ptr ss:[ebp+edx+6]
	   06
 000028F7  66| 36: 89 5C 2A	        mov     word ptr ss:[ebp+edx+4],bx
	   04

 000028FD  66| 36: 89 44 2A	        mov     word ptr ss:[ebp+edx+6],ax
	   06
 00002903  E8 FFFFFCC6		        call    invDEBI_FPU_update_display
 00002908  C3			        ret
 00002909			    invDEBI_mmx_pror_mmx_16     ENDP




 00002909			    invDEBI_mmx_pror_mmx_8      PROC
 00002909  E8 FFFFFACA		        call    invDEBI_menu_cancel
 0000290E  8B 15 0000B8F4 R	        mov     edx,ds:fpu_data
 00002914  36: 8A 04 2A		        mov     al,byte ptr ss:[ebp+edx]
 00002918  36: 8A 5C 2A		        mov     bl,byte ptr ss:[ebp+edx+1]
	   01
 0000291D  36: 88 1C 2A		        mov     byte ptr ss:[ebp+edx],bl

 00002921  36: 8A 5C 2A		        mov     bl,byte ptr ss:[ebp+edx+2]
	   02
 00002926  36: 88 5C 2A		        mov     byte ptr ss:[ebp+edx+1],bl
	   01

 0000292B  36: 8A 5C 2A		        mov     bl,byte ptr ss:[ebp+edx+3]
	   03
 00002930  36: 88 5C 2A		        mov     byte ptr ss:[ebp+edx+2],bl
	   02

 00002935  36: 8A 5C 2A		        mov     bl,byte ptr ss:[ebp+edx+4]
	   04
 0000293A  36: 88 5C 2A		        mov     byte ptr ss:[ebp+edx+3],bl
	   03

 0000293F  36: 8A 5C 2A		        mov     bl,byte ptr ss:[ebp+edx+5]
	   05
 00002944  36: 88 5C 2A		        mov     byte ptr ss:[ebp+edx+4],bl
	   04

 00002949  36: 8A 5C 2A		        mov     bl,byte ptr ss:[ebp+edx+6]
	   06
 0000294E  36: 88 5C 2A		        mov     byte ptr ss:[ebp+edx+5],bl
	   05

 00002953  36: 8A 5C 2A		        mov     bl,byte ptr ss:[ebp+edx+7]
	   07
 00002958  36: 88 5C 2A		        mov     byte ptr ss:[ebp+edx+6],bl
	   06

 0000295D  36: 88 44 2A		        mov     byte ptr ss:[ebp+edx+7],al
	   07
 00002962  E8 FFFFFC67		        call    invDEBI_FPU_update_display
 00002967  C3			        ret
 00002968			    invDEBI_mmx_pror_mmx_8      ENDP




 00002968			    invDEBI_mmx_pror_mmx_1      PROC
 00002968  E8 FFFFFA6B		        call    invDEBI_menu_cancel
 0000296D  8B 15 0000B8F4 R	        mov     edx,ds:fpu_data
 00002973  36: 8B 04 2A		        mov     eax,dword ptr ss:[ebp+edx+0]
 00002977  D1 E8		        shr     eax,1
 00002979  36: D1 5C 2A		        rcr     dword ptr ss:[ebp+edx+4],1
	   04
 0000297E  36: D1 1C 2A		        rcr     dword ptr ss:[ebp+edx+0],1
 00002982  E8 FFFFFC47		        call    invDEBI_FPU_update_display
 00002987  C3			        ret
 00002988			    invDEBI_mmx_pror_mmx_1      ENDP




 00002988			    invDEBI_mmx_pshr_mmx_1      PROC
 00002988  E8 FFFFFA4B		        call    invDEBI_menu_cancel
 0000298D  8B 15 0000B8F4 R	        mov     edx,ds:fpu_data
 00002993  36: D1 6C 2A		        shr     dword ptr ss:[ebp+edx+4],1
	   04
 00002998  36: D1 1C 2A		        rcr     dword ptr ss:[ebp+edx+0],1
 0000299C  E8 FFFFFC2D		        call    invDEBI_FPU_update_display
 000029A1  C3			        ret
 000029A2			    invDEBI_mmx_pshr_mmx_1      ENDP




 000029A2			    invDEBI_mmx_prol_mmx_16     PROC
 000029A2  E8 FFFFFA31		        call    invDEBI_menu_cancel
 000029A7  8B 15 0000B8F4 R	        mov     edx,ds:fpu_data
 000029AD  66| 36: 8B 44 2A	        mov     ax,word ptr ss:[ebp+edx+6]
	   06

 000029B3  66| 36: 8B 5C 2A	        mov     bx,word ptr ss:[ebp+edx+4]
	   04
 000029B9  66| 36: 89 5C 2A	        mov     word ptr ss:[ebp+edx+6],bx
	   06

 000029BF  66| 36: 8B 5C 2A	        mov     bx,word ptr ss:[ebp+edx+2]
	   02
 000029C5  66| 36: 89 5C 2A	        mov     word ptr ss:[ebp+edx+4],bx
	   04

 000029CB  66| 36: 8B 1C 2A	        mov     bx,word ptr ss:[ebp+edx+0]
 000029D0  66| 36: 89 5C 2A	        mov     word ptr ss:[ebp+edx+2],bx
	   02

 000029D6  66| 36: 89 04 2A	        mov     word ptr ss:[ebp+edx+0],ax
 000029DB  E8 FFFFFBEE		        call    invDEBI_FPU_update_display
 000029E0  C3			        ret
 000029E1			    invDEBI_mmx_prol_mmx_16     ENDP




 000029E1			    invDEBI_mmx_prol_mmx_8      PROC
 000029E1  E8 FFFFF9F2		        call    invDEBI_menu_cancel
 000029E6  8B 15 0000B8F4 R	        mov     edx,ds:fpu_data
 000029EC  36: 8A 44 2A		        mov     al,byte ptr ss:[ebp+edx+7]
	   07
 000029F1  36: 8A 5C 2A		        mov     bl,byte ptr ss:[ebp+edx+6]
	   06
 000029F6  36: 88 5C 2A		        mov     byte ptr ss:[ebp+edx+7],bl
	   07

 000029FB  36: 8A 5C 2A		        mov     bl,byte ptr ss:[ebp+edx+5]
	   05
 00002A00  36: 88 5C 2A		        mov     byte ptr ss:[ebp+edx+6],bl
	   06

 00002A05  36: 8A 5C 2A		        mov     bl,byte ptr ss:[ebp+edx+4]
	   04
 00002A0A  36: 88 5C 2A		        mov     byte ptr ss:[ebp+edx+5],bl
	   05

 00002A0F  36: 8A 5C 2A		        mov     bl,byte ptr ss:[ebp+edx+3]
	   03
 00002A14  36: 88 5C 2A		        mov     byte ptr ss:[ebp+edx+4],bl
	   04

 00002A19  36: 8A 5C 2A		        mov     bl,byte ptr ss:[ebp+edx+2]
	   02
 00002A1E  36: 88 5C 2A		        mov     byte ptr ss:[ebp+edx+3],bl
	   03

 00002A23  36: 8A 5C 2A		        mov     bl,byte ptr ss:[ebp+edx+1]
	   01
 00002A28  36: 88 5C 2A		        mov     byte ptr ss:[ebp+edx+2],bl
	   02

 00002A2D  36: 8A 1C 2A		        mov     bl,byte ptr ss:[ebp+edx+0]
 00002A31  36: 88 5C 2A		        mov     byte ptr ss:[ebp+edx+1],bl
	   01

 00002A36  36: 88 04 2A		        mov     byte ptr ss:[ebp+edx+0],al
 00002A3A  E8 FFFFFB8F		        call    invDEBI_FPU_update_display
 00002A3F  C3			        ret
 00002A40			    invDEBI_mmx_prol_mmx_8      ENDP




 00002A40			    invDEBI_mmx_prol_mmx_1      PROC
 00002A40  E8 FFFFF993		        call    invDEBI_menu_cancel
 00002A45  8B 15 0000B8F4 R	        mov     edx,ds:fpu_data
 00002A4B  36: 8B 44 2A		        mov     eax,dword ptr ss:[ebp+edx+4]
	   04
 00002A50  D1 E0		        shl     eax,1
 00002A52  36: D1 14 2A		        rcl     dword ptr ss:[ebp+edx+0],1
 00002A56  36: D1 54 2A		        rcl     dword ptr ss:[ebp+edx+4],1
	   04
 00002A5B  E8 FFFFFB6E		        call    invDEBI_FPU_update_display
 00002A60  C3			        ret
 00002A61			    invDEBI_mmx_prol_mmx_1      ENDP




 00002A61			    invDEBI_mmx_pshl_mmx_1      PROC
 00002A61  E8 FFFFF972		        call    invDEBI_menu_cancel
 00002A66  8B 15 0000B8F4 R	        mov     edx,ds:fpu_data
 00002A6C  36: D1 24 2A		        shl     dword ptr ss:[ebp+edx+0],1
 00002A70  36: D1 54 2A		        rcl     dword ptr ss:[ebp+edx+4],1
	   04
 00002A75  E8 FFFFFB54		        call    invDEBI_FPU_update_display
 00002A7A  C3			        ret
 00002A7B			    invDEBI_mmx_pshl_mmx_1      ENDP




 00002A7B			    invDEBI_mmx_movq_ffff_ffff_ffff_ffff     PROC
 00002A7B  68 FFFFFFFF		        push    dword ptr 0ffffffffh
 00002A80  68 FFFFFFFF		        push    dword ptr 0ffffffffh
 00002A85  E9 00000252		        jmp     invDEBI_mmx_movq
 00002A8A			    invDEBI_mmx_movq_ffff_ffff_ffff_ffff     ENDP




 00002A8A			    invDEBI_mmx_movq_0000_ffff_ffff_ffff     PROC
 00002A8A  68 0000FFFF		        push    dword ptr 00000ffffh
 00002A8F  68 FFFFFFFF		        push    dword ptr 0ffffffffh
 00002A94  E9 00000243		        jmp     invDEBI_mmx_movq
 00002A99			    invDEBI_mmx_movq_0000_ffff_ffff_ffff     ENDP




 00002A99			    invDEBI_mmx_movq_0000_0000_ffff_ffff     PROC
 00002A99  68 00000000		        push    dword ptr 000000000h
 00002A9E  68 FFFFFFFF		        push    dword ptr 0ffffffffh
 00002AA3  E9 00000234		        jmp     invDEBI_mmx_movq
 00002AA8			    invDEBI_mmx_movq_0000_0000_ffff_ffff     ENDP




 00002AA8			    invDEBI_mmx_movq_0000_0000_0000_ffff     PROC
 00002AA8  68 00000000		        push    dword ptr 000000000h
 00002AAD  68 0000FFFF		        push    dword ptr 00000ffffh
 00002AB2  E9 00000225		        jmp     invDEBI_mmx_movq
 00002AB7			    invDEBI_mmx_movq_0000_0000_0000_ffff     ENDP




 00002AB7			    invDEBI_mmx_movq_0000_0000_0000_0fff     PROC
 00002AB7  68 00000000		        push    dword ptr 000000000h
 00002ABC  68 00000FFF		        push    dword ptr 000000fffh
 00002AC1  E9 00000216		        jmp     invDEBI_mmx_movq
 00002AC6			    invDEBI_mmx_movq_0000_0000_0000_0fff     ENDP




 00002AC6			    invDEBI_mmx_movq_0000_0000_0000_00ff     PROC
 00002AC6  68 00000000		        push    dword ptr 000000000h
 00002ACB  68 000000FF		        push    dword ptr 0000000ffh
 00002AD0  E9 00000207		        jmp     invDEBI_mmx_movq
 00002AD5			    invDEBI_mmx_movq_0000_0000_0000_00ff     ENDP




 00002AD5			    invDEBI_mmx_movq_0000_0000_0000_000f     PROC
 00002AD5  68 00000000		        push    dword ptr 000000000h
 00002ADA  68 0000000F		        push    dword ptr 00000000fh
 00002ADF  E9 000001F8		        jmp     invDEBI_mmx_movq
 00002AE4			    invDEBI_mmx_movq_0000_0000_0000_000f     ENDP




 00002AE4			    invDEBI_mmx_movq_0000_0000_0000_0000     PROC
 00002AE4  68 00000000		        push    dword ptr 000000000h
 00002AE9  68 00000000		        push    dword ptr 000000000h
 00002AEE  E9 000001E9		        jmp     invDEBI_mmx_movq
 00002AF3			    invDEBI_mmx_movq_0000_0000_0000_0000    ENDP




 00002AF3			    invDEBI_mmx_pand_ffff_0000_0000_0000        PROC
 00002AF3  68 FFFF0000		        push    dword ptr 0ffff0000h
 00002AF8  68 00000000		        push    dword ptr 000000000h
 00002AFD  E9 000001FE		        jmp     invDEBI_mmx_pand
 00002B02			    invDEBI_mmx_pand_ffff_0000_0000_0000        ENDP




 00002B02			    invDEBI_mmx_pand_0000_ffff_0000_0000        PROC
 00002B02  68 0000FFFF		        push    dword ptr 00000ffffh
 00002B07  68 00000000		        push    dword ptr 000000000h
 00002B0C  E9 000001EF		        jmp     invDEBI_mmx_pand
 00002B11			    invDEBI_mmx_pand_0000_ffff_0000_0000        ENDP




 00002B11			    invDEBI_mmx_pand_0000_0000_ffff_0000        PROC
 00002B11  68 00000000		        push    dword ptr 000000000h
 00002B16  68 FFFF0000		        push    dword ptr 0ffff0000h
 00002B1B  E9 000001E0		        jmp     invDEBI_mmx_pand
 00002B20			    invDEBI_mmx_pand_0000_0000_ffff_0000        ENDP




 00002B20			    invDEBI_mmx_pand_0000_0000_0000_ffff        PROC
 00002B20  68 00000000		        push    dword ptr 000000000h
 00002B25  68 0000FFFF		        push    dword ptr 00000ffffh
 00002B2A  E9 000001D1		        jmp     invDEBI_mmx_pand
 00002B2F			    invDEBI_mmx_pand_0000_0000_0000_ffff        ENDP




 00002B2F			    invDEBI_mmx_pand_0000_0000_0000_0fff        PROC
 00002B2F  68 00000000		        push    dword ptr 000000000h
 00002B34  68 00000FFF		        push    dword ptr 000000fffh
 00002B39  E9 000001C2		        jmp     invDEBI_mmx_pand
 00002B3E			    invDEBI_mmx_pand_0000_0000_0000_0fff        ENDP




 00002B3E			    invDEBI_mmx_pand_0000_0000_0000_00ff        PROC
 00002B3E  68 00000000		        push    dword ptr 000000000h
 00002B43  68 000000FF		        push    dword ptr 0000000ffh
 00002B48  E9 000001B3		        jmp     invDEBI_mmx_pand
 00002B4D			    invDEBI_mmx_pand_0000_0000_0000_00ff        ENDP




 00002B4D			    invDEBI_mmx_pand_0000_0000_0000_000f        PROC
 00002B4D  68 00000000		        push    dword ptr 000000000h
 00002B52  68 0000000F		        push    dword ptr 00000000fh
 00002B57  E9 000001A4		        jmp     invDEBI_mmx_pand
 00002B5C			    invDEBI_mmx_pand_0000_0000_0000_000f        ENDP




 00002B5C			    invDEBI_mmx_pand_ffff_ffff_0000_0000        PROC
 00002B5C  68 FFFFFFFF		        push    dword ptr 0ffffffffh
 00002B61  68 00000000		        push    dword ptr 000000000h
 00002B66  E9 00000195		        jmp     invDEBI_mmx_pand
 00002B6B			    invDEBI_mmx_pand_ffff_ffff_0000_0000        ENDP




 00002B6B			    invDEBI_mmx_pand_0000_0000_ffff_ffff        PROC
 00002B6B  68 00000000		        push    dword ptr 000000000h
 00002B70  68 FFFFFFFF		        push    dword ptr 0ffffffffh
 00002B75  E9 00000186		        jmp     invDEBI_mmx_pand
 00002B7A			    invDEBI_mmx_pand_0000_0000_ffff_ffff        ENDP




 00002B7A			    invDEBI_mmx_pand_ffff_0000_ffff_0000        PROC
 00002B7A  68 FFFF0000		        push    dword ptr 0ffff0000h
 00002B7F  68 FFFF0000		        push    dword ptr 0ffff0000h
 00002B84  E9 00000177		        jmp     invDEBI_mmx_pand
 00002B89			    invDEBI_mmx_pand_ffff_0000_ffff_0000        ENDP




 00002B89			    invDEBI_mmx_pand_0000_ffff_0000_ffff        PROC
 00002B89  68 0000FFFF		        push    dword ptr 00000ffffh
 00002B8E  68 0000FFFF		        push    dword ptr 00000ffffh
 00002B93  E9 00000168		        jmp     invDEBI_mmx_pand
 00002B98			    invDEBI_mmx_pand_0000_ffff_0000_ffff        ENDP




 00002B98			    invDEBI_mmx_por_ffff_0000_0000_0000         PROC
 00002B98  68 FFFF0000		        push    dword ptr 0ffff0000h
 00002B9D  68 00000000		        push    dword ptr 000000000h
 00002BA2  E9 0000017D		        jmp     invDEBI_mmx_por
 00002BA7			    invDEBI_mmx_por_ffff_0000_0000_0000         ENDP




 00002BA7			    invDEBI_mmx_por_0000_ffff_0000_0000         PROC
 00002BA7  68 0000FFFF		        push    dword ptr 00000ffffh
 00002BAC  68 00000000		        push    dword ptr 000000000h
 00002BB1  E9 0000016E		        jmp     invDEBI_mmx_por
 00002BB6			    invDEBI_mmx_por_0000_ffff_0000_0000         ENDP




 00002BB6			    invDEBI_mmx_por_0000_0000_ffff_0000         PROC
 00002BB6  68 00000000		        push    dword ptr 000000000h
 00002BBB  68 FFFF0000		        push    dword ptr 0ffff0000h
 00002BC0  E9 0000015F		        jmp     invDEBI_mmx_por
 00002BC5			    invDEBI_mmx_por_0000_0000_ffff_0000         ENDP




 00002BC5			    invDEBI_mmx_por_0000_0000_0000_ffff         PROC
 00002BC5  68 00000000		        push    dword ptr 000000000h
 00002BCA  68 0000FFFF		        push    dword ptr 00000ffffh
 00002BCF  E9 00000150		        jmp     invDEBI_mmx_por
 00002BD4			    invDEBI_mmx_por_0000_0000_0000_ffff         ENDP




 00002BD4			    invDEBI_mmx_por_0000_0000_0000_0fff         PROC
 00002BD4  68 00000000		        push    dword ptr 000000000h
 00002BD9  68 00000FFF		        push    dword ptr 000000fffh
 00002BDE  E9 00000141		        jmp     invDEBI_mmx_por
 00002BE3			    invDEBI_mmx_por_0000_0000_0000_0fff         ENDP




 00002BE3			    invDEBI_mmx_por_0000_0000_0000_00ff         PROC
 00002BE3  68 00000000		        push    dword ptr 000000000h
 00002BE8  68 000000FF		        push    dword ptr 0000000ffh
 00002BED  E9 00000132		        jmp     invDEBI_mmx_por
 00002BF2			    invDEBI_mmx_por_0000_0000_0000_00ff         ENDP




 00002BF2			    invDEBI_mmx_por_0000_0000_0000_000f         PROC
 00002BF2  68 00000000		        push    dword ptr 000000000h
 00002BF7  68 0000000F		        push    dword ptr 00000000fh
 00002BFC  E9 00000123		        jmp     invDEBI_mmx_por
 00002C01			    invDEBI_mmx_por_0000_0000_0000_000f         ENDP




 00002C01			    invDEBI_mmx_por_ffff_ffff_0000_0000         PROC
 00002C01  68 FFFFFFFF		        push    dword ptr 0ffffffffh
 00002C06  68 00000000		        push    dword ptr 000000000h
 00002C0B  E9 00000114		        jmp     invDEBI_mmx_por
 00002C10			    invDEBI_mmx_por_ffff_ffff_0000_0000         ENDP




 00002C10			    invDEBI_mmx_por_0000_0000_ffff_ffff         PROC
 00002C10  68 00000000		        push    dword ptr 000000000h
 00002C15  68 FFFFFFFF		        push    dword ptr 0ffffffffh
 00002C1A  E9 00000105		        jmp     invDEBI_mmx_por
 00002C1F			    invDEBI_mmx_por_0000_0000_ffff_ffff         ENDP




 00002C1F			    invDEBI_mmx_por_ffff_0000_ffff_0000         PROC
 00002C1F  68 FFFF0000		        push    dword ptr 0ffff0000h
 00002C24  68 FFFF0000		        push    dword ptr 0ffff0000h
 00002C29  E9 000000F6		        jmp     invDEBI_mmx_por
 00002C2E			    invDEBI_mmx_por_ffff_0000_ffff_0000         ENDP




 00002C2E			    invDEBI_mmx_por_0000_ffff_0000_ffff         PROC
 00002C2E  68 0000FFFF		        push    dword ptr 00000ffffh
 00002C33  68 0000FFFF		        push    dword ptr 00000ffffh
 00002C38  E9 000000E7		        jmp     invDEBI_mmx_por
 00002C3D			    invDEBI_mmx_por_0000_ffff_0000_ffff         ENDP




 00002C3D			    invDEBI_mmx_pandn_ffff_0000_0000_0000       PROC
 00002C3D  68 FFFF0000		        push    dword ptr 0ffff0000h
 00002C42  68 00000000		        push    dword ptr 000000000h
 00002C47  E9 000000FC		        jmp     invDEBI_mmx_pandn
 00002C4C			    invDEBI_mmx_pandn_ffff_0000_0000_0000       ENDP




 00002C4C			    invDEBI_mmx_pandn_0000_ffff_0000_0000       PROC
 00002C4C  68 0000FFFF		        push    dword ptr 00000ffffh
 00002C51  68 00000000		        push    dword ptr 000000000h
 00002C56  E9 000000ED		        jmp     invDEBI_mmx_pandn
 00002C5B			    invDEBI_mmx_pandn_0000_ffff_0000_0000       ENDP




 00002C5B			    invDEBI_mmx_pandn_0000_0000_ffff_0000       PROC
 00002C5B  68 00000000		        push    dword ptr 000000000h
 00002C60  68 FFFF0000		        push    dword ptr 0ffff0000h
 00002C65  E9 000000DE		        jmp     invDEBI_mmx_pandn
 00002C6A			    invDEBI_mmx_pandn_0000_0000_ffff_0000       ENDP




 00002C6A			    invDEBI_mmx_pandn_0000_0000_0000_ffff       PROC
 00002C6A  68 00000000		        push    dword ptr 000000000h
 00002C6F  68 0000FFFF		        push    dword ptr 00000ffffh
 00002C74  E9 000000CF		        jmp     invDEBI_mmx_pandn
 00002C79			    invDEBI_mmx_pandn_0000_0000_0000_ffff       ENDP




 00002C79			    invDEBI_mmx_pandn_0000_0000_0000_0fff       PROC
 00002C79  68 00000000		        push    dword ptr 000000000h
 00002C7E  68 00000FFF		        push    dword ptr 000000fffh
 00002C83  E9 000000C0		        jmp     invDEBI_mmx_pandn
 00002C88			    invDEBI_mmx_pandn_0000_0000_0000_0fff       ENDP




 00002C88			    invDEBI_mmx_pandn_0000_0000_0000_00ff       PROC
 00002C88  68 00000000		        push    dword ptr 000000000h
 00002C8D  68 000000FF		        push    dword ptr 0000000ffh
 00002C92  E9 000000B1		        jmp     invDEBI_mmx_pandn
 00002C97			    invDEBI_mmx_pandn_0000_0000_0000_00ff       ENDP




 00002C97			    invDEBI_mmx_pandn_0000_0000_0000_000f       PROC
 00002C97  68 00000000		        push    dword ptr 000000000h
 00002C9C  68 0000000F		        push    dword ptr 00000000fh
 00002CA1  E9 000000A2		        jmp     invDEBI_mmx_pandn
 00002CA6			    invDEBI_mmx_pandn_0000_0000_0000_000f       ENDP




 00002CA6			    invDEBI_mmx_pandn_ffff_ffff_0000_0000       PROC
 00002CA6  68 FFFFFFFF		        push    dword ptr 0ffffffffh
 00002CAB  68 00000000		        push    dword ptr 000000000h
 00002CB0  E9 00000093		        jmp     invDEBI_mmx_pandn
 00002CB5			    invDEBI_mmx_pandn_ffff_ffff_0000_0000       ENDP




 00002CB5			    invDEBI_mmx_pandn_0000_0000_ffff_ffff       PROC
 00002CB5  68 00000000		        push    dword ptr 000000000h
 00002CBA  68 FFFFFFFF		        push    dword ptr 0ffffffffh
 00002CBF  E9 00000084		        jmp     invDEBI_mmx_pandn
 00002CC4			    invDEBI_mmx_pandn_0000_0000_ffff_ffff       ENDP




 00002CC4			    invDEBI_mmx_pandn_ffff_0000_ffff_0000       PROC
 00002CC4  68 FFFF0000		        push    dword ptr 0ffff0000h
 00002CC9  68 FFFF0000		        push    dword ptr 0ffff0000h
 00002CCE  EB 78		        jmp     invDEBI_mmx_pandn
 00002CD0			    invDEBI_mmx_pandn_ffff_0000_ffff_0000       ENDP




 00002CD0			    invDEBI_mmx_pandn_0000_ffff_0000_ffff       PROC
 00002CD0  68 0000FFFF		        push    dword ptr 00000ffffh
 00002CD5  68 0000FFFF		        push    dword ptr 00000ffffh
 00002CDA  EB 6C		        jmp     invDEBI_mmx_pandn
 00002CDC			    invDEBI_mmx_pandn_0000_ffff_0000_ffff       ENDP




 00002CDC			    invDEBI_mmx_movq        PROC
 00002CDC  8B 15 0000B8F4 R	        mov     edx,ds:fpu_data
 00002CE2  E8 FFFFF6F1		        call    invDEBI_menu_cancel

 00002CE7  8B 5C 24 04		        mov     ebx,dword ptr ss:[esp+4]
 00002CEB  36: 89 5C 2A		        mov     dword ptr ss:[ebp+edx+4],ebx
	   04

 00002CF0  8B 1C 24		        mov     ebx,dword ptr ss:[esp+0]
 00002CF3  36: 89 1C 2A		        mov     dword ptr ss:[ebp+edx+0],ebx
 00002CF7  E8 FFFFF8D2		        call    invDEBI_FPU_update_display
 00002CFC  83 C4 08		        add     esp,8
 00002CFF  C3			        ret
 00002D00			    invDEBI_mmx_movq        ENDP




 00002D00			    invDEBI_mmx_pand        PROC
 00002D00  8B 15 0000B8F4 R	        mov     edx,ds:fpu_data
 00002D06  E8 FFFFF6CD		        call    invDEBI_menu_cancel

 00002D0B  8B 5C 24 04		        mov     ebx,dword ptr ss:[esp+4]
 00002D0F  36: 21 5C 2A		        and     dword ptr ss:[ebp+edx+4],ebx
	   04

 00002D14  8B 1C 24		        mov     ebx,dword ptr ss:[esp+0]
 00002D17  36: 21 1C 2A		        and     dword ptr ss:[ebp+edx+0],ebx
 00002D1B  E8 FFFFF8AE		        call    invDEBI_FPU_update_display
 00002D20  83 C4 08		        add     esp,8
 00002D23  C3			        ret
 00002D24			    invDEBI_mmx_pand        ENDP




 00002D24			    invDEBI_mmx_por         PROC
 00002D24  8B 15 0000B8F4 R	        mov     edx,ds:fpu_data
 00002D2A  E8 FFFFF6A9		        call    invDEBI_menu_cancel

 00002D2F  8B 5C 24 04		        mov     ebx,dword ptr ss:[esp+4]
 00002D33  36: 09 5C 2A		        or      dword ptr ss:[ebp+edx+4],ebx
	   04

 00002D38  8B 1C 24		        mov     ebx,dword ptr ss:[esp+0]
 00002D3B  36: 09 1C 2A		        or      dword ptr ss:[ebp+edx+0],ebx
 00002D3F  E8 FFFFF88A		        call    invDEBI_FPU_update_display
 00002D44  83 C4 08		        add     esp,8
 00002D47  C3			        ret
 00002D48			    invDEBI_mmx_por         ENDP




 00002D48			    invDEBI_mmx_pandn       PROC
 00002D48  8B 15 0000B8F4 R	        mov     edx,ds:fpu_data
 00002D4E  E8 FFFFF685		        call    invDEBI_menu_cancel

 00002D53  8B 5C 24 04		        mov     ebx,dword ptr ss:[esp+4]
 00002D57  F7 D3		        not     ebx
 00002D59  36: 21 5C 2A		        and     dword ptr ss:[ebp+edx+4],ebx
	   04

 00002D5E  8B 1C 24		        mov     ebx,dword ptr ss:[esp+0]
 00002D61  F7 D3		        not     ebx
 00002D63  36: 21 1C 2A		        and     dword ptr ss:[ebp+edx+0],ebx
 00002D67  E8 FFFFF862		        call    invDEBI_FPU_update_display
 00002D6C  83 C4 08		        add     esp,8
 00002D6F  C3			        ret
 00002D70			    invDEBI_mmx_pandn       ENDP




 00002D70			    invDEBI_quick_watch_show_EBP_relative_selector      PROC
 00002D70  E8 FFFFE2E8		        call    invDEBI_quick_watch_add_divider
 00002D75  0F BF 5F 15		        movsx   ebx,word ptr ds:[edi+_MO_DATA]
 00002D79  36: 8B 14 2B		        mov     edx,dword ptr ss:[ebp+ebx]
 00002D7D  BB 00000010		        mov     ebx,16
 00002D82  BF 0000BD99 R	        mov     edi,offset hex_text
 00002D87  E8 FFFFE252		        call    invDEBI_quick_watch_add_radix_in_edx
 00002D8C  BB 0000000A		        mov     ebx,10
 00002D91  BF 0000BD9F R	        mov     edi,offset dec_text
 00002D96  E8 FFFFE243		        call    invDEBI_quick_watch_add_radix_in_edx
 00002D9B  BB 00000002		        mov     ebx,2
 00002DA0  BF 0000BDA5 R	        mov     edi,offset bin_text
 00002DA5  E8 FFFFE234		        call    invDEBI_quick_watch_add_radix_in_edx
				        .IF (edx == 08h)
 00002DAA  83 FA 08	   *	    cmp    edx, 008h
 00002DAD  75 0A	   *	    jne    @C0307
 00002DAF  BE 0000BBBB R	            mov     esi,offset _sIDT_text
				        .ELSEIF (edx == 010h)
 00002DB4  E9 000001DC	   *	    jmp    @C0309
 00002DB9		   *@C0307:
 00002DB9  83 FA 10	   *	    cmp    edx, 010h
 00002DBC  75 0A	   *	    jne    @C030A
 00002DBE  BE 0000BBC4 R	            mov     esi,offset _sGDT_text
				        .ELSEIF (edx == 018h)
 00002DC3  E9 000001CD	   *	    jmp    @C030C
 00002DC8		   *@C030A:
 00002DC8  83 FA 18	   *	    cmp    edx, 018h
 00002DCB  75 0A	   *	    jne    @C030D
 00002DCD  BE 0000BBCD R	            mov     esi,offset _sSTACK_text
				        .ELSEIF (edx == 020h)
 00002DD2  E9 000001BE	   *	    jmp    @C030F
 00002DD7		   *@C030D:
 00002DD7  83 FA 20	   *	    cmp    edx, 020h
 00002DDA  75 0A	   *	    jne    @C0310
 00002DDC  BE 0000BBD8 R	            mov     esi,offset _sCODE_text
				        .ELSEIF (edx == 028h)
 00002DE1  E9 000001AF	   *	    jmp    @C0312
 00002DE6		   *@C0310:
 00002DE6  83 FA 28	   *	    cmp    edx, 028h
 00002DE9  75 0A	   *	    jne    @C0313
 00002DEB  BE 0000BBE2 R	            mov     esi,offset _sGRAPHICS_text
				        .ELSEIF (edx == 030h)
 00002DF0  E9 000001A0	   *	    jmp    @C0315
 00002DF5		   *@C0313:
 00002DF5  83 FA 30	   *	    cmp    edx, 030h
 00002DF8  75 0A	   *	    jne    @C0316
 00002DFA  BE 0000BBF0 R	            mov     esi,offset _sMONO_text
				        .ELSEIF (edx == 038h)
 00002DFF  E9 00000191	   *	    jmp    @C0318
 00002E04		   *@C0316:
 00002E04  83 FA 38	   *	    cmp    edx, 038h
 00002E07  75 0A	   *	    jne    @C0319
 00002E09  BE 0000BBFA R	            mov     esi,offset _sVGA_text
				        .ELSEIF (edx == 040h)
 00002E0E  E9 00000182	   *	    jmp    @C031B
 00002E13		   *@C0319:
 00002E13  83 FA 40	   *	    cmp    edx, 040h
 00002E16  75 0A	   *	    jne    @C031C
 00002E18  BE 0000BC03 R	            mov     esi,offset _sALL_MEM_text
				        .ELSEIF (edx == 048h)
 00002E1D  E9 00000173	   *	    jmp    @C031E
 00002E22		   *@C031C:
 00002E22  83 FA 48	   *	    cmp    edx, 048h
 00002E25  75 0A	   *	    jne    @C031F
 00002E27  BE 0000BC10 R	            mov     esi,offset _sDATA_text
				        .ELSEIF (edx == 050h)
 00002E2C  E9 00000164	   *	    jmp    @C0321
 00002E31		   *@C031F:
 00002E31  83 FA 50	   *	    cmp    edx, 050h
 00002E34  75 0A	   *	    jne    @C0322
 00002E36  BE 0000BC1A R	            mov     esi,offset _sEXODUS_MEM_text
				        .ELSEIF (edx == 058h)
 00002E3B  E9 00000155	   *	    jmp    @C0324
 00002E40		   *@C0322:
 00002E40  83 FA 58	   *	    cmp    edx, 058h
 00002E43  75 0A	   *	    jne    @C0325
 00002E45  BE 0000BC2A R	            mov     esi,offset _sEXODUS_PORTS_text
				        .ELSEIF (edx == 060h)
 00002E4A  E9 00000146	   *	    jmp    @C0327
 00002E4F		   *@C0325:
 00002E4F  83 FA 60	   *	    cmp    edx, 060h
 00002E52  75 0A	   *	    jne    @C0328
 00002E54  BE 0000BC3C R	            mov     esi,offset _sEXODUS_INTS_text
				;        .ELSEIF (edx == 068h)
				;          ; Not used, this is slot 13.  13 is bad luck. :)
				        .ELSEIF (edx == 070h)
 00002E59  E9 00000137	   *	    jmp    @C032A
 00002E5E		   *@C0328:
 00002E5E  83 FA 70	   *	    cmp    edx, 070h
 00002E61  75 0A	   *	    jne    @C032B
 00002E63  BE 0000BC4D R	            mov     esi,offset _sEXODUS_TSS_text
				        .ELSEIF (edx == 078h)
 00002E68  E9 00000128	   *	    jmp    @C032D
 00002E6D		   *@C032B:
 00002E6D  83 FA 78	   *	    cmp    edx, 078h
 00002E70  75 0A	   *	    jne    @C032E
 00002E72  BE 0000BD65 R	            mov     esi,offset _sEXODUS_TSS_GATE_text
				        .ELSEIF (edx == 080h)
 00002E77  E9 00000119	   *	    jmp    @C0330
 00002E7C		   *@C032E:
 00002E7C  81 FA 00000080  *	    cmp    edx, 080h
 00002E82  75 0A	   *	    jne    @C0331
 00002E84  BE 0000BC5D R	            mov     esi,offset _sSTACK0_text
				        .ELSEIF (edx == 088h)
 00002E89  E9 00000107	   *	    jmp    @C0333
 00002E8E		   *@C0331:
 00002E8E  81 FA 00000088  *	    cmp    edx, 088h
 00002E94  75 0A	   *	    jne    @C0334
 00002E96  BE 0000BC69 R	            mov     esi,offset _sSTACK1_text
				        .ELSEIF (edx == 090h)
 00002E9B  E9 000000F5	   *	    jmp    @C0336
 00002EA0		   *@C0334:
 00002EA0  81 FA 00000090  *	    cmp    edx, 090h
 00002EA6  75 0A	   *	    jne    @C0337
 00002EA8  BE 0000BC75 R	            mov     esi,offset _sSTACK2_text
				        .ELSEIF (edx == 098h)
 00002EAD  E9 000000E3	   *	    jmp    @C0339
 00002EB2		   *@C0337:
 00002EB2  81 FA 00000098  *	    cmp    edx, 098h
 00002EB8  75 0A	   *	    jne    @C033A
 00002EBA  BE 0000BC81 R	            mov     esi,offset _sPRIMATIVES_text
				        .ELSEIF (edx == 0a0h)
 00002EBF  E9 000000D1	   *	    jmp    @C033C
 00002EC4		   *@C033A:
 00002EC4  81 FA 000000A0  *	    cmp    edx, 0A0h
 00002ECA  75 0A	   *	    jne    @C033D
 00002ECC  BE 0000BD77 R	            mov     esi,offset _sPRIMATIVES_LOAD_INFO_text
				        .ELSEIF (edx == 0a8h)
 00002ED1  E9 000000BF	   *	    jmp    @C033F
 00002ED6		   *@C033D:
 00002ED6  81 FA 000000A8  *	    cmp    edx, 0A8h
 00002EDC  75 0A	   *	    jne    @C0340
 00002EDE  BE 0000BC91 R	            mov     esi,offset _sSYSTEM_text
				        .ELSEIF (edx == 0b0h)
 00002EE3  E9 000000AD	   *	    jmp    @C0342
 00002EE8		   *@C0340:
 00002EE8  81 FA 000000B0  *	    cmp    edx, 0B0h
 00002EEE  75 0A	   *	    jne    @C0343
 00002EF0  BE 0000BC9D R	            mov     esi,offset _sEXODUS_REQUESTOR_text
				        .ELSEIF (edx == 0b8h)
 00002EF5  E9 0000009B	   *	    jmp    @C0345
 00002EFA		   *@C0343:
 00002EFA  81 FA 000000B8  *	    cmp    edx, 0B8h
 00002F00  75 0A	   *	    jne    @C0346
 00002F02  BE 0000BCB3 R	            mov     esi,offset _sSYSTEM_RING1_text
				        .ELSEIF (edx == 0c0h)
 00002F07  E9 00000089	   *	    jmp    @C0348
 00002F0C		   *@C0346:
 00002F0C  81 FA 000000C0  *	    cmp    edx, 0C0h
 00002F12  75 07	   *	    jne    @C0349
 00002F14  BE 0000BCC5 R	            mov     esi,offset _sSYSTEM_RING2_text
				        .ELSEIF (edx == 0c8h)
 00002F19  EB 7A	   *	    jmp    @C034B
 00002F1B		   *@C0349:
 00002F1B  81 FA 000000C8  *	    cmp    edx, 0C8h
 00002F21  75 07	   *	    jne    @C034C
 00002F23  BE 0000BCD7 R	            mov     esi,offset _sSYSTEM_RING3_text
				        .ELSEIF (edx == 0d0h)
 00002F28  EB 6B	   *	    jmp    @C034E
 00002F2A		   *@C034C:
 00002F2A  81 FA 000000D0  *	    cmp    edx, 0D0h
 00002F30  75 07	   *	    jne    @C034F
 00002F32  BE 0000BCE9 R	            mov     esi,offset _sDEBI_screen_text
				        .ELSEIF (edx == 0d8h)
 00002F37  EB 5C	   *	    jmp    @C0351
 00002F39		   *@C034F:
 00002F39  81 FA 000000D8  *	    cmp    edx, 0D8h
 00002F3F  75 07	   *	    jne    @C0352
 00002F41  BE 0000BCFA R	            mov     esi,offset _sDEBI_memory_text
				        .ELSEIF (edx == 0e0h)
 00002F46  EB 4D	   *	    jmp    @C0354
 00002F48		   *@C0352:
 00002F48  81 FA 000000E0  *	    cmp    edx, 0E0h
 00002F4E  75 07	   *	    jne    @C0355
 00002F50  BE 0000BD0B R	            mov     esi,offset _sFLOPPY_TRACK_text
				        .ELSEIF (edx == 0e8h)
 00002F55  EB 3E	   *	    jmp    @C0357
 00002F57		   *@C0355:
 00002F57  81 FA 000000E8  *	    cmp    edx, 0E8h
 00002F5D  75 07	   *	    jne    @C0358
 00002F5F  BE 0000BD1D R	            mov     esi,offset _sVGA_BACKUP_text
				        .ELSEIF (edx == 0190h)
 00002F64  EB 2F	   *	    jmp    @C035A
 00002F66		   *@C0358:
 00002F66  81 FA 00000190  *	    cmp    edx, 00190h
 00002F6C  75 07	   *	    jne    @C035B
 00002F6E  BE 0000BD2D R	            mov     esi,offset _sEXODUS_INI_text
				        .ELSEIF (edx == 0198h)
 00002F73  EB 20	   *	    jmp    @C035D
 00002F75		   *@C035B:
 00002F75  81 FA 00000198  *	    cmp    edx, 00198h
 00002F7B  75 07	   *	    jne    @C035E
 00002F7D  BE 0000BD3D R	            mov     esi,offset _sEXODUS_INI_ERRORS_text
				        .ELSEIF (edx == 01a0h)
 00002F82  EB 11	   *	    jmp    @C0360
 00002F84		   *@C035E:
 00002F84  81 FA 000001A0  *	    cmp    edx, 001A0h
 00002F8A  75 07	   *	    jne    @C0361
 00002F8C  BE 0000BD54 R	            mov     esi,offset _sTASK_SYSTEM_text
				        .ELSE
 00002F91  EB 02	   *	    jmp    @C0363
 00002F93		   *@C0361:
 00002F93  EB 0A		            jmp     @F
				        .ENDIF
 00002F95		   *@C0363:
 00002F95		   *@C0360:
 00002F95		   *@C035D:
 00002F95		   *@C035A:
 00002F95		   *@C0357:
 00002F95		   *@C0354:
 00002F95		   *@C0351:
 00002F95		   *@C034E:
 00002F95		   *@C034B:
 00002F95		   *@C0348:
 00002F95		   *@C0345:
 00002F95		   *@C0342:
 00002F95		   *@C033F:
 00002F95		   *@C033C:
 00002F95		   *@C0339:
 00002F95		   *@C0336:
 00002F95		   *@C0333:
 00002F95		   *@C0330:
 00002F95		   *@C032D:
 00002F95		   *@C032A:
 00002F95		   *@C0327:
 00002F95		   *@C0324:
 00002F95		   *@C0321:
 00002F95		   *@C031E:
 00002F95		   *@C031B:
 00002F95		   *@C0318:
 00002F95		   *@C0315:
 00002F95		   *@C0312:
 00002F95		   *@C030F:
 00002F95		   *@C030C:
 00002F95		   *@C0309:
 00002F95  BF 0000BD8E R	        mov     edi,offset _selector_text
 00002F9A  E8 FFFFDF27		        call    invDEBI_quick_watch_add_item
 00002F9F			      @@:
 00002F9F  C3			        ret
 00002FA0			    invDEBI_quick_watch_show_EBP_relative_selector      ENDP




 00002FA0			    invDEBI_quick_watch_show_EBP_relative_32        PROC
				    ; This routine displays a 32-bit value that's in the data Debi saved when it was called
 00002FA0  0F BF 5F 15		        movsx   ebx,word ptr ds:[edi+_MO_DATA]
 00002FA4  36: 8B 14 2B		        mov     edx,dword ptr ss:[ebp+ebx]
 00002FA8  E8 00000001		        call    invDEBI_quick_watch_common_32
 00002FAD  C3			        ret
 00002FAE			    invDEBI_quick_watch_show_EBP_relative_32        ENDP




 00002FAE			    invDEBI_quick_watch_common_32       PROC
				    ; This routine displays the value in edx in three different formats
				    ;
				    ; Upon entry:   edx - value to display
				    ;
				    ; Upon exit:    It is displayed in hex, decimal and binary
				    ;
 00002FAE  E8 FFFFE0AA		        call    invDEBI_quick_watch_add_divider
 00002FB3  BB 00000010		        mov     ebx,16
 00002FB8  BF 0000BD99 R	        mov     edi,offset hex_text
 00002FBD  E8 FFFFE01C		        call    invDEBI_quick_watch_add_radix_in_edx
 00002FC2  BB 0000000A		        mov     ebx,10
 00002FC7  BF 0000BD9F R	        mov     edi,offset dec_text
 00002FCC  E8 FFFFE00D		        call    invDEBI_quick_watch_add_radix_in_edx
 00002FD1  BB 00000002		        mov     ebx,2
 00002FD6  BF 0000BDA5 R	        mov     edi,offset bin_text
 00002FDB  E8 FFFFDFFE		        call    invDEBI_quick_watch_add_radix_in_edx
 00002FE0  BF 0000BDAB R	        mov     edi,offset real4_text
 00002FE5  E8 FFFFE046		        call    invDEBI_quick_watch_add_real4_in_edx
 00002FEA  C3			        ret
 00002FEB			    invDEBI_quick_watch_common_32       ENDP




 00002FEB			    invDEBI_quick_watch_show_fpu_cw     PROC
 00002FEB  0F BF 5F 15		        movsx   ebx,word ptr ds:[edi+_MO_DATA]
 00002FEF  36: 0F B7 14 2B	        movzx   edx,word ptr ss:[ebp+ebx]

				      ; Show the value in binary
 00002FF4  E8 FFFFE064		        call    invDEBI_quick_watch_add_divider
 00002FF9  BB 00000010		        mov     ebx,16
 00002FFE  BF 0000BD99 R	        mov     edi,offset hex_text
 00003003  E8 FFFFDFD6		        call    invDEBI_quick_watch_add_radix_in_edx
 00003008  BB 00000002		        mov     ebx,2
 0000300D  BF 0000BDA5 R	        mov     edi,offset bin_text
 00003012  E8 FFFFDFC7		        call    invDEBI_quick_watch_add_radix_in_edx

 00003017  8B DA		        mov     ebx,edx
 00003019  81 E3 00000C00	        and     ebx,_CW_ROUNDING
				        .IF (ebx == _CW_ROUNDING_00)
 0000301F  0B DB	   *	    or	ebx, ebx
 00003021  75 07	   *	    jne    @C0364
				          ; Round to nearest
 00003023  BE 0000B699 R	            mov     esi,offset round_to_nearest
				        .ELSEIF (ebx == _CW_ROUNDING_01)
 00003028  EB 23	   *	    jmp    @C0366
 0000302A		   *@C0364:
 0000302A  81 FB 00000400  *	    cmp    ebx, _CW_ROUNDING_01
 00003030  75 07	   *	    jne    @C0367
				          ; Round down
 00003032  BE 0000B6A3 R	            mov     esi,offset round_down
				        .ELSEIF (ebx == _CW_ROUNDING_10)
 00003037  EB 14	   *	    jmp    @C0369
 00003039		   *@C0367:
 00003039  81 FB 00000800  *	    cmp    ebx, _CW_ROUNDING_10
 0000303F  75 07	   *	    jne    @C036A
				          ; Round up
 00003041  BE 0000B6A9 R	            mov     esi,offset round_up
				        .ELSE
 00003046  EB 05	   *	    jmp    @C036C
 00003048		   *@C036A:
				          ; Truncate
 00003048  BE 0000B6AD R	            mov     esi,offset round_truncate
				        .ENDIF
 0000304D		   *@C036C:
 0000304D		   *@C0369:
 0000304D		   *@C0366:
 0000304D  BF 0000BDC6 R	        mov     edi,offset rounding_text
 00003052  E8 FFFFDE6F		        call    invDEBI_quick_watch_add_item

 00003057  8B DA		        mov     ebx,edx
 00003059  81 E3 00000300	        and     ebx,_CW_PRECISION
				        .IF (ebx == _CW_PRECISION_00)
 0000305F  0B DB	   *	    or	ebx, ebx
 00003061  75 07	   *	    jne    @C036D
				          ; Single (23 bit w/1)
 00003063  BE 0000B6B4 R	            mov     esi,offset precision_single
				        .ELSEIF (ebx == _CW_PRECISION_01)
 00003068  EB 23	   *	    jmp    @C036F
 0000306A		   *@C036D:
 0000306A  81 FB 00000100  *	    cmp    ebx, _CW_PRECISION_01
 00003070  75 07	   *	    jne    @C0370
				          ; Reserved
 00003072  BE 0000B6C1 R	            mov     esi,offset precision_reserved
				        .ELSEIF (ebx == _CW_PRECISION_10)
 00003077  EB 14	   *	    jmp    @C0372
 00003079		   *@C0370:
 00003079  81 FB 00000200  *	    cmp    ebx, _CW_PRECISION_10
 0000307F  75 07	   *	    jne    @C0373
				          ; Double (53 bit w/1)
 00003081  BE 0000B6D2 R	            mov     esi,offset precision_double
				        .ELSE
 00003086  EB 05	   *	    jmp    @C0375
 00003088		   *@C0373:
				          ; Extended (64 bit w/1)
 00003088  BE 0000B6DF R	            mov     esi,offset precision_extended
				        .ENDIF
 0000308D		   *@C0375:
 0000308D		   *@C0372:
 0000308D		   *@C036F:
 0000308D  BF 0000BDD1 R	        mov     edi,offset precision_prefix_text
 00003092  E8 FFFFDE2F		        call    invDEBI_quick_watch_add_item

 00003097  BF 0000BDE9 R	        mov     edi,offset mask_text
 0000309C  F7 C2 00000020	        test    edx,_CW_PM
				        .IF (!zero?)
 000030A2  74 0A	   *	    je     @C0376
 000030A4  BE 0000B6E6 R	            mov     esi,offset precision_text
 000030A9  E8 FFFFDE18		            call    invDEBI_quick_watch_add_item
				        .ENDIF
 000030AE		   *@C0376:

 000030AE  F7 C2 00000010	        test    edx,_CW_UM
				        .IF (!zero?)
 000030B4  74 0A	   *	    je     @C0378
 000030B6  BE 0000B6F0 R	            mov     esi,offset underflow_text
 000030BB  E8 FFFFDE06		            call    invDEBI_quick_watch_add_item
				        .ENDIF
 000030C0		   *@C0378:

 000030C0  F7 C2 00000008	        test    edx,_CW_OM
				        .IF (!zero?)
 000030C6  74 0A	   *	    je     @C037A
 000030C8  BE 0000B6FA R	            mov     esi,offset overflow_text
 000030CD  E8 FFFFDDF4		            call    invDEBI_quick_watch_add_item
				        .ENDIF
 000030D2		   *@C037A:

 000030D2  F7 C2 00000004	        test    edx,_CW_ZM
				        .IF (!zero?)
 000030D8  74 0A	   *	    je     @C037C
 000030DA  BE 0000B703 R	            mov     esi,offset divide_by_zero_text
 000030DF  E8 FFFFDDE2		            call    invDEBI_quick_watch_add_item
				        .ENDIF
 000030E4		   *@C037C:

 000030E4  F7 C2 00000002	        test    edx,_CW_DM
				        .IF (!zero?)
 000030EA  74 0A	   *	    je     @C037E
 000030EC  BE 0000B712 R	            mov     esi,offset denormalized_text
 000030F1  E8 FFFFDDD0		            call    invDEBI_quick_watch_add_item
				        .ENDIF
 000030F6		   *@C037E:

 000030F6  F7 C2 00000001	        test    edx,_CW_IM
				        .IF (!zero?)
 000030FC  74 0A	   *	    je     @C0380
 000030FE  BE 0000B71F R	            mov     esi,offset invalid_text
 00003103  E8 FFFFDDBE		            call    invDEBI_quick_watch_add_item
				        .ENDIF
 00003108		   *@C0380:

 00003108  C3			        ret
 00003109			    invDEBI_quick_watch_show_fpu_cw     ENDP




 00003109			    invDEBI_quick_watch_show_fpu_sw     PROC
 00003109  0F BF 5F 15		        movsx   ebx,word ptr ds:[edi+_MO_DATA]
 0000310D  36: 0F B7 14 2B	        movzx   edx,word ptr ss:[ebp+ebx]

				      ; Show the value in binary
 00003112  E8 FFFFDF46		        call    invDEBI_quick_watch_add_divider
 00003117  BB 00000010		        mov     ebx,16
 0000311C  BF 0000BD99 R	        mov     edi,offset hex_text
 00003121  E8 FFFFDEB8		        call    invDEBI_quick_watch_add_radix_in_edx
 00003126  BB 00000002		        mov     ebx,2
 0000312B  BF 0000BDA5 R	        mov     edi,offset bin_text
 00003130  E8 FFFFDEA9		        call    invDEBI_quick_watch_add_radix_in_edx

 00003135  F7 C2 00008000	        test    edx,_SW_BUSY
				        .IF (!zero?)
 0000313B  74 0A	   *	    je     @C0382
 0000313D  BE 0000B74B R	            mov     esi,offset busy
 00003142  E8 FFFFDD7F		            call    invDEBI_quick_watch_add_item
				        .ENDIF
 00003147		   *@C0382:

				      ; Display the condition codes in binary
 00003147  8B DA		        mov     ebx,edx
 00003149  81 E3 00004000	        and     ebx,_SW_C3
 0000314F  C1 EB 0B		        shr     ebx,11
 00003152  8B CA		        mov     ecx,edx
 00003154  81 E1 00000700	        and     ecx,_SW_C2 or _SW_C1 or _SW_C0
 0000315A  C1 E9 FF		        shr     ecx,_SW_C0-1
 0000315D  0B D9		        or      ebx,ecx
				      ; Right now, ecx contains the value
 0000315F  52			        push    edx
 00003160  8B D3		        mov     edx,ebx
 00003162  BB 00000002		        mov     ebx,2
 00003167  BF 0000BDF0 R	        mov     edi,offset condition_codes_text
 0000316C  E8 FFFFDE6D		        call    invDEBI_quick_watch_add_radix_in_edx
 00003171  5A			        pop     edx

				      ; Top of stack
 00003172  8B DA		        mov     ebx,edx
 00003174  81 E3 00003800	        and     ebx,_SW_TOS
 0000317A  C1 EB 0B		        shr     ebx,11
 0000317D  52			        push    edx
 0000317E  8B D3		        mov     edx,ebx
 00003180  BB 0000000A		        mov     ebx,10
 00003185  BF 0000BDF8 R	        mov     edi,offset top_of_stack_text
 0000318A  E8 FFFFDE4F		        call    invDEBI_quick_watch_add_radix_in_edx
 0000318F  5A			        pop     edx

				      ; Add all of the flags
 00003190  BF FFFFFFFF		        mov     edi,-1
 00003195  F7 C2 00000080	        test    edx,_SW_ERROR_SUMMARY
				        .IF (!zero?)
 0000319B  74 0A	   *	    je     @C0384
 0000319D  BE 0000B731 R	            mov     esi,offset error_summary
 000031A2  E8 FFFFDD1F		            call    invDEBI_quick_watch_add_item
				        .ENDIF
 000031A7		   *@C0384:

 000031A7  F7 C2 00000040	        test    edx,_SW_STACK_FAULT
				        .IF (!zero?)
 000031AD  74 0A	   *	    je     @C0386
 000031AF  BE 0000B73F R	            mov     esi,offset stack_fault
 000031B4  E8 FFFFDD0D		            call    invDEBI_quick_watch_add_item
				        .ENDIF
 000031B9		   *@C0386:

 000031B9  BF 0000BDDD R	        mov     edi,offset exception_prefix_text
 000031BE  F7 C2 00000020	        test    edx,_SW_PE
				        .IF (!zero?)
 000031C4  74 0A	   *	    je     @C0388
 000031C6  BE 0000B6E6 R	            mov     esi,offset precision_text
 000031CB  E8 FFFFDCF6		            call    invDEBI_quick_watch_add_item
				        .ENDIF
 000031D0		   *@C0388:

 000031D0  F7 C2 00000010	        test    edx,_SW_UE
				        .IF (!zero?)
 000031D6  74 0A	   *	    je     @C038A
 000031D8  BE 0000B6F0 R	            mov     esi,offset underflow_text
 000031DD  E8 FFFFDCE4		            call    invDEBI_quick_watch_add_item
				        .ENDIF
 000031E2		   *@C038A:

 000031E2  F7 C2 00000008	        test    edx,_SW_OE
				        .IF (!zero?)
 000031E8  74 0A	   *	    je     @C038C
 000031EA  BE 0000B6FA R	            mov     esi,offset overflow_text
 000031EF  E8 FFFFDCD2		            call    invDEBI_quick_watch_add_item
				        .ENDIF
 000031F4		   *@C038C:

 000031F4  F7 C2 00000004	        test    edx,_SW_ZE
				        .IF (!zero?)
 000031FA  74 0A	   *	    je     @C038E
 000031FC  BE 0000B703 R	            mov     esi,offset divide_by_zero_text
 00003201  E8 FFFFDCC0		            call    invDEBI_quick_watch_add_item
				        .ENDIF
 00003206		   *@C038E:

 00003206  F7 C2 00000002	        test    edx,_SW_DE
				        .IF (!zero?)
 0000320C  74 0A	   *	    je     @C0390
 0000320E  BE 0000B712 R	            mov     esi,offset denormalized_text
 00003213  E8 FFFFDCAE		            call    invDEBI_quick_watch_add_item
				        .ENDIF
 00003218		   *@C0390:

 00003218  F7 C2 00000001	        test    edx,_SW_IE
				        .IF (!zero?)
 0000321E  74 0A	   *	    je     @C0392
 00003220  BE 0000B71F R	            mov     esi,offset invalid_text
 00003225  E8 FFFFDC9C		            call    invDEBI_quick_watch_add_item
				        .ENDIF
 0000322A		   *@C0392:
 0000322A  C3			        ret
 0000322B			    invDEBI_quick_watch_show_fpu_sw     ENDP




 0000322B			    invDEBI_quick_watch_show_fpu_tw     PROC
 0000322B  0F BF 5F 15		        movsx   ebx,word ptr ds:[edi+_MO_DATA]
 0000322F  36: 0F B7 14 2B	        movzx   edx,word ptr ss:[ebp+ebx]

 00003234  E8 FFFFDE24		        call    invDEBI_quick_watch_add_divider
 00003239  B9 00000008		        mov     ecx,8
 0000323E  BF 0000BDFE R	        mov     edi,offset stx_text
 00003243  C6 47 02 37		        mov     byte ptr ds:[edi+2],'7'
 00003247			      @@:
 00003247  8A DA		        mov     bl,dl
 00003249  80 E3 03		        and     bl,11b
				        .IF (bl == 00b)
 0000324C  0A DB	   *	    or	bl, bl
 0000324E  75 07	   *	    jne    @C0394
				          ; Valid
 00003250  BE 0000B74F R	            mov     esi,offset tag_valid
				        .ELSEIF (bl == 01b)
 00003255  EB 1D	   *	    jmp    @C0396
 00003257		   *@C0394:
 00003257  80 FB 01	   *	    cmp    bl, 001h
 0000325A  75 07	   *	    jne    @C0397
				          ; Zero
 0000325C  BE 0000B755 R	            mov     esi,offset tag_zero
				        .ELSEIF (bl == 10b)
 00003261  EB 11	   *	    jmp    @C0399
 00003263		   *@C0397:
 00003263  80 FB 02	   *	    cmp    bl, 002h
 00003266  75 07	   *	    jne    @C039A
				          ; Special
 00003268  BE 0000B75A R	            mov     esi,offset tag_special
				        .ELSE
 0000326D  EB 05	   *	    jmp    @C039C
 0000326F		   *@C039A:
				          ; Empty
 0000326F  BE 0000B762 R	            mov     esi,offset tag_empty
				        .ENDIF
 00003274		   *@C039C:
 00003274		   *@C0399:
 00003274		   *@C0396:
 00003274  E8 FFFFDC4D		        call    invDEBI_quick_watch_add_item
 00003279  FE 4F 02		        dec     byte ptr ds:[edi+2]
 0000327C  66| C1 CA 02		        ror     dx,2
 00003280  E2 C5		        loop    @B
 00003282  C3			        ret
 00003283			    invDEBI_quick_watch_show_fpu_tw     ENDP




 00003283			    invDEBI_quick_watch_stack_32        PROC
				    ; This routine displays a 32-bit value that's on the user's stack
 00003283  0F BF 5F 15		        movsx   ebx,word ptr ds:[edi+_MO_DATA]
 00003287  8B 55 FC		        mov     edx,dword ptr ss:[ebp-04]
 0000328A  36: 8B 14 13		        mov     edx,dword ptr ss:[edx+ebx]
 0000328E  E8 FFFFDDCA		        call    invDEBI_quick_watch_add_divider
 00003293  E8 FFFFFD16		        call    invDEBI_quick_watch_common_32
 00003298  C3			        ret
 00003299			    invDEBI_quick_watch_stack_32        ENDP




 00003299			    invDEBI_quick_watch_locals_32       PROC
				    ; This routine displays a 32-bit value that's on the user's stack
 00003299  0F BF 5F 15		        movsx   ebx,word ptr ds:[edi+_MO_DATA]
 0000329D  8B 55 00		        mov     edx,dword ptr ss:[ebp+00]
 000032A0  36: 8B 14 13		        mov     edx,dword ptr ss:[edx+ebx]
 000032A4  E8 FFFFDDB4		        call    invDEBI_quick_watch_add_divider
 000032A9  E8 FFFFFD00		        call    invDEBI_quick_watch_common_32
 000032AE  C3			        ret
 000032AF			    invDEBI_quick_watch_locals_32       ENDP




 000032AF			    invDEBI_quick_watch_show_fpu_opcode     PROC
				    ; This routine displays the 11 bits of an FPU opcode.  It is known that the prefix bits are always 11011.
				    ; These 11-bits help to make up the entire opcode.  That opcode is used here and the corresponding FPU command is found.
				    ;
 000032AF  1E			        push    ds
 000032B0  BB 0000D800		        mov     ebx,1101100000000000b
 000032B5  0F BF 57 15		        movsx   edx,word ptr ds:[edi+_MO_DATA]
 000032B9  36: 0F B7 14 2A	        movzx   edx,word ptr ss:[ebp+edx]
 000032BE  81 E2 000007FF	        and     edx,0000011111111111b
 000032C4  0B DA		        or      ebx,edx
				      ; Right now, ebx - opcode of last FPU instruction
 000032C6  E8 FFFFDD92		        call    invDEBI_quick_watch_add_divider
 000032CB  FF 1D 0000D111 R	        call    fword ptr ds:_X86_fpu_opcode
 000032D1  BF 0000BDBD R	        mov     edi,offset disasm_text
 000032D6  E8 FFFFDC5D		        call    invDEBI_quick_watch_add_item_ecx
 000032DB  1F			        pop     ds
 000032DC  C3			        ret
 000032DD			    invDEBI_quick_watch_show_fpu_opcode     ENDP




 000032DD			    invDEBI_mem1_window     PROC
 000032DD  B4 00		        mov     ah,0                                                ; Ul X
 000032DF  B0 01		        mov     al,1                                                ; Ul Y
 000032E1  B7 0E		        mov     bh,14                                               ; Lr X
 000032E3  B3 0C		        mov     bl,12                                               ; Lr Y
 000032E5  E8 0000002B		        call    invDEBI_populate_mem_window
 000032EA  C3			        ret
 000032EB			    invDEBI_mem1_window     ENDP




 000032EB			    invDEBI_mem2_window     PROC
 000032EB  B4 00		        mov     ah,0                                                ; Ul X
 000032ED  B0 01		        mov     al,1                                                ; Ul Y
 000032EF  B7 1D		        mov     bh,29                                               ; Lr X
 000032F1  B3 0C		        mov     bl,12                                               ; Lr Y
 000032F3  E8 0000001D		        call    invDEBI_populate_mem_window
 000032F8  C3			        ret
 000032F9			    invDEBI_mem2_window     ENDP




 000032F9			    invDEBI_mem3_window     PROC
 000032F9  B4 00		        mov     ah,0                                                ; Ul X
 000032FB  B0 01		        mov     al,1                                                ; Ul Y
 000032FD  B7 2C		        mov     bh,44                                               ; Lr X
 000032FF  B3 0C		        mov     bl,12                                               ; Lr Y
 00003301  E8 0000000F		        call    invDEBI_populate_mem_window
 00003306  C3			        ret
 00003307			    invDEBI_mem3_window     ENDP




 00003307			    invDEBI_mem4_window     PROC
 00003307  B4 00		        mov     ah,0                                                ; Ul X
 00003309  B0 01		        mov     al,1                                                ; Ul Y
 0000330B  B7 3B		        mov     bh,59                                               ; Lr X
 0000330D  B3 0C		        mov     bl,12                                               ; Lr Y
 0000330F  E8 00000001		        call    invDEBI_populate_mem_window
 00003314  C3			        ret
 00003315			    invDEBI_mem4_window     ENDP




 00003315			    invDEBI_populate_mem_window     PROC
				    ; This routine is called to populate a memory window
				    ;
				    ; Upon entry:      ah,al - Upper left X,Y
				    ;                  bh,bl - Lower right X,Y
				    ;               ds:[esi] - far ptr to mem.x window object
				    ;
				    ; Upon exit:    The window is populated with whatever the current address expression suggests
				    ;
				        .IF (dword ptr ds:[esi+_ST_MEMVAR_OFFSET] != -1)
 00003315  83 7E 0C FF	   *	    cmp    dword ptr ds : [esi + _ST_MEMVAR_OFFSET], - 001h
 00003319  0F 84 00000150  *	    je     @C039D
 0000331F  06			            push    es                                              ; Copy data from the MEMVAR memory into local variables
 00003320  53			            push    ebx
 00003321  56			            push    esi
 00003322  BB 000000D8		            mov     ebx,_sDEBI_memory
 00003327  8E C3		            mov     es,ebx
 00003329  BB 0000AA8A R	            mov     ebx,offset DEBI_exp_memvar_list
 0000332E  8B 76 0C		            mov     esi,dword ptr ds:[esi+_ST_MEMVAR_OFFSET]
 00003331  E8 00001755		            call    invDEBI_from_object_memvar
 00003336  5E			            pop     esi
 00003337  5B			            pop     ebx
 00003338  07			            pop     es

				          ; See if we need to update the data there
				            .IF (ds:live == 'X' || ds:force_func_windows == _YES)
 00003339  80 3D 0000ABDC R
	   58		   *	    cmp    ds : live, 'X'
 00003340  74 0D	   *	    je     @C03A0
 00003342  80 3D 0000B8B2 R
	   01		   *	    cmp    ds : force_func_windows, _YES
 00003349  0F 85 00000120  *	    jne    @C039F
 0000334F		   *@C03A0:
				              ; It is a live expression (which means whatever on the screen being displayed right now needs to be overwritten)
 0000334F  9C			                pushfd
 00003350  FA			                cli
 00003351  E8 0000060C		                call    invDEBI_get_mem_window_coords
 00003356  BE 0000AFBD R	                mov     esi,offset text_22
 0000335B  B9 00000016		                mov     ecx,sizeof text_22 - 1
 00003360  E8 0000174A		                call    invDEBI_parse_expression
 00003365  0F 82 00000104	                jc      quit                                        ; Branch if error in expression
 0000336B  A3 0000B8CC R	                mov     ds:mem_segment,eax
 00003370  89 1D 0000B8D0 R	                mov     ds:mem_offset,ebx

				              ; Obtain limit for this selector (to find out when a pointer is going beyond readable memory)
 00003376  8B D0		                mov     edx,eax                                     ; Selector
 00003378  B8 67657420		                mov     eax,'get '
 0000337D  BB 6C696D69		                mov     ebx,'limi'
 00003382  FF 1D 0000D0D7 R	                call    fword ptr ds:_EXODUS_requestor
 00003388  89 0D 0000B8D8 R	                mov     ds:mem_limit,ecx

 0000338E  BE 0000AFD4 R	                mov     esi,offset disp_22
 00003393  B9 00000016		                mov     ecx,sizeof disp_22 - 1
 00003398  E8 00001712		                call    invDEBI_parse_expression
 0000339D  0F 82 000000CC	                jc      quit                                        ; Branch if error in expressions
 000033A3  89 1D 0000B8D4 R	                mov     ds:mem_displacement,ebx

				              ; Display the top line (if any)
				                .IF (ds:show_addresses == 'X')
 000033A9  80 3D 0000AC34 R
	   58		   *	    cmp    ds : show_addresses, 'X'
 000033B0  75 0C	   *	    jne    @C03A2
 000033B2  E8 000000B9		                    call    invDEBI_pop_line_show_address
 000033B7  B8 00000001		                    mov     eax,1
				                .ELSE
 000033BC  EB 02	   *	    jmp    @C03A4
 000033BE		   *@C03A2:
 000033BE  33 C0		                    xor     eax,eax
				                .ENDIF
 000033C0		   *@C03A4:
 000033C0  83 EC 04		                sub     esp,4
				              ; [esp+0] - dword, holds current Y value (for each line displayed)

				              ; Now, for each line, parse the data
 000033C3  89 04 24		                mov     dword ptr ss:[esp+0],eax
 000033C6  E9 00000091		                jmp     @F
				                .WHILE (eax <= ds:mem_height)
 000033CB  E9 0000008F	   *	    jmp    @C03A5
 000033D0		   *@C03A6:
				                  ; Determine the window type and populate a line of data based on that type
				                    .IF (ds:ascii_char == 'X')
 000033D0  80 3D 0000ACAC R
	   58		   *	    cmp    ds : ascii_char, 'X'
 000033D7  75 07	   *	    jne    @C03A7
 000033D9			                      default_window:
 000033D9  E8 000000F6		                        call    invDEBI_pop_line_mem_window_ascii_char
				                    .ELSEIF (ds:_byte == 'X')
 000033DE  EB 72	   *	    jmp    @C03A9
 000033E0		   *@C03A7:
 000033E0  80 3D 0000ACD8 R
	   58		   *	    cmp    ds : _byte, 'X'
 000033E7  75 07	   *	    jne    @C03AA
 000033E9  E8 00000181		                        call    invDEBI_pop_line_mem_window_byte
				                    .ELSEIF (ds:_word == 'X')
 000033EE  EB 62	   *	    jmp    @C03AC
 000033F0		   *@C03AA:
 000033F0  80 3D 0000AD04 R
	   58		   *	    cmp    ds : _word, 'X'
 000033F7  75 07	   *	    jne    @C03AD
 000033F9  E8 00000213		                        call    invDEBI_pop_line_mem_window_word
				                    .ELSEIF (ds:_dword == 'X')
 000033FE  EB 52	   *	    jmp    @C03AF
 00003400		   *@C03AD:
 00003400  80 3D 0000AD30 R
	   58		   *	    cmp    ds : _dword, 'X'
 00003407  75 07	   *	    jne    @C03B0
 00003409  E8 000002C1		                        call    invDEBI_pop_line_mem_window_dword
				                    .ELSEIF (ds:_qword == 'X')
 0000340E  EB 42	   *	    jmp    @C03B2
 00003410		   *@C03B0:
 00003410  80 3D 0000AD5C R
	   58		   *	    cmp    ds : _qword, 'X'
 00003417  75 07	   *	    jne    @C03B3
 00003419  E8 00000384		                        call    invDEBI_pop_line_mem_window_qword
				                    .ELSEIF (ds:float32 == 'X')
 0000341E  EB 32	   *	    jmp    @C03B5
 00003420		   *@C03B3:
 00003420  80 3D 0000AD88 R
	   58		   *	    cmp    ds : float32, 'X'
 00003427  75 07	   *	    jne    @C03B6
 00003429  E8 00001CEC		                        call    invDEBI_pop_line_mem_window_float32
				                    .ELSEIF (ds:float64 == 'X')
 0000342E  EB 22	   *	    jmp    @C03B8
 00003430		   *@C03B6:
 00003430  80 3D 0000ADB4 R
	   58		   *	    cmp    ds : float64, 'X'
 00003437  75 07	   *	    jne    @C03B9
 00003439  E8 00001CE2		                        call    invDEBI_pop_line_mem_window_float64
				                    .ELSEIF (ds:float80 == 'X')
 0000343E  EB 12	   *	    jmp    @C03BB
 00003440		   *@C03B9:
 00003440  80 3D 0000ADE0 R
	   58		   *	    cmp    ds : float80, 'X'
 00003447  75 07	   *	    jne    @C03BC
 00003449  E8 00001CD8		                        call    invDEBI_pop_line_mem_window_float80
				                    .ELSE
 0000344E  EB 02	   *	    jmp    @C03BE
 00003450		   *@C03BC:
 00003450  EB 87		                        jmp     default_window
				                    .ENDIF
 00003452		   *@C03BE:
 00003452		   *@C03BB:
 00003452		   *@C03B8:
 00003452		   *@C03B5:
 00003452		   *@C03B2:
 00003452		   *@C03AF:
 00003452		   *@C03AC:
 00003452		   *@C03A9:
 00003452  FF 04 24		                    inc     dword ptr ss:[esp+0]                    ; Move to next logical line
 00003455  83 05 0000B8C0 R	                    add     ds:mem_ul_y,FONT_Y                      ; Move down to next displayable line
	   06
 0000345C			                  @@:
 0000345C  8B 04 24		                    mov     eax,dword ptr ss:[esp+0]
				                .ENDW
 0000345F		   *@C03A5:
 0000345F  3B 05 0000B8C8 R *	    cmp    eax, ds : mem_height
 00003465  0F 86 FFFFFF65  *	    jbe    @C03A6

 0000346B  83 C4 04		                add     esp,4
 0000346E  9D			                popfd
				            .ENDIF
				        .ENDIF
 0000346F		   *@C039F:
 0000346F		   *@C039D:
 0000346F			      quit:
 0000346F  C3			        ret
 00003470			    invDEBI_populate_mem_window     ENDP




				    ; All routines below receive the same input.
				    ;
				    ; Upon entry:     ds:mem_ul_x - starting X pixel coordinate
				    ;                 ds:mem_ul_y - starting Y pixel coordinate
				    ;                ds:mem_width - # of characters wide before spilling out of window
				    ;               ds:mem_height - # of lines tall before spilling out of window
				    ;              ds:mem_segment - segment to use for addresses
				    ;               ds:mem_offset - offset to use for addresses
				    ;         ds:mem_displacement - displacement to use for address
				    ;
				    ; Upon exit:    The memory window is populated
				    ;
 00003470			    invDEBI_pop_line_show_address       PROC
				    ; This routine is used to show the address
 00003470  60			        pushad
 00003471  1E			        push    ds
 00003472  06			        push    es
 00003473  C8 0010 00		        enter   16,0

				      ; Data gets stored to ss:[esp] converted to es:[edi] (Note, esi is used below for display purposes)
 00003477  16			        push    ss
 00003478  07			        pop     es
 00003479  8B FC		        mov     edi,esp
 0000347B  8B F4		        mov     esi,esp
 0000347D  66| 26: C7 07	        mov     word ptr es:[edi],'x0'
	   7830
 00003483  83 C7 02		        add     edi,2
				      ; Store the segment
 00003486  A1 0000B8CC R	        mov     eax,ds:mem_segment
 0000348B  C1 C8 0C		        ror     eax,12
 0000348E  B9 00000004		        mov     ecx,4
 00003493  E8 0000047D		        call    invDEBI_store_ecx_hexadecimal_in_eax
 00003498  B0 3A		        mov     al,':'
 0000349A  AA			        stosb

				      ; Store the offset
 0000349B  A1 0000B8D0 R	        mov     eax,ds:mem_offset
 000034A0  C1 C0 04		        rol     eax,4
 000034A3  B9 00000008		        mov     ecx,8
 000034A8  E8 00000468		        call    invDEBI_store_ecx_hexadecimal_in_eax
 000034AD  32 C0		        xor     al,al
 000034AF  AA			        stosb

				      ; Show the address
 000034B0  16			        push    ss
 000034B1  1F			        pop     ds
 000034B2  2E: FF 35		        push    cs:mem_ul_x                                         ; horizontal
	   0000B8BC R
 000034B9  2E: FF 35		        push    cs:mem_ul_y                                         ; vertical
	   0000B8C0 R
 000034C0  56			        push    esi                                                 ; start of text we've just created to display
 000034C1  2E: FF 1D		        call    fword ptr cs:_VID_g_mono_display_text               ;
	   0000D0E3 R

 000034C8  C9			        leave
 000034C9  07			        pop     es
 000034CA  1F			        pop     ds
 000034CB  61			        popad

				      ; Move down to next displayable line
 000034CC  83 05 0000B8C0 R	        add     ds:mem_ul_y,FONT_Y
	   06
 000034D3  C3			        ret
 000034D4			    invDEBI_pop_line_show_address       ENDP




 000034D4			    invDEBI_pop_line_mem_window_ascii_char      PROC
				    ; This routine is called to display a line of data in an ASCII character format
 000034D4  E8 000003C3		        call    invDEBI_pop_line_show_displacement
				        .IF (ds:show_addresses == 'X')
 000034D9  80 3D 0000AC34 R
	   58		   *	    cmp    ds : show_addresses, 'X'
 000034E0  75 07	   *	    jne    @C03C0
 000034E2  83 05 0000B8DC R	            add     ds:mem_temp_x,1*FONT_X                          ; Move over one more space between displacement and data
	   08
				        .ENDIF
 000034E9		   *@C03C0:
 000034E9  60			        pushad
 000034EA  1E			        push    ds
 000034EB  06			        push    es
 000034EC  C8 00B8 00		        enter   184,0                                               ; Screen is 90 columns wide, must accomodate a potential max!

				      ; Get our temporary destination address
 000034F0  16			        push    ss
 000034F1  07			        pop     es
 000034F2  8B FC		        mov     edi,esp

				      ; Get our source address
 000034F4  8E 1D 0000B8CC R	        mov     ds,ds:mem_segment
 000034FA  2E: 8B 35		        mov     esi,cs:mem_offset
	   0000B8D0 R
 00003501  2E: 03 35		        add     esi,cs:mem_displacement
	   0000B8D4 R

				      ; Now, copy the text to our temp area
 00003508  2E: 8B 15		        mov     edx,cs:mem_temp_x
	   0000B8DC R
 0000350F  2E: 8B 0D		        mov     ecx,cs:mem_max_x
	   0000B8E0 R
 00003516  33 DB		        xor     ebx,ebx
				        .WHILE (edx < ecx && ebx < 90)                              ; while temp_x < max_x and count < 90)
 00003518  EB 24	   *	    jmp    @C03C2
 0000351A		   *@C03C3:
 0000351A  83 C2 08		            add     edx,FONT_X
				            .IF (edx < ecx)
 0000351D  3B D1	   *	    cmp    edx, ecx
 0000351F  73 03	   *	    jae    @C03C4
 00003521  B0 A8		                mov     al,168                                      ; Store the ® character (indicating the character to the right
 00003523  AA			                stosb                                               ;                 should be displayed regardless of what it is)
				            .ENDIF
				            .IF (esi <= cs:mem_limit)
 00003524		   *@C03C4:
 00003524  2E: 3B 35
	   0000B8D8 R	   *	    cmp    esi, cs : mem_limit
 0000352B  77 09	   *	    ja     @C03C6
 0000352D  AC			                lodsb
 0000352E  0A C0		                or      al,al
 00003530  75 06		                jnz     @F
 00003532  B0 FF		                mov     al,-1
				            .ELSE
 00003534  EB 02	   *	    jmp    @C03C8
 00003536		   *@C03C6:
 00003536  B0 3F		                mov     al,'?'
				            .ENDIF
 00003538			          @@:
				            .IF (edx < ecx)
 00003538		   *@C03C8:
 00003538  3B D1	   *	    cmp    edx, ecx
 0000353A  73 01	   *	    jae    @C03C9
 0000353C  AA			                stosb
				            .ENDIF
 0000353D		   *@C03C9:
 0000353D  43			            inc     ebx
				        .ENDW
 0000353E		   *@C03C2:
 0000353E  3B D1	   *	    cmp    edx, ecx
 00003540  73 05	   *	    jae    @C03CB
 00003542  83 FB 5A	   *	    cmp    ebx, 05Ah
 00003545  72 D3	   *	    jb     @C03C3
 00003547		   *@C03CB:
 00003547  32 C0		        xor     al,al
 00003549  AA			        stosb

				      ; Now, display what we've just copied
 0000354A  16			        push    ss
 0000354B  1F			        pop     ds
 0000354C  8B F4		        mov     esi,esp
 0000354E  2E: FF 35		        push    cs:mem_temp_x
	   0000B8DC R
 00003555  2E: FF 35		        push    cs:mem_ul_y
	   0000B8C0 R
 0000355C  56			        push    esi
 0000355D  2E: FF 1D		        call    fword ptr cs:_VID_g_mono_display_text
	   0000D0E3 R

				      ; We're finished
 00003564  C9			        leave
 00003565  07			        pop     es
 00003566  1F			        pop     ds
 00003567  01 1D 0000B8D4 R	        add     ds:mem_displacement,ebx
 0000356D  61			        popad
 0000356E  C3			        ret
 0000356F			    invDEBI_pop_line_mem_window_ascii_char      ENDP




 0000356F			    invDEBI_pop_line_mem_window_byte            PROC
				    ; This routine is called to display a line of data in a BYTE format
 0000356F  E8 00000328		        call    invDEBI_pop_line_show_displacement
				        .IF (ds:show_addresses == 'X')
 00003574  80 3D 0000AC34 R
	   58		   *	    cmp    ds : show_addresses, 'X'
 0000357B  75 07	   *	    jne    @C03CD
 0000357D  83 05 0000B8DC R	            add     ds:mem_temp_x,1*FONT_X                          ; Move over one more space between displacement and data
	   08
				        .ENDIF
 00003584		   *@C03CD:
 00003584  60			        pushad
 00003585  1E			        push    ds
 00003586  06			        push    es
 00003587  C8 0060 00		        enter   96,0                                                ; Screen is 90 columns wide, must accomodate a potential max!
				      ; [ebp-04], dword - Maximum offset to achieve for the three-byte field used for BYTE data

				      ; Get our temporary destination address
 0000358B  16			        push    ss
 0000358C  07			        pop     es
 0000358D  8B FC		        mov     edi,esp

				      ; Get our source address
 0000358F  8E 1D 0000B8CC R	        mov     ds,ds:mem_segment
 00003595  2E: 8B 35		        mov     esi,cs:mem_offset
	   0000B8D0 R
 0000359C  2E: 03 35		        add     esi,cs:mem_displacement
	   0000B8D4 R

				      ; Now, copy the text to our temp area
 000035A3  2E: 8B 15		        mov     edx,cs:mem_temp_x
	   0000B8DC R
 000035AA  2E: 8B 0D		        mov     ecx,cs:mem_max_x
	   0000B8E0 R
 000035B1  89 4D FC		        mov     dword ptr ss:[ebp-04],ecx
 000035B4  83 6D FC 18		        sub     dword ptr ss:[ebp-04],3*FONT_X
 000035B8  33 DB		        xor     ebx,ebx
				        .WHILE (edx < ecx && edx <= dword ptr ss:[ebp-04] && ebx < 90/3)
 000035BA  EB 1F	   *	    jmp    @C03CF
 000035BC		   *@C03D0:
				          ; The above line basically equates to:  while temp_x < max_x and (enough_space) and count < 30)

				          ; Get the character to display in BYTE format
				            .IF (esi <= cs:mem_limit)
 000035BC  2E: 3B 35
	   0000B8D8 R	   *	    cmp    esi, cs : mem_limit
 000035C3  77 03	   *	    ja     @C03D1
 000035C5  AC			                lodsb
				            .ELSE
 000035C6  EB 02	   *	    jmp    @C03D3
 000035C8		   *@C03D1:
 000035C8  32 C0		                xor     al,al
				            .ENDIF

 000035CA			          @@:
 000035CA		   *@C03D3:
 000035CA  E8 0000036D		            call    invDEBI_store_byte_data_in_al

 000035CF  83 C2 18		            add     edx,FONT_X*3
				            .IF (edx <= dword ptr ss:[ebp-04])
 000035D2  3B 55 FC	   *	    cmp    edx, dword ptr ss : [ebp - 004h]
 000035D5  77 03	   *	    ja     @C03D4
				              ; Store space after
 000035D7  B0 20		                mov     al,32
 000035D9  AA			                stosb
				            .ENDIF

				          ; Move to next screen location
 000035DA		   *@C03D4:
 000035DA  43			            inc     ebx
				        .ENDW
 000035DB		   *@C03CF:
 000035DB  3B D1	   *	    cmp    edx, ecx
 000035DD  73 0A	   *	    jae    @C03D6
 000035DF  3B 55 FC	   *	    cmp    edx, dword ptr ss : [ebp - 004h]
 000035E2  77 05	   *	    ja     @C03D6
 000035E4  83 FB 1E	   *	    cmp    ebx, 05Ah / 003h
 000035E7  72 D3	   *	    jb     @C03D0
 000035E9		   *@C03D6:
 000035E9  32 C0		        xor     al,al
 000035EB  AA			        stosb

				      ; Now, display what we've just copied
 000035EC  16			        push    ss
 000035ED  1F			        pop     ds
 000035EE  8B F4		        mov     esi,esp
 000035F0  2E: FF 35		        push    cs:mem_temp_x
	   0000B8DC R
 000035F7  2E: FF 35		        push    cs:mem_ul_y
	   0000B8C0 R
 000035FE  56			        push    esi
 000035FF  2E: FF 1D		        call    fword ptr cs:_VID_g_mono_display_text
	   0000D0E3 R

				      ; We're finished
 00003606  C9			        leave
 00003607  07			        pop     es
 00003608  1F			        pop     ds
 00003609  01 1D 0000B8D4 R	        add     ds:mem_displacement,ebx
 0000360F  61			        popad
 00003610  C3			        ret
 00003611			    invDEBI_pop_line_mem_window_byte            ENDP




 00003611			    invDEBI_pop_line_mem_window_word            PROC
				    ; This routine is called to display a line of data in a WORD format
 00003611  E8 00000286		        call    invDEBI_pop_line_show_displacement
				        .IF (ds:show_addresses == 'X')
 00003616  80 3D 0000AC34 R
	   58		   *	    cmp    ds : show_addresses, 'X'
 0000361D  75 07	   *	    jne    @C03D9
 0000361F  83 05 0000B8DC R	            add     ds:mem_temp_x,1*FONT_X                          ; Move over one more space between displacement and data
	   08
				        .ENDIF
 00003626		   *@C03D9:
 00003626  60			        pushad
 00003627  1E			        push    ds
 00003628  06			        push    es
 00003629  C8 0060 00		        enter   96,0                                                ; Screen is 90 columns wide, must accomodate a potential max!
				      ; [ebp-04], dword - Maximum offset to achieve for the three-byte field used for BYTE data

				      ; Get our temporary destination address
 0000362D  16			        push    ss
 0000362E  07			        pop     es
 0000362F  8B FC		        mov     edi,esp

				      ; Get our source address
 00003631  83 2D 0000B8D8 R	        sub     ds:mem_limit,2
	   02
 00003638  8E 1D 0000B8CC R	        mov     ds,ds:mem_segment
 0000363E  2E: 8B 35		        mov     esi,cs:mem_offset
	   0000B8D0 R
 00003645  2E: 03 35		        add     esi,cs:mem_displacement
	   0000B8D4 R

				      ; Now, copy the text to our temp area
 0000364C  2E: 8B 15		        mov     edx,cs:mem_temp_x
	   0000B8DC R
 00003653  2E: 8B 0D		        mov     ecx,cs:mem_max_x
	   0000B8E0 R
 0000365A  89 4D FC		        mov     dword ptr ss:[ebp-04],ecx
 0000365D  83 6D FC 28		        sub     dword ptr ss:[ebp-04],5*FONT_X
 00003661  33 DB		        xor     ebx,ebx
				        .WHILE (edx < ecx && edx <= dword ptr ss:[ebp-04] && ebx < 2*90/5)
 00003663  EB 2D	   *	    jmp    @C03DB
 00003665		   *@C03DC:
				          ; The above line basically equates to:  while temp_x < max_x and (enough_space) and count < 18)

				          ; Get the character to display in WORD format
				            .IF (esi <= cs:mem_limit)
 00003665  2E: 3B 35
	   0000B8D8 R	   *	    cmp    esi, cs : mem_limit
 0000366C  77 04	   *	    ja     @C03DD
 0000366E  66| AD		                lodsw
				            .ELSE
 00003670  EB 03	   *	    jmp    @C03DF
 00003672		   *@C03DD:
 00003672  66| 33 C0		                xor     ax,ax
				            .ENDIF

 00003675			          @@:
				          ; Store upper high byte
 00003675		   *@C03DF:
 00003675  50			            push    eax
 00003676  C1 E8 08		            shr     eax,8
 00003679  E8 000002BE		            call    invDEBI_store_byte_data_in_al
 0000367E  58			            pop     eax

				          ; Store upper low byte
 0000367F  E8 000002B8		            call    invDEBI_store_byte_data_in_al

 00003684  83 C2 28		            add     edx,FONT_X*5
				            .IF (edx <= dword ptr ss:[ebp-04])
 00003687  3B 55 FC	   *	    cmp    edx, dword ptr ss : [ebp - 004h]
 0000368A  77 03	   *	    ja     @C03E0
				              ; Store space after
 0000368C  B0 20		                mov     al,32
 0000368E  AA			                stosb
				            .ENDIF

				          ; Move to next screen location
 0000368F		   *@C03E0:
 0000368F  83 C3 02		            add     ebx,2
				        .ENDW
 00003692		   *@C03DB:
 00003692  3B D1	   *	    cmp    edx, ecx
 00003694  73 0A	   *	    jae    @C03E2
 00003696  3B 55 FC	   *	    cmp    edx, dword ptr ss : [ebp - 004h]
 00003699  77 05	   *	    ja     @C03E2
 0000369B  83 FB 24	   *	    cmp    ebx, 002h * 05Ah / 005h
 0000369E  72 C5	   *	    jb     @C03DC
 000036A0		   *@C03E2:
 000036A0  32 C0		        xor     al,al
 000036A2  AA			        stosb

				      ; Now, display what we've just copied
 000036A3  16			        push    ss
 000036A4  1F			        pop     ds
 000036A5  8B F4		        mov     esi,esp
 000036A7  2E: FF 35		        push    cs:mem_temp_x
	   0000B8DC R
 000036AE  2E: FF 35		        push    cs:mem_ul_y
	   0000B8C0 R
 000036B5  56			        push    esi
 000036B6  2E: FF 1D		        call    fword ptr cs:_VID_g_mono_display_text
	   0000D0E3 R

				      ; We're finished
 000036BD  C9			        leave
 000036BE  07			        pop     es
 000036BF  1F			        pop     ds
 000036C0  01 1D 0000B8D4 R	        add     ds:mem_displacement,ebx
 000036C6  83 05 0000B8D8 R	        add     ds:mem_limit,2
	   02
 000036CD  61			        popad
 000036CE  C3			        ret
 000036CF			    invDEBI_pop_line_mem_window_word            ENDP




 000036CF			    invDEBI_pop_line_mem_window_dword           PROC
				    ; This routine is called to display a line of data in a DWORD format
 000036CF  E8 000001C8		        call    invDEBI_pop_line_show_displacement
				        .IF (ds:show_addresses == 'X')
 000036D4  80 3D 0000AC34 R
	   58		   *	    cmp    ds : show_addresses, 'X'
 000036DB  75 07	   *	    jne    @C03E5
 000036DD  83 05 0000B8DC R	            add     ds:mem_temp_x,1*FONT_X                          ; Move over one more space between displacement and data
	   08
				        .ENDIF
 000036E4		   *@C03E5:
 000036E4  60			        pushad
 000036E5  1E			        push    ds
 000036E6  06			        push    es
 000036E7  C8 0060 00		        enter   96,0                                                ; Screen is 90 columns wide, must accomodate a potential max!
				      ; [ebp-04], dword - Maximum offset to achieve for the three-byte field used for BYTE data

				      ; Get our temporary destination address
 000036EB  16			        push    ss
 000036EC  07			        pop     es
 000036ED  8B FC		        mov     edi,esp

				      ; Get our source address
 000036EF  83 2D 0000B8D8 R	        sub     ds:mem_limit,4
	   04
 000036F6  8E 1D 0000B8CC R	        mov     ds,ds:mem_segment
 000036FC  2E: 8B 35		        mov     esi,cs:mem_offset
	   0000B8D0 R
 00003703  2E: 03 35		        add     esi,cs:mem_displacement
	   0000B8D4 R

				      ; Now, copy the text to our temp area
 0000370A  2E: 8B 15		        mov     edx,cs:mem_temp_x
	   0000B8DC R
 00003711  2E: 8B 0D		        mov     ecx,cs:mem_max_x
	   0000B8E0 R
 00003718  89 4D FC		        mov     dword ptr ss:[ebp-04],ecx
 0000371B  83 6D FC 50		        sub     dword ptr ss:[ebp-04],10*FONT_X
 0000371F  33 DB		        xor     ebx,ebx
				        .WHILE (edx < ecx && edx <= dword ptr ss:[ebp-04] && ebx < 4*90/10)
 00003721  EB 42	   *	    jmp    @C03E7
 00003723		   *@C03E8:
				          ; The above line basically equates to:  while temp_x < max_x and (enough_space) and count < whatever:) )

				          ; Get the character to display in DWORD format
				            .IF (esi <= cs:mem_limit)
 00003723  2E: 3B 35
	   0000B8D8 R	   *	    cmp    esi, cs : mem_limit
 0000372A  77 03	   *	    ja     @C03E9
 0000372C  AD			                lodsd
				            .ELSE
 0000372D  EB 02	   *	    jmp    @C03EB
 0000372F		   *@C03E9:
 0000372F  33 C0		                xor     eax,eax
				            .ENDIF

 00003731			          @@:
				          ; Store upper high byte of high word
 00003731		   *@C03EB:
 00003731  50			            push    eax
 00003732  C1 E8 18		            shr     eax,24
 00003735  E8 00000202		            call    invDEBI_store_byte_data_in_al
 0000373A  58			            pop     eax

				          ; Store upper low byte of high word
 0000373B  50			            push    eax
 0000373C  C1 E8 10		            shr     eax,16
 0000373F  E8 000001F8		            call    invDEBI_store_byte_data_in_al

				          ; Store period between high word and low word
 00003744  B0 2E		            mov     al,'.'
 00003746  AA			            stosb
 00003747  58			            pop     eax

				          ; Store upper high byte of low word
 00003748  50			            push    eax
 00003749  C1 E8 08		            shr     eax,8
 0000374C  E8 000001EB		            call    invDEBI_store_byte_data_in_al
 00003751  58			            pop     eax

				          ; Store upper low byte of low word
 00003752  E8 000001E5		            call    invDEBI_store_byte_data_in_al

 00003757  83 C2 50		            add     edx,FONT_X*10
				            .IF (edx <= dword ptr ss:[ebp-04])
 0000375A  3B 55 FC	   *	    cmp    edx, dword ptr ss : [ebp - 004h]
 0000375D  77 03	   *	    ja     @C03EC
				              ; Store one space after
 0000375F  B0 20		                mov     al,32
 00003761  AA			                stosb
				            .ENDIF

				          ; Move to next screen location
 00003762		   *@C03EC:
 00003762  83 C3 04		            add     ebx,4
				        .ENDW
 00003765		   *@C03E7:
 00003765  3B D1	   *	    cmp    edx, ecx
 00003767  73 0A	   *	    jae    @C03EE
 00003769  3B 55 FC	   *	    cmp    edx, dword ptr ss : [ebp - 004h]
 0000376C  77 05	   *	    ja     @C03EE
 0000376E  83 FB 24	   *	    cmp    ebx, 004h * 05Ah / 00Ah
 00003771  72 B0	   *	    jb     @C03E8
 00003773		   *@C03EE:
 00003773  32 C0		        xor     al,al
 00003775  AA			        stosb

				      ; Now, display what we've just copied
 00003776  16			        push    ss
 00003777  1F			        pop     ds
 00003778  8B F4		        mov     esi,esp
 0000377A  2E: FF 35		        push    cs:mem_temp_x
	   0000B8DC R
 00003781  2E: FF 35		        push    cs:mem_ul_y
	   0000B8C0 R
 00003788  56			        push    esi
 00003789  2E: FF 1D		        call    fword ptr cs:_VID_g_mono_display_text
	   0000D0E3 R

				      ; We're finished
 00003790  C9			        leave
 00003791  07			        pop     es
 00003792  1F			        pop     ds
 00003793  01 1D 0000B8D4 R	        add     ds:mem_displacement,ebx
 00003799  83 05 0000B8D8 R	        add     ds:mem_limit,4
	   04
 000037A0  61			        popad
 000037A1  C3			        ret
 000037A2			    invDEBI_pop_line_mem_window_dword           ENDP




 000037A2			    invDEBI_pop_line_mem_window_qword           PROC
				    ; This routine is called to display a line of data in a QWORD format
 000037A2  E8 000000F5		        call    invDEBI_pop_line_show_displacement
				        .IF (ds:show_addresses == 'X')
 000037A7  80 3D 0000AC34 R
	   58		   *	    cmp    ds : show_addresses, 'X'
 000037AE  75 07	   *	    jne    @C03F1
 000037B0  83 05 0000B8DC R	            add     ds:mem_temp_x,1*FONT_X                          ; Move over one more space between displacement and data
	   08
				        .ENDIF
 000037B7		   *@C03F1:
 000037B7  60			        pushad
 000037B8  1E			        push    ds
 000037B9  06			        push    es
 000037BA  C8 0060 00		        enter   96,0                                                ; Screen is 90 columns wide, must accomodate a potential max!
				      ; [ebp-04], dword - Maximum offset to achieve for the three-byte field used for BYTE data

				      ; Get our temporary destination address
 000037BE  16			        push    ss
 000037BF  07			        pop     es
 000037C0  8B FC		        mov     edi,esp

				      ; Get our source address
 000037C2  83 2D 0000B8D8 R	        sub     ds:mem_limit,8
	   08
 000037C9  8E 1D 0000B8CC R	        mov     ds,ds:mem_segment
 000037CF  2E: 8B 35		        mov     esi,cs:mem_offset
	   0000B8D0 R
 000037D6  2E: 03 35		        add     esi,cs:mem_displacement
	   0000B8D4 R

				      ; Now, copy the text to our temp area
 000037DD  2E: 8B 15		        mov     edx,cs:mem_temp_x
	   0000B8DC R
 000037E4  2E: 8B 0D		        mov     ecx,cs:mem_max_x
	   0000B8E0 R
 000037EB  89 4D FC		        mov     dword ptr ss:[ebp-04],ecx
 000037EE  81 6D FC		        sub     dword ptr ss:[ebp-04],19*FONT_X
	   00000098
 000037F5  33 DB		        xor     ebx,ebx
				        .WHILE (edx < ecx && edx <= dword ptr ss:[ebp-04] && ebx < 8*90/19)
 000037F7  EB 66	   *	    jmp    @C03F3
 000037F9		   *@C03F4:
				          ; The above line basically equates to:  while temp_x < max_x and (enough_space) and count < whatever:) )
 000037F9  51			            push    ecx

 000037FA  B9 00000002		            mov     ecx,2
 000037FF			          top_loop:
				              ; Get the character to display in QWORD format
				                .IF (esi <= cs:mem_limit)
 000037FF  2E: 3B 35
	   0000B8D8 R	   *	    cmp    esi, cs : mem_limit
 00003806  77 0E	   *	    ja     @C03F5
				                    .IF (ecx == 2)
 00003808  83 F9 02	   *	    cmp    ecx, 002h
 0000380B  75 05	   *	    jne    @C03F7
 0000380D  8B 46 04		                        mov     eax,dword ptr ds:[esi+4]
				                    .ELSE
 00003810  EB 06	   *	    jmp    @C03F9
 00003812		   *@C03F7:
 00003812  8B 06		                        mov     eax,dword ptr ds:[esi+0]
				                    .ENDIF
				                .ELSE
 00003814  EB 02	   *	    jmp    @C03FA
 00003816		   *@C03F5:
 00003816  33 C0		                    xor     eax,eax
				                .ENDIF

 00003818			              @@:
				              ; Store upper high byte of high word
 00003818		   *@C03FA:
 00003818		   *@C03F9:
 00003818  50			                push    eax
 00003819  C1 E8 18		                shr     eax,24
 0000381C  E8 0000011B		                call    invDEBI_store_byte_data_in_al
 00003821  58			                pop     eax

				              ; Store upper low byte of high word
 00003822  50			                push    eax
 00003823  C1 E8 10		                shr     eax,16
 00003826  E8 00000111		                call    invDEBI_store_byte_data_in_al

				              ; Store period between high word and low word
 0000382B  B0 2E		                mov     al,'.'
 0000382D  AA			                stosb
 0000382E  58			                pop     eax

				              ; Store upper high byte of low word
 0000382F  50			                push    eax
 00003830  C1 E8 08		                shr     eax,8
 00003833  E8 00000104		                call    invDEBI_store_byte_data_in_al
 00003838  58			                pop     eax

				              ; Store upper low byte of low word
 00003839  E8 000000FE		                call    invDEBI_store_byte_data_in_al

				              ; Store one space after
				                .IF (ecx == 2)
 0000383E  83 F9 02	   *	    cmp    ecx, 002h
 00003841  75 05	   *	    jne    @C03FB
 00003843  B0 2E		                    mov     al,'.'
 00003845  AA			                    stosb
				                .ELSE
 00003846  EB 0E	   *	    jmp    @C03FD
 00003848		   *@C03FB:
 00003848  81 C2 00000098	                    add     edx,FONT_X*19
				                    .IF (edx <= dword ptr ss:[ebp-04])
 0000384E  3B 55 FC	   *	    cmp    edx, dword ptr ss : [ebp - 004h]
 00003851  77 03	   *	    ja     @C03FE
 00003853  B0 20		                        mov     al,32
 00003855  AA			                        stosb
				                    .ENDIF
				                .ENDIF
 00003856		   *@C03FE:
 00003856		   *@C03FD:
 00003856  E2 A7		                loop    top_loop

 00003858  59			            pop     ecx
 00003859  83 C6 08		            add     esi,8
				          ; Move to next screen location
 0000385C  83 C3 08		            add     ebx,8
				        .ENDW
 0000385F		   *@C03F3:
 0000385F  3B D1	   *	    cmp    edx, ecx
 00003861  73 0A	   *	    jae    @C0400
 00003863  3B 55 FC	   *	    cmp    edx, dword ptr ss : [ebp - 004h]
 00003866  77 05	   *	    ja     @C0400
 00003868  83 FB 25	   *	    cmp    ebx, 008h * 05Ah / 013h
 0000386B  72 8C	   *	    jb     @C03F4
 0000386D		   *@C0400:
 0000386D  32 C0		        xor     al,al
 0000386F  AA			        stosb

				      ; Now, display what we've just copied
 00003870  16			        push    ss
 00003871  1F			        pop     ds
 00003872  8B F4		        mov     esi,esp
 00003874  2E: FF 35		        push    cs:mem_temp_x
	   0000B8DC R
 0000387B  2E: FF 35		        push    cs:mem_ul_y
	   0000B8C0 R
 00003882  56			        push    esi
 00003883  2E: FF 1D		        call    fword ptr cs:_VID_g_mono_display_text
	   0000D0E3 R

				      ; We're finished
 0000388A  C9			        leave
 0000388B  07			        pop     es
 0000388C  1F			        pop     ds
 0000388D  01 1D 0000B8D4 R	        add     ds:mem_displacement,ebx
 00003893  83 05 0000B8D8 R	        add     ds:mem_limit,8
	   08
 0000389A  61			        popad
 0000389B  C3			        ret
 0000389C			    invDEBI_pop_line_mem_window_qword           ENDP




 0000389C			    invDEBI_pop_line_show_displacement      PROC
				    ; This routine is used to show the displacement for the current line
				    ;
				    ; Upon entry:   ds:show_addresses - set to 'X' if address should be displayed
				    ;                     ds:mem_ul_x - X coordinate on-screen to display
				    ;                     ds:mem_ul_y - Y coordinate on-screen to display
				    ;             ds:mem_displacement - displacement value to display
				    ;
				    ; Upon exit:    ds:mem_temp_x - set to next available X coordinate (to be compared with ds:mem_max_x)
				    ;
 0000389C  A1 0000B8BC R	        mov     eax,ds:mem_ul_x
 000038A1  A3 0000B8DC R	        mov     ds:mem_temp_x,eax
				        .IF (ds:show_addresses == 'X')
 000038A6  80 3D 0000AC34 R
	   58		   *	    cmp    ds : show_addresses, 'X'
 000038AD  75 4A	   *	    jne    @C0403
 000038AF  1E			            push    ds
 000038B0  06			            push    es
 000038B1  60			            pushad
 000038B2  C8 0008 00		            enter   8,0
				          ; [ebp-16], 16-bytes, string set aside for display

				          ; Store the value to ss:[esp] converted to es:[edi]
 000038B6  8B FC		            mov     edi,esp
 000038B8  16			            push    ss
 000038B9  07			            pop     es

				          ; Always store 4 characters plus the sign
 000038BA  A1 0000B8D4 R	            mov     eax,ds:mem_displacement
 000038BF  E8 00000036		            call    invDEBI_store_eax_sign
 000038C4  B9 00000003		            mov     ecx,3
 000038C9  C1 C8 08		            ror     eax,8
 000038CC  E8 0000003B		            call    invDEBI_store_ecx_hexadecimal_in_eax_no_sign
 000038D1  32 C0		            xor     al,al
 000038D3  AA			            stosb

				          ; Now, display what we've just created
 000038D4  16			            push    ss
 000038D5  1F			            pop     ds
 000038D6  8B F4		            mov     esi,esp
 000038D8  2E: FF 35		            push    cs:mem_temp_x                                   ; horizontal
	   0000B8DC R
 000038DF  2E: FF 35		            push    cs:mem_ul_y                                     ; vertical
	   0000B8C0 R
 000038E6  56			            push    esi                                             ; start of text we've just created to display
 000038E7  2E: FF 1D		            call    fword ptr cs:_VID_g_mono_display_text           ;
	   0000D0E3 R

 000038EE  C9			            leave
 000038EF  61			            popad
 000038F0  07			            pop     es
 000038F1  1F			            pop     ds

				          ; Adjust for the data that will display now
 000038F2  83 05 0000B8DC R	            add     ds:mem_temp_x,4*FONT_X                          ; 4 for "+000"
	   20
				        .ENDIF
 000038F9		   *@C0403:
 000038F9  C3			        ret
 000038FA			    invDEBI_pop_line_show_displacement      ENDP




 000038FA			    invDEBI_store_eax_sign      PROC
				    ; This routine is used to store the sign in EAX
				    ;
				    ; Upon entry:        eax - value to examine
				    ;               es:[edi] - far ptr to where to store the sign
				    ;
				    ; Upon exit:    The sign is stored
				    ;
				      ; Store the sign
				        .IF (eax > 7fffffffh)
 000038FA  3D 7FFFFFFF	   *	    cmp    eax, 07FFFFFFFh
 000038FF  76 04	   *	    jbe    @C0405
 00003901  B2 2D		            mov     dl,'-'
				        .ELSE
 00003903  EB 02	   *	    jmp    @C0407
 00003905		   *@C0405:
 00003905  B2 2B		            mov     dl,'+'
				        .ENDIF
 00003907		   *@C0407:
 00003907  26: 88 17		        mov     byte ptr es:[edi],dl
 0000390A  47			        inc     edi
 0000390B  C3			        ret
 0000390C			    invDEBI_store_eax_sign      ENDP




 0000390C			    invDEBI_store_ecx_hexadecimal_in_eax_no_sign        PROC
				    ; This routine is used to store the data in eax to the output string
				    ;
				    ; Upon entry:        eax - value to convert to text (without regard to sign, meaning negative values are NEG'd)
				    ;                    ecx - # of characters to store
				    ;               es:[edi] - far ptr to where to store to
				    ;
				    ; Upon exit:    The data is stored for each character
				    ;
				      ; Store the data
				        .IF (eax > 7fffffffh)
 0000390C  3D 7FFFFFFF	   *	    cmp    eax, 07FFFFFFFh
 00003911  76 02	   *	    jbe    @C0408
				          ; Convert from - to + for display (the sign has already been displayed)
 00003913  F7 D8		            neg     eax
				        .ENDIF
 00003915		   *@C0408:
				        ; No return is here because this function will simply flow into the one below to complete the display
				        ;ret
 00003915			    invDEBI_store_ecx_hexadecimal_in_eax_no_sign        ENDP




 00003915			    invDEBI_store_ecx_hexadecimal_in_eax        PROC
				    ; This routine is used to store the data in eax to the output string
				    ;
				    ; Upon entry:        eax - value to convert to text
				    ;                    ecx - # of characters to store
				    ;               es:[edi] - far ptr to where to store to
				    ;
				    ; Upon exit:    The data is stored for each character
				    ;
				      ; Store the data
				        .WHILE (ecx > 0)
 00003915  EB 1F	   *	    jmp    @C040A
 00003917		   *@C040B:
 00003917  8A D0		            mov     dl,al
 00003919  80 E2 0F		            and     dl,0fh
				            .IF (dl >= 0 && dl <= 9)
 0000391C  80 FA 00	   *	    cmp    dl, 000h
 0000391F  72 0A	   *	    jb     @C040C
 00003921  80 FA 09	   *	    cmp    dl, 009h
 00003924  77 05	   *	    ja     @C040C
 00003926  80 C2 30		                add     dl,'0'
				            .ELSE
 00003929  EB 03	   *	    jmp    @C040F
 0000392B		   *@C040C:
 0000392B  80 C2 57		                add     dl,'a'-10
				            .ENDIF
 0000392E		   *@C040F:
 0000392E  26: 88 17		            mov     byte ptr es:[edi],dl
 00003931  47			            inc     edi
 00003932  C1 C0 04		            rol     eax,4
 00003935  49			            dec     ecx
				        .ENDW
 00003936		   *@C040A:
 00003936  83 F9 00	   *	    cmp    ecx, 000h
 00003939  77 DC	   *	    ja     @C040B
 0000393B  C3			        ret
 0000393C			    invDEBI_store_ecx_hexadecimal_in_eax        ENDP




 0000393C			    invDEBI_store_byte_data_in_al       PROC
				    ; This routine is used to store the nibbles in al to es:[edi]
				    ;
				    ; Upon entry:         al - value to store
				    ;               es:[edi] - far ptr to where to store
				    ;
				    ; Upon exit:    data is stored and edi is moved
				    ;
				      ; Store upper nibble
 0000393C  50			        push    eax
 0000393D  C0 E8 04		        shr     al,4
				        .IF (al >= 0 && al <= 9)
 00003940  3C 00	   *	    cmp    al, 000h
 00003942  72 08	   *	    jb     @C0411
 00003944  3C 09	   *	    cmp    al, 009h
 00003946  77 04	   *	    ja     @C0411
 00003948  04 30		            add     al,'0'
				        .ELSE
 0000394A  EB 02	   *	    jmp    @C0414
 0000394C		   *@C0411:
 0000394C  04 57		            add     al,'a'-10
				        .ENDIF
 0000394E		   *@C0414:
 0000394E  AA			        stosb
 0000394F  58			        pop     eax

				      ; Store lower nibble
 00003950  24 0F		        and     al,0fh
				        .IF (al >= 0 && al <= 9)
 00003952  3C 00	   *	    cmp    al, 000h
 00003954  72 08	   *	    jb     @C0415
 00003956  3C 09	   *	    cmp    al, 009h
 00003958  77 04	   *	    ja     @C0415
 0000395A  04 30		            add     al,'0'
				        .ELSE
 0000395C  EB 02	   *	    jmp    @C0418
 0000395E		   *@C0415:
 0000395E  04 57		            add     al,'a'-10
				        .ENDIF
 00003960		   *@C0418:
 00003960  AA			        stosb
 00003961  C3			        ret
 00003962			    invDEBI_store_byte_data_in_al       ENDP




 00003962			    invDEBI_get_mem_window_coords       PROC
				    ; This routine is used to determine the ul X,Y and lr X,Y coordinates for the current mem window update
				    ;
				    ; Upon entry:      ah,al - Upper left X,Y
				    ;                  bh,bl - Lower right X,Y
				    ;               ds:[esi] - far ptr to screen object
				    ;
				    ; Upon exit:      ds:mem_ul_x - Starting UL X pixel for data
				    ;                 ds:mem_ul_y - Starting UL Y pixel for data
				    ;                ds:mem_width - How many characters are available horizontally before spilling out of window
				    ;               ds:mem_height - How many lines are available vertically before spilling out of window
				    ;
 00003962  60			        pushad
 00003963  C8 0004 00		        enter   4,0
				      ; [ebp-04], dword - Ul Y
				      ;
				      ; Now, calculate the new pixel coordinates
 00003967  0F B6 CC		        movzx   ecx,ah
 0000396A  0F B6 D0		        movzx   edx,al
 0000396D  89 55 FC		        mov     dword ptr ss:[ebp-04],edx                           ; Ul y

				      ; Determine how wide/high the window is
 00003970  2A FC		        sub     bh,ah
 00003972  2A D8		        sub     bl,al
				      ; Right now, bh - width of usable window
				      ;            bl - height of usable window
 00003974  0F B6 C7		        movzx   eax,bh                                              ; Width
 00003977  0F B6 DB		        movzx   ebx,bl                                              ; Height
 0000397A  A3 0000B8C4 R	        mov     ds:mem_width,eax
 0000397F  89 1D 0000B8C8 R	        mov     ds:mem_height,ebx

				      ; Now, adjust for the current font
 00003985  B8 00000008		        mov     eax,FONT_X
 0000398A  F7 E1		        mul     ecx                                                 ; Ul x
 0000398C  03 46 04		        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 0000398F  A3 0000B8BC R	        mov     ds:mem_ul_x,eax

 00003994  B8 00000006		        mov     eax,FONT_Y
 00003999  F7 65 FC		        mul     dword ptr ss:[ebp-04]                               ; Ul y
 0000399C  03 46 08		        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 0000399F  A3 0000B8C0 R	        mov     ds:mem_ul_y,eax

				      ; Determine the maximum X pixel (used in loops)
 000039A4  A1 0000B8C4 R	        mov     eax,ds:mem_width
 000039A9  40			        inc     eax
 000039AA  BB 00000008		        mov     ebx,FONT_X
 000039AF  F7 E3		        mul     ebx
 000039B1  03 05 0000B8BC R	        add     eax,ds:mem_ul_x
 000039B7  A3 0000B8E0 R	        mov     ds:mem_max_x,eax

				      ; We're finished
 000039BC  C9			        leave
 000039BD  61			        popad
 000039BE  C3			        ret
 000039BF			    invDEBI_get_mem_window_coords       ENDP




 000039BF			    invDEBI_logo_window     PROC
				    ; This routine is called when updating the screen.  It is called from the @FunctionHandlesObject macro
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to screen info
				    ;               ds:[edi] - far ptr to function handle
				    ;
				    ; Upon exit:    The logo is redrawn
				    ;
				;        mov     ebx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
				;        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
				;
				;        push    ebx                                                 ; ul-x
				;        push    edx                                                 ; ul-y
				;        add     ebx,30*FONT_X
				;        push    ebx                                                 ; lr-x
				;        add     edx,4*FONT_Y-1
				;        push    edx                                                 ; lr-y
				;        push    dword ptr 0                                         ; Put this string
				;        push    dword ptr offset debi_debugger_logo                 ; Offset to the buffer
				;        call    fword ptr cs:_VID_g_mono_window_function
 000039BF  C3			        ret
 000039C0			    invDEBI_logo_window     ENDP




				  ; These options all do the same thing, but they're individuall identified in the source code because at some point in
				  ; the future it might become advantageous to break them out individually (or to have one menu be different)
 000039C0			    invDEBI_descriptor_right_click:
 000039C0			    invDEBI_fpu_1_right_click:
 000039C0			    invDEBI_fpu_2_right_click:
 000039C0			    invDEBI_fpu_save_state_right_click:
 000039C0			    invDEBI_fpu_summary_right_click:
 000039C0			    invDEBI_locals_right_click:
 000039C0			    invDEBI_mem_1_right_click:
 000039C0			    invDEBI_mem_2_right_click:
 000039C0			    invDEBI_mem_3_right_click:
 000039C0			    invDEBI_mem_4_right_click:
 000039C0			    invDEBI_mmx_right_click:
 000039C0			    invDEBI_query_right_click:
 000039C0			    invDEBI_quick_watch_right_click:
 000039C0			    invDEBI_reg_1_right_click:
 000039C0			    invDEBI_reg_3_right_click:
 000039C0			    invDEBI_reg_right_click:
 000039C0			    invDEBI_stack_right_click:
 000039C0  E9 FFFFEB6D		        jmp     invDEBI_general_menu




 000039C5			    invDEBI_cfsca_1_right_click:
 000039C5			    invDEBI_cfsca_2_right_click:
 000039C5			    invDEBI_cfsca_3_right_click:
 000039C5  E9 FFFFEB7F		        jmp     invDEBI_cfsca_menu




 000039CA			    invDEBI_change_window_cfsca_1   PROC
 000039CA  68 0000A9CC R	        push    offset DEBI_t_keyboard_objects
 000039CF  68 0000A9E3 R	        push    offset DEBI_t_mouse_objects
 000039D4  68 0000A9D6 R	        push    offset DEBI_t_screen_objects
 000039D9  EB 22		        jmp     invDEBI_change_window_common_cfsca
 000039DB			    invDEBI_change_window_cfsca_1   ENDP




 000039DB			    invDEBI_change_window_cfsca_2   PROC
 000039DB  68 00006553 R	        push    offset DEBI_c_keyboard_objects
 000039E0  68 0000656A R	        push    offset DEBI_c_mouse_objects
 000039E5  68 0000655D R	        push    offset DEBI_c_screen_objects
 000039EA  EB 11		        jmp     invDEBI_change_window_common_cfsca
 000039EC			    invDEBI_change_window_cfsca_2   ENDP




 000039EC			    invDEBI_change_window_cfsca_3   PROC
 000039EC  68 0000663B R	        push    offset DEBI_d_keyboard_objects
 000039F1  68 00006652 R	        push    offset DEBI_d_mouse_objects
 000039F6  68 00006645 R	        push    offset DEBI_d_screen_objects
 000039FB  EB 00		        jmp     invDEBI_change_window_common_cfsca
 000039FD			    invDEBI_change_window_cfsca_3   ENDP




 000039FD			    invDEBI_change_window_common_cfsca      PROC
				    ; There can only be one active CFSCA window at a time.  This algorithm will try to replace the existing one
				    ;
				    ; Upon entry:   The stack is arranged as below
				    ;
				    ; Upon exit:    The window is either replaced with the new one, or control goes to invDEBI_new_window_common
				    ;
				      ; [esp+12] - Calling function offset
				      ; [esp+08] - Keyboard objects
				      ; [esp+04] - Mouse objects
				      ; [esp+00] - Screen objects
 000039FD  BE 000054C2 R	        mov     esi,offset DEBI_screen_table
 00003A02  33 C9		        xor     ecx,ecx
				        .WHILE (ecx < 15)
 00003A04  EB 5B	   *	    jmp    @C0419
 00003A06		   *@C041A:
				            .IF (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _YES)
 00003A06  80 7E 01 01	   *	    cmp    byte ptr ds : [esi + _ST_OBJECT_ACTIVE], _YES
 00003A0A  75 51	   *	    jne    @C041B
 00003A0C  8B 46 1C		                mov     eax,dword ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]
				                .IF (eax == DEBI_d_screen_objects || eax == DEBI_c_screen_objects || eax == DEBI_t_screen_objects)
 00003A0F  3D 00006645 R   *	    cmp    eax, DEBI_d_screen_objects
 00003A14  74 0E	   *	    je     @C041E
 00003A16  3D 0000655D R   *	    cmp    eax, DEBI_c_screen_objects
 00003A1B  74 07	   *	    je     @C041E
 00003A1D  3D 0000A9D6 R   *	    cmp    eax, DEBI_t_screen_objects
 00003A22  75 39	   *	    jne    @C041D
 00003A24		   *@C041E:
 00003A24  C6 05 0000B8BB R	                    mov     ds:menu_restore_screen_after,_NO        ; Force the menu cancelation algorithm to not restore screen
	   00
 00003A2B  C7 05 0000B944 R	                    mov     ds:single_step_top,0                    ; Force the CFSCA window to reposition the current disassembly
	   00000000
 00003A35  C7 05 0000B948 R	                    mov     ds:single_step_end,0                    ;  line to the top line of the CFSCA window
	   00000000

				                  ; Let's update the existing CFSCA item
 00003A3F  8B 54 24 08		                    mov     edx,dword ptr ss:[esp+08]
 00003A43  89 56 10		                    mov     dword ptr ds:[esi+_ST_OBJECT_KBD_OFFSET],edx
 00003A46  8B 54 24 04		                    mov     edx,dword ptr ss:[esp+04]
 00003A4A  89 56 18		                    mov     dword ptr ds:[esi+_ST_OBJECT_MOUSE_OFFSET],edx
 00003A4D  8B 14 24		                    mov     edx,dword ptr ss:[esp+00]
 00003A50  89 56 1C		                    mov     dword ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET],edx

				                  ; Redraw the new window
 00003A53  9C			                    pushfd
 00003A54  FA			                    cli
 00003A55  E8 FFFFCA65		                    call    invDEBI_clear_screen_and_redraw_windows
 00003A5A  9D			                    popfd
 00003A5B  EB 09		                    jmp     quit
				                .ENDIF
				            .ENDIF
 00003A5D		   *@C041D:

 00003A5D			          next_one:
 00003A5D		   *@C041B:
 00003A5D  83 C6 20		            add     esi,_ST_LENGTH
 00003A60  41			            inc     ecx
				        .ENDW
 00003A61		   *@C0419:
 00003A61  83 F9 0F	   *	    cmp    ecx, 00Fh
 00003A64  72 A0	   *	    jb     @C041A
				      ; We didn't find one, so we do nothing

 00003A66			      quit:
 00003A66  83 C4 0C		        add     esp,12
 00003A69  C3			        ret
 00003A6A			    invDEBI_change_window_common_cfsca      ENDP




				    ; The following invDEBI_new_window_*() functions all receive the same information
				    ;
				    ; Upon entry:   ds:general_menu_esi - Offset to screen object which created this menu
				    ;
				    ; Upon exit:    If there is room, a new object is created
				    ;
 00003A6A			    invDEBI_new_window_descriptor       PROC
 00003A6A  68 000056A2 R	        push    offset DEBI_keyboard_objects
 00003A6F  68 00005A38 R	        push    offset DEBI_a_mouse_objects
 00003A74  68 0000592A R	        push    offset DEBI_a_screen_objects
 00003A79  E9 000000EC		        jmp     invDEBI_new_window_common
 00003A7E			    invDEBI_new_window_descriptor       ENDP




 00003A7E			    invDEBI_new_window_regs_1       PROC
 00003A7E  68 000056A2 R	        push    offset DEBI_keyboard_objects
 00003A83  68 000095E6 R	        push    offset DEBI_p_mouse_objects
 00003A88  68 000093EA R	        push    offset DEBI_p_screen_objects
 00003A8D  E9 000000D8		        jmp     invDEBI_new_window_common
 00003A92			    invDEBI_new_window_regs_1       ENDP




 00003A92			    invDEBI_new_window_regs_3       PROC
 00003A92  68 000056A2 R	        push    offset DEBI_keyboard_objects
 00003A97  68 00005EEE R	        push    offset DEBI_b_mouse_objects
 00003A9C  68 00005C52 R	        push    offset DEBI_b_screen_objects
 00003AA1  E9 000000C4		        jmp     invDEBI_new_window_common
 00003AA6			    invDEBI_new_window_regs_3       ENDP




 00003AA6			    invDEBI_new_window_mmx      PROC
 00003AA6  68 000056A2 R	        push    offset DEBI_keyboard_objects
 00003AAB  68 0000A76C R	        push    offset DEBI_s_mouse_objects
 00003AB0  68 0000A564 R	        push    offset DEBI_s_screen_objects
 00003AB5  E9 000000B0		        jmp     invDEBI_new_window_common
 00003ABA			    invDEBI_new_window_mmx      ENDP




 00003ABA			    invDEBI_new_window_fpu_1        PROC
 00003ABA  68 000056A2 R	        push    offset DEBI_keyboard_objects
 00003ABF  68 00009A30 R	        push    offset DEBI_q_mouse_objects
 00003AC4  68 000099A8 R	        push    offset DEBI_q_screen_objects
 00003AC9  E9 0000009C		        jmp     invDEBI_new_window_common
 00003ACE			    invDEBI_new_window_fpu_1        ENDP




 00003ACE			    invDEBI_new_window_fpu_2        PROC
 00003ACE  68 000056A2 R	        push    offset DEBI_keyboard_objects
 00003AD3  68 00009DC1 R	        push    offset DEBI_r_mouse_objects
 00003AD8  68 00009CF9 R	        push    offset DEBI_r_screen_objects
 00003ADD  E9 00000088		        jmp     invDEBI_new_window_common
 00003AE2			    invDEBI_new_window_fpu_2        ENDP




 00003AE2			    invDEBI_new_window_fpu_summary      PROC
 00003AE2  68 000056A2 R	        push    offset DEBI_keyboard_objects
 00003AE7  68 000069B4 R	        push    offset DEBI_e_mouse_objects
 00003AEC  68 0000684C R	        push    offset DEBI_e_screen_objects
 00003AF1  EB 77		        jmp     invDEBI_new_window_common
 00003AF3			    invDEBI_new_window_fpu_summary      ENDP




 00003AF3			    invDEBI_new_window_fpu_savestate        PROC
 00003AF3  68 000056A2 R	        push    offset DEBI_keyboard_objects
 00003AF8  68 000071D2 R	        push    offset DEBI_f_mouse_objects
 00003AFD  68 0000704A R	        push    offset DEBI_f_screen_objects
 00003B02  EB 66		        jmp     invDEBI_new_window_common
 00003B04			    invDEBI_new_window_fpu_savestate        ENDP




 00003B04			    invDEBI_new_window_mem_1        PROC
 00003B04  68 000056A2 R	        push    offset DEBI_keyboard_objects
 00003B09  68 00008A08 R	        push    offset DEBI_m_mouse_objects
 00003B0E  68 000089FB R	        push    offset DEBI_m_screen_objects
 00003B13  EB 55		        jmp     invDEBI_new_window_common
 00003B15			    invDEBI_new_window_mem_1        ENDP




 00003B15			    invDEBI_new_window_mem_2        PROC
 00003B15  68 000056A2 R	        push    offset DEBI_keyboard_objects
 00003B1A  68 000076DC R	        push    offset DEBI_g_mouse_objects
 00003B1F  68 000076CF R	        push    offset DEBI_g_screen_objects
 00003B24  EB 44		        jmp     invDEBI_new_window_common
 00003B26			    invDEBI_new_window_mem_2        ENDP




 00003B26			    invDEBI_new_window_mem_3        PROC
 00003B26  68 000056A2 R	        push    offset DEBI_keyboard_objects
 00003B2B  68 00008DDD R	        push    offset DEBI_n_mouse_objects
 00003B30  68 00008DD0 R	        push    offset DEBI_n_screen_objects
 00003B35  EB 33		        jmp     invDEBI_new_window_common
 00003B37			    invDEBI_new_window_mem_3        ENDP




 00003B37			    invDEBI_new_window_mem_4        PROC
 00003B37  68 000056A2 R	        push    offset DEBI_keyboard_objects
 00003B3C  68 00007D34 R	        push    offset DEBI_h_mouse_objects
 00003B41  68 00007D27 R	        push    offset DEBI_h_screen_objects
 00003B46  EB 22		        jmp     invDEBI_new_window_common
 00003B48			    invDEBI_new_window_mem_4        ENDP




 00003B48			    invDEBI_new_window_locals       PROC
 00003B48  68 000056A2 R	        push    offset DEBI_keyboard_objects
 00003B4D  68 0000872D R	        push    offset DEBI_l_mouse_objects
 00003B52  68 00008645 R	        push    offset DEBI_l_screen_objects
 00003B57  EB 11		        jmp     invDEBI_new_window_common
 00003B59			    invDEBI_new_window_locals       ENDP




 00003B59			    invDEBI_new_window_stack        PROC
 00003B59  68 000056A2 R	        push    offset DEBI_keyboard_objects
 00003B5E  68 00007F82 R	        push    offset DEBI_i_mouse_objects
 00003B63  68 00007E9A R	        push    offset DEBI_i_screen_objects
 00003B68  EB 00		        jmp     invDEBI_new_window_common
 00003B6A			    invDEBI_new_window_stack        ENDP




 00003B6A			    invDEBI_new_window_common       PROC
				    ; This routine is used to create a new common window (if there's room for one)
				    ;
				    ; Upon entry:   The stack is arranged as below
				    ;
				    ; Upon exit:    The window is either created or not
				    ;
				      ; [esp+48] - Calling function offset
				      ; [esp+44] - Keyboard objects
				      ; [esp+40] - Mouse objects
				      ; [esp+36] - Screen objects
				      ; [esp+32] - eax
				      ; [esp+28] - ecx
				      ; [esp+24] - edx
				      ; [esp+20] - ebx
				      ; [esp+16] - esp
				      ; [esp+12] - ebp
				      ; [esp+08] - esi
				      ; [esp+04] - edi
				      ; [esp+00] - eflags
 00003B6A  60			        pushad
 00003B6B  9C			        pushfd

				      ; Determine if there's room
 00003B6C  BE 000054C2 R	        mov     esi,offset DEBI_screen_table
 00003B71  33 C9		        xor     ecx,ecx
				        .WHILE (ecx < 15)
 00003B73  EB 51	   *	    jmp    @C0422
 00003B75		   *@C0423:
				            .IF (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _NO)
 00003B75  80 7E 01 00	   *	    cmp    byte ptr ds : [esi + _ST_OBJECT_ACTIVE], _NO
 00003B79  75 47	   *	    jne    @C0424
				              ; We found where we can add it
 00003B7B  FA			                cli
 00003B7C  C6 06 01		                mov     byte ptr ds:[esi+_ST_OBJECT_ALTERABLE],_YES
 00003B7F  C6 46 01 01		                mov     byte ptr ds:[esi+_ST_OBJECT_ACTIVE],_YES
 00003B83  C7 46 04		                mov     dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL],0       ; Force it in the upper-left corner (they'll move it)
	   00000000
 00003B8A  C7 46 08		                mov     dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL],0
	   00000000
 00003B91  C7 46 0C		                mov     dword ptr ds:[esi+_ST_MEMVAR_OFFSET],-1
	   FFFFFFFF
 00003B98  8B 54 24 2C		                mov     edx,dword ptr ss:[esp+44]
 00003B9C  89 56 10		                mov     dword ptr ds:[esi+_ST_OBJECT_KBD_OFFSET],edx
 00003B9F  C7 46 14		                mov     dword ptr ds:[esi+_ST_OBJECT_MEMORY_OFFSET],-1
	   FFFFFFFF
 00003BA6  8B 54 24 28		                mov     edx,dword ptr ss:[esp+40]
 00003BAA  89 56 18		                mov     dword ptr ds:[esi+_ST_OBJECT_MOUSE_OFFSET],edx
 00003BAD  8B 54 24 24		                mov     edx,dword ptr ss:[esp+36]
 00003BB1  89 56 1C		                mov     dword ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET],edx

				              ; Right now, ds:[esi] - far ptr to this object
 00003BB4  E8 FFFFC906		                call    invDEBI_clear_screen_and_redraw_windows

 00003BB9  C6 05 0000B8BB R	                mov     ds:menu_restore_screen_after,_NO
	   00
 00003BC0  EB 09		                jmp     quit
				            .ENDIF
 00003BC2		   *@C0424:
 00003BC2  83 C6 20		            add     esi,_ST_LENGTH
 00003BC5  41			            inc     ecx
				        .ENDW
 00003BC6		   *@C0422:
 00003BC6  83 F9 0F	   *	    cmp    ecx, 00Fh
 00003BC9  72 AA	   *	    jb     @C0423

 00003BCB			      quit:
 00003BCB  9D			        popfd
 00003BCC  61			        popad
 00003BCD  83 C4 0C		        add     esp,12
 00003BD0  C3			        ret
 00003BD1			    invDEBI_new_window_common       ENDP
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; END - 66666 - Actions taken when various menu items are selected
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; 77777 - Menu bar events
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 00003BD1			    invDEBI_menu_continue_click     PROC
				    ; This routine is called when they click on the continue cask
 00003BD1  C6 05 0000B787 R	        mov     ds:debi_ok_to_quit,2
	   02
 00003BD8  F9			        stc
 00003BD9  C3			        ret
 00003BDA			    invDEBI_menu_continue_click     ENDP




 00003BDA			    invDEBI_menu_break_click        PROC
				    ; This routine is called when they click on the break cask
 00003BDA  C3			        ret
 00003BDB			    invDEBI_menu_break_click        ENDP




 00003BDB			    invDEBI_menu_over_click         PROC
				    ; This routine is called when they click on the over cask
 00003BDB  C3			        ret
 00003BDC			    invDEBI_menu_over_click         ENDP




 00003BDC			    invDEBI_menu_step_click         PROC
				    ; This routine is called when they click on the step cask
 00003BDC  C6 05 0000B787 R	        mov     ds:debi_ok_to_quit,1
	   01
 00003BE3  F9			        stc
 00003BE4  C3			        ret
 00003BE5			    invDEBI_menu_step_click         ENDP
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; END - 77777 - Menu bar events
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=










				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; 88888 - DRAG and DRAG RELEASE handlers
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 00003BE5			    invDEBI_object_drag_start       PROC
				    ; This routine is called when an object needs to be dragged
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to screen object
				    ;               ds:[edi] - far ptr to mouse object
				    ;
				    ; Upon exit:    The object is picked up and dragging begins
				    ;
 00003BE5  60			        pushad
 00003BE6  89 35 0000B7D9 R	        mov     ds:dragging_esi,esi
 00003BEC  89 3D 0000B7DD R	        mov     ds:dragging_edi,edi
 00003BF2  C7 05 0000B7E1 R	        mov     ds:dragging_object,_YES
	   00000001

				      ; Calculate starting coordinates
 00003BFC  8B 56 04		        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 00003BFF  89 15 0000B7AD R	        mov     ds:dragging_x,edx
 00003C05  8B 56 08		        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00003C08  89 15 0000B7B1 R	        mov     ds:dragging_y,edx

				      ; Grab the height and width
 00003C0E  8B 56 1C		        mov     edx,dword ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]
 00003C11  0F B7 42 FC		        movzx   eax,word ptr ds:[edx+_ST_OBJECT_SCREEN_WIDTH]
 00003C15  A3 0000B7B9 R	        mov     ds:dragging_width,eax
 00003C1A  0F B7 42 FE		        movzx   eax,word ptr ds:[edx+_ST_OBJECT_SCREEN_HEIGHT]
 00003C1E  A3 0000B7B5 R	        mov     ds:dragging_height,eax

				      ; Calculate the offset (the mouse wasn't at the upper-left corner when it was clicked, this tells how far away we were
 00003C23  8B 15 0000B82E R	        mov     edx,ds:mouse_left_click_x_start
 00003C29  2B 15 0000B7AD R	        sub     edx,ds:dragging_x
 00003C2F  89 15 0000B7BD R	        mov     ds:dragging_offset_x,edx

 00003C35  8B 15 0000B832 R	        mov     edx,ds:mouse_left_click_y_start
 00003C3B  2B 15 0000B7B1 R	        sub     edx,ds:dragging_y
 00003C41  89 15 0000B7C1 R	        mov     ds:dragging_offset_y,edx

				      ; Begin the dragging
 00003C47  C7 05 0000B7C5 R	        mov     ds:dragging_snap_x,8
	   00000008
 00003C51  C7 05 0000B7C9 R	        mov     ds:dragging_snap_y,6
	   00000006
 00003C5B  B2 01		        mov     dl,1
 00003C5D  E8 000003C6		        call    invDEBI_drag_start
 00003C62  61			        popad
 00003C63  C3			        ret
 00003C64			    invDEBI_object_drag_start       ENDP




 00003C64			    invDEBI_object_drag_stop        PROC
				    ; This routine is called when an object needs to be dragged
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to screen object
				    ;               ds:[edi] - far ptr to mouse object
				    ;
				    ; Upon exit:    The object is picked up and dragging begins
				    ;
				      ; Restore the original screen
 00003C64  C7 05 0000B7E1 R	        mov     ds:dragging_object,_NO
	   00000000
 00003C6E  E8 00000452		        call    invDEBI_drag_stop
 00003C73  E8 FFFFDAE4		        call    invDEBI_restore_screen2

 00003C78  9C			        pushfd
 00003C79  FA			        cli
 00003C7A  8B 35 0000B7D9 R	        mov     esi,ds:dragging_esi
				      ; Drop the window at its new location
 00003C80  8B 15 0000B7AD R	        mov     edx,ds:dragging_x
 00003C86  2B 15 0000B7BD R	        sub     edx,ds:dragging_offset_x
 00003C8C  52			        push    edx
 00003C8D  E8 FFFFD7A0		        call    invDEBI_dragging_snap_x
 00003C92  5A			        pop     edx
 00003C93  89 56 04		        mov     dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL],edx
				      ; Now, update the mouse position (we were snapping the values, and may not be exactly where we ended up)
 00003C96  03 15 0000B7BD R	        add     edx,ds:dragging_offset_x
 00003C9C  89 15 0000B7E5 R	        mov     ds:mouse_current_x,edx

 00003CA2  A1 0000B7B1 R	        mov     eax,ds:dragging_y
 00003CA7  2B 05 0000B7C1 R	        sub     eax,ds:dragging_offset_y
 00003CAD  50			        push    eax
 00003CAE  E8 FFFFD7A8		        call    invDEBI_dragging_snap_y
 00003CB3  58			        pop     eax
 00003CB4  89 46 08		        mov     dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL],eax
				      ; Now, update the mouse position
 00003CB7  03 05 0000B7C1 R	        add     eax,ds:dragging_offset_y
 00003CBD  A3 0000B7E9 R	        mov     ds:mouse_current_y,eax

				      ; Now, force a redraw
 00003CC2  0F B6 05		        movzx   eax,ds:force_screen_redraw
	   0000B786 R
 00003CC9  50			        push    eax
 00003CCA  C6 05 0000B786 R	        mov     ds:force_screen_redraw,_YES
	   01
 00003CD1  E8 FFFFC82B		        call    invDEBI_populate_debug_screen
 00003CD6  58			        pop     eax
 00003CD7  A2 0000B786 R	        mov     ds:force_screen_redraw,al


 00003CDC  9D			        popfd

 00003CDD  C3			        ret
 00003CDE			    invDEBI_object_drag_stop        ENDP




 00003CDE			    invDEBI_stx_drag_start  PROC
				    ; This routine is called when a left-drag event is recognized from the various stx regions
				      ; Save original information
 00003CDE  60			        pushad
 00003CDF  89 35 0000B8E4 R	        mov     ds:fpu_esi,esi
 00003CE5  89 3D 0000B8E8 R	        mov     ds:fpu_edi,edi

 00003CEB  A1 0000B82E R	        mov     eax,ds:mouse_left_click_x_start
 00003CF0  A3 0000B8EC R	        mov     ds:fpu_x,eax
 00003CF5  8B 15 0000B832 R	        mov     edx,ds:mouse_left_click_y_start
 00003CFB  89 15 0000B8F0 R	        mov     ds:fpu_y,edx
 00003D01  E8 000000ED		        call    invDEBI_determine_stx_variable
 00003D06  89 15 0000B8F8 R	        mov     ds:fpu_source,edx
				      ; Right now, edx - offset to reach the stx value on the stack
				      ;            ecx - x value of st(x)
				      ;            eax - position down the screen (0-st7, 1-st6, 7-st0)
				        .IF (edx == -1)
 00003D0C  83 FA FF	   *	    cmp    edx, - 001h
 00003D0F  75 02	   *	    jne    @C0427
 00003D11  EB 70		            jmp     quit
				        .ENDIF
 00003D13		   *@C0427:

				      ; Move down the specified number of stx's
 00003D13  BB 00000006		        mov     ebx,FONT_Y
 00003D18  F7 E3		        mul     ebx
 00003D1A  8B 56 04		        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 00003D1D  03 57 01		        add     edx,dword ptr ds:[edi+_MO_X1]
 00003D20  89 15 0000B7AD R	        mov     ds:dragging_x,edx

 00003D26  A3 0000B8F4 R	        mov     ds:fpu_data,eax
 00003D2B  29 05 0000B8F0 R	        sub     ds:fpu_y,eax
 00003D31  03 46 08		        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00003D34  03 47 05		        add     eax,dword ptr ds:[edi+_MO_Y1]
 00003D37  A3 0000B7B1 R	        mov     ds:dragging_y,eax

				      ; Setup the variables for dragging
 00003D3C  8B 57 09		        mov     edx,dword ptr ds:[edi+_MO_X2]
 00003D3F  2B 57 01		        sub     edx,dword ptr ds:[edi+_MO_X1]
 00003D42  83 C2 08		        add     edx,8
 00003D45  83 E2 F8		        and     edx,not 111b                                        ; Round to nearest 8th pixel (so we only load multiples of 8)
 00003D48  89 15 0000B7B9 R	        mov     ds:dragging_width,edx
 00003D4E  C7 05 0000B7B5 R	        mov     ds:dragging_height,FONT_Y-1                         ; change base-1 to base-0
	   00000005

				      ; Determine the offset
 00003D58  8B 15 0000B8EC R	        mov     edx,ds:fpu_x
 00003D5E  2B 56 04		        sub     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 00003D61  2B 57 01		        sub     edx,dword ptr ds:[edi+_MO_X1]
 00003D64  89 15 0000B7BD R	        mov     ds:dragging_offset_x,edx

 00003D6A  8B 15 0000B8F0 R	        mov     edx,ds:fpu_y
 00003D70  2B 56 08		        sub     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00003D73  2B 57 05		        sub     edx,dword ptr ds:[edi+_MO_Y1]
 00003D76  89 15 0000B7C1 R	        mov     ds:dragging_offset_y,edx

 00003D7C  B2 01		        mov     dl,1
 00003D7E  E8 000002A5		        call    invDEBI_drag_start
 00003D83			      quit:
 00003D83  61			        popad
 00003D84  C3			        ret
 00003D85			    invDEBI_stx_drag_start  ENDP




 00003D85			    invDEBI_stx_drag_stop   PROC
				    ; This routine is called when something is dropped over an stx region
				      ; Cancel the dragging
				        .IF (ds:dragging_object == _YES)
 00003D85  83 3D 0000B7E1 R
	   01		   *	    cmp    ds : dragging_object, _YES
 00003D8C  75 05	   *	    jne    @C0429
 00003D8E  E9 FFFFFED1		            jmp     invDEBI_object_drag_stop
				        .ENDIF
 00003D93		   *@C0429:
 00003D93  E8 0000032D		        call    invDEBI_drag_stop
 00003D98  E8 FFFFD9BF		        call    invDEBI_restore_screen2

				      ; Determine where they landed
 00003D9D  8B 3D 0000B8E8 R	        mov     edi,ds:fpu_edi
 00003DA3  A1 0000B83E R	        mov     eax,ds:mouse_left_click_x_stop
 00003DA8  2B 05 0000B7BD R	        sub     eax,ds:dragging_offset_x
				      ; Right now, eax is the upper left corner
				      ; But, the way things are dragged in this system we have to average out the location
 00003DAE  8B 5F 09		        mov     ebx,dword ptr ds:[edi+_MO_X2]
 00003DB1  2B 5F 01		        sub     ebx,dword ptr ds:[edi+_MO_X1]
 00003DB4  D1 EB		        shr     ebx,1
 00003DB6  03 C3		        add     eax,ebx
				      ; Right now, eax is the average (to the nearest pixel) of the left side and right side
 00003DB8  A3 0000B8EC R	        mov     ds:fpu_x,eax

 00003DBD  8B 15 0000B842 R	        mov     edx,ds:mouse_left_click_y_stop
 00003DC3  2B 15 0000B7C1 R	        sub     edx,ds:dragging_offset_y
 00003DC9  83 C2 03		        add     edx,FONT_Y / 2
				      ; Right now, edx is the average (to the nearest pixel) of the top and bottom
 00003DCC  89 15 0000B8F0 R	        mov     ds:fpu_y,edx

 00003DD2  E8 0000001C		        call    invDEBI_determine_stx_variable
				        .IF (edx != -1)
 00003DD7  83 FA FF	   *	    cmp    edx, - 001h
 00003DDA  74 16	   *	    je     @C042B
 00003DDC  9B DB E3		            finit
 00003DDF  8B 1D 0000B8F8 R	            mov     ebx,ds:fpu_source
 00003DE5  36: DB 2C 2B		            fld     tbyte ptr ss:[ebp+ebx]
 00003DE9  36: DB 3C 2A		            fstp    tbyte ptr ss:[ebp+edx]
 00003DED  E8 FFFFE7DC		            call    invDEBI_FPU_update_display
				        .ENDIF
 00003DF2		   *@C042B:
 00003DF2  C3			        ret
 00003DF3			    invDEBI_stx_drag_stop   ENDP




 00003DF3			    invDEBI_determine_stx_variable      PROC
				    ; This routine is used to determine which stx variable was clicked on (assuming st7 is at the top, st0 at the bottom)
				    ;
				    ; Upon entry:   ds:fpu_x - X coord where click was made
				    ;               ds:fpu_y - Y coord
				    ;               ds:[esi] - far ptr to screen object
				    ;               ds:[edi] - far ptr to mouse object
				    ;
				    ; Upon exit:    edx - offset to get to stx variable on stack
				    ;               ecx - x value in stx, -1 if invalid range specified
				    ;
 00003DF3  53			        push    ebx

 00003DF4  8B 15 0000B8F0 R	        mov     edx,ds:fpu_y
 00003DFA  2B 56 08		        sub     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00003DFD  2B 57 05		        sub     edx,dword ptr ds:[edi+_MO_Y1]
				      ; Right now, edx - pixels down from upper-left coordinate of stx block
 00003E00  8B C2		        mov     eax,edx
 00003E02  33 D2		        xor     edx,edx
 00003E04  BB 00000006		        mov     ebx,FONT_Y
 00003E09  F7 F3		        div     ebx
				      ; Right now, eax - the # of items down
				        .IF (al == 0)
 00003E0B  0A C0	   *	    or	al, al
 00003E0D  75 0C	   *	    jne    @C042D
				          ; st7
 00003E0F  BA FFFFFF9A		            mov     edx,-200+98
 00003E14  B9 00000007		            mov     ecx,7
				        .ELSEIF (al == 1)
 00003E19  EB 7A	   *	    jmp    @C042F
 00003E1B		   *@C042D:
 00003E1B  3C 01	   *	    cmp    al, 001h
 00003E1D  75 0C	   *	    jne    @C0430
				          ; st6
 00003E1F  BA FFFFFF90		            mov     edx,-200+88
 00003E24  B9 00000006		            mov     ecx,6
				        .ELSEIF (al == 2)
 00003E29  EB 6A	   *	    jmp    @C0432
 00003E2B		   *@C0430:
 00003E2B  3C 02	   *	    cmp    al, 002h
 00003E2D  75 0C	   *	    jne    @C0433
				          ; st5
 00003E2F  BA FFFFFF86		            mov     edx,-200+78
 00003E34  B9 00000005		            mov     ecx,5
				        .ELSEIF (al == 3)
 00003E39  EB 5A	   *	    jmp    @C0435
 00003E3B		   *@C0433:
 00003E3B  3C 03	   *	    cmp    al, 003h
 00003E3D  75 0C	   *	    jne    @C0436
				          ; st4
 00003E3F  BA FFFFFF7C		            mov     edx,-200+68
 00003E44  B9 00000004		            mov     ecx,4
				        .ELSEIF (al == 4)
 00003E49  EB 4A	   *	    jmp    @C0438
 00003E4B		   *@C0436:
 00003E4B  3C 04	   *	    cmp    al, 004h
 00003E4D  75 0C	   *	    jne    @C0439
				          ; st3
 00003E4F  BA FFFFFF72		            mov     edx,-200+58
 00003E54  B9 00000003		            mov     ecx,3
				        .ELSEIF (al == 5)
 00003E59  EB 3A	   *	    jmp    @C043B
 00003E5B		   *@C0439:
 00003E5B  3C 05	   *	    cmp    al, 005h
 00003E5D  75 0C	   *	    jne    @C043C
				          ; st2
 00003E5F  BA FFFFFF68		            mov     edx,-200+48
 00003E64  B9 00000002		            mov     ecx,2
				        .ELSEIF (al == 6)
 00003E69  EB 2A	   *	    jmp    @C043E
 00003E6B		   *@C043C:
 00003E6B  3C 06	   *	    cmp    al, 006h
 00003E6D  75 0C	   *	    jne    @C043F
				          ; st1
 00003E6F  BA FFFFFF5E		            mov     edx,-200+38
 00003E74  B9 00000001		            mov     ecx,1
				        .ELSEIF (al == 7)
 00003E79  EB 1A	   *	    jmp    @C0441
 00003E7B		   *@C043F:
 00003E7B  3C 07	   *	    cmp    al, 007h
 00003E7D  75 0C	   *	    jne    @C0442
				          ; st0
 00003E7F  BA FFFFFF54		            mov     edx,-200+28
 00003E84  B9 00000000		            mov     ecx,0
				        .ELSE
 00003E89  EB 0A	   *	    jmp    @C0444
 00003E8B		   *@C0442:
 00003E8B  BA FFFFFFFF		            mov     edx,-1
 00003E90  B9 FFFFFFFF		            mov     ecx,-1
				        .ENDIF
 00003E95		   *@C0444:
 00003E95		   *@C0441:
 00003E95		   *@C043E:
 00003E95		   *@C043B:
 00003E95		   *@C0438:
 00003E95		   *@C0435:
 00003E95		   *@C0432:
 00003E95		   *@C042F:

 00003E95  5B			        pop     ebx
 00003E96  C3			        ret
 00003E97			    invDEBI_determine_stx_variable      ENDP




 00003E97			    invDEBI_mmx_drag_start  PROC
				    ; This routine is called when a left-drag event is recognized from the various mmx regions
				      ; Save original information
 00003E97  60			        pushad
 00003E98  89 35 0000B8E4 R	        mov     ds:fpu_esi,esi
 00003E9E  89 3D 0000B8E8 R	        mov     ds:fpu_edi,edi

 00003EA4  A1 0000B82E R	        mov     eax,ds:mouse_left_click_x_start
 00003EA9  A3 0000B8EC R	        mov     ds:fpu_x,eax
 00003EAE  8B 15 0000B832 R	        mov     edx,ds:mouse_left_click_y_start
 00003EB4  89 15 0000B8F0 R	        mov     ds:fpu_y,edx
 00003EBA  E8 000000ED		        call    invDEBI_determine_mmx_variable
 00003EBF  89 15 0000B8F8 R	        mov     ds:fpu_source,edx
				      ; Right now, edx - offset to reach the mmx value on the stack
				      ;            eax - position down the screen (0-mm0, 1-mm1, 7-mm7)
				        .IF (edx == -1)
 00003EC5  83 FA FF	   *	    cmp    edx, - 001h
 00003EC8  75 02	   *	    jne    @C0445
 00003ECA  EB 70		            jmp     quit
				        .ENDIF
 00003ECC		   *@C0445:

				      ; Move down the specified number of mmx's
 00003ECC  BB 00000006		        mov     ebx,FONT_Y
 00003ED1  F7 E3		        mul     ebx
 00003ED3  8B 56 04		        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 00003ED6  03 57 01		        add     edx,dword ptr ds:[edi+_MO_X1]
 00003ED9  89 15 0000B7AD R	        mov     ds:dragging_x,edx

 00003EDF  A3 0000B8F4 R	        mov     ds:fpu_data,eax
 00003EE4  29 05 0000B8F0 R	        sub     ds:fpu_y,eax
 00003EEA  03 46 08		        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00003EED  03 47 05		        add     eax,dword ptr ds:[edi+_MO_Y1]
 00003EF0  A3 0000B7B1 R	        mov     ds:dragging_y,eax

				      ; Setup the variables for dragging
 00003EF5  8B 57 09		        mov     edx,dword ptr ds:[edi+_MO_X2]
 00003EF8  2B 57 01		        sub     edx,dword ptr ds:[edi+_MO_X1]
 00003EFB  83 C2 08		        add     edx,8
 00003EFE  83 E2 F8		        and     edx,not 111b                                        ; Round to nearest 8th pixel (so we only load multiples of 8)
 00003F01  89 15 0000B7B9 R	        mov     ds:dragging_width,edx
 00003F07  C7 05 0000B7B5 R	        mov     ds:dragging_height,FONT_Y-1                         ; change base-1 to base-0
	   00000005

				      ; Determine the offset
 00003F11  8B 15 0000B8EC R	        mov     edx,ds:fpu_x
 00003F17  2B 56 04		        sub     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 00003F1A  2B 57 01		        sub     edx,dword ptr ds:[edi+_MO_X1]
 00003F1D  89 15 0000B7BD R	        mov     ds:dragging_offset_x,edx

 00003F23  8B 15 0000B8F0 R	        mov     edx,ds:fpu_y
 00003F29  2B 56 08		        sub     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00003F2C  2B 57 05		        sub     edx,dword ptr ds:[edi+_MO_Y1]
 00003F2F  89 15 0000B7C1 R	        mov     ds:dragging_offset_y,edx

 00003F35  B2 01		        mov     dl,1
 00003F37  E8 000000EC		        call    invDEBI_drag_start
 00003F3C			      quit:
 00003F3C  61			        popad
 00003F3D  C3			        ret
 00003F3E			    invDEBI_mmx_drag_start  ENDP




 00003F3E			    invDEBI_mmx_drag_stop   PROC
				    ; This routine is called when something is dropped over an mmx region
				      ; Cancel the dragging
				        .IF (ds:dragging_object == _YES)
 00003F3E  83 3D 0000B7E1 R
	   01		   *	    cmp    ds : dragging_object, _YES
 00003F45  75 05	   *	    jne    @C0447
 00003F47  E9 FFFFFD18		            jmp     invDEBI_object_drag_stop
				        .ENDIF
 00003F4C		   *@C0447:
 00003F4C  E8 00000174		        call    invDEBI_drag_stop
 00003F51  E8 FFFFD806		        call    invDEBI_restore_screen2

				      ; Determine where they landed
 00003F56  8B 3D 0000B8E8 R	        mov     edi,ds:fpu_edi
 00003F5C  A1 0000B83E R	        mov     eax,ds:mouse_left_click_x_stop
 00003F61  2B 05 0000B7BD R	        sub     eax,ds:dragging_offset_x
				      ; Right now, eax is the upper left corner
				      ; But, the way things are dragged in this system we have to average out the location
 00003F67  8B 5F 09		        mov     ebx,dword ptr ds:[edi+_MO_X2]
 00003F6A  2B 5F 01		        sub     ebx,dword ptr ds:[edi+_MO_X1]
 00003F6D  D1 EB		        shr     ebx,1
 00003F6F  03 C3		        add     eax,ebx
				      ; Right now, eax is the average (to the nearest pixel) of the left side and right side
 00003F71  A3 0000B8EC R	        mov     ds:fpu_x,eax

 00003F76  8B 15 0000B842 R	        mov     edx,ds:mouse_left_click_y_stop
 00003F7C  2B 15 0000B7C1 R	        sub     edx,ds:dragging_offset_y
 00003F82  83 C2 03		        add     edx,FONT_Y / 2
				      ; Right now, edx is the average (to the nearest pixel) of the top and bottom
 00003F85  89 15 0000B8F0 R	        mov     ds:fpu_y,edx

 00003F8B  E8 0000001C		        call    invDEBI_determine_mmx_variable
				        .IF (edx != -1)
 00003F90  83 FA FF	   *	    cmp    edx, - 001h
 00003F93  74 16	   *	    je     @C0449
 00003F95  9B DB E3		            finit
 00003F98  8B 1D 0000B8F8 R	            mov     ebx,ds:fpu_source
 00003F9E  36: DF 2C 2B		            fild    qword ptr ss:[ebp+ebx]
 00003FA2  36: DF 3C 2A		            fistp   qword ptr ss:[ebp+edx]
 00003FA6  E8 FFFFE623		            call    invDEBI_FPU_update_display
				        .ENDIF
 00003FAB		   *@C0449:
 00003FAB  C3			        ret
 00003FAC			    invDEBI_mmx_drag_stop   ENDP




 00003FAC			    invDEBI_determine_mmx_variable      PROC
				    ; This routine is used to determine which mmx variable was clicked on (assuming st7 is at the top, st0 at the bottom)
				    ;
				    ; Upon entry:   ds:fpu_x - X coord where click was made
				    ;               ds:fpu_y - Y coord
				    ;               ds:[esi] - far ptr to screen object
				    ;               ds:[edi] - far ptr to mouse object
				    ;
				    ; Upon exit:    edx - offset to get to mmx variable on stack
				    ;               ecx - x value in mmx, -1 if invalid range specified
				    ;
 00003FAC  53			        push    ebx

 00003FAD  8B 15 0000B8F0 R	        mov     edx,ds:fpu_y
 00003FB3  2B 56 08		        sub     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00003FB6  2B 57 05		        sub     edx,dword ptr ds:[edi+_MO_Y1]
				      ; Right now, edx - pixels down from upper-left coordinate of mmx block
 00003FB9  8B C2		        mov     eax,edx
 00003FBB  33 D2		        xor     edx,edx
 00003FBD  BB 00000006		        mov     ebx,FONT_Y
 00003FC2  F7 F3		        div     ebx
				      ; Right now, eax - the # of items down
				        .IF (al == 0)
 00003FC4  0A C0	   *	    or	al, al
 00003FC6  75 07	   *	    jne    @C044B
				          ; mm0
 00003FC8  BA FFFFFF54		            mov     edx,-200+28
				        .ELSEIF (al == 1)
 00003FCD  EB 57	   *	    jmp    @C044D
 00003FCF		   *@C044B:
 00003FCF  3C 01	   *	    cmp    al, 001h
 00003FD1  75 07	   *	    jne    @C044E
				          ; mm1
 00003FD3  BA FFFFFF5E		            mov     edx,-200+38
				        .ELSEIF (al == 2)
 00003FD8  EB 4C	   *	    jmp    @C0450
 00003FDA		   *@C044E:
 00003FDA  3C 02	   *	    cmp    al, 002h
 00003FDC  75 07	   *	    jne    @C0451
				          ; mm2
 00003FDE  BA FFFFFF68		            mov     edx,-200+48
				        .ELSEIF (al == 3)
 00003FE3  EB 41	   *	    jmp    @C0453
 00003FE5		   *@C0451:
 00003FE5  3C 03	   *	    cmp    al, 003h
 00003FE7  75 07	   *	    jne    @C0454
				          ; mm3
 00003FE9  BA FFFFFF72		            mov     edx,-200+58
				        .ELSEIF (al == 4)
 00003FEE  EB 36	   *	    jmp    @C0456
 00003FF0		   *@C0454:
 00003FF0  3C 04	   *	    cmp    al, 004h
 00003FF2  75 07	   *	    jne    @C0457
				          ; mm4
 00003FF4  BA FFFFFF7C		            mov     edx,-200+68
				        .ELSEIF (al == 5)
 00003FF9  EB 2B	   *	    jmp    @C0459
 00003FFB		   *@C0457:
 00003FFB  3C 05	   *	    cmp    al, 005h
 00003FFD  75 07	   *	    jne    @C045A
				          ; mm5
 00003FFF  BA FFFFFF86		            mov     edx,-200+78
				        .ELSEIF (al == 6)
 00004004  EB 20	   *	    jmp    @C045C
 00004006		   *@C045A:
 00004006  3C 06	   *	    cmp    al, 006h
 00004008  75 07	   *	    jne    @C045D
				          ; mm6
 0000400A  BA FFFFFF90		            mov     edx,-200+88
				        .ELSEIF (al == 7)
 0000400F  EB 15	   *	    jmp    @C045F
 00004011		   *@C045D:
 00004011  3C 07	   *	    cmp    al, 007h
 00004013  75 07	   *	    jne    @C0460
				          ; mm7
 00004015  BA FFFFFF9A		            mov     edx,-200+98
				        .ELSE
 0000401A  EB 0A	   *	    jmp    @C0462
 0000401C		   *@C0460:
 0000401C  BA FFFFFFFF		            mov     edx,-1
 00004021  B9 FFFFFFFF		            mov     ecx,-1
				        .ENDIF
 00004026		   *@C0462:
 00004026		   *@C045F:
 00004026		   *@C045C:
 00004026		   *@C0459:
 00004026		   *@C0456:
 00004026		   *@C0453:
 00004026		   *@C0450:
 00004026		   *@C044D:

 00004026  5B			        pop     ebx
 00004027  C3			        ret
 00004028			    invDEBI_determine_mmx_variable      ENDP




 00004028			    invDEBI_drag_start      PROC
				    ; This routine is used to begin the process of grabbing something on the screen in preparation for dragging it
				    ;
				    ; Upon entry:   ds:dragging_* - setup
				    ;                          dl - How to grab?  0-grab object as is, 1-grab as NOT image of itself
 00004028  1E			        push    ds
 00004029  60			        pushad
 0000402A  9C			        pushfd

				      ; Save this object to the screen buffer (for dragging)
				        .IF (dl == 0)
 0000402B  0A D2	   *	    or	dl, dl
 0000402D  75 07	   *	    jne    @C0463
				          ; Grab the image as is
 0000402F  B8 00000001		            mov     eax,1
				        .ELSE
 00004034  EB 05	   *	    jmp    @C0465
 00004036		   *@C0463:
				          ; Grab the NOT image of itself
 00004036  B8 0000000B		            mov     eax,11
				        .ENDIF
 0000403B		   *@C0465:

 0000403B  FA			        cli
				      ; Grab the image to be dragged
 0000403C  FF 35 0000B7AD R	        push    dword ptr ds:dragging_x
 00004042  FF 35 0000B7B1 R	        push    dword ptr ds:dragging_y
 00004048  8B 15 0000B7AD R	        mov     edx,ds:dragging_x
 0000404E  03 15 0000B7B9 R	        add     edx,ds:dragging_width
 00004054  52			        push    edx
 00004055  8B 15 0000B7B1 R	        mov     edx,ds:dragging_y
 0000405B  03 15 0000B7B5 R	        add     edx,ds:dragging_height
 00004061  52			        push    edx
 00004062  50			        push    eax                                                 ; Get or Get_NOT
 00004063  68 00004000		        push    dword ptr 4000h
 00004068  B8 000000D0		        mov     eax,_sDEBI_screen
 0000406D  8E D8		        mov     ds,eax
 0000406F  2E: FF 1D		        call    fword ptr cs:_VID_g_mono_window_function
	   0000D0FD R

				      ; Clear the image of where it was dragged
 00004076  2E: FF 35		        push    dword ptr cs:dragging_x
	   0000B7AD R
 0000407D  2E: FF 35		        push    dword ptr cs:dragging_y
	   0000B7B1 R
 00004084  2E: A1		        mov     eax,cs:dragging_x
	   0000B7AD R
 0000408A  2E: 03 05		        add     eax,cs:dragging_width
	   0000B7B9 R
 00004091  50			        push    eax
 00004092  2E: 8B 15		        mov     edx,cs:dragging_y
	   0000B7B1 R
 00004099  2E: 03 15		        add     edx,cs:dragging_height
	   0000B7B5 R
 000040A0  52			        push    edx
 000040A1  68 00000002		        push    dword ptr 2                                         ; Clear
 000040A6  68 00000000		        push    dword ptr 0                                         ; Not used here, but required for spacer
 000040AB  2E: FF 1D		        call    fword ptr cs:_VID_g_mono_window_function
	   0000D0FD R

				      ; Save the screen after the area has been cleared
 000040B2  E8 FFFFD682		        call    invDEBI_save_screen2

 000040B7  9D			        popfd
 000040B8  61			        popad
 000040B9  1F			        pop     ds
 000040BA  C7 05 0000B7A9 R	        mov     ds:dragging_something,1
	   00000001
 000040C4  C3			        ret
 000040C5			    invDEBI_drag_start      ENDP




 000040C5			    invDEBI_drag_stop       PROC
				        .IF (ds:dragging_object == _YES)
 000040C5  83 3D 0000B7E1 R
	   01		   *	    cmp    ds : dragging_object, _YES
 000040CC  75 07	   *	    jne    @C0466
				          ; We're dragging a window (no release point was specified because it could be released anywhere)
 000040CE  E8 FFFFFB91		            call    invDEBI_object_drag_stop
				        .ELSE
 000040D3  EB 14	   *	    jmp    @C0468
 000040D5		   *@C0466:
				          ; We're just canceling the drag
 000040D5  C7 05 0000B7A9 R	            mov     ds:dragging_something,0
	   00000000
 000040DF  C7 05 0000B7D5 R	            mov     ds:dragging_skipped,0
	   00000000
				        .ENDIF
 000040E9		   *@C0468:
 000040E9  C3			        ret
 000040EA			    invDEBI_drag_stop       ENDP
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; END - 88888 - DRAG and DRAG RELEASE handlers
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=










				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; 99999 - Keyboard events
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 000040EA			    invDEBI_clear_text_22        PROC
				    ; This routine is called when there is input to process from the keyboard
				    ;
				    ; Upon entry:   eax - key
				    ;               ebx - flags
				    ;                ds - Debi's data segment
				    ;
				    ; Upon exit:    The key is either accepted and processed or ignored
				    ;               Note that processing might include moving to another field
				    ;
				        .IF (ax == tab)
 000040EA  66| 3D 0F09	   *	    cmp    ax, tab
 000040EE  75 0C	   *	    jne    @C0469
				          ; Move to next item (or first one if we're on the last)
 000040F0  BA 00000001		            mov     edx,1
 000040F5  E8 00000503		            call    invDEBI_next_keyboard_item
				        .ELSEIF (ax == shift_tab)
 000040FA  EB 4D	   *	    jmp    @C046B
 000040FC		   *@C0469:
 000040FC  66| 3D 0F00	   *	    cmp    ax, shift_tab
 00004100  75 0C	   *	    jne    @C046C
				          ; Move to previous item (or last one if we're on the first)
 00004102  BA FFFFFFFF		            mov     edx,-1
 00004107  E8 000004F1		            call    invDEBI_next_keyboard_item
				        .ELSEIF (ax == enter_key || ax == grey_enter)
 0000410C  EB 3B	   *	    jmp    @C046E
 0000410E		   *@C046C:
 0000410E  66| 3D 1C0D	   *	    cmp    ax, enter_key
 00004112  74 06	   *	    je     @C0470
 00004114  66| 3D E00D	   *	    cmp    ax, grey_enter
 00004118  75 2F	   *	    jne    @C046F
 0000411A		   *@C0470:
				          ; They've selected this option
 0000411A  E8 000006F4		            call    invDEBI_lostFocus
 0000411F  BE 0000AFBD R	            mov     esi,offset text_22
 00004124  B9 00000016		            mov     ecx,22
 00004129  E8 00000094		            call    invDEBI_input_clear_field
 0000412E  8B 35 0000B79C R	            mov     esi,ds:screen_object
 00004134  E8 000000B9		            call    invDEBI_screen_refresh
 00004139  BF 0000AFF6 R	            mov     edi,offset text_22_object
 0000413E  89 3D 0000B78C R	            mov     ds:kbd_object,edi
 00004144  E8 000005B4		            call    invDEBI_setFocus
				        .ENDIF
 00004149		   *@C046F:
 00004149		   *@C046E:
 00004149		   *@C046B:
 00004149  C3			        ret
 0000414A			    invDEBI_clear_text_22        ENDP




 0000414A			    invDEBI_input_clear_var_click       PROC
				    ; This routine is called when a mouse button is clicked on the "text_22" clear-item option
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to screen object
				    ;               ds:[edi] - far ptr to mouse object
				    ;
				    ; Upon exit:    The input field is cleared, and the focus is set
				    ;
 0000414A  8B 77 15		        mov     esi,dword ptr ds:[edi+_MO_DATA1]
 0000414D  0F B7 4F 19		        movzx   ecx,word ptr ds:[edi+_MO_DATA2]
 00004151  E8 0000006C		        call    invDEBI_input_clear_field
 00004156  8B 35 0000B79C R	        mov     esi,ds:screen_object
 0000415C  E8 00000091		        call    invDEBI_screen_refresh
 00004161  C3			        ret
 00004162			    invDEBI_input_clear_var_click       ENDP




 00004162			    invDEBI_clear_disp_22       PROC
				    ; This routine is called when there is input to process from the keyboard
				    ;
				    ; Upon entry:   eax - key
				    ;               ebx - flags
				    ;                ds - Debi's data segment
				    ;
				    ; Upon exit:    The key is either accepted and processed or ignored
				    ;               Note that processing might include moving to another field
				    ;
				        .IF (ax == tab)
 00004162  66| 3D 0F09	   *	    cmp    ax, tab
 00004166  75 0C	   *	    jne    @C0472
				          ; Move to next item (or first one if we're on the last)
 00004168  BA 00000001		            mov     edx,1
 0000416D  E8 0000048B		            call    invDEBI_next_keyboard_item
				        .ELSEIF (ax == shift_tab)
 00004172  EB 4D	   *	    jmp    @C0474
 00004174		   *@C0472:
 00004174  66| 3D 0F00	   *	    cmp    ax, shift_tab
 00004178  75 0C	   *	    jne    @C0475
				          ; Move to previous item (or last one if we're on the first)
 0000417A  BA FFFFFFFF		            mov     edx,-1
 0000417F  E8 00000479		            call    invDEBI_next_keyboard_item
				        .ELSEIF (ax == enter_key || ax == grey_enter)
 00004184  EB 3B	   *	    jmp    @C0477
 00004186		   *@C0475:
 00004186  66| 3D 1C0D	   *	    cmp    ax, enter_key
 0000418A  74 06	   *	    je     @C0479
 0000418C  66| 3D E00D	   *	    cmp    ax, grey_enter
 00004190  75 2F	   *	    jne    @C0478
 00004192		   *@C0479:
				          ; They've selected this option
 00004192  E8 0000067C		            call    invDEBI_lostFocus
 00004197  BE 0000AFD4 R	            mov     esi,offset disp_22
 0000419C  B9 00000016		            mov     ecx,22
 000041A1  E8 0000001C		            call    invDEBI_input_clear_field
 000041A6  8B 35 0000B79C R	            mov     esi,ds:screen_object
 000041AC  E8 00000041		            call    invDEBI_screen_refresh
 000041B1  BF 0000B026 R	            mov     edi,offset disp_22_object
 000041B6  89 3D 0000B78C R	            mov     ds:kbd_object,edi
 000041BC  E8 0000053C		            call    invDEBI_setFocus
				        .ENDIF
 000041C1		   *@C0478:
 000041C1		   *@C0477:
 000041C1		   *@C0474:
 000041C1  C3			        ret
 000041C2			    invDEBI_clear_disp_22       ENDP




 000041C2			    invDEBI_input_clear_field       PROC
				    ; This routine is called to clear the contents of a field
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to string
				    ;                    ecx - length of string
				    ;
				    ; Upon exit:    String is reset to spaces
 000041C2  51			        push    ecx
 000041C3  56			        push    esi
				        .WHILE (ecx > 0)
 000041C4  EB 05	   *	    jmp    @C047B
 000041C6		   *@C047C:
 000041C6  C6 06 20		            mov     byte ptr ds:[esi],32
 000041C9  46			            inc     esi
 000041CA  49			            dec     ecx
				        .ENDW
 000041CB		   *@C047B:
 000041CB  83 F9 00	   *	    cmp    ecx, 000h
 000041CE  77 F6	   *	    ja     @C047C
 000041D0  5E			        pop     esi
 000041D1  59			        pop     ecx
 000041D2  C3			        ret
 000041D3			    invDEBI_input_clear_field       ENDP




 000041D3			    invDEBI_checkbox_mouse_handler      PROC
				    ; This routine is called to toggle a character from "X" to space, and back again
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to screen objects
				    ;               ds:[edi] - far ptr to mouse objects
				    ;
				    ; Upon exit:    The data item pointed to by the mouse object is toggled
				    ;
 000041D3  8B 5F 15		        mov     ebx,dword ptr ds:[edi+_MO_DATA]
 000041D6  E8 00000001		        call    invDEBI_checkbox_toggle
 000041DB  C3			        ret
 000041DC			    invDEBI_checkbox_mouse_handler      ENDP




 000041DC			    invDEBI_checkbox_toggle     PROC
				    ; This routine executes a toggle on the data item at ds:[ebx]
				    ;
				    ; Upon entry:   ds:[ebx] - The byte there is either a space or something else
				    ;
				    ; Upon exit:    If it's a space, it's changed to an 'X'
				    ;               If it's something else, it's changed to a space
				    ;               The screen is refreshed
				    ;
 000041DC  B0 20		        mov     al,32
				        .IF (byte ptr ds:[ebx] == al)
 000041DE  38 03	   *	    cmp    byte ptr ds : [ebx], al
 000041E0  75 02	   *	    jne    @C047E
				          ; It's a space
 000041E2  B0 58		            mov     al,'X'
				        .ENDIF
 000041E4		   *@C047E:
 000041E4  88 03		        mov     byte ptr ds:[ebx],al

				      ; Refresh the screen with the new data
 000041E6  8B 35 0000B79C R	        mov     esi,ds:screen_object
 000041EC  E8 00000001		        call    invDEBI_screen_refresh
 000041F1  C3			        ret
 000041F2			    invDEBI_checkbox_toggle     ENDP




 000041F2			    invDEBI_screen_refresh      PROC
				    ; This routine is called when the current screen needs to be redrawn, then all keyboard objects contained within redrawn also
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to screen objects to refresh
				    ;
				    ; Upon exit:    The screen is redrawn first, then any and all keyboard objects are redrawn afterwards
				    ;               This has the effect of rendering the victim extremely succeptable to ... er, suggestion.
				    ;               Oh, sorry.  Uhm, this has the effect of refreshing the current screen
				    ;
 000041F2  60			        pushad
 000041F3  9C			        pushfd
				      ; Save current object
 000041F4  FF 35 0000B78C R	        push    ds:kbd_object

				      ; Save textbox items
 000041FA  FF 35 0000B908 R	        push    ds:textbox_x
 00004200  FF 35 0000B90C R	        push    ds:textbox_y
 00004206  FF 35 0000B910 R	        push    ds:textbox_offset
 0000420C  FF 35 0000B918 R	        push    ds:textbox_sel_end                                  ; Note, only sel_end is used to determine if text is selected

				      ; Save checkbox items
 00004212  FF 35 0000B91C R	        push    ds:checkbox_x
 00004218  FF 35 0000B920 R	        push    ds:checkbox_y
 0000421E  FF 35 0000B924 R	        push    ds:checkbox_offset

				      ; Save button items
 00004224  FF 35 0000B928 R	        push    ds:button_x
 0000422A  FF 35 0000B92C R	        push    ds:button_y
 00004230  FF 35 0000B930 R	        push    ds:button_offset

				      ; Save function items
 00004236  FF 35 0000B934 R	        push    ds:function_x
 0000423C  FF 35 0000B938 R	        push    ds:function_y

				      ; Turn off the mouse and cursor for this redisplay
 00004242  FA			        cli
 00004243  E8 FFFFD441		        call    invDEBI_hide_mouse_pointer
 00004248  E8 FFFFD592		        call    invDEBI_turn_cursor_off

				      ; Redraw the entire window
 0000424D  8B 7E 1C		        mov     edi,dword ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]
 00004250  E8 FFFFC2E6		        call    invDEBI_draw_objects

				      ; Initialize variables that might alter the appearance of the refresh
 00004255  C7 05 0000B910 R	        mov     ds:textbox_offset,0
	   00000000
 0000425F  C7 05 0000B918 R	        mov     ds:textbox_sel_end,0
	   00000000

				      ; Now, redraw the displayable keyboard objects
 00004269  8B 7E 10		        mov     edi,dword ptr ds:[esi+_ST_OBJECT_KBD_OFFSET]
				        .WHILE (byte ptr ds:[edi] != _END)
 0000426C  E9 00000098	   *	    jmp    @C0480
 00004271		   *@C0481:
 00004271  89 3D 0000B78C R	            mov     ds:kbd_object,edi
 00004277  8B 56 04		            mov     edx,ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 0000427A  03 57 01		            add     edx,ds:[edi+_KO_X]
 0000427D  8B 5E 08		            mov     ebx,ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00004280  03 5F 05		            add     ebx,ds:[edi+_KO_Y]
 00004283  8A 07		            mov     al,byte ptr ds:[edi]
				            .IF (al == _START)
 00004285  3C FC	   *	    cmp    al, _START
 00004287  75 05	   *	    jne    @C0482
 00004289  47			                inc     edi
 0000428A  EB 7D		                jmp     @F
				            .ELSEIF (al == _KO_TEXTBOX)
 0000428C  EB 78	   *	    jmp    @C0484
 0000428E		   *@C0482:
 0000428E  0A C0	   *	    or	al, al
 00004290  75 13	   *	    jne    @C0485
				              ; This needs redrawn
 00004292  89 15 0000B908 R	                mov     ds:textbox_x,edx
 00004298  89 1D 0000B90C R	                mov     ds:textbox_y,ebx
 0000429E  E8 0000061B		                call    invDEBI_textbox_refresh
				            .ELSEIF (al == _KO_CHECKBOX)
 000042A3  EB 61	   *	    jmp    @C0487
 000042A5		   *@C0485:
 000042A5  3C 01	   *	    cmp    al, _KO_CHECKBOX
 000042A7  75 1C	   *	    jne    @C0488
				              ; This needs redrawn
 000042A9  0F B6 47 11		                movzx   eax,byte ptr ds:[edi+_KO_X_OFFSET]
 000042AD  89 15 0000B91C R	                mov     ds:checkbox_x,edx
 000042B3  89 1D 0000B920 R	                mov     ds:checkbox_y,ebx
 000042B9  A3 0000B924 R	                mov     ds:checkbox_offset,eax
 000042BE  E8 000006A4		                call    invDEBI_checkbox_refresh
				            .ELSEIF (al == _KO_BUTTON)
 000042C3  EB 41	   *	    jmp    @C048A
 000042C5		   *@C0488:
 000042C5  3C 02	   *	    cmp    al, _KO_BUTTON
 000042C7  75 1C	   *	    jne    @C048B
				              ; This does not need to be redrawn
 000042C9  0F B6 47 11		                movzx   eax,byte ptr ds:[edi+_KO_X_OFFSET]
 000042CD  89 15 0000B928 R	                mov     ds:button_x,edx
 000042D3  89 1D 0000B92C R	                mov     ds:button_y,ebx
 000042D9  A3 0000B930 R	                mov     ds:button_offset,eax
 000042DE  E8 000006A9		                call    invDEBI_button_refresh
				            .ELSEIF (al == _KO_FUNCTION)
 000042E3  EB 21	   *	    jmp    @C048D
 000042E5		   *@C048B:
 000042E5  3C FE	   *	    cmp    al, _KO_FUNCTION
 000042E7  75 1D	   *	    jne    @C048E
				              ; This might need to be redrawn.
				              ; We let the function decide that one. :)
 000042E9  0F B7 57 01		                movzx   edx,word ptr ds:[edi+_KO_X_FUNCTION]
 000042ED  03 56 04		                add     edx,ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 000042F0  0F B7 5F 03		                movzx   ebx,word ptr ds:[edi+_KO_Y_FUNCTION]
 000042F4  03 5E 08		                add     ebx,ds:[esi+_ST_OBJECT_UL_VERTICAL]
 000042F7  89 15 0000B934 R	                mov     ds:function_x,edx
 000042FD  89 1D 0000B938 R	                mov     ds:function_y,ebx
 00004303  FF 57 0D		                call    dword ptr ds:[edi+_KO_REFRESH_FUNCTION]
				            .ENDIF
 00004306		   *@C048E:
 00004306		   *@C048D:
 00004306		   *@C048A:
 00004306		   *@C0487:
 00004306		   *@C0484:
 00004306  83 C7 18		            add     edi,_KO_LENGTH
 00004309			          @@:
				        .ENDW
 00004309		   *@C0480:
 00004309  80 3F FF	   *	    cmp    byte ptr ds : [edi], _END
 0000430C  0F 85 FFFFFF5F  *	    jne    @C0481

				      ; Restore function items
 00004312  8F 05 0000B938 R	        pop     ds:function_y
 00004318  8F 05 0000B934 R	        pop     ds:function_x

				      ; Restore button items
 0000431E  8F 05 0000B930 R	        pop     ds:button_offset
 00004324  8F 05 0000B92C R	        pop     ds:button_y
 0000432A  8F 05 0000B928 R	        pop     ds:button_x

				      ; Restore checkbox items
 00004330  8F 05 0000B924 R	        pop     ds:checkbox_offset
 00004336  8F 05 0000B92C R	        pop     ds:button_y
 0000433C  8F 05 0000B928 R	        pop     ds:button_x

				      ; Restore textbox items
 00004342  8F 05 0000B918 R	        pop     ds:textbox_sel_end
 00004348  8F 05 0000B910 R	        pop     ds:textbox_offset
 0000434E  8F 05 0000B90C R	        pop     ds:textbox_y
 00004354  8F 05 0000B908 R	        pop     ds:textbox_x

				      ; Restore current object
 0000435A  8F 05 0000B78C R	        pop     ds:kbd_object
 00004360  9D			        popfd
 00004361  61			        popad
 00004362  C3			        ret
 00004363			    invDEBI_screen_refresh      ENDP




 00004363			    invDEBI_textbox_kbd_handler     PROC
				    ; This routine is called when there is input to process from the keyboard
				    ;
				    ; Upon entry:   eax - key
				    ;               ebx - flags
				    ;                ds - Debi's data segment
				    ;
				    ; Upon exit:    The key is either accepted and processed or ignored
				    ;               Note that processing might include moving to another field
				    ;
				        .IF (ax == 0)
 00004363  66| 0B C0	   *	    or	ax, ax
 00004366  75 06	   *	    jne    @C0491
 00004368  C3			            ret
				        .ELSEIF (ax == home || ax == grey_home)
 00004369  E9 000001F7	   *	    jmp    @C0493
 0000436E		   *@C0491:
 0000436E  66| 3D 4700	   *	    cmp    ax, home
 00004372  74 06	   *	    je     @C0495
 00004374  66| 3D 47E0	   *	    cmp    ax, grey_home
 00004378  75 19	   *	    jne    @C0494
 0000437A		   *@C0495:
				          ; They want to move to the beginning
 0000437A  C7 05 0000B918 R	            mov     ds:textbox_sel_end,0
	   00000000
 00004384  C7 05 0000B910 R	            mov     ds:textbox_offset,0
	   00000000
				        .ELSEIF (ax == end_key || ax == grey_end)
 0000438E  E9 000001D2	   *	    jmp    @C0497
 00004393		   *@C0494:
 00004393  66| 3D 4F00	   *	    cmp    ax, end_key
 00004397  74 06	   *	    je     @C0499
 00004399  66| 3D 4FE0	   *	    cmp    ax, grey_end
 0000439D  75 14	   *	    jne    @C0498
 0000439F		   *@C0499:
 0000439F  C7 05 0000B918 R	            mov     ds:textbox_sel_end,0
	   00000000
 000043A9  E8 000004B7		            call    invDEBI_textbox_end
				        .ELSEIF (ax == left || ax == grey_left)
 000043AE  E9 000001B2	   *	    jmp    @C049B
 000043B3		   *@C0498:
 000043B3  66| 3D 4B00	   *	    cmp    ax, left
 000043B7  74 06	   *	    je     @C049D
 000043B9  66| 3D 4BE0	   *	    cmp    ax, grey_left
 000043BD  75 22	   *	    jne    @C049C
 000043BF		   *@C049D:
 000043BF  C7 05 0000B918 R	            mov     ds:textbox_sel_end,0
	   00000000
				            .IF (ds:textbox_offset > 0)
 000043C9  83 3D 0000B910 R
	   00		   *	    cmp    ds : textbox_offset, 000h
 000043D0  0F 86 0000018F  *	    jbe    @C049F
 000043D6  FF 0D 0000B910 R	                dec     ds:textbox_offset
				            .ENDIF
				        .ELSEIF (ax == right || ax == grey_right)
 000043DC  E9 00000184	   *	    jmp    @C04A1
 000043E1		   *@C049C:
 000043E1  66| 3D 4D00	   *	    cmp    ax, right
 000043E5  74 06	   *	    je     @C04A3
 000043E7  66| 3D 4DE0	   *	    cmp    ax, grey_right
 000043EB  75 2C	   *	    jne    @C04A2
 000043ED		   *@C04A3:
 000043ED  C7 05 0000B918 R	            mov     ds:textbox_sel_end,0
	   00000000
 000043F7			          right_key:
 000043F7  8B 0D 0000B910 R	            mov     ecx,ds:textbox_offset
 000043FD  E8 00000489		            call    invDEBI_textbox_get_length
				            .IF (ds:textbox_offset < ecx)
 00004402  39 0D 0000B910 R *	    cmp    ds : textbox_offset, ecx
 00004408  0F 83 00000157  *	    jae    @C04A5
 0000440E  FF 05 0000B910 R	                inc     ds:textbox_offset
				            .ENDIF
				        .ELSEIF (ax == escape)
 00004414  E9 0000014C	   *	    jmp    @C04A7
 00004419		   *@C04A2:
 00004419  66| 3D 011B	   *	    cmp    ax, escape
 0000441D  75 0A	   *	    jne    @C04A8
 0000441F  E9 000005A4		            jmp     invDEBI_kbd_input_cancel
				        .ELSEIF (ax == F8)
 00004424  E9 0000013C	   *	    jmp    @C04AA
 00004429		   *@C04A8:
 00004429  66| 3D 4200	   *	    cmp    ax, f8
 0000442D  75 0B	   *	    jne    @C04AB
 0000442F  F7 15 0000B93C R	            not     ds:insert_mode
				        .ELSEIF (ax == backspace || ax == f5)
 00004435  E9 0000012B	   *	    jmp    @C04AD
 0000443A		   *@C04AB:
 0000443A  66| 3D 0E08	   *	    cmp    ax, backspace
 0000443E  74 06	   *	    je     @C04AF
 00004440  66| 3D 3F00	   *	    cmp    ax, f5
 00004444  75 51	   *	    jne    @C04AE
 00004446		   *@C04AF:
				            .IF (ds:textbox_sel_end != 0)
 00004446  83 3D 0000B918 R
	   00		   *	    cmp    ds : textbox_sel_end, 000h
 0000444D  74 1C	   *	    je     @C04B1
 0000444F  E8 00000251		                call    invDEBI_textbox_delete_selected
 00004454  8B 0D 0000B914 R	                mov     ecx,ds:textbox_sel_start
				                .IF (ecx > 0)
 0000445A  83 F9 00	   *	    cmp    ecx, 000h
 0000445D  76 01	   *	    jbe    @C04B3
 0000445F  49			                    dec     ecx
				                .ENDIF
 00004460		   *@C04B3:
 00004460  89 0D 0000B910 R	                mov     ds:textbox_offset,ecx
				            .ELSE
 00004466  E9 000000FA	   *	    jmp    @C04B5
 0000446B		   *@C04B1:
				                .IF (ds:textbox_offset > 0)
 0000446B  83 3D 0000B910 R
	   00		   *	    cmp    ds : textbox_offset, 000h
 00004472  76 1E	   *	    jbe    @C04B6
 00004474  8B 0D 0000B910 R	                    mov     ecx,ds:textbox_offset
 0000447A  89 0D 0000B918 R	                    mov     ds:textbox_sel_end,ecx
 00004480  49			                    dec     ecx
 00004481  89 0D 0000B914 R	                    mov     ds:textbox_sel_start,ecx
 00004487  E8 00000219		                    call    invDEBI_textbox_delete_selected
 0000448C  FF 0D 0000B910 R	                    dec     ds:textbox_offset
				                .ENDIF
				            .ENDIF
 00004492		   *@C04B6:
				        .ELSEIF (ax == delete || ax == grey_delete)
 00004492  E9 000000CE	   *	    jmp    @C04B8
 00004497		   *@C04AE:
 00004497  66| 3D 5300	   *	    cmp    ax, delete
 0000449B  74 06	   *	    je     @C04BA
 0000449D  66| 3D 53E0	   *	    cmp    ax, grey_delete
 000044A1  75 46	   *	    jne    @C04B9
 000044A3		   *@C04BA:
				            .IF (ds:textbox_sel_end != 0)
 000044A3  83 3D 0000B918 R
	   00		   *	    cmp    ds : textbox_sel_end, 000h
 000044AA  74 16	   *	    je     @C04BC
 000044AC  E8 000001F4		                call    invDEBI_textbox_delete_selected
 000044B1  8B 0D 0000B914 R	                mov     ecx,ds:textbox_sel_start
 000044B7  89 0D 0000B910 R	                mov     ds:textbox_offset,ecx
				            .ELSE
 000044BD  E9 000000A3	   *	    jmp    @C04BE
 000044C2		   *@C04BC:
 000044C2  E8 000003C4		                call    invDEBI_textbox_get_length
				                .IF (ds:textbox_offset < ecx)
 000044C7  39 0D 0000B910 R *	    cmp    ds : textbox_offset, ecx
 000044CD  73 18	   *	    jae    @C04BF
 000044CF  8B 0D 0000B910 R	                    mov     ecx,ds:textbox_offset
 000044D5  89 0D 0000B914 R	                    mov     ds:textbox_sel_start,ecx
 000044DB  41			                    inc     ecx
 000044DC  89 0D 0000B918 R	                    mov     ds:textbox_sel_end,ecx
 000044E2  E8 000001BE		                    call    invDEBI_textbox_delete_selected
				                .ENDIF
				            .ENDIF
 000044E7		   *@C04BF:
				        .ELSEIF (ax == tab || ax == enter_key || ax == grey_enter)
 000044E7  EB 7C	   *	    jmp    @C04C1
 000044E9		   *@C04B9:
 000044E9  66| 3D 0F09	   *	    cmp    ax, tab
 000044ED  74 0C	   *	    je     @C04C3
 000044EF  66| 3D 1C0D	   *	    cmp    ax, enter_key
 000044F3  74 06	   *	    je     @C04C3
 000044F5  66| 3D E00D	   *	    cmp    ax, grey_enter
 000044F9  75 0E	   *	    jne    @C04C2
 000044FB		   *@C04C3:
				          ; Move to next item (or first one if we're on the last)
 000044FB  BA 00000001		            mov     edx,1
 00004500  E8 000000F8		            call    invDEBI_next_keyboard_item
 00004505  EB 68		            jmp     do_not_refresh
				        .ELSEIF (ax == shift_tab)
 00004507  EB 5C	   *	    jmp    @C04C6
 00004509		   *@C04C2:
 00004509  66| 3D 0F00	   *	    cmp    ax, shift_tab
 0000450D  75 0E	   *	    jne    @C04C7
				          ; Move to previous item (or last one if we're on the first)
 0000450F  BA FFFFFFFF		            mov     edx,-1
 00004514  E8 000000E4		            call    invDEBI_next_keyboard_item
 00004519  EB 54		            jmp     do_not_refresh
				        .ELSEIF (al >= 32)
 0000451B  EB 48	   *	    jmp    @C04C9
 0000451D		   *@C04C7:
 0000451D  3C 20	   *	    cmp    al, 020h
 0000451F  72 44	   *	    jb     @C04CA
				            .IF (ds:textbox_sel_end != 0)
 00004521  83 3D 0000B918 R
	   00		   *	    cmp    ds : textbox_sel_end, 000h
 00004528  74 11	   *	    je     @C04CC
 0000452A  E8 00000176		                call    invDEBI_textbox_delete_selected
 0000452F  8B 0D 0000B914 R	                mov     ecx,ds:textbox_sel_start
 00004535  89 0D 0000B910 R	                mov     ds:textbox_offset,ecx
				            .ENDIF
 0000453B		   *@C04CC:
 0000453B  E8 0000034B		            call    invDEBI_textbox_get_length
				            .IF (ds:textbox_offset < ecx)
 00004540  39 0D 0000B910 R *	    cmp    ds : textbox_offset, ecx
 00004546  73 1D	   *	    jae    @C04CE
 00004548  E8 00000124		                call    invDEBI_textbox_insert
 0000454D  8B 3D 0000B78C R	                mov     edi,ds:kbd_object
 00004553  8B 7F 0D		                mov     edi,dword ptr ds:[edi+_KO_VAR]
 00004556  8B 0D 0000B910 R	                mov     ecx,ds:textbox_offset
 0000455C  88 04 39		                mov     byte ptr ds:[edi+ecx],al
 0000455F  FF 05 0000B910 R	                inc     ds:textbox_offset
				            .ENDIF
				        .ENDIF
 00004565		   *@C04CE:
 00004565		   *@C04CA:
 00004565		   *@C04C9:
 00004565		   *@C04C6:
 00004565		   *@C04C1:
 00004565		   *@C04B8:
 00004565		   *@C04AD:
 00004565		   *@C04AA:
 00004565		   *@C04A7:
 00004565		   *@C04A1:
 00004565		   *@C049B:
 00004565		   *@C0497:
 00004565		   *@C0493:
 00004565		   *@C049F:
 00004565		   *@C04A5:
 00004565		   *@C04B5:
 00004565		   *@C04BE:
 00004565  E8 000003D7		        call    invDEBI_textbox_set_cursor
 0000456A  E8 0000034F		        call    invDEBI_textbox_refresh
 0000456F			      do_not_refresh:
 0000456F  C3			        ret
 00004570			    invDEBI_textbox_kbd_handler     ENDP




 00004570			    invDEBI_checkbox_kbd_handler        PROC
				    ; This routine is called when there is input to process from the keyboard
				    ;
				    ; Upon entry:   eax - key
				    ;               ebx - flags
				    ;                ds - Debi's data segment
				    ;
				    ; Upon exit:    The key is either accepted and processed or ignored
				    ;               Note that processing might include moving to another field
				    ;
				      ; Rules:  X or x - Marks the checkbox to positive
				      ;         space or return - Toggle the checkbox setting
 00004570  8B 35 0000B79C R	        mov     esi,ds:screen_object
 00004576  8B 3D 0000B78C R	        mov     edi,ds:kbd_object
 0000457C  8B 5F 0D		        mov     ebx,dword ptr ds:[edi+13]                       ; Refer to DEBI\DEBI_MAC.ASP @DEBI_checkbox macro for offset
				        .IF (al == 'X' || al == 'x')
 0000457F  3C 58	   *	    cmp    al, 'X'
 00004581  74 04	   *	    je     @C04D1
 00004583  3C 78	   *	    cmp    al, 'x'
 00004585  75 0A	   *	    jne    @C04D0
 00004587		   *@C04D1:
				          ; Time to set (we clear it here so it will toggle there)
 00004587  C6 03 20		            mov     byte ptr ds:[ebx],32
 0000458A  E8 FFFFFC4D		            call    invDEBI_checkbox_toggle
				        .ELSEIF (al == 32 || al == 13)
 0000458F  EB 31	   *	    jmp    @C04D3
 00004591		   *@C04D0:
 00004591  3C 20	   *	    cmp    al, 020h
 00004593  74 04	   *	    je     @C04D5
 00004595  3C 0D	   *	    cmp    al, 00Dh
 00004597  75 07	   *	    jne    @C04D4
 00004599		   *@C04D5:
				          ; Time to toggle whatever it currently is
 00004599  E8 FFFFFC3E		            call    invDEBI_checkbox_toggle
				        .ELSEIF (ax == tab)
 0000459E  EB 22	   *	    jmp    @C04D7
 000045A0		   *@C04D4:
 000045A0  66| 3D 0F09	   *	    cmp    ax, tab
 000045A4  75 0C	   *	    jne    @C04D8
				          ; Move to next item (or first one if we're on the last)
 000045A6  BA 00000001		            mov     edx,1
 000045AB  E8 0000004D		            call    invDEBI_next_keyboard_item
				        .ELSEIF (ax == shift_tab)
 000045B0  EB 10	   *	    jmp    @C04DA
 000045B2		   *@C04D8:
 000045B2  66| 3D 0F00	   *	    cmp    ax, shift_tab
 000045B6  75 0A	   *	    jne    @C04DB
				          ; Move to previous item (or last one if we're on the first)
 000045B8  BA FFFFFFFF		            mov     edx,-1
 000045BD  E8 0000003B		            call    invDEBI_next_keyboard_item
				        .ENDIF
 000045C2		   *@C04DB:
 000045C2		   *@C04DA:
 000045C2		   *@C04D7:
 000045C2		   *@C04D3:
 000045C2  C3			        ret
 000045C3			    invDEBI_checkbox_kbd_handler        ENDP




 000045C3			    invDEBI_button_kbd_handler          PROC
				    ; This routine is called when there is input to process from the keyboard
				    ;
				    ; Upon entry:   eax - key
				    ;               ebx - flags
				    ;                ds - Debi's data segment
				    ;
				    ; Upon exit:    The key is either accepted and processed or ignored
				    ;               Note that processing might include moving to another field
				    ;
				        .IF (ax == tab)
 000045C3  66| 3D 0F09	   *	    cmp    ax, tab
 000045C7  75 0C	   *	    jne    @C04DD
				          ; Move to next item (or first one if we're on the last)
 000045C9  BA 00000001		            mov     edx,1
 000045CE  E8 0000002A		            call    invDEBI_next_keyboard_item
				        .ELSEIF (ax == shift_tab)
 000045D3  EB 27	   *	    jmp    @C04DF
 000045D5		   *@C04DD:
 000045D5  66| 3D 0F00	   *	    cmp    ax, shift_tab
 000045D9  75 0C	   *	    jne    @C04E0
				          ; Move to previous item (or last one if we're on the first)
 000045DB  BA FFFFFFFF		            mov     edx,-1
 000045E0  E8 00000018		            call    invDEBI_next_keyboard_item
				        .ELSEIF (ax == enter_key || ax == grey_enter)
 000045E5  EB 15	   *	    jmp    @C04E2
 000045E7		   *@C04E0:
 000045E7  66| 3D 1C0D	   *	    cmp    ax, enter_key
 000045EB  74 06	   *	    je     @C04E4
 000045ED  66| 3D E00D	   *	    cmp    ax, grey_enter
 000045F1  75 09	   *	    jne    @C04E3
 000045F3		   *@C04E4:
				          ; They've selected this button
 000045F3  8B 3D 0000B78C R	            mov     edi,ds:kbd_object
 000045F9  FF 57 0D		            call    dword ptr ds:[edi+_KO_FUNC]
				        .ENDIF
 000045FC		   *@C04E3:
 000045FC		   *@C04E2:
 000045FC		   *@C04DF:
 000045FC  C3			        ret
 000045FD			    invDEBI_button_kbd_handler          ENDP




 000045FD			    invDEBI_next_keyboard_item      PROC
				    ; This routine is used to move to the next or previous item (depending on the value in edx)
				    ;
				    ; Upon entry:   edx - Direction to move, 1=Next item, -1=Previous item
				    ;
				    ; Upon exit:    kbd_object - updated
				    ;                kbd_focus - updated
 000045FD  60			        pushad
				        .IF (edx == -1)
 000045FE  83 FA FF	   *	    cmp    edx, - 001h
 00004601  75 07	   *	    jne    @C04E6
 00004603  BA FFFFFFE8		            mov     edx,-_KO_LENGTH
				        .ELSE
 00004608  EB 05	   *	    jmp    @C04E8
 0000460A		   *@C04E6:
 0000460A  BA 00000018		            mov     edx,_KO_LENGTH
				        .ENDIF
 0000460F		   *@C04E8:
 0000460F  8B 3D 0000B78C R	        mov     edi,ds:kbd_object
 00004615  89 3D 0000B790 R	        mov     ds:save_kbd_object,edi
 0000461B  8B 35 0000B79C R	        mov     esi,ds:screen_object
 00004621  8B 5E 10		        mov     ebx,dword ptr ds:[esi+_ST_OBJECT_KBD_OFFSET]
				      ; Right now, ds:[esi] - far ptr to the current screen object
				      ;            ds:[edi] - far ptr to the current KBD object
				      ;            ds:[ebx] - far ptr to the first KBD object
				      ;                 edx - direction to go
 00004624  E8 000001EA		        call    invDEBI_lostFocus                                   ; Current item loses focus
 00004629			      @@:
				      ; Move to the next object
				        .IF (byte ptr ds:[edi] != _START)
 00004629  80 3F FC	   *	    cmp    byte ptr ds : [edi], _START
 0000462C  74 04	   *	    je     @C04E9
 0000462E  03 FA		            add     edi,edx
				        .ELSE
 00004630  EB 0A	   *	    jmp    @C04EB
 00004632		   *@C04E9:
				            .IF (edx == -_KO_LENGTH)
 00004632  83 FA E8	   *	    cmp    edx, - _KO_LENGTH
 00004635  75 04	   *	    jne    @C04EC
				              ; Go backwards to previous item
 00004637  03 FA		                add     edi,edx
				            .ELSE
 00004639  EB 01	   *	    jmp    @C04EE
 0000463B		   *@C04EC:
				              ; Go forward to next item (since it's _START, we only move forward 1 byte)
 0000463B  47			                inc     edi
				            .ENDIF
				        .ENDIF
 0000463C		   *@C04EE:
 0000463C		   *@C04EB:
				      ; Now, see if we've gone too far
				        .IF (edi < ebx)
 0000463C  3B FB	   *	    cmp    edi, ebx
 0000463E  73 1B	   *	    jae    @C04EF
				          ; We've gone passed the top, so we start back over at the end
 00004640  8B FB		            mov     edi,ebx
				            .WHILE (byte ptr ds:[edi] != _END)
 00004642  EB 0B	   *	    jmp    @C04F1
 00004644		   *@C04F2:
				                .IF (byte ptr ds:[edi] == _START)
 00004644  80 3F FC	   *	    cmp    byte ptr ds : [edi], _START
 00004647  75 03	   *	    jne    @C04F3
 00004649  47			                    inc     edi
				                .ELSE
 0000464A  EB 03	   *	    jmp    @C04F5
 0000464C		   *@C04F3:
 0000464C  83 C7 18		                    add     edi,_KO_LENGTH
				                .ENDIF
				            .ENDW
 0000464F		   *@C04F5:
 0000464F		   *@C04F1:
 0000464F  80 3F FF	   *	    cmp    byte ptr ds : [edi], _END
 00004652  75 F0	   *	    jne    @C04F2

 00004654  83 EF 18		            sub     edi,_KO_LENGTH
 00004657  EB D0		            jmp     @B
				        .ELSEIF (byte ptr ds:[edi] == _END)
 00004659  EB 09	   *	    jmp    @C04F7
 0000465B		   *@C04EF:
 0000465B  80 3F FF	   *	    cmp    byte ptr ds : [edi], _END
 0000465E  75 04	   *	    jne    @C04F8
				          ; We're at the end, so we start back over
 00004660  8B FB		            mov     edi,ebx
 00004662  EB C5		            jmp     @B
				        .ENDIF
 00004664		   *@C04F8:
 00004664		   *@C04F7:
				      ; We've found the next item
 00004664  89 3D 0000B78C R	        mov     ds:kbd_object,edi
 0000466A  E8 0000008E		        call    invDEBI_setFocus
 0000466F  61			        popad
 00004670  C3			        ret
 00004671			    invDEBI_next_keyboard_item      ENDP




 00004671			    invDEBI_textbox_insert      PROC
				    ; This routine is called to insert a space (if we're in insert mode)
				    ;
				    ; Upon entry:   ecx - Current textbox length
				    ;
				    ; Upon exit:    A space is inserted at the current location if in insert mode
				    ;
				        .IF (ds:insert_mode != 0 && ecx != 1)
 00004671  83 3D 0000B93C R
	   00		   *	    cmp    ds : insert_mode, 000h
 00004678  74 2A	   *	    je     @C04FA
 0000467A  83 F9 01	   *	    cmp    ecx, 001h
 0000467D  74 25	   *	    je     @C04FA
				          ; We're in insert mode
 0000467F  9C			            pushfd
 00004680  60			            pushad
 00004681  06			            push    es
				          ; Copy from ds:[esi] to es:[edi]
				          ; We're doing this backwards, so we start at the end of the string
 00004682  66| 8E 05		            mov     es,ds:data_segment
	   0000B77F R
 00004689  49			            dec     ecx
 0000468A  8B 35 0000B78C R	            mov     esi,ds:kbd_object
 00004690  8B 7E 0D		            mov     edi,dword ptr ds:[esi+_KO_VAR]
 00004693  03 F9		            add     edi,ecx
 00004695  8B F7		            mov     esi,edi
 00004697  4E			            dec     esi
 00004698  2B 0D 0000B910 R	            sub     ecx,ds:textbox_offset
				          ; Right now, ds:[esi] - far ptr to character before the last one in the string
				          ;            es:[edi] - far ptr to last string
				          ;                 ecx - # of characters to copy
 0000469E  FD			            std
 0000469F  F3/ A4		            rep     movsb

 000046A1  07			            pop     es
 000046A2  61			            popad
 000046A3  9D			            popfd
				        .ENDIF
 000046A4		   *@C04FA:
 000046A4  C3			        ret
 000046A5			    invDEBI_textbox_insert      ENDP




 000046A5			    invDEBI_textbox_delete_selected     PROC
				    ; This routine is used to delete the selected text from the current textbox string
				    ;
				    ; Upon entry:   ds:textbox_sel_start - start of selected text
				    ;               ds:textbox_sel_end   - end of selected text
				    ;
				    ; Upon exit:    The string is updated and the
				    ;
				        .IF (ds:textbox_sel_end == 0)
 000046A5  83 3D 0000B918 R
	   00		   *	    cmp    ds : textbox_sel_end, 000h
 000046AC  75 01	   *	    jne    @C04FD
 000046AE  C3			            ret
				        .ENDIF
 000046AF		   *@C04FD:

				      ; There is text that's selected, let's delete it
 000046AF  9C			        pushfd
 000046B0  60			        pushad
 000046B1  06			        push    es
 000046B2  66| 8E 05		        mov     es,ds:data_segment
	   0000B77F R
 000046B9  8B 35 0000B78C R	        mov     esi,ds:kbd_object
 000046BF  8B 7E 0D		        mov     edi,dword ptr ds:[esi+_KO_VAR]
 000046C2  03 3D 0000B914 R	        add     edi,ds:textbox_sel_start
 000046C8  8B F7		        mov     esi,edi
 000046CA  03 35 0000B918 R	        add     esi,ds:textbox_sel_end
 000046D0  2B 35 0000B914 R	        sub     esi,ds:textbox_sel_start

				      ; Right now, ds:[edi] - far ptr to string
				      ; Copy the text over the selected portion
 000046D6  E8 000001B0		        call    invDEBI_textbox_get_length
 000046DB  2B 0D 0000B918 R	        sub     ecx,ds:textbox_sel_end
 000046E1  FC			        cld
 000046E2  F3/ A4		        rep     movsb

				      ; Pad with spaces to the end
 000046E4  B0 20		        mov     al,32
				        .WHILE (byte ptr es:[edi] != 0)
 000046E6  EB 01	   *	    jmp    @C04FF
 000046E8		   *@C0500:
 000046E8  AA			            stosb
				        .ENDW
 000046E9		   *@C04FF:
 000046E9  26: 80 3F 00	   *	    cmp    byte ptr es : [edi], 000h
 000046ED  75 F9	   *	    jne    @C0500

 000046EF  07			        pop     es
 000046F0  61			        popad
 000046F1  9D			        popfd
 000046F2  C7 05 0000B918 R	        mov     ds:textbox_sel_end,0
	   00000000
 000046FC  C3			        ret
 000046FD			    invDEBI_textbox_delete_selected     ENDP




 000046FD			    invDEBI_setFocus    PROC
				    ; This routine is called to set focus on a particular item
				    ;
				    ; Upon entry:   ds:kbd_object - far ptr to object that should have kbd focus
				    ;            ds:screen_object - far ptr to screen object
				    ;
				    ; Upon exit:    Cursor is flashing at the appropriate location
				    ;               Keyboard input is routed to the appropriate handler
				    ;               Other unique-to-type-of-data settings are established
				    ;
 000046FD  8B 35 0000B79C R	        mov     esi,ds:screen_object
 00004703  8B 3D 0000B78C R	        mov     edi,ds:kbd_object
 00004709  9C			        pushfd
 0000470A  FA			        cli
 0000470B  E8 FFFFCF79		        call    invDEBI_hide_mouse_pointer
 00004710  E8 FFFFD0CA		        call    invDEBI_turn_cursor_off

				      ; Determine where the item will be displayed
 00004715  8B 56 04		        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 00004718  03 57 01		        add     edx,dword ptr ds:[edi+_KO_X]
 0000471B  8B 5E 08		        mov     ebx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 0000471E  03 5F 05		        add     ebx,dword ptr ds:[edi+_KO_Y]
 00004721  8A 07		        mov     al,byte ptr ds:[edi]
				        .IF (al == _KO_TEXTBOX)
 00004723  0A C0	   *	    or	al, al
 00004725  75 40	   *	    jne    @C0502
 00004727  89 15 0000B908 R	            mov     ds:textbox_x,edx
 0000472D  89 1D 0000B90C R	            mov     ds:textbox_y,ebx
 00004733  E8 0000012D		            call    invDEBI_textbox_end                             ; Position the cursor at the end of the line
 00004738  8B 0D 0000B910 R	            mov     ecx,ds:textbox_offset                           ; Select everything on a setFocus
 0000473E  C7 05 0000B914 R	            mov     ds:textbox_sel_start,0                          ;   (so if they press a key all is replaced)
	   00000000
 00004748  89 0D 0000B918 R	            mov     ds:textbox_sel_end,ecx
 0000474E  E8 0000016B		            call    invDEBI_textbox_refresh
 00004753  C7 05 0000B794 R	            mov     ds:kbd_focus,offset invDEBI_textbox_kbd_handler     ; Set the keyboard focus to the correct handler
	   00004363 R
 0000475D  E8 000001D9		            call    invDEBI_textbox_activate
				        .ELSEIF (al == _KO_CHECKBOX)
 00004762  E9 00000082	   *	    jmp    @C0504
 00004767		   *@C0502:
 00004767  3C 01	   *	    cmp    al, _KO_CHECKBOX
 00004769  75 26	   *	    jne    @C0505
				          ; It's a checkbox item
 0000476B  0F B6 47 11		            movzx   eax,byte ptr ds:[edi+_KO_X_OFFSET]
 0000476F  89 15 0000B91C R	            mov     ds:checkbox_x,edx
 00004775  89 1D 0000B920 R	            mov     ds:checkbox_y,ebx
 0000477B  A3 0000B924 R	            mov     ds:checkbox_offset,eax
 00004780  C7 05 0000B794 R	            mov     ds:kbd_focus,offset invDEBI_checkbox_kbd_handler    ; Set the keyboard focus to the correct handler
	   00004570 R
 0000478A  E8 000001D9		            call    invDEBI_checkbox_activate
				        .ELSEIF (al == _KO_BUTTON)
 0000478F  EB 58	   *	    jmp    @C0507
 00004791		   *@C0505:
 00004791  3C 02	   *	    cmp    al, _KO_BUTTON
 00004793  75 26	   *	    jne    @C0508
				          ; It's a button
 00004795  0F B6 47 11		            movzx   eax,byte ptr ds:[edi+_KO_X_OFFSET]
 00004799  89 15 0000B928 R	            mov     ds:button_x,edx
 0000479F  89 1D 0000B92C R	            mov     ds:button_y,ebx
 000047A5  A3 0000B930 R	            mov     ds:button_offset,eax
 000047AA  C7 05 0000B794 R	            mov     ds:kbd_focus,offset invDEBI_button_kbd_handler      ; Set the keyboard focus to the correct handler
	   000045C3 R
 000047B4  E8 000001D4		            call    invDEBI_button_activate
				        .ELSEIF (al == _KO_FUNCTION)
 000047B9  EB 2E	   *	    jmp    @C050A
 000047BB		   *@C0508:
 000047BB  3C FE	   *	    cmp    al, _KO_FUNCTION
 000047BD  75 2A	   *	    jne    @C050B
				          ; It's a special function
 000047BF  0F B7 57 01		            movzx   edx,word ptr ds:[edi+_KO_X_FUNCTION]
 000047C3  03 56 04		            add     edx,ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 000047C6  0F B7 5F 03		            movzx   ebx,word ptr ds:[edi+_KO_Y_FUNCTION]
 000047CA  03 5E 08		            add     ebx,ds:[esi+_ST_OBJECT_UL_VERTICAL]
 000047CD  89 15 0000B934 R	            mov     ds:function_x,edx
 000047D3  89 1D 0000B938 R	            mov     ds:function_y,ebx
 000047D9  8B 47 09		            mov     eax,dword ptr ds:[edi+_KO_KBD_FUNCTION]
 000047DC  A3 0000B794 R	            mov     ds:kbd_focus,eax
 000047E1  E8 000001CB		            call    invDEBI_function_set_cursor
 000047E6  FF 57 11		            call    dword ptr ds:[edi+_KO_ACTIVATE_FUNCTION]
				        .ENDIF
 000047E9		   *@C050B:
 000047E9		   *@C050A:
 000047E9		   *@C0507:
 000047E9		   *@C0504:
 000047E9  C6 05 0000B8B1 R	        mov     ds:force_cursor_off,0
	   00
 000047F0  9D			        popfd
 000047F1  C3			        ret
 000047F2			    invDEBI_setFocus    ENDP




 000047F2			    invDEBI_object_setFocus     PROC
				    ; This routine is used when any button of a mouse is clicked in an area of a keyboard object (focus needs to be set there)
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to screen objects
				    ;               ds:[edi] - far ptr to mouse object (* Note: The references below relate to offsets for the @AnyClick macro)
				    ;
				    ; Upon exit:    Whatever item currently has the focus loses it
				    ;               Whatever item they clicked on gets the focus (* Note: Could be the same thing)
				    ;
 000047F2  50			        push    eax
 000047F3  53			        push    ebx

				      ; See if we're moving to the same item
 000047F4  A1 0000B794 R	        mov     eax,ds:kbd_focus
 000047F9  8B 5F 15		        mov     ebx,dword ptr ds:[edi+_MO_DATA]
				        .IF (ebx != eax)
 000047FC  3B D8	   *	    cmp    ebx, eax
 000047FE  74 10	   *	    je     @C050D
				          ; It's a different one
 00004800  E8 0000000E		            call    invDEBI_lostFocus
 00004805  89 1D 0000B78C R	            mov     ds:kbd_object,ebx
 0000480B  E8 FFFFFEED		            call    invDEBI_setFocus
				        .ENDIF
 00004810		   *@C050D:

 00004810  5B			        pop     ebx
 00004811  58			        pop     eax
 00004812  C3			        ret
 00004813			    invDEBI_object_setFocus     ENDP




 00004813			    invDEBI_lostFocus       PROC
				    ; This routine is called when the current item is about to lose focus
				    ;
				    ; Upon entry:   ds:kbd_object - far ptr to object that should have kbd focus
				    ;            ds:screen_object - far ptr to screen object
				    ;
				    ; Upon exit:    Cursor is flashing at the appropriate location
				    ;               Keyboard input is routed to the appropriate handler
				    ;               Other unique-to-type-of-data settings are established
				    ;
 00004813  60			        pushad
 00004814  9C			        pushfd
 00004815  8B 35 0000B79C R	        mov     esi,ds:screen_object
 0000481B  8B 3D 0000B78C R	        mov     edi,ds:kbd_object
 00004821  FA			        cli
 00004822  E8 FFFFCE62		        call    invDEBI_hide_mouse_pointer
 00004827  E8 FFFFCFB3		        call    invDEBI_turn_cursor_off

				      ; Determine where the item will be displayed
 0000482C  8B 56 04		        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
 0000482F  03 57 01		        add     edx,dword ptr ds:[edi+_KO_X]
 00004832  8B 5E 08		        mov     ebx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
 00004835  03 5F 05		        add     ebx,dword ptr ds:[edi+_KO_Y]
 00004838  8A 07		        mov     al,byte ptr ds:[edi]
				        .IF (al == _KO_TEXTBOX && ds:textbox_sel_end != 0)
 0000483A  0A C0	   *	    or	al, al
 0000483C  75 24	   *	    jne    @C050F
 0000483E  83 3D 0000B918 R
	   00		   *	    cmp    ds : textbox_sel_end, 000h
 00004845  74 1B	   *	    je     @C050F
				          ; During a lose focus we basically just un-higlight everything on the current item that's higlighted
 00004847  89 15 0000B908 R	            mov     ds:textbox_x,edx
 0000484D  89 1D 0000B90C R	            mov     ds:textbox_y,ebx
 00004853  C7 05 0000B918 R	            mov     ds:textbox_sel_end,0                            ; Force a deselect of anything on this item
	   00000000
 0000485D  E8 0000005C		            call    invDEBI_textbox_refresh
				        .ENDIF
 00004862		   *@C050F:
 00004862  9D			        popfd
 00004863  61			        popad
 00004864  C3			        ret
 00004865			    invDEBI_lostFocus       ENDP




 00004865			    invDEBI_textbox_end     PROC
				    ; This routine is called to move to the end of the current textbox
				    ;
				    ; Upon entry:   Nothing
				    ;
				    ; Upon exit:    textbox_offset - updated with new position
				    ;
 00004865  60			        pushad

 00004866  E8 00000020		        call    invDEBI_textbox_get_length
				      ; Now, move backwards to the first non-space
 0000486B  8B 3D 0000B78C R	        mov     edi,ds:kbd_object
 00004871  8B 57 0D		        mov     edx,dword ptr ds:[edi+_KO_VAR]
				        .WHILE (byte ptr ds:[edx+ecx-1] == 32 && ecx > 0)
 00004874  EB 01	   *	    jmp    @C0512
 00004876		   *@C0513:
 00004876  49			            dec     ecx
				        .ENDW
 00004877		   *@C0512:
 00004877  80 7C 11 FF 20  *	    cmp    byte ptr ds : [edx + ecx - 001h], 020h
 0000487C  75 05	   *	    jne    @C0514
 0000487E  83 F9 00	   *	    cmp    ecx, 000h
 00004881  77 F3	   *	    ja     @C0513
 00004883		   *@C0514:
 00004883  89 0D 0000B910 R	        mov     ds:textbox_offset,ecx

 00004889  61			        popad
 0000488A  C3			        ret
 0000488B			    invDEBI_textbox_end     ENDP




 0000488B			    invDEBI_textbox_get_length      PROC
				    ; This routine is used to get the length of the curren textbox item
				    ;
				    ; Upon entry:   ds - data_segment
				    ;
				    ; Upon exit:    ecx - length
				    ;
 0000488B  57			        push    edi
 0000488C  52			        push    edx

				      ; Move to the end of the variable (to find out how long it is)
 0000488D  8B 3D 0000B78C R	        mov     edi,ds:kbd_object
 00004893  8B 57 0D		        mov     edx,dword ptr ds:[edi+_KO_VAR]
 00004896  33 C9		        xor     ecx,ecx
				        .WHILE (byte ptr ds:[edx+ecx] != 0)
 00004898  EB 01	   *	    jmp    @C0516
 0000489A		   *@C0517:
 0000489A  41			            inc     ecx
				        .ENDW
 0000489B		   *@C0516:
 0000489B  80 3C 11 00	   *	    cmp    byte ptr ds : [edx + ecx], 000h
 0000489F  75 F9	   *	    jne    @C0517

 000048A1  5A			        pop     edx
 000048A2  5F			        pop     edi
 000048A3  C3			        ret
 000048A4			    invDEBI_textbox_get_length      ENDP




 000048A4			    invDEBI_force_lowercase_ds_edx      PROC
				    ; This routine is used to force the null-terminated string at ds:[edx]
				    ;
				    ; Upon entry:   ds:[edx] - far ptr to null-terminated string
				    ;
				    ; Upon exit:    The string is forced to lower-case
				    ;
 000048A4  52			        push    edx
 000048A5  50			        push    eax

				        .WHILE (byte ptr ds:[edx] != 0)
 000048A6  EB 0E	   *	    jmp    @C0519
 000048A8		   *@C051A:
 000048A8  8A 02		            mov     al,byte ptr ds:[edx]
				            .IF (al >= 'A' && al <= 'Z')
 000048AA  3C 41	   *	    cmp    al, 'A'
 000048AC  72 07	   *	    jb     @C051B
 000048AE  3C 5A	   *	    cmp    al, 'Z'
 000048B0  77 03	   *	    ja     @C051B
				              ; It is upper-case, let's lower the bad boy
 000048B2  80 2A 20		                sub     byte ptr ds:[edx],20h
				            .ENDIF
 000048B5		   *@C051B:
 000048B5  42			            inc     edx
				        .ENDW
 000048B6		   *@C0519:
 000048B6  80 3A 00	   *	    cmp    byte ptr ds : [edx], 000h
 000048B9  75 ED	   *	    jne    @C051A

 000048BB  58			        pop     eax
 000048BC  5A			        pop     edx
 000048BD  C3			        ret
 000048BE			    invDEBI_force_lowercase_ds_edx      ENDP




 000048BE			    invDEBI_textbox_refresh     PROC
				    ; This routine is called to refresh the textbox item
				    ;
				    ; Upon entry:   ds:kbd_object - set to textbox object to refresh
				    ;               ds:textbox_* variables
				    ;
				    ; Upon exit:    The item is refreshed
				    ;
 000048BE  60			        pushad
 000048BF  9C			        pushfd
 000048C0  FA			        cli
 000048C1  E8 FFFFCDC3		        call    invDEBI_hide_mouse_pointer
 000048C6  E8 FFFFCF14		        call    invDEBI_turn_cursor_off

 000048CB  8B 3D 0000B78C R	        mov     edi,ds:kbd_object
 000048D1  A1 0000B908 R	        mov     eax,ds:textbox_x
 000048D6  8B 1D 0000B90C R	        mov     ebx,ds:textbox_y
 000048DC  8B 57 0D		        mov     edx,dword ptr ds:[edi+_KO_VAR]
				      ; Right now, eax - X coord
				      ;            ebx - Y coord
				      ;            edx - offset to variable
 000048DF  50			        push    eax                                                 ; horizontal
 000048E0  53			        push    ebx                                                 ; vertical
 000048E1  52			        push    edx                                                 ; offset to variable
 000048E2  FF 1D 0000D0E3 R	        call    fword ptr ds:_VID_g_mono_display_text               ;

				        .IF (ds:textbox_sel_end != 0)
 000048E8  83 3D 0000B918 R
	   00		   *	    cmp    ds : textbox_sel_end, 000h
 000048EF  74 47	   *	    je     @C051F
				          ; Now, re-draw the selected portion only in reverse video
 000048F1  8B 0D 0000B914 R	            mov     ecx,ds:textbox_sel_start
				            .WHILE (ecx > 0)
 000048F7  EB 05	   *	    jmp    @C0521
 000048F9		   *@C0522:
 000048F9  42			                inc     edx
 000048FA  83 C0 08		                add     eax,FONT_X
 000048FD  49			                dec     ecx
				            .ENDW
 000048FE		   *@C0521:
 000048FE  83 F9 00	   *	    cmp    ecx, 000h
 00004901  77 F6	   *	    ja     @C0522
 00004903  BE 0000B9B4 R	            mov     esi,offset trash_string
 00004908  8B 0D 0000B918 R	            mov     ecx,ds:textbox_sel_end
 0000490E  2B 0D 0000B914 R	            sub     ecx,ds:textbox_sel_start
 00004914  50			            push    eax
				            .WHILE (ecx > 0)
 00004915  EB 07	   *	    jmp    @C0524
 00004917		   *@C0525:
 00004917  8A 02		                mov     al,byte ptr ds:[edx]
 00004919  88 06		                mov     byte ptr ds:[esi],al
 0000491B  42			                inc     edx
 0000491C  46			                inc     esi
 0000491D  49			                dec     ecx
				            .ENDW
 0000491E		   *@C0524:
 0000491E  83 F9 00	   *	    cmp    ecx, 000h
 00004921  77 F4	   *	    ja     @C0525
 00004923  58			            pop     eax
 00004924  C6 06 00		            mov     byte ptr ds:[esi],0
 00004927  6A 00		            push    0                                               ; Write operation (0-overlay)
 00004929  50			            push    eax                                             ; horizontal
 0000492A  53			            push    ebx                                             ; vertical
 0000492B  6A 01		            push    1                                               ; Display mode (1-reverse)
 0000492D  68 0000B9B4 R	            push    dword ptr offset trash_string
 00004932  FF 1D 0000D0E1 R	            call    fword ptr ds:_VID_g_mono_display_text_mode
				        .ENDIF
 00004938		   *@C051F:

 00004938  9D			        popfd
 00004939  61			        popad
 0000493A  C3			        ret
 0000493B			    invDEBI_textbox_refresh     ENDP




 0000493B			    invDEBI_textbox_activate    PROC
				    ; This routine is used to activate a textbox item (basically it puts the cursor where it should be)
				    ;
				    ; Upon entry:   ds:textbox_offset - set to the offset in the textbox from the current item
				    ;                    ds:textbox_x - set based on the current item
				    ;                    ds:textbox_y - set based on the current item
				    ;
				    ; Upon exit:    ds:cursor_x - updated
				    ;               ds:cursor_y - updated
				    ;
 0000493B  E8 00000001		        call    invDEBI_textbox_set_cursor
 00004940  C3			        ret
 00004941			    invDEBI_textbox_activate    ENDP




 00004941			    invDEBI_textbox_set_cursor      PROC
				    ; This routine is used to put the cursor at the correction locaiton on the screen
				    ;
				    ; Upon entry:   ds:textbox_offset - offset into the current textbox item
				    ;                    ds:textbox_x - textbox item's X coordinate for left-most character
				    ;                    ds:textbox_y - textbox item's Y coordinate for left-most character
				    ;
				    ; Upon exit:    ds:cursor_x - updated
				    ;               ds:cursor_y - updated
				    ;
 00004941  60			        pushad
 00004942  A1 0000B910 R	        mov     eax,ds:textbox_offset
 00004947  BB 00000008		        mov     ebx,FONT_X
 0000494C  F7 E3		        mul     ebx
 0000494E  03 05 0000B908 R	        add     eax,ds:textbox_x
 00004954  A3 0000B8A4 R	        mov     ds:cursor_x,eax
 00004959  8B 1D 0000B90C R	        mov     ebx,ds:textbox_y
 0000495F  89 1D 0000B8A8 R	        mov     ds:cursor_y,ebx
 00004965  61			        popad
 00004966  C3			        ret
 00004967			    invDEBI_textbox_set_cursor      ENDP




 00004967			    invDEBI_checkbox_refresh    PROC
				    ; This routine is called to refresh the checkbox item
				    ;
				    ; Upon entry:   ds:kbd_object - set to checkbox object to refresh
				    ;               ds:checkbox_* variables
				    ;
				    ; Upon exit:    The item is refreshed
				    ;
 00004967  C3			        ret
 00004968			    invDEBI_checkbox_refresh    ENDP




 00004968			    invDEBI_checkbox_activate   PROC
				    ; This routine is used to activate a checkbox item (basically it puts the cursor where it should be)
				    ;
				    ; Upon entry:   ds:checkbox_x - set based on the current item
				    ;               ds:checkbox_y - set based on the current item
				    ;
				    ; Upon exit:    ds:cursor_x - updated
				    ;               ds:cursor_y - updated
				    ;
 00004968  60			        pushad
 00004969  A1 0000B924 R	        mov     eax,ds:checkbox_offset
 0000496E  BB 00000008		        mov     ebx,FONT_X
 00004973  F7 E3		        mul     ebx
 00004975  03 05 0000B91C R	        add     eax,ds:checkbox_x
 0000497B  A3 0000B8A4 R	        mov     ds:cursor_x,eax
 00004980  A1 0000B920 R	        mov     eax,ds:checkbox_y
 00004985  A3 0000B8A8 R	        mov     ds:cursor_y,eax
 0000498A  61			        popad
 0000498B  C3			        ret
 0000498C			    invDEBI_checkbox_activate   ENDP




 0000498C			    invDEBI_button_refresh      PROC
				    ; This routine is called to refresh the button item
				    ;
				    ; Upon entry:   ds:kbd_object - set to button object to refresh
				    ;               ds:button_* variables
				    ;
				    ; Upon exit:    The item is refreshed
				    ;
 0000498C  C3			        ret
 0000498D			    invDEBI_button_refresh      ENDP




 0000498D			    invDEBI_button_activate     PROC
				    ; This routine is used to activate a button item (basically it puts the cursor where it should be)
				    ;
				    ; Upon entry:   ds:button_x - set based on the current item
				    ;               ds:button_y - set based on the current item
				    ;
				    ; Upon exit:    ds:cursor_x - updated
				    ;               ds:cursor_y - updated
				    ;
 0000498D  60			        pushad
 0000498E  A1 0000B930 R	        mov     eax,ds:button_offset
 00004993  BB 00000008		        mov     ebx,FONT_X
 00004998  F7 E3		        mul     ebx
 0000499A  03 05 0000B928 R	        add     eax,ds:button_x
 000049A0  A3 0000B8A4 R	        mov     ds:cursor_x,eax
 000049A5  A1 0000B92C R	        mov     eax,ds:button_y
 000049AA  A3 0000B8A8 R	        mov     ds:cursor_y,eax
 000049AF  61			        popad
 000049B0  C3			        ret
 000049B1			    invDEBI_button_activate     ENDP




 000049B1			    invDEBI_function_set_cursor     PROC
				    ; This routine is used to position the cursor on an item handled by a function
				    ;
				    ; Upon entry:   ds:function_x - set based on the current item
				    ;               ds:function_y - set based on the current item
				    ;
				    ; Upon exit:    ds:cursor_x - updated
				    ;               ds:cursor_y - updated
				    ;
 000049B1  50			        push    eax
 000049B2  A1 0000B934 R	        mov     eax,ds:function_x
 000049B7  A3 0000B8A4 R	        mov     ds:cursor_x,eax
 000049BC  A1 0000B938 R	        mov     eax,ds:function_y
 000049C1  A3 0000B8A8 R	        mov     ds:cursor_y,eax
 000049C6  58			        pop     eax
 000049C7  C3			        ret
 000049C8			    invDEBI_function_set_cursor     ENDP




 000049C8			    invDEBI_kbd_input_cancel        PROC
				    ; Note, one flaw in Debi's internal design is that multiple layes of input cannot be nested
				    ; There is only the top level (which is the main Debi screen that comes up when debugging)
				    ; and then there's the programmable level (which is whatever popup is being used)
				    ; That's why you see the "mov ds:object_mode,0" line below.  This puts Debi back into its top level object processing.
 000049C8  9C			        pushfd
 000049C9  FA			        cli

				      ; Cancel the focus
 000049CA  C7 05 0000B794 R	        mov     ds:kbd_focus,-1
	   FFFFFFFF

				      ; Turn off the mouse, cursor and restore the screen
 000049D4  E8 FFFFCCB0		        call    invDEBI_hide_mouse_pointer
 000049D9  E8 FFFFCE01		        call    invDEBI_turn_cursor_off
 000049DE  C6 05 0000B8B1 R	        mov     ds:force_cursor_off,1
	   01
 000049E5  E8 FFFFCD72		        call    invDEBI_restore_screen2

				      ; Cancel the popup mode
 000049EA  C7 05 0000B788 R	        mov     ds:object_mode,0
	   00000000
 000049F4  9D			        popfd
 000049F5  C3			        ret
 000049F6			    invDEBI_kbd_input_cancel        ENDP




 000049F6			    invDEBI_exp_screen_ok       PROC
				    ; This routine is used when they click on the address expression window's OK button
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to screen object
				    ;               ds:[edi] - far ptr to mouse object (the OK button object)
				    ;
				    ; Upon exit:    The address is parsed, if valid then it's encoded into the desired location and input is terminated
				    ;               If it's invalid, then they're not allowed to click OK (an invalid message appears in the Quick Watch
				    ;                                area and editing continues)
				    ;
				    ;-----
				    ; The allowable formats are:
				    ;   1 - exp                     - exp linear memory address
				    ;   2 - exp:exp                 - exp relative address in specified reg1 segment
				    ; Expressions can be:
				    ;   [const/reg] [*-/+] [const/reg] [*-/+] [const/reg]
				    ;
 000049F6  06			        push    es
 000049F7  60			        pushad
 000049F8  BB 000000D8		        mov     ebx,_sDEBI_memory
 000049FD  8E C3		        mov     es,ebx

 000049FF  BE 0000AFBD R	        mov     esi,offset text_22
 00004A04  B9 00000016		        mov     ecx,sizeof text_22 - 1
 00004A09  E8 000000A1		        call    invDEBI_parse_expression
				        .IF (!carry?)
 00004A0E  72 61	   *	    jb     @C0527
 00004A10  BE 0000AFD4 R	            mov     esi,offset disp_22
 00004A15  B9 00000016		            mov     ecx,sizeof disp_22 - 1
 00004A1A  E8 00000090		            call    invDEBI_parse_expression
				            .IF (!carry?)
 00004A1F  72 50	   *	    jb     @C0529
				              ; The expression is parsable
 00004A21  8B 3D 0000B900 R	                mov     edi,ds:exp_esi
 00004A27  8B 7F 0C		                mov     edi,dword ptr ds:[edi+_ST_MEMVAR_OFFSET]
 00004A2A  BB 0000AA8A R	                mov     ebx,offset DEBI_exp_memvar_list
 00004A2F  E8 00000040		                call    invDEBI_into_object_memvar
 00004A34  E8 FFFFFF8F		                call    invDEBI_kbd_input_cancel

				              ; Now, refresh the screen with the new changes they've made
 00004A39  0F B6 05		                movzx   eax,ds:force_screen_redraw
	   0000B786 R
 00004A40  50			                push    eax
 00004A41  0F B6 05		                movzx   eax,ds:force_func_windows
	   0000B8B2 R
 00004A48  50			                push    eax
 00004A49  C6 05 0000B786 R	                mov     ds:force_screen_redraw,_YES
	   01
 00004A50  C6 05 0000B8B2 R	                mov     ds:force_func_windows,_YES
	   01
 00004A57  8B 35 0000B900 R	                mov     esi,ds:exp_esi                                          ; Screen
 00004A5D  8B 7E 1C		                mov     edi,dword ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]         ; Object data
 00004A60  E8 FFFFBAD6		                call    invDEBI_draw_objects
 00004A65  58			                pop     eax
 00004A66  A2 0000B8B2 R	                mov     ds:force_func_windows,al
 00004A6B  58			                pop     eax
 00004A6C  A2 0000B786 R	                mov     ds:force_screen_redraw,al
				            .ENDIF
				        .ENDIF
 00004A71		   *@C0529:
 00004A71		   *@C0527:
 00004A71  61			        popad
 00004A72  07			        pop     es
 00004A73  C3			        ret
 00004A74			    invDEBI_exp_screen_ok       ENDP




 00004A74			    invDEBI_into_object_memvar      PROC
				    ; This routine is used to copy from local variables into an object's MEMVAR location
				    ;
				    ; Upon entry:   ds:[ebx] - far ptr to variable listing
				    ;               es:[edi] - far ptr to destination memory location
				    ;
				    ; Upon exit:    Data is copied
				    ;
 00004A74  9C			        pushfd
 00004A75  60			        pushad
 00004A76  FC			        cld
				        .WHILE (dword ptr ds:[ebx+_MEMVAR_MEMORY_VARIABLE] != -1)
 00004A77  EB 0A	   *	    jmp    @C052B
 00004A79		   *@C052C:
 00004A79  8B 33		            mov     esi,dword ptr ds:[ebx+_MEMVAR_MEMORY_VARIABLE]
 00004A7B  8B 4B 04		            mov     ecx,dword ptr ds:[ebx+_MEMVAR_LENGTH]
 00004A7E  F3/ A4		            rep     movsb
 00004A80  83 C3 08		            add     ebx,_MEMVAR_STRUCT_LENGTH
				        .ENDW
 00004A83		   *@C052B:
 00004A83  83 3B FF	   *	    cmp    dword ptr ds : [ebx + _MEMVAR_MEMORY_VARIABLE], - 001h
 00004A86  75 F1	   *	    jne    @C052C
 00004A88  61			        popad
 00004A89  9D			        popfd
 00004A8A  C3			        ret
 00004A8B			    invDEBI_into_object_memvar      ENDP




 00004A8B			    invDEBI_from_object_memvar      PROC
				    ; This routine is used to copy from an object's MEMVAR location to local variables
				    ;
				    ; Upon entry:   ds:[ebx] - far ptr to variable listing
				    ;               es:[esi] - far ptr to source memory location
				    ;
				    ; Upon exit:    Data is copied
				    ;
 00004A8B  9C			        pushfd
 00004A8C  60			        pushad
 00004A8D  FC			        cld
				        .WHILE (dword ptr ds:[ebx+_MEMVAR_MEMORY_VARIABLE] != -1)
 00004A8E  EB 17	   *	    jmp    @C052E
 00004A90		   *@C052F:
 00004A90  8B 3B		            mov     edi,dword ptr ds:[ebx+_MEMVAR_MEMORY_VARIABLE]
 00004A92  8B 4B 04		            mov     ecx,dword ptr ds:[ebx+_MEMVAR_LENGTH]
				          ; Copy from _sDEBI_memory memory location to variable
				            .WHILE (ecx > 0)
 00004A95  EB 08	   *	    jmp    @C0530
 00004A97		   *@C0531:
 00004A97  26: 8A 06		                mov     al,byte ptr es:[esi]
 00004A9A  88 07		                mov     byte ptr ds:[edi],al
 00004A9C  46			                inc     esi
 00004A9D  47			                inc     edi
 00004A9E  49			                dec     ecx
				            .ENDW
 00004A9F		   *@C0530:
 00004A9F  83 F9 00	   *	    cmp    ecx, 000h
 00004AA2  77 F3	   *	    ja     @C0531
 00004AA4  83 C3 08		            add     ebx,_MEMVAR_STRUCT_LENGTH
				        .ENDW
 00004AA7		   *@C052E:
 00004AA7  83 3B FF	   *	    cmp    dword ptr ds : [ebx + _MEMVAR_MEMORY_VARIABLE], - 001h
 00004AAA  75 E4	   *	    jne    @C052F
 00004AAC  61			        popad
 00004AAD  9D			        popfd
 00004AAE  C3			        ret
 00004AAF			    invDEBI_from_object_memvar      ENDP




 00004AAF			    invDEBI_parse_expression        PROC
				    ; This routine is used to parse the text expression into a segment and offset
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to address expression (has been lower-cased)
				    ;                    ecx - length
				    ;
				    ; Upon exit:    carry? - SET if error, CLEAR if OK
				    ;               ¿¬ƒ SET
				    ;                ≥ eax - error code if error
				    ;                ¿ƒ CLEAR
				    ;                  eax - segment to use
				    ;                  ebx - offset if no error
				    ;
				        .IF (byte ptr ds:[esi] == 32)
 00004AAF  80 3E 20	   *	    cmp    byte ptr ds : [esi], 020h
 00004AB2  75 09	   *	    jne    @C0534
				          ; Nothing to do, default to ds:0x0
 00004AB4  F8			            clc
 00004AB5  8B 45 14		            mov     eax,dword ptr ss:[ebp+_STACK_DS]
 00004AB8  33 DB		            xor     ebx,ebx
 00004ABA  C3			            ret
				        .ELSEIF (ecx < 2)
 00004ABB  EB 07	   *	    jmp    @C0536
 00004ABD		   *@C0534:
 00004ABD  83 F9 02	   *	    cmp    ecx, 002h
 00004AC0  73 02	   *	    jae    @C0537
				          ; Not enough space to do anything
 00004AC2  F9			            stc
 00004AC3  C3			            ret
				        .ENDIF
 00004AC4		   *@C0537:
 00004AC4		   *@C0536:
 00004AC4  0F A0		        push    fs
 00004AC6  66| 2E: 8E 25	        mov     fs,cs:data_segment
	   0000B77F R

				      ; Initialize default values (in case they don't specify portions)
				      ; Note, that this algorithm assumes a segment override won't be specified and stores the calculation in offset_to_use
				      ;       until a ":" is found, at which time it is copied and the seg_specified variable is raised
 00004ACE  64: C6 05		        mov     fs:seg_specified,_NO                                ; The default condition is "they haven't specified a data seg"
	   0000BBB0 R 00
 00004AD6  64: C6 05		        mov     fs:last_operator,_NONE
	   0000BBB9 R 00
 00004ADE  8B 5D 14		        mov     ebx,dword ptr ss:[ebp+_STACK_DS]                    ; The default segment is DS
 00004AE1  64: 89 1D		        mov     fs:seg_to_use,ebx
	   0000BBB1 R
 00004AE8  64: C7 05		        mov     fs:offset_to_use,0
	   0000BBB5 R
	   00000000
				        .WHILE (ecx > 0)
 00004AF3  E9 00000199	   *	    jmp    @C0539
 00004AF8		   *@C053A:
 00004AF8  66| 8B 06		            mov     ax,word ptr ds:[esi]
				            .IF (al == 32)
 00004AFB  3C 20	   *	    cmp    al, 020h
 00004AFD  75 07	   *	    jne    @C053B
 00004AFF  46			                inc     esi
 00004B00  49			                dec     ecx
				            .ELSEIF (al == ':')
 00004B01  E9 0000018B	   *	    jmp    @C053D
 00004B06		   *@C053B:
 00004B06  3C 3A	   *	    cmp    al, ':'
 00004B08  75 2D	   *	    jne    @C053E
				              ; It's the end of the segment section
				                .IF (fs:seg_specified == _YES)
 00004B0A  64: 80 3D
	   0000BBB0 R 01   *	    cmp    fs : seg_specified, _YES
 00004B12  75 06	   *	    jne    @C0540
				                  ; It's a syntax error (they've already specified something)
 00004B14  F9			                    stc
 00004B15  E9 0000018E		                    jmp     quit_in_error
				                .ENDIF
 00004B1A		   *@C0540:
 00004B1A  64: C6 05		                mov     fs:seg_specified,_YES
	   0000BBB0 R 01
 00004B22  64: 8B 1D		                mov     ebx,fs:offset_to_use
	   0000BBB5 R
 00004B29  64: 89 1D		                mov     fs:seg_to_use,ebx
	   0000BBB1 R
 00004B30  46			                inc     esi
 00004B31  49			                dec     ecx
				            .ELSEIF (al == '+')
 00004B32  E9 0000015A	   *	    jmp    @C0542
 00004B37		   *@C053E:
 00004B37  3C 2B	   *	    cmp    al, '+'
 00004B39  75 09	   *	    jne    @C0543
 00004B3B  B0 01		                mov     al,_ADDITION
 00004B3D  EB 25		                jmp     skip_past_operator_byte
				            .ELSEIF (al == '*')
 00004B3F  E9 0000014D	   *	    jmp    @C0545
 00004B44		   *@C0543:
 00004B44  3C 2A	   *	    cmp    al, '*'
 00004B46  75 09	   *	    jne    @C0546
 00004B48  B0 02		                mov     al,_MULTIPLICATION
 00004B4A  EB 18		                jmp     skip_past_operator_byte
				            .ELSEIF (al == '/')
 00004B4C  E9 00000140	   *	    jmp    @C0548
 00004B51		   *@C0546:
 00004B51  3C 2F	   *	    cmp    al, '/'
 00004B53  75 09	   *	    jne    @C0549
 00004B55  B0 03		                mov     al,_DIVISION
 00004B57  EB 0B		                jmp     skip_past_operator_byte
				            .ELSEIF (al == '-')
 00004B59  E9 00000133	   *	    jmp    @C054B
 00004B5E		   *@C0549:
 00004B5E  3C 2D	   *	    cmp    al, '-'
 00004B60  75 1F	   *	    jne    @C054C
 00004B62  B0 04		                mov     al,_SUBTRACTION
 00004B64			              skip_past_operator_byte:
				                .IF (fs:last_operator != _NONE)
 00004B64  64: 80 3D
	   0000BBB9 R 00   *	    cmp    fs : last_operator, _NONE
 00004B6C  74 06	   *	    je     @C054E
				                  ; it's a syntax error (they've already specified an operator, but nothing to operate against)
 00004B6E  F9			                    stc
 00004B6F  E9 00000134		                    jmp     quit_in_error
				                .ENDIF
 00004B74		   *@C054E:
 00004B74  64: A2		                mov     fs:last_operator,al
	   0000BBB9 R
 00004B7A  46			                inc     esi
 00004B7B  49			                dec     ecx
				            .ELSEIF (ecx > 2)
 00004B7C  E9 00000110	   *	    jmp    @C0550
 00004B81		   *@C054C:
 00004B81  83 F9 02	   *	    cmp    ecx, 002h
 00004B84  0F 86 00000104  *	    jbe    @C0551
				                .IF (ax == '>>')
 00004B8A  66| 3D 3E3E	   *	    cmp    ax, '>>'
 00004B8E  75 09	   *	    jne    @C0553
 00004B90  B0 05		                    mov     al,_SHIFT_RIGHT
 00004B92  EB 0D		                    jmp     skip_past_operator_word
				                .ELSEIF (ax == '<<')
 00004B94  E9 000000F8	   *	    jmp    @C0555
 00004B99		   *@C0553:
 00004B99  66| 3D 3C3C	   *	    cmp    ax, '<<'
 00004B9D  75 23	   *	    jne    @C0556
 00004B9F  B0 06		                    mov     al,_SHIFT_LEFT
 00004BA1			                  skip_past_operator_word:
				                    .IF (fs:last_operator != _NONE)
 00004BA1  64: 80 3D
	   0000BBB9 R 00   *	    cmp    fs : last_operator, _NONE
 00004BA9  74 06	   *	    je     @C0558
				                      ; It's a syntax error (they've already specified an operator, but nothing to operate against)
 00004BAB  F9			                        stc
 00004BAC  E9 000000F7		                        jmp     quit_in_error
				                    .ENDIF
 00004BB1		   *@C0558:
 00004BB1  64: A2		                    mov     fs:last_operator,al
	   0000BBB9 R
 00004BB7  83 C6 02		                    add     esi,2
 00004BBA  83 E9 02		                    sub     ecx,2
				                .ELSEIF (ax == 'x0')
 00004BBD  E9 000000CF	   *	    jmp    @C055A
 00004BC2		   *@C0556:
 00004BC2  66| 3D 7830	   *	    cmp    ax, 'x0'
 00004BC6  75 0C	   *	    jne    @C055B
				                  ; It's a hexadecimal constant
 00004BC8  E8 000000DE		                    call    invDEBI_parse_hexadecimal_constant
 00004BCD  EB 34		                    jmp     process_operator
				                .ELSEIF (ax == 'y0')
 00004BCF  E9 000000BD	   *	    jmp    @C055D
 00004BD4		   *@C055B:
 00004BD4  66| 3D 7930	   *	    cmp    ax, 'y0'
 00004BD8  75 0C	   *	    jne    @C055E
				                  ; It's a binary constant
 00004BDA  E8 00000176		                    call    invDEBI_parse_binary_constant
 00004BDF  EB 22		                    jmp     process_operator
				                .ELSEIF (ax == 'd0')
 00004BE1  E9 000000AB	   *	    jmp    @C0560
 00004BE6		   *@C055E:
 00004BE6  66| 3D 6430	   *	    cmp    ax, 'd0'
 00004BEA  75 0C	   *	    jne    @C0561
				                  ; It's a decimal constant
 00004BEC  E8 000000F6		                    call    invDEBI_parse_decimal_constant
 00004BF1  EB 10		                    jmp     process_operator
				                .ELSEIF (ax == 'o0')
 00004BF3  E9 00000099	   *	    jmp    @C0563
 00004BF8		   *@C0561:
 00004BF8  66| 3D 6F30	   *	    cmp    ax, 'o0'
 00004BFC  75 79	   *	    jne    @C0564
				                  ; It's an octal constant
 00004BFE  E8 00000122		                    call    invDEBI_parse_octal_constant
 00004C03			                  process_operator:
				                    .IF (fs:last_operator == _NONE)
 00004C03  64: 80 3D
	   0000BBB9 R 00   *	    cmp    fs : last_operator, _NONE
 00004C0B  75 09	   *	    jne    @C0566
				                      ; Ok, we just store it
 00004C0D  64: 89 1D		                        mov     fs:offset_to_use,ebx
	   0000BBB5 R
				                    .ELSE
 00004C14  EB 7B	   *	    jmp    @C0568
 00004C16		   *@C0566:
				                      ; We have to operate on it
				                        .IF (fs:last_operator == _ADDITION)
 00004C16  64: 80 3D
	   0000BBB9 R 01   *	    cmp    fs : last_operator, _ADDITION
 00004C1E  75 09	   *	    jne    @C0569
 00004C20  64: 01 1D		                            add     fs:offset_to_use,ebx
	   0000BBB5 R
				                        .ELSEIF (fs:last_operator == _SUBTRACTION)
 00004C27  EB 44	   *	    jmp    @C056B
 00004C29		   *@C0569:
 00004C29  64: 80 3D
	   0000BBB9 R 04   *	    cmp    fs : last_operator, _SUBTRACTION
 00004C31  75 09	   *	    jne    @C056C
 00004C33  64: 29 1D		                            sub     fs:offset_to_use,ebx
	   0000BBB5 R
				                        .ELSEIF (fs:last_operator == _MULTIPLICATION)
 00004C3A  EB 31	   *	    jmp    @C056E
 00004C3C		   *@C056C:
 00004C3C  64: 80 3D
	   0000BBB9 R 02   *	    cmp    fs : last_operator, _MULTIPLICATION
 00004C44  75 10	   *	    jne    @C056F
 00004C46  64: A1		                            mov     eax,fs:offset_to_use
	   0000BBB5 R
 00004C4C  F7 E3		                            mul     ebx
 00004C4E  64: A3		                            mov     fs:offset_to_use,eax
	   0000BBB5 R
				                        .ELSE
 00004C54  EB 17	   *	    jmp    @C0571
 00004C56		   *@C056F:
				                          ; It must be a division
				                            .IF (ebx == 0)
 00004C56  0B DB	   *	    or	ebx, ebx
 00004C58  75 03	   *	    jne    @C0572
				                              ; It's division by 0, error
 00004C5A  F9			                                stc
 00004C5B  EB 4B		                                jmp     quit_in_error
				                            .ENDIF
 00004C5D		   *@C0572:
 00004C5D  64: A1		                            mov     eax,fs:offset_to_use
	   0000BBB5 R
 00004C63  33 D2		                            xor     edx,edx
 00004C65  F7 F3		                            div     ebx
 00004C67  64: A3		                            mov     fs:offset_to_use,eax
	   0000BBB5 R
				                        .ENDIF
 00004C6D		   *@C0571:
 00004C6D		   *@C056E:
 00004C6D		   *@C056B:
 00004C6D  64: C6 05		                        mov     fs:last_operator,_NONE
	   0000BBB9 R 00
				                    .ENDIF
				                .ELSE
 00004C75  EB 1A	   *	    jmp    @C0574
 00004C77		   *@C0564:
				                  ; It must be a keyword
 00004C77  E8 00000108		                    call    invDEBI_search_regs
 00004C7C  75 85		                    jnz     process_operator                        ; Branch if found
 00004C7E  E8 00000191		                    call    invDEBI_search_keywords
 00004C83  0F 85 FFFFFF7A	                    jnz     process_operator                        ; Branch if found
 00004C89  F9			                    stc
 00004C8A  EB 1C		                    jmp     quit_in_error
				                .ENDIF
				            .ELSE
 00004C8C  EB 03	   *	    jmp    @C0575
 00004C8E		   *@C0551:
				              ; No idea
 00004C8E  F9			                stc
 00004C8F  EB 17		                jmp     quit_in_error
				            .ENDIF
 00004C91			          next_part:
				        .ENDW
 00004C91		   *@C0575:
 00004C91		   *@C0550:
 00004C91		   *@C054B:
 00004C91		   *@C0548:
 00004C91		   *@C0545:
 00004C91		   *@C0542:
 00004C91		   *@C053D:
 00004C91		   *@C0574:
 00004C91		   *@C0563:
 00004C91		   *@C0560:
 00004C91		   *@C055D:
 00004C91		   *@C055A:
 00004C91		   *@C0555:
 00004C91		   *@C0568:
 00004C91		   *@C0539:
 00004C91  83 F9 00	   *	    cmp    ecx, 000h
 00004C94  0F 87 FFFFFE5E  *	    ja     @C053A

 00004C9A			      quit:
 00004C9A  64: A1		        mov     eax,fs:seg_to_use
	   0000BBB1 R
 00004CA0  64: 8B 1D		        mov     ebx,fs:offset_to_use
	   0000BBB5 R
 00004CA7  F8			        clc
 00004CA8			      quit_in_error:
 00004CA8  0F A1		        pop     fs
 00004CAA  C3			        ret
 00004CAB			    invDEBI_parse_expression        ENDP




 00004CAB			    invDEBI_parse_hexadecimal_constant      PROC
				    ; This routine is used to convert a hexadecimal number
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to source (known to be lower-cased)
				    ;                    ecx - maximum number of chars left
				    ;
				    ; Upon exit:    ebx - converted value
				    ;               ds:[esi] - new ptr to first character after the number
				    ;
 00004CAB  83 C6 02		        add     esi,2                                               ; Skip passed the "0x" part
 00004CAE  83 E9 02		        sub     ecx,2                                               ; Decrease the count by the number of bytes in the "0x" part
 00004CB1  33 D2		        xor     edx,edx                                             ; Initialize our output variable
 00004CB3  33 DB		        xor     ebx,ebx
				        .WHILE (ecx > 0 && edx < 8)                                 ; When edx == 8, we've loaded 8 characters (which account for
 00004CB5  EB 25	   *	    jmp    @C0577
 00004CB7		   *@C0578:
 00004CB7  0F B6 06		            movzx   eax,byte ptr ds:[esi]                           ;                            all nibbles in a 32-bit quantity)
				            .IF (al >= '0' && al <= '9')
 00004CBA  3C 30	   *	    cmp    al, '0'
 00004CBC  72 08	   *	    jb     @C0579
 00004CBE  3C 39	   *	    cmp    al, '9'
 00004CC0  77 04	   *	    ja     @C0579
 00004CC2  2C 30		                sub     al,'0'                                      ; It's 0-9
				            .ELSEIF (al >= 'a' && al <= 'f')
 00004CC4  EB 0E	   *	    jmp    @C057C
 00004CC6		   *@C0579:
 00004CC6  3C 61	   *	    cmp    al, 'a'
 00004CC8  72 08	   *	    jb     @C057D
 00004CCA  3C 66	   *	    cmp    al, 'f'
 00004CCC  77 04	   *	    ja     @C057D
 00004CCE  2C 61		                sub     al,'a'                                      ; It's a-f
				            .ELSE
 00004CD0  EB 02	   *	    jmp    @C0580
 00004CD2		   *@C057D:
				              ; We're past the last character, we're done
 00004CD2  EB 12		                jmp     quit                                        ; It's something else
				            .ENDIF
 00004CD4		   *@C0580:
 00004CD4		   *@C057C:
 00004CD4  C1 E3 04		            shl     ebx,4                                           ; Make room for the nibble
 00004CD7  0B D8		            or      ebx,eax                                         ; Stick in in there

 00004CD9  49			            dec     ecx                                             ; Decrease count
 00004CDA  46			            inc     esi                                             ; Increase offset
 00004CDB  42			            inc     edx                                             ; Increase # of characters skipped
				        .ENDW
 00004CDC		   *@C0577:
 00004CDC  83 F9 00	   *	    cmp    ecx, 000h
 00004CDF  76 05	   *	    jbe    @C0581
 00004CE1  83 FA 08	   *	    cmp    edx, 008h
 00004CE4  72 D1	   *	    jb     @C0578
 00004CE6		   *@C0581:

 00004CE6			      quit:
 00004CE6  C3			        ret
 00004CE7			    invDEBI_parse_hexadecimal_constant      ENDP




 00004CE7			    invDEBI_parse_decimal_constant      PROC
				    ; This routine is used to convert a decimal number
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to source
				    ;                    ecx - maximum number of chars left
				    ;
				    ; Upon exit:    ebx - converted value
				    ;               ds:[esi] - new ptr to first character after the number
				    ;
 00004CE7  83 C6 02		        add     esi,2                                               ; Skip passed the "0d" part
 00004CEA  83 E9 02		        sub     ecx,2                                               ; Decrease the count by the number of bytes in the "0d" part
 00004CED  33 D2		        xor     edx,edx                                             ; Initialize our output variable
 00004CEF  33 DB		        xor     ebx,ebx
				        .WHILE (ecx > 0 && edx < 10)                                ; When edx == 10, we've loaded 10 characters (which account for
 00004CF1  EB 27	   *	    jmp    @C0583
 00004CF3		   *@C0584:
 00004CF3  0F B6 06		            movzx   eax,byte ptr ds:[esi]                           ;                      all base-10 nibbles in a 32-bit quantity)
				            .IF (al >= '0' && al <= '9')
 00004CF6  3C 30	   *	    cmp    al, '0'
 00004CF8  72 1B	   *	    jb     @C0585
 00004CFA  3C 39	   *	    cmp    al, '9'
 00004CFC  77 17	   *	    ja     @C0585
 00004CFE  2C 30		                sub     al,'0'                                      ; Convert from ASCII to base-0 numeric
 00004D00  50			                push    eax
 00004D01  53			                push    ebx
 00004D02  52			                push    edx

 00004D03  8B C3		                mov     eax,ebx                                     ; Multiply by 10
 00004D05  BB 0000000A		                mov     ebx,10
 00004D0A  F7 E3		                mul     ebx

 00004D0C  5A			                pop     edx
 00004D0D  5B			                pop     ebx
 00004D0E  8B D8		                mov     ebx,eax
 00004D10  58			                pop     eax
 00004D11  03 D8		                add     ebx,eax
				            .ELSE
 00004D13  EB 02	   *	    jmp    @C0588
 00004D15		   *@C0585:
				              ; We're past the last character, we're done
 00004D15  EB 0D		                jmp     quit                                        ; It's something else
				            .ENDIF

 00004D17		   *@C0588:
 00004D17  49			            dec     ecx                                             ; Decrease count
 00004D18  46			            inc     esi                                             ; Increase offset
 00004D19  42			            inc     edx                                             ; Increase # of characters skipped
				        .ENDW
 00004D1A		   *@C0583:
 00004D1A  83 F9 00	   *	    cmp    ecx, 000h
 00004D1D  76 05	   *	    jbe    @C0589
 00004D1F  83 FA 0A	   *	    cmp    edx, 00Ah
 00004D22  72 CF	   *	    jb     @C0584
 00004D24		   *@C0589:

 00004D24			      quit:
 00004D24  C3			        ret
 00004D25			    invDEBI_parse_decimal_constant      ENDP




 00004D25			    invDEBI_parse_octal_constant    PROC
				    ; This routine is used to convert an octal number
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to source
				    ;                    ecx - maximum number of chars left
				    ;
				    ; Upon exit:    ebx - converted value
				    ;               ds:[esi] - new ptr to first character after the number
				    ;                    edx - chars moved
				    ;
 00004D25  83 C6 02		        add     esi,2                                               ; Skip passed the "0o" part
 00004D28  83 E9 02		        sub     ecx,2                                               ; Decrease the count by the number of bytes in the "0o" part
 00004D2B  33 D2		        xor     edx,edx                                             ; Initialize our output variable
 00004D2D  33 DB		        xor     ebx,ebx
				        .WHILE (ecx > 0 && edx < 11)                                ; When edx == 11, we've loaded 11 characters (which account for
 00004D2F  EB 19	   *	    jmp    @C058B
 00004D31		   *@C058C:
 00004D31  0F B6 06		            movzx   eax,byte ptr ds:[esi]                           ;                        all octal-nibbles in a 32-bit quantity)
				            .IF (al >= '0' && al <= '7')
 00004D34  3C 30	   *	    cmp    al, '0'
 00004D36  72 08	   *	    jb     @C058D
 00004D38  3C 37	   *	    cmp    al, '7'
 00004D3A  77 04	   *	    ja     @C058D
 00004D3C  2C 30		                sub     al,'0'                                      ; It's 0-7
				            .ELSE
 00004D3E  EB 02	   *	    jmp    @C0590
 00004D40		   *@C058D:
				              ; We're past the last character, we're done
 00004D40  EB 12		                jmp     quit                                        ; It's something else
				            .ENDIF
 00004D42		   *@C0590:
 00004D42  C1 E3 03		            shl     ebx,3                                           ; Make room for the nibble
 00004D45  0B D8		            or      ebx,eax                                         ; Stick in in there

 00004D47  49			            dec     ecx                                             ; Decrease count
 00004D48  46			            inc     esi                                             ; Increase offset
 00004D49  42			            inc     edx                                             ; Increase # of characters skipped
				        .ENDW
 00004D4A		   *@C058B:
 00004D4A  83 F9 00	   *	    cmp    ecx, 000h
 00004D4D  76 05	   *	    jbe    @C0591
 00004D4F  83 FA 0B	   *	    cmp    edx, 00Bh
 00004D52  72 DD	   *	    jb     @C058C
 00004D54		   *@C0591:

 00004D54			      quit:
 00004D54  C3			        ret
 00004D55			    invDEBI_parse_octal_constant    ENDP




 00004D55			    invDEBI_parse_binary_constant       PROC
				    ; This routine is used to convert a binary number
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to source
				    ;                    ecx - maximum number of chars left
				    ;
				    ; Upon exit:    ebx - converted value
				    ;               ds:[esi] - new ptr to first character after the number
				    ;                    edx - chars moved
				    ;
 00004D55  83 C6 02		        add     esi,2                                               ; Skip passed the "0y" part
 00004D58  83 E9 02		        sub     ecx,2                                               ; Decrease the count by the number of bytes in the "0y" part
 00004D5B  33 D2		        xor     edx,edx                                             ; Initialize our output variable
 00004D5D  33 DB		        xor     ebx,ebx
				        .WHILE (ecx > 0 && edx < 32)                                ; When edx == 32, we've loaded 32 characters (which account for
 00004D5F  EB 18	   *	    jmp    @C0593
 00004D61		   *@C0594:
 00004D61  0F B6 06		            movzx   eax,byte ptr ds:[esi]                           ;                                 all bits in a 32-bit quantity)
				            .IF (al >= '0' && al <= '1')
 00004D64  3C 30	   *	    cmp    al, '0'
 00004D66  72 08	   *	    jb     @C0595
 00004D68  3C 31	   *	    cmp    al, '1'
 00004D6A  77 04	   *	    ja     @C0595
 00004D6C  2C 30		                sub     al,'0'                                      ; It's 0-1
				            .ELSE
 00004D6E  EB 02	   *	    jmp    @C0598
 00004D70		   *@C0595:
				              ; We're past the last character, we're done
 00004D70  EB 11		                jmp     quit                                        ; It's something else
				            .ENDIF
 00004D72		   *@C0598:
 00004D72  D1 E3		            shl     ebx,1                                           ; Make room for the nibble
 00004D74  0B D8		            or      ebx,eax                                         ; Stick in in there

 00004D76  49			            dec     ecx                                             ; Decrease count
 00004D77  46			            inc     esi                                             ; Increase offset
 00004D78  42			            inc     edx                                             ; Increase # of characters skipped
				        .ENDW
 00004D79		   *@C0593:
 00004D79  83 F9 00	   *	    cmp    ecx, 000h
 00004D7C  76 05	   *	    jbe    @C0599
 00004D7E  83 FA 20	   *	    cmp    edx, 020h
 00004D81  72 DE	   *	    jb     @C0594
 00004D83		   *@C0599:

 00004D83			      quit:
 00004D83  C3			        ret
 00004D84			    invDEBI_parse_binary_constant       ENDP




 00004D84			    invDEBI_search_regs     PROC
				    ; This routine is used to search the registers for a match
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to source
				    ;                    ecx - maximum number of chars left in string
				    ;
				    ; Upon exit:       zero? - SET if not found, CLEAR if found
				    ;                    ebx - converted value (from the derived expression)
				    ;               ds:[esi] - new ptr to first character after the found text (if any where found)
				    ;                    ecx - new value
				    ;
 00004D84  57			        push    edi
 00004D85  50			        push    eax
 00004D86  83 EC 0C		        sub     esp,12
				      ; [esp+8], dword, original value of esp
				      ; [esp+4], dword, length of current item in reg_list
				      ; [esp+0], dword, hold value for reg_list pointer
 00004D89  89 64 24 08		        mov     dword ptr ss:[esp+8],esp
 00004D8D  83 44 24 08 0C	        add     dword ptr ss:[esp+8],12

 00004D92  BF 0000BAF5 R	        mov     edi,offset reg_list
				        .WHILE (byte ptr fs:[edi] != -1)
 00004D97  EB 6C	   *	    jmp    @C059B
 00004D99		   *@C059C:
 00004D99  89 3C 24		            mov     dword ptr ss:[esp+0],edi                        ; Save pointer
 00004D9C  64: 0F B6 17		            movzx   edx,byte ptr fs:[edi]                           ; Load length
 00004DA0  89 54 24 04		            mov     dword ptr ss:[esp+4],edx                        ; Save length
 00004DA4  47			            inc     edi                                             ; Move passed length
 00004DA5  33 D2		            xor     edx,edx                                         ; Reset counter
				            .WHILE (edx < dword ptr ss:[esp+4])                     ; Continue for length
 00004DA7  EB 13	   *	    jmp    @C059D
 00004DA9		   *@C059E:
 00004DA9  8A 04 32		                mov     al,byte ptr ds:[esi+edx]                    ; Compare source
 00004DAC  64: 8A 24 3A		                mov     ah,byte ptr fs:[edi+edx]                    ;   to list
 00004DB0  E8 000000C9		                call    invDEBI_force_lowercase_ah_al
				                .IF (ah != al)
 00004DB5  38 C4	   *	    cmp    ah, al
 00004DB7  74 02	   *	    je     @C059F
 00004DB9  EB 40		                    jmp     next                                    ; Branch if they don't match
				                .ENDIF
 00004DBB		   *@C059F:
 00004DBB  42			                inc     edx
				            .ENDW
 00004DBC		   *@C059D:
 00004DBC  3B 54 24 04	   *	    cmp    edx, dword ptr ss : [esp + 004h]
 00004DC0  72 E7	   *	    jb     @C059E
				          ; We've found a match
 00004DC2  64: 8A 04 3A		            mov     al,byte ptr fs:[edi+edx]                        ; Load the byte immediately after
 00004DC6  64: 0F BE 5C 3A	            movsx   ebx,byte ptr fs:[edi+edx+1]                     ; Load the byte immediately after that
	   01
				          ; Right now, eax is hte byte after the found item.  It is a pointer into the stack indicating where we should get our value.
				            .IF (al >= _CS && al <= _ECODE)
 00004DCC  3C 00	   *	    cmp    al, _CS
 00004DCE  72 0A	   *	    jb     @C05A2
 00004DD0  3C 21	   *	    cmp    al, _ECODE
 00004DD2  77 06	   *	    ja     @C05A2
				              ; It's a 32-bit reference
 00004DD4  36: 8B 1C 2B		                mov     ebx,dword ptr ss:[ebp+ebx]
				            .ELSEIF (al >= _AL && al <= _DH)
 00004DD8  EB 14	   *	    jmp    @C05A5
 00004DDA		   *@C05A2:
 00004DDA  3C 06	   *	    cmp    al, _AL
 00004DDC  72 0B	   *	    jb     @C05A6
 00004DDE  3C 13	   *	    cmp    al, _DH
 00004DE0  77 07	   *	    ja     @C05A6
				              ; It's an 8-bit reference
 00004DE2  36: 0F B6 1C 2B	                movzx   ebx,byte ptr ss:[ebp+ebx]
				            .ELSE
 00004DE7  EB 05	   *	    jmp    @C05A9
 00004DE9		   *@C05A6:
				              ; It's a 16-bit reference
 00004DE9  36: 0F B7 1C 2B	                movzx   ebx,word ptr ss:[ebp+ebx]
				            .ENDIF
 00004DEE		   *@C05A9:
 00004DEE		   *@C05A5:
 00004DEE  03 74 24 04		            add     esi,dword ptr ss:[esp+4]
 00004DF2  2B 4C 24 04		            sub     ecx,dword ptr ss:[esp+4]
				          ; We're done
 00004DF6  83 C8 01		            or      eax,1                                           ; Lower ZERO?
 00004DF9  EB 12		            jmp     quit

 00004DFB			          next:
 00004DFB  8B 3C 24		            mov     edi,dword ptr ss:[esp+0]                        ; get original pointer back
 00004DFE  03 7C 24 04		            add     edi,dword ptr ss:[esp+4]                        ; for item
 00004E02  83 C7 03		            add     edi,3                                           ; for overhead
				        .ENDW
 00004E05		   *@C059B:
 00004E05  64: 80 3F FF	   *	    cmp    byte ptr fs : [edi], - 001h
 00004E09  75 8E	   *	    jne    @C059C
 00004E0B  2B C0		        sub     eax,eax                                             ; Set ZERO?

 00004E0D			      quit:
 00004E0D  8B 64 24 08		        mov     esp,dword ptr ss:[esp+8]                            ; This doesn't affect the ZERO? flag (as an add esp,12 would)
 00004E11  58			        pop     eax
 00004E12  5F			        pop     edi
 00004E13  C3			        ret
 00004E14			    invDEBI_search_regs     ENDP




 00004E14			    invDEBI_search_keywords     PROC
				    ; This routine is used to search the keywords for a match
				    ;
				    ; Upon entry:   ds:[esi] - far ptr to source
				    ;                    ecx - maximum number of chars left in string
				    ;
				    ; Upon exit:       zero? - SET if not found, CLEAR if found
				    ;                    ebx - converted value
				    ;               ds:[esi] - new ptr to first character after the number
				    ;                    ecx - new value
				    ;
 00004E14  57			        push    edi
 00004E15  50			        push    eax
 00004E16  83 EC 0C		        sub     esp,12
				      ; [esp+8], dword, original value of esp
				      ; [esp+4], dword, length of current item in reg_list
				      ; [esp+0], dword, hold value for reg_list pointer
 00004E19  89 64 24 08		        mov     dword ptr ss:[esp+8],esp
 00004E1D  83 44 24 08 0C	        add     dword ptr ss:[esp+8],12

 00004E22  BF 0000BBBA R	        mov     edi,offset keyword_listing
				        .WHILE (byte ptr fs:[edi] != -1)
 00004E27  EB 46	   *	    jmp    @C05AB
 00004E29		   *@C05AC:
 00004E29  89 3C 24		            mov     dword ptr ss:[esp+0],edi                        ; Save pointer
 00004E2C  64: 0F B6 17		            movzx   edx,byte ptr fs:[edi]                           ; Load length
 00004E30  89 54 24 04		            mov     dword ptr ss:[esp+4],edx                        ; Save length
 00004E34  47			            inc     edi                                             ; Move passed length
 00004E35  33 D2		            xor     edx,edx                                         ; Reset counter
				            .WHILE (edx < dword ptr ss:[esp+4])                     ; Continue for length
 00004E37  EB 13	   *	    jmp    @C05AD
 00004E39		   *@C05AE:
 00004E39  8A 04 32		                mov     al,byte ptr ds:[esi+edx]                    ; Compare source
 00004E3C  64: 8A 24 3A		                mov     ah,byte ptr fs:[edi+edx]                    ;   to list
 00004E40  E8 00000039		                call    invDEBI_force_lowercase_ah_al
				                .IF (ah != al)
 00004E45  38 C4	   *	    cmp    ah, al
 00004E47  74 02	   *	    je     @C05AF
 00004E49  EB 1A		                    jmp     next                                    ; Branch if they don't match
				                .ENDIF
 00004E4B		   *@C05AF:
 00004E4B  42			                inc     edx
				            .ENDW
 00004E4C		   *@C05AD:
 00004E4C  3B 54 24 04	   *	    cmp    edx, dword ptr ss : [esp + 004h]
 00004E50  72 E7	   *	    jb     @C05AE
				          ; We've found a match
 00004E52  64: 0F BF 5C 3A	            movsx   ebx,word ptr fs:[edi+edx+1]                     ; Load the word immediately after the trailing NULL
	   01
 00004E58  03 74 24 04		            add     esi,dword ptr ss:[esp+4]
 00004E5C  2B 4C 24 04		            sub     ecx,dword ptr ss:[esp+4]
				          ; We're done
 00004E60  83 C8 01		            or      eax,1                                           ; Lower ZERO?
 00004E63  EB 12		            jmp     quit

 00004E65			          next:
 00004E65  8B 3C 24		            mov     edi,dword ptr ss:[esp+0]                        ; get original pointer back
 00004E68  03 7C 24 04		            add     edi,dword ptr ss:[esp+4]                        ; for item
 00004E6C  83 C7 04		            add     edi,4                                           ; for overhead
				        .ENDW
 00004E6F		   *@C05AB:
 00004E6F  64: 80 3F FF	   *	    cmp    byte ptr fs : [edi], - 001h
 00004E73  75 B4	   *	    jne    @C05AC
 00004E75  2B C0		        sub     eax,eax                                             ; Set ZERO?

 00004E77			      quit:
 00004E77  8B 64 24 08		        mov     esp,dword ptr ss:[esp+8]                            ; This doesn't affect the ZERO? flag (as an add esp,12 would)
 00004E7B  58			        pop     eax
 00004E7C  5F			        pop     edi
 00004E7D  C3			        ret
 00004E7E			    invDEBI_search_keywords     ENDP




 00004E7E			    invDEBI_force_lowercase_ah_al       PROC
				    ; This routine is used to force the characters in ah and al to lower-case
				    ;
				    ; Upon entry:   ah - character
				    ;               al - character
				    ;
				    ; Upon exit:    ah and al are lower-cased (if they're letters)
				    ;
				        .IF (ah >= 'A' && ah <= 'Z')
 00004E7E  80 FC 41	   *	    cmp    ah, 'A'
 00004E81  72 08	   *	    jb     @C05B3
 00004E83  80 FC 5A	   *	    cmp    ah, 'Z'
 00004E86  77 03	   *	    ja     @C05B3
 00004E88  80 CC 20		            or      ah,20h
				        .ENDIF
 00004E8B		   *@C05B3:
				        .IF (al >= 'A' && al <= 'Z')
 00004E8B  3C 41	   *	    cmp    al, 'A'
 00004E8D  72 06	   *	    jb     @C05B6
 00004E8F  3C 5A	   *	    cmp    al, 'Z'
 00004E91  77 02	   *	    ja     @C05B6
 00004E93  0C 20		            or      al,20h
				        .ENDIF
 00004E95		   *@C05B6:
 00004E95  C3			        ret
 00004E96			    invDEBI_force_lowercase_ah_al       ENDP
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; END - 99999 - Keyboard events
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=










				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; AAAAA - INCLUDE files
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				    ; invDEBI_cfsca_1_window()
				    ; invDEBI_cfsca_2_window()
				    ; invDEBI_cfsca_3_window()
				    ; invDEBI_cfsca_1_click()
				    ; invDEBI_cfsca_2_click()
				    ; invDEBI_cfsca_3_click()
				    INCLUDE cfsca.asp
			      C ; cfsca.asp
			      C ;
			      C ; Low-Level Debi Debugger CFSCA window handler
			      C ;
			      C ;
			      C 
			      C 
 00004E96 AE 3C 53 6F 75      C source_not_available    db  "Æ<Source not available>Ø",0
	   72 63 65 20 6E
	   6F 74 20 61 76
	   61 69 6C 61 62
	   6C 65 3E AF 00
 00004EAF  00000080 [	      C cfsca_buffer1           db  128 dup(0)
	    00
	   ]
 00004F2F  00000080 [	      C cfsca_buffer2           db  128 dup(0)
	    00
	   ]
			      C 
			      C 
			      C 
 00004FAF		      C invDEBI_cfsca_1_window      PROC
			      C ; This routine is called to populate the CFSCA.1 window
			      C ;
 00004FAF  C7 45 F4	      C     mov     dword ptr ss:[ebp-12],13*FONT_Y
	   0000004E
 00004FB6  EB 10	      C     jmp     invDEBI_cfsca_window_common
 00004FB8		      C invDEBI_cfsca_1_window      ENDP
			      C 
			      C 
			      C 
 00004FB8		      C invDEBI_cfsca_2_window      PROC
			      C ; This routine is called to populate the CFSCA.2 window
			      C ;
 00004FB8  C7 45 F4	      C     mov     dword ptr ss:[ebp-12],26*FONT_Y
	   0000009C
 00004FBF  EB 07	      C     jmp     invDEBI_cfsca_window_common
 00004FC1		      C invDEBI_cfsca_2_window      ENDP
			      C 
			      C 
			      C 
			      C 
 00004FC1		      C invDEBI_cfsca_3_window      PROC
			      C ; This routine is called to populate the CFSCA.3 window
			      C ;
 00004FC1  C7 45 F4	      C     mov     dword ptr ss:[ebp-12],39*FONT_Y
	   000000EA
			      C     ; Note, this next line is not executed because it will flow right into that algorithm
			      C     ;jmp     invDEBI_cfsca_window_common
 00004FC8		      C invDEBI_cfsca_3_window      ENDP
			      C 
			      C 
			      C 
			      C 
 00004FC8		      C invDEBI_cfsca_window_common     PROC
			      C ; This routine is called to process the cfsca windows
			      C ;
			      C ; Upon entry:   ds:[esi] - far ptr to this object's screen table info
			      C ;               ds:[edi] - far ptr to this object's parameters
			      C ;                  [ebp] - pointer to stack frame from debi_debug()
			      C ;               [ebp-12] - dword indicating maximum line to reach
			      C ;
			      C ; Upon exit:    The window is updated with either source code or an assembly listing
			      C ;
			      C   ; Refer to debi_debug() for these stack references
			      C   ; [ebp+56] - cs
			      C   ; [ebp+52] - eip
			      C   ; [ebp-08] - dword, Current font increment
			      C   ; [ebp-12] - dword, maximum line to reach
 00004FC8  1E		      C     push    ds
 00004FC9  06		      C     push    es
 00004FCA  0F A0	      C     push    fs
 00004FCC  9C		      C     pushfd
 00004FCD  60		      C     pushad
			      C 
			      C   ; Save esi use below (as edx)
 00004FCE  8B D6	      C     mov     edx,esi
			      C 
			      C   ; We need:  ds:[esi] - far ptr to execution code
			      C   ;           es:[edi] - far ptr to text string
			      C   ;                 fs - current data segment (used below for DEBI_simplify_disassembly)
			      C   ;                ebx - used to indicate how far down the screen we are
 00004FD0  66| 2E: 8E 05      C     mov     es,cs:data_segment
	   0000B77F R
 00004FD8  66| 2E: 8E 25      C     mov     fs,cs:data_segment
	   0000B77F R
 00004FE0  8B 75 34	      C     mov     esi,dword ptr ss:[ebp+52]
			      C     .IF (es:single_step_history != 0ffffffffh)
 00004FE3  26: 83 3D
	   0000B940 R FF   *	    cmp    es : single_step_history, 0FFFFFFFFh
 00004FEB  74 19	   *	    je     @C05B9
			      C       ; They've been single stepping
			      C         .IF (esi >= es:single_step_top && esi < es:single_step_end)
 00004FED  26: 3B 35
	   0000B944 R	   *	    cmp    esi, es : single_step_top
 00004FF4  72 10	   *	    jb     @C05BB
 00004FF6  26: 3B 35
	   0000B948 R	   *	    cmp    esi, es : single_step_end
 00004FFD  73 07	   *	    jae    @C05BB
 00004FFF  26: 8B 35	      C             mov     esi,es:single_step_top
	   0000B944 R
			      C         .ENDIF
			      C     .ENDIF
 00005006		   *@C05BB:
 00005006		   *@C05B9:
 00005006  26: C7 05	      C     mov     es:single_step_history,0
	   0000B940 R
	   00000000
 00005011  26: 89 35	      C     mov     es:single_step_top,esi
	   0000B944 R
			      C 
 00005018  8B 5D F8	      C     mov     ebx,dword ptr ss:[ebp-08]                               ; Start at 8 pixels down in window
			      C   ;-[loop]---
 0000501B		      C   @@:
 0000501B  8E 5D 38	      C         mov     ds,dword ptr ss:[ebp+56]
 0000501E  BF 00004EAF R      C         mov     edi,offset cfsca_buffer1
 00005023  26: FF 1D	      C         call    fword ptr es:_x86_disassemble
	   0000D10B R
 0000502A  51		      C         push    ecx
			      C 
			      C       ; We need:  es:[edi] - far ptr to disassembly cask
			      C       ;           fs:[ebx] - far ptr to simplified string
			      C       ;                eax - number of spaces in string to use for displaying instruction bytes
			      C       ;                ecx - maximum length of string
 0000502B  53		      C         push    ebx
 0000502C  B8 00000010	      C         mov     eax,16
 00005031  B9 00000037	      C         mov     ecx,55                                              ; Actually 59-4 (-4 for the "CFSCA" vertical frames)
 00005036  BB 00004F2F R      C         mov     ebx,offset cfsca_buffer2
 0000503B  26: FF 1D	      C         call    fword ptr es:_x86_simplify_disassembly
	   0000D10D R
 00005042  5B		      C         pop     ebx
			      C 
 00005043  66| 2E: 8E 1D      C         mov     ds,cs:data_segment
	   0000B77F R
 0000504B  9C		      C         pushfd
			      C         .IF (esi == dword ptr ss:[ebp+52])
 0000504C  3B 75 34	   *	    cmp    esi, dword ptr ss : [ebp + 034h]
 0000504F  75 47	   *	    jne    @C05BE
			      C           ; It is the current instruction, we have to display it in reverse color
 00005051  8B 4C 24 04	      C             mov     ecx,dword ptr ss:[esp+04]
 00005055  89 35 0000B770 R   C             mov     ds:instruction_offset,esi
 0000505B  89 0D 0000B774 R   C             mov     ds:instruction_length,ecx
			      C           ; Draw the text
 00005061  68 00000000	      C             push    dword ptr 0                                     ; Write mode (0-overlay)
 00005066  FF 72 04	      C             push    dword ptr ds:[edx+_ST_OBJECT_UL_HORIZONTAL]
 00005069  83 04 24 20	      C             add     dword ptr ss:[esp+00],8*4                       ; Move over for the "CFSCA" vertical frames
 0000506D  8B 0C 24	      C             mov     ecx,dword ptr ss:[esp+00]
 00005070  89 0D 0000B8A4 R   C             mov     ds:cursor_x,ecx
 00005076  FF 72 08	      C             push    dword ptr ds:[edx+_ST_OBJECT_UL_VERTICAL]
 00005079  01 1C 24	      C             add     dword ptr ss:[esp+00],ebx                       ; Move down to whatever line we're currently on
 0000507C  8B 0C 24	      C             mov     ecx,dword ptr ss:[esp+00]
 0000507F  89 0D 0000B8A8 R   C             mov     ds:cursor_y,ecx
 00005085  68 00000001	      C             push    dword ptr 1                                     ; Display mode (1-reverse)
 0000508A  68 00004F2F R      C             push    dword ptr offset cfsca_buffer2
 0000508F  FA		      C             cli
 00005090  FF 1D 0000D0E1 R   C             call    fword ptr ds:_VID_g_mono_display_text_mode
			      C         .ELSE
 00005096  EB 19	   *	    jmp    @C05C0
 00005098		   *@C05BE:
			      C           ; It's not the current instruction
 00005098  FF 72 04	      C             push    dword ptr ds:[edx+_ST_OBJECT_UL_HORIZONTAL]
 0000509B  83 04 24 20	      C             add     dword ptr ss:[esp+00],8*4                       ; Move over for the "CFSCA" vertical frames
 0000509F  FF 72 08	      C             push    dword ptr ds:[edx+_ST_OBJECT_UL_VERTICAL]
 000050A2  01 1C 24	      C             add     dword ptr ss:[esp+00],ebx                       ; Move down to whatever line we're currently on
 000050A5  68 00004F2F R      C             push    dword ptr offset cfsca_buffer2
 000050AA  FA		      C             cli
 000050AB  FF 1D 0000D0E3 R   C             call    fword ptr ds:_VID_g_mono_display_text
			      C         .ENDIF
 000050B1		   *@C05C0:
 000050B1  9D		      C         popfd
			      C 
			      C       ; Move to the next instruction
 000050B2  59		      C         pop     ecx
 000050B3  03 F1	      C         add     esi,ecx
			      C 
 000050B5  03 5D F8	      C     add     ebx,dword ptr ss:[ebp-08]
 000050B8  3B 5D F4	      C     cmp     ebx,dword ptr ss:[ebp-12]
 000050BB  0F 82 FFFFFF5A     C     jb      @B
			      C   ;-------
 000050C1  89 35 0000B948 R   C     mov     ds:single_step_end,esi
			      C 
 000050C7  61		      C     popad
 000050C8  9D		      C     popfd
 000050C9  0F A1	      C     pop     fs
 000050CB  07		      C     pop     es
 000050CC  1F		      C     pop     ds
 000050CD  C3		      C     ret
 000050CE		      C invDEBI_cfsca_window_common     ENDP
			      C 
			      C 
			      C 
			      C 
 000050CE		      C invDEBI_cfsca_2_click       PROC
			      C ; This routine is called when they click on the cfsca.2 casq
 000050CE  C3		      C     ret
 000050CF		      C invDEBI_cfsca_2_click       ENDP
			      C 
			      C 
			      C 
			      C 
 000050CF		      C invDEBI_cfsca_3_click       PROC
			      C ; This routine is called when they click on the cfsca.3 casq
 000050CF  C3		      C     ret
 000050D0		      C invDEBI_cfsca_3_click       ENDP
			      C 
			      C 
			      C 
			      C 
 000050D0		      C invDEBI_cfsca_4_click       PROC
			      C ; This routine is called when they click on the cfsca.4 casq
 000050D0  C3		      C     ret
 000050D1		      C invDEBI_cfsca_4_click       ENDP
			      C 


				    ; Algorithms still being worked on (or slated to be completed at some point in the future)
				    INCLUDE todo.asp
			      C ; todo.asp
			      C ;
			      C ; Low-Level Debi Debugger algorithms still left to complete
			      C ;
			      C ;
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
 000050D1		      C     null_function       PROC
			      C     ; This function doesn't do anything.  It is used where a function definition is required, but not necessary.
			      C     ;
			      C     ; Upon entry:   Doesn't matter
			      C     ;
			      C     ; Upon exit:    Returns everything exactly as it was prior to calling
			      C     ;
 000050D1  C3		      C         ret
 000050D2		      C     null_function       ENDP
			      C 
			      C 
			      C 
			      C 
 000050D2		      C     invDEBI_button      PROC
 000050D2  C3		      C         ret
 000050D3		      C     invDEBI_button      ENDP
			      C 
			      C 
			      C 
			      C 
 000050D3		      C     invDEBI_checkbox        PROC
 000050D3  C3		      C         ret
 000050D4		      C     invDEBI_checkbox        ENDP
			      C 
			      C 
			      C 
			      C 
 000050D4		      C     invDEBI_CFSCA_kbd_handler       PROC
 000050D4  C3		      C         ret
 000050D5		      C     invDEBI_CFSCA_kbd_handler       ENDP
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			      C ;
			      C ; Text displayed while hovering over an object
			      C ;
			      C ; ----
			      C ; Common to all of the below sub-routines.  This information is passed to each of them.
			      C ;
			      C ; Upon entry:   ds:[esi] - far ptr to screen object
			      C ;               ds:[edi] - far ptr to mouse object
			      C ;
			      C ; Upon exit:    Information about this opcode is displayed
			      C ;
			      C ;
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 000050D5		      C     invDEBI_descriptor_hover        PROC
 000050D5  E8 FFFFBF83	      C         call    invDEBI_quick_watch_add_divider
 000050DA  C3		      C         ret
 000050DB		      C     invDEBI_descriptor_hover        ENDP
			      C 
			      C 
			      C 
			      C 
 000050DB		      C     invDEBI_quick_watch_mem_32      PROC
 000050DB  E8 FFFFBF7D	      C         call    invDEBI_quick_watch_add_divider
 000050E0  C3		      C         ret
 000050E1		      C     invDEBI_quick_watch_mem_32      ENDP
			      C 
			      C 
			      C 
			      C 
 000050E1		      C     invDEBI_quick_watch_mem_8       PROC
 000050E1  E8 FFFFBF77	      C         call    invDEBI_quick_watch_add_divider
 000050E6  C3		      C         ret
 000050E7		      C     invDEBI_quick_watch_mem_8       ENDP
			      C 
			      C 
			      C 
			      C 
 000050E7		      C     invDEBI_quick_watch_show_EBP_relative_80        PROC
 000050E7  E8 FFFFBF71	      C         call    invDEBI_quick_watch_add_divider
 000050EC  C3		      C         ret
 000050ED		      C     invDEBI_quick_watch_show_EBP_relative_80        ENDP
			      C 
			      C 
			      C 
			      C 
 000050ED		      C     invDEBI_quick_watch_show_EBP_relative_eflags        PROC
 000050ED  E8 FFFFBF6B	      C         call    invDEBI_quick_watch_add_divider
 000050F2  C3		      C         ret
 000050F3		      C     invDEBI_quick_watch_show_EBP_relative_eflags        ENDP
			      C 
			      C 
			      C 
			      C 
 000050F3		      C     invDEBI_quick_watch_show_selector       PROC
 000050F3  E8 FFFFBF65	      C         call    invDEBI_quick_watch_add_divider
 000050F8  C3		      C         ret
 000050F9		      C     invDEBI_quick_watch_show_selector       ENDP
			      C 
			      C 
			      C 
			      C 
 000050F9		      C     invDEBI_quick_watch_mem_ascii_8     PROC
 000050F9  E8 FFFFBF5F	      C         call    invDEBI_quick_watch_add_divider
 000050FE  C3		      C         ret
 000050FF		      C     invDEBI_quick_watch_mem_ascii_8     ENDP
			      C 
			      C 
			      C 
			      C 
 000050FF		      C     invDEBI_quick_watch_show_EBP_relative_64        PROC
 000050FF  E8 FFFFBF59	      C         call    invDEBI_quick_watch_add_divider
 00005104  C3		      C         ret
 00005105		      C     invDEBI_quick_watch_show_EBP_relative_64        ENDP
			      C 
			      C 
			      C 
			      C 
 00005105		      C     invDEBI_quick_watch_show_32_selector_separated      PROC
 00005105  E8 FFFFBF53	      C         call    invDEBI_quick_watch_add_divider
 0000510A  C3		      C         ret
 0000510B		      C     invDEBI_quick_watch_show_32_selector_separated      ENDP
			      C 
			      C 
			      C 
			      C 
 0000510B		      C     invDEBI_object_close        PROC
			      C     ; This routine is calld when they want to remove an object from the screen
			      C     ;
			      C     ; Upon entry:   ds:[esi] - far ptr to screen table item
			      C     ;
			      C     ; Upon exit:    If the item is alterable, then it is closed
			      C     ;
			      C         .IF (byte ptr ds:[esi+_ST_OBJECT_ALTERABLE] == _YES)
 0000510B  80 3E 01	   *	    cmp    byte ptr ds : [esi + _ST_OBJECT_ALTERABLE], _YES
 0000510E  75 09	   *	    jne    @C05C1
 00005110  C6 46 01 00	      C             mov     byte ptr ds:[esi+_ST_OBJECT_ACTIVE],_NO
 00005114  E8 FFFFB3A6	      C             call    invDEBI_clear_screen_and_redraw_windows
			      C         .ENDIF
 00005119		   *@C05C1:
 00005119  C3		      C         ret
 0000511A		      C     invDEBI_object_close        ENDP
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			      C ;
			      C ; END - Text displayed while hovering over an object
			      C ;
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			      C ;
			      C ; SCREEN OBJECT handlers
			      C ;
			      C ; -----
			      C ; The following routines are all called with these parameters
			      C ; Upon entry:   The stack is arranged as below
			      C ;               ds:[esi] - ptr to screen table structure
			      C ;               ds:[edi] - ptr to this item's objects (which is the @FunctionHandlesIt macro)
			      C ;
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 0000511A		      C     invDEBI_pop_line_mem_window_float32         PROC
			      C     ; This routine is called to display a line of data in a FLOAT32 format
 0000511A  E8 FFFFE77D	      C         call    invDEBI_pop_line_show_displacement
 0000511F  C3		      C         ret
 00005120		      C     invDEBI_pop_line_mem_window_float32         ENDP
			      C 
			      C 
			      C 
			      C 
 00005120		      C     invDEBI_pop_line_mem_window_float64         PROC
			      C     ; This routine is called to display a line of data in a FLOAT64 format
 00005120  E8 FFFFE777	      C         call    invDEBI_pop_line_show_displacement
 00005125  C3		      C         ret
 00005126		      C     invDEBI_pop_line_mem_window_float64         ENDP
			      C 
			      C 
			      C 
			      C 
 00005126		      C     invDEBI_pop_line_mem_window_float80         PROC
			      C     ; This routine is called to display a line of data in a FLOAT80 format
 00005126  E8 FFFFE771	      C         call    invDEBI_pop_line_show_displacement
 0000512B  C3		      C         ret
 0000512C		      C     invDEBI_pop_line_mem_window_float80         ENDP
			      C 
			      C 
			      C 
			      C 
 0000512C		      C     invDEBI_quick_watch_window      PROC
			      C     ; This routine is called when updating the screen.  It is called from the @FunctionHandlesObject macro
			      C     ;
			      C     ; Upon entry:   ds:[esi] - far ptr to screen info
			      C     ;               ds:[edi] - far ptr to function handle
			      C     ;
			      C     ; Upon exit:    Nothing
			      C     ;
 0000512C  C3		      C         ret
 0000512D		      C     invDEBI_quick_watch_window      ENDP
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			      C ;
			      C ; END - SCREEN OBJECT handlers
			      C ;
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			      C ;
			      C ; CASK clicking
			      C ;
			      C ; -----
			      C ; The following routines are all called with these parameters
			      C ; Upon entry:   The stack is arranged as below
			      C ;               ds:[esi] - ptr to screen table structure
			      C ;               ds:[edi] - ptr to this item's objects
			      C ;
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 0000512D		      C     invDEBI_center_item_around_mouse    PROC
			      C     ; This routine is used to center the object around the current mouse coordinates
			      C     ;
			      C     ; Upon entry:   ds:[esi] - far ptr to screen object (_ST_xxx structure)
			      C     ;                    eax - width of item
			      C     ;                    edx - height of item
			      C     ;
			      C     ; Upon exit:    ds:[esi+_ST_OBJECT_UL_HORIZONTAL] - updated
			      C     ;               ds:[esi+_ST_OBJECT_UL_VERTICAL]   - updated
			      C     ;
 0000512D  50		      C         push    eax
 0000512E  51		      C         push    ecx
 0000512F  52		      C         push    edx
			      C 
			      C       ; Do X
 00005130  8B 0D 0000B7E5 R   C         mov     ecx,ds:mouse_current_x
 00005136  D1 E8	      C         shr     eax,1
 00005138  2B C8	      C         sub     ecx,eax
			      C         .IF (sign?)
 0000513A  79 02	   *	    jns    @C05C3
			      C           ; It's negative
 0000513C  33 C9	      C             xor     ecx,ecx
			      C         .ENDIF
 0000513E		   *@C05C3:
 0000513E  89 4E 04	      C         mov     dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL],ecx
			      C 
			      C       ; Do Y
 00005141  8B 0D 0000B7E9 R   C         mov     ecx,ds:mouse_current_y
 00005147  D1 EA	      C         shr     edx,1
 00005149  2B CA	      C         sub     ecx,edx
			      C         .IF (sign?)
 0000514B  79 02	   *	    jns    @C05C5
			      C           ; It's negative
 0000514D  33 C9	      C             xor     ecx,ecx
			      C         .ENDIF
 0000514F		   *@C05C5:
 0000514F  89 4E 08	      C         mov     dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL],ecx
			      C 
 00005152  5A		      C         pop     edx
 00005153  59		      C         pop     ecx
 00005154  58		      C         pop     eax
 00005155  C3		      C         ret
 00005156		      C     invDEBI_center_item_around_mouse    ENDP
			      C 
			      C 
			      C 
			      C 
 00005156		      C     invDEBI_address_expression      PROC
			      C     ; This routine is used to input an address expression for a mem.x window
			      C     ;
			      C     ; Upon entry:   ds:[esi] - far ptr to screen object
			      C     ;               ds:[edi] - far ptr to mouse object which called this function
			      C     ;
			      C     ; Upon exit:    This sets up the conditions whereby the address can be updated
			      C     ;
 00005156  60		      C         pushad
 00005157  06		      C         push    es
			      C       ; Save this information
 00005158  89 35 0000B900 R   C         mov     ds:exp_esi,esi
 0000515E  89 3D 0000B904 R   C         mov     ds:exp_edi,edi
			      C 
			      C       ; Setup the input field
 00005164  B8 000000D8	      C         mov     eax,_sDEBI_memory 
 00005169  8E C0	      C         mov     es,eax
			      C         .IF (dword ptr ds:[esi+_ST_MEMVAR_OFFSET] == -1)
 0000516B  83 7E 0C FF	   *	    cmp    dword ptr ds : [esi + _ST_MEMVAR_OFFSET], - 001h
 0000516F  75 32	   *	    jne    @C05C7
			      C           ; No memory has yet been defined for this item, so we set it up here (only done once per mem.x window)
 00005171  67& 26: 8B 1E      C             mov     ebx,es:[0]
	   0000
 00005177  89 5E 0C	      C             mov     dword ptr ds:[esi+_ST_MEMVAR_OFFSET],ebx
 0000517A  BF 0000AA8A R      C             mov     edi,offset DEBI_exp_memvar_list
 0000517F  33 C9	      C             xor     ecx,ecx
			      C           ; Right now,      ebx - offset in _sDEBI_memory where these memory variables will go
			      C           ;            ds:[edi] - far ptr to DEBI_exp_memvar_list (which tells us what variables get stored where)
			      C           ;            ds:[esi] - far ptr to the mem.x screen object which called this routine
			      C           ;                 ecx - used as a count below (to determine how much to add to ebx (for next offset))
			      C           ;              es:[0] - (ebx) current offset into _sDEBI_memory
			      C             .WHILE (dword ptr ds:[edi+_MEMVAR_MEMORY_VARIABLE] != -1)
 00005181  EB 15	   *	    jmp    @C05C9
 00005183		   *@C05CA:
 00005183  03 4F 04	      C                 add     ecx,dword ptr ds:[edi+_MEMVAR_LENGTH]
 00005186  8B C1	      C                 mov     eax,ecx
			      C               ; Initialize as we go
			      C                 .WHILE (eax > 0)
 00005188  EB 06	   *	    jmp    @C05CB
 0000518A		   *@C05CC:
 0000518A  26: C6 03 20	      C                     mov     byte ptr es:[ebx],32
 0000518E  43		      C                     inc     ebx
 0000518F  48		      C                     dec     eax
			      C                 .ENDW
 00005190		   *@C05CB:
 00005190  83 F8 00	   *	    cmp    eax, 000h
 00005193  77 F5	   *	    ja     @C05CC
 00005195  83 C7 08	      C                 add     edi,_MEMVAR_STRUCT_LENGTH
			      C             .ENDW
 00005198		   *@C05C9:
 00005198  83 3F FF	   *	    cmp    dword ptr ds : [edi + _MEMVAR_MEMORY_VARIABLE], - 001h
 0000519B  75 E6	   *	    jne    @C05CA
 0000519D  67& 26: 01 0E      C             add     dword ptr es:[0],ecx                            ; Increase offset for next window
	   0000
			      C         .ENDIF
 000051A3		   *@C05C7:
			      C 
			      C       ; Copy the string that's there to our temporary input variables
 000051A3  9C		      C         pushfd
 000051A4  8B 76 0C	      C         mov     esi,dword ptr ds:[esi+_ST_MEMVAR_OFFSET]
 000051A7  BB 0000AA8A R      C         mov     ebx,offset DEBI_exp_memvar_list
 000051AC  E8 FFFFF8DA	      C         call    invDEBI_from_object_memvar
			      C 
			      C       ; Save the current screen
 000051B1  FA		      C         cli
 000051B2  E8 FFFFC4D2	      C         call    invDEBI_hide_mouse_pointer
 000051B7  E8 FFFFC623	      C         call    invDEBI_turn_cursor_off
 000051BC  E8 FFFFC578	      C         call    invDEBI_save_screen2
			      C 
			      C       ; Display the window
 000051C1  BE 0000AA6A R      C         mov     esi,offset exp_screen_object
 000051C6  89 35 0000B79C R   C         mov     ds:screen_object,esi
 000051CC  BF 0000AFEF R      C         mov     edi,offset exp_screen_screen_objects
 000051D1  B8 00000140	      C         mov     eax,_EXP_SCREEN_WIDTH * FONT_X
 000051D6  BA 000000A2	      C         mov     edx,_EXP_SCREEN_HEIGHT * FONT_Y
 000051DB  E8 FFFFFF4D	      C         call    invDEBI_center_item_around_mouse
 000051E0  E8 FFFFB356	      C         call    invDEBI_draw_objects                                ; Draw the window
			      C 
			      C       ; Setup the input
 000051E5  C7 05 0000B78C R   C         mov     ds:kbd_object,offset exp_screen_keyboard_top_object
	   0000AFF6 R
 000051EF  C7 05 0000B798 R   C         mov     ds:mouse_objects,offset exp_screen_mouse_objects
	   0000B1EF R
 000051F9  C7 05 0000B788 R   C         mov     ds:object_mode,1                                    ; Indicate we're no longer processing defaults
	   00000001
 00005203  E8 FFFFF4F5	      C         call    invDEBI_setFocus
 00005208  E8 FFFFEFE5	      C         call    invDEBI_screen_refresh
 0000520D  9D		      C         popfd
			      C 
 0000520E  07		      C         pop     es
 0000520F  61		      C         popad
 00005210  C3		      C         ret
 00005211		      C     invDEBI_address_expression      ENDP
			      C 
			      C 
			      C 
			      C 
 00005211		      C     invDEBI_store_hex_address_in_eax        PROC
			      C     ; This routine is used to store the hexidecimal address stored in eax into the current string
			      C     ;
			      C     ; Upon entry:       eax - 32-bit address
			      C     ;              ds:[esi] - where the address will be stored
			      C     ;
			      C     ; Upon exit:    Address is stored like "0x12345678"
			      C     ;
 00005211  51		      C         push    ecx
 00005212  52		      C         push    edx
			      C 
 00005213  66| C7 06 7830     C         mov     word ptr ds:[esi],'x0'
 00005218  83 C6 02	      C         add     esi,2
 0000521B  B9 00000008	      C         mov     ecx,8
 00005220		      C       @@:
 00005220  C1 C0 04	      C         rol     eax,4
 00005223  8A D0	      C         mov     dl,al
 00005225  80 E2 0F	      C         and     dl,0fh
			      C         .IF (dl <= 9)
 00005228  80 FA 09	   *	    cmp    dl, 009h
 0000522B  77 05	   *	    ja     @C05CF
 0000522D  80 C2 30	      C             add     dl,'0'
			      C         .ELSE
 00005230  EB 03	   *	    jmp    @C05D1
 00005232		   *@C05CF:
 00005232  80 C2 57	      C             add     dl,'a'-10
			      C         .ENDIF
 00005235		   *@C05D1:
 00005235  88 16	      C         mov     byte ptr ds:[esi],dl
 00005237  46		      C         inc     esi
 00005238  E2 E6	      C         loop    @B
			      C 
 0000523A  5A		      C         pop     edx
 0000523B  59		      C         pop     ecx
 0000523C  C3		      C         ret
 0000523D		      C     invDEBI_store_hex_address_in_eax        ENDP
			      C 
			      C 
			      C 
			      C 
 0000523D		      C     invDEBI_store_bytes_in_eax      PROC
			      C     ; This routine is used to store bytes from eax into the current string
			      C     ;
			      C     ; Upon entry:       eax - contains something like "  ds"
			      C     ;              ds:[esi] - where "ds" will be stored
			      C     ;
			      C     ; Upon exit:    Any characters after the first non-space are stored
			      C     ;
 0000523D  51		      C         push    ecx
 0000523E  53		      C         push    ebx
			      C 
 0000523F  B9 00000004	      C         mov     ecx,4
 00005244  33 DB	      C         xor     ebx,ebx
 00005246		      C       @@:
 00005246  C1 C0 08	      C         rol     eax,8
			      C         .IF (al != 32 || ebx != 0)
 00005249  3C 20	   *	    cmp    al, 020h
 0000524B  75 04	   *	    jne    @C05D3
 0000524D  0B DB	   *	    or	ebx, ebx
 0000524F  74 08	   *	    je     @C05D2
 00005251		   *@C05D3:
 00005251  BB 00000001	      C             mov     ebx,1
 00005256  88 06	      C             mov     byte ptr ds:[esi],al
 00005258  46		      C             inc     esi
			      C         .ENDIF
 00005259		   *@C05D2:
 00005259  E2 EB	      C         loop    @B
			      C 
 0000525B  5B		      C         pop     ebx
 0000525C  59		      C         pop     ecx
 0000525D  C3		      C         ret
 0000525E		      C     invDEBI_store_bytes_in_eax      ENDP
			      C 
			      C 
			      C 
			      C 
 0000525E		      C     invDEBI_quick_watch_click       PROC
			      C ;    ; This routine forces a redraw of the t_and_s_logo image
			      C ;        mov     ds:t_and_s_displayed,0
			      C ;        call    invDEBI_quick_watch_window
 0000525E  C3		      C         ret
 0000525F		      C     invDEBI_quick_watch_click       ENDP
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			      C ;
			      C ; END - CASK clicking
			      C ;
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			      C ;
			      C ; EDITING
			      C ;
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 0000525F		      C     invDEBI_edit_variable       PROC
 0000525F  C3		      C         ret
 00005260		      C     invDEBI_edit_variable       ENDP
			      C 
			      C 
			      C 
 00005260		      C     invDEBI_kbd_handler     PROC
			      C     ; This is the default keyboard handler for DEBI
			      C     ;
			      C     ; Upon entry:   eax - key pressed
			      C     ;               ebx - keyboard flags
			      C     ;
			      C     ; Upon exit:    Internal flags are raised, or the key is ignored if not recognized
			      C     ;
			      C         .IF (ax == F5)
 00005260  66| 3D 3F00	   *	    cmp    ax, f5
 00005264  75 0C	   *	    jne    @C05D5
			      C           ; F5 (go)
 00005266  C6 05 0000B787 R   C             mov     ds:debi_ok_to_quit,2
	   02
			      C         .ELSEIF (ax == F8)
 0000526D  E9 0000011E	   *	    jmp    @C05D7
 00005272		   *@C05D5:
 00005272  66| 3D 4200	   *	    cmp    ax, f8
 00005276  75 0C	   *	    jne    @C05D8
			      C           ; F8 (single step)
 00005278		      C           single_step:
 00005278  C6 05 0000B787 R   C             mov     ds:debi_ok_to_quit,1
	   01
			      C         .ELSEIF (ax == F10)
 0000527F  E9 0000010C	   *	    jmp    @C05DA
 00005284		   *@C05D8:
 00005284  66| 3D 4400	   *	    cmp    ax, f10
 00005288  0F 85 00000102  *	    jne    @C05DB
			      C           ; F10 (step over)
 0000528E		      C           try_again:
 0000528E  8B 1D 0000B770 R   C             mov     ebx,ds:instruction_offset
 00005294  1E		      C             push    ds
 00005295  8E 5D 38	      C             mov     ds,dword ptr ss:[ebp+56]
 00005298  66| 8B 03	      C             mov     ax,word ptr ds:[ebx]
 0000529B  66| 8B D0	      C             mov     dx,ax
 0000529E  C0 EC 03	      C             shr     ah,3
 000052A1  80 E4 07	      C             and     ah,111b
 000052A4  1F		      C             pop     ds
			      C             .IF (al != 09ah && al != 0e8h && al != 0cch && al != 0cdh && al != 0ceh && !(al == 0ffh && (ah == 010b || ah == 011b)))
 000052A5  3C 9A	   *	    cmp    al, 09Ah
 000052A7  74 7B	   *	    je     @C05DD
 000052A9  3C E8	   *	    cmp    al, 0E8h
 000052AB  74 77	   *	    je     @C05DD
 000052AD  3C CC	   *	    cmp    al, 0CCh
 000052AF  74 73	   *	    je     @C05DD
 000052B1  3C CD	   *	    cmp    al, 0CDh
 000052B3  74 6F	   *	    je     @C05DD
 000052B5  3C CE	   *	    cmp    al, 0CEh
 000052B7  74 6B	   *	    je     @C05DD
 000052B9  3C FF	   *	    cmp    al, 0FFh
 000052BB  75 0A	   *	    jne    @C05DE
 000052BD  80 FC 02	   *	    cmp    ah, 002h
 000052C0  74 62	   *	    je     @C05DD
 000052C2  80 FC 03	   *	    cmp    ah, 003h
 000052C5  74 5D	   *	    je     @C05DD
 000052C7		   *@C05DE:
			      C               ; This instruction is not a CALL/INT3/INTO/INT x instruction, so we just single-step because it
			      C               ; will have the same effect
			      C               ; But, check certain conditions
			      C                 .IF (al == 0f2h || al == 0f3h)
 000052C7  3C F2	   *	    cmp    al, 0F2h
 000052C9  74 04	   *	    je     @C05E7
 000052CB  3C F3	   *	    cmp    al, 0F3h
 000052CD  75 19	   *	    jne    @C05E6
 000052CF		   *@C05E7:
			      C                   ; it's a REP prefix
			      C                     .IF (dh >= 0a4h && dh <= 0afh && dh != 0a8h && dh != 0a9h)
 000052CF  80 FE A4	   *	    cmp    dh, 0A4h
 000052D2  72 49	   *	    jb     @C05E9
 000052D4  80 FE AF	   *	    cmp    dh, 0AFh
 000052D7  77 44	   *	    ja     @C05E9
 000052D9  80 FE A8	   *	    cmp    dh, 0A8h
 000052DC  74 3F	   *	    je     @C05E9
 000052DE  80 FE A9	   *	    cmp    dh, 0A9h
 000052E1  74 3A	   *	    je     @C05E9
			      C                       ; It's part of a proper REP XXX instruction combination
 000052E3  43		      C                         inc     ebx
 000052E4  EB 3E	      C                         jmp     @F
			      C                     .ENDIF
			      C                 .ELSEIF (al == 0f0h || al == 26h || al == 2eh || al == 36h || al == 3eh || al == 64h || al == 65h || al == 66h || al == 67h)
 000052E6  EB 35	   *	    jmp    @C05EE
 000052E8		   *@C05E6:
 000052E8  3C F0	   *	    cmp    al, 0F0h
 000052EA  74 20	   *	    je     @C05F0
 000052EC  3C 26	   *	    cmp    al, 026h
 000052EE  74 1C	   *	    je     @C05F0
 000052F0  3C 2E	   *	    cmp    al, 02Eh
 000052F2  74 18	   *	    je     @C05F0
 000052F4  3C 36	   *	    cmp    al, 036h
 000052F6  74 14	   *	    je     @C05F0
 000052F8  3C 3E	   *	    cmp    al, 03Eh
 000052FA  74 10	   *	    je     @C05F0
 000052FC  3C 64	   *	    cmp    al, 064h
 000052FE  74 0C	   *	    je     @C05F0
 00005300  3C 65	   *	    cmp    al, 065h
 00005302  74 08	   *	    je     @C05F0
 00005304  3C 66	   *	    cmp    al, 066h
 00005306  74 04	   *	    je     @C05F0
 00005308  3C 67	   *	    cmp    al, 067h
 0000530A  75 11	   *	    jne    @C05EF
 0000530C		   *@C05F0:
			      C                   ; it's an LOCK(0f0h) or override prefix
 0000530C  FF 05 0000B770 R   C                     inc     ds:instruction_offset
 00005312  FF 0D 0000B774 R   C                     dec     ds:instruction_length
 00005318  E9 FFFFFF71	      C                     jmp     try_again
			      C                 .ENDIF
 0000531D		   *@C05EF:
 0000531D		   *@C05EE:
 0000531D		   *@C05E9:
 0000531D  E9 FFFFFF56	      C                 jmp     single_step
			      C             .ELSE
 00005322  EB 6C	   *	    jmp    @C05F9
 00005324		   *@C05DD:
			      C               ; Right now, ebx is the offset of the next instruction
 00005324		      C               @@:
 00005324  03 1D 0000B774 R   C                 add     ebx,ds:instruction_length
 0000532A  89 1D 0000B779 R   C                 mov     ds:step_offset,ebx
			      C               ; Get the base/limit for this code segment
 00005330  B8 67657420	      C                 mov     eax,'get '
 00005335  BB 67647463	      C                 mov     ebx,'gdtc'
 0000533A  8B 55 38	      C                 mov     edx,dword ptr ss:[ebp+56]
 0000533D  C1 EA 03	      C                 shr     edx,3
 00005340  2E: FF 1D	      C                 call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
			      C                 .IF (!carry?)
 00005347  72 47	   *	    jb     @C05FA
			      C                   ; Set a data segment that's the same base/limit as the code segment
 00005349  8B F3	      C                     mov     esi,ebx
 0000534B  8B FA	      C                     mov     edi,edx
 0000534D  B8 73657420	      C                     mov     eax,'set '
 00005352  BB 67647464	      C                     mov     ebx,'gdtd'
 00005357  BA 0000001F	      C                     mov     edx,_sDEBI_temp / 8
 0000535C  2E: FF 1D	      C                     call    fword ptr cs:_EXODUS_requestor
	   0000D0D7 R
			      C                     .IF (!carry?)
 00005363  72 2B	   *	    jb     @C05FC
			      C                       ; Right now, _sDEBI_temp is a data segment to the code segment that's being debugged
 00005365  8B 1D 0000B779 R   C                         mov     ebx,ds:step_offset
 0000536B  0F A0	      C                         push    fs
 0000536D  B8 000000F8	      C                         mov     eax,_sDEBI_temp
 00005372  8E E0	      C                         mov     fs,eax
 00005374  64: 8A 03	      C                         mov     al,byte ptr fs:[ebx]
 00005377  64: C6 03 CC	      C                         mov     byte ptr fs:[ebx],0cch
 0000537B  A2 0000B77D R      C                         mov     ds:step_replaced_byte,al
 00005380  0F A1	      C                         pop     fs
 00005382  C6 05 0000B778 R   C                         mov     ds:step_over,1
	   01
 00005389  C6 05 0000B787 R   C                         mov     ds:debi_ok_to_quit,3
	   03
			      C                     .ENDIF
			      C                 .ENDIF
 00005390		   *@C05FC:
			      C             .ENDIF
 00005390		   *@C05FA:
			      C         .ENDIF
 00005390		   *@C05F9:
 00005390		   *@C05DB:
 00005390		   *@C05DA:
 00005390		   *@C05D7:
 00005390  C3		      C         ret
 00005391		      C     invDEBI_kbd_handler     ENDP
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			      C ;
			      C ; END - EDITING
			      C ;
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			      C 
			      C 
			      C ;break_here  proc
			      C ;    push    ds
			      C ;    mov     ds,cs:data_segment
			      C ;    mov     ds:object_mode,0
			      C ;    mov     ds:kbd_focus,-1
			      C ;    pop     ds
			      C ;    int 3
			      C ;    ret
			      C ;break_here  endp
			      C 


				    ; iDEBI_open_file()
				    ; iDEBI_close_file()
				    ; iDEBI_read_file()
				    ; iDEBI_write_file()
				    ; iDEBI_search_file()
				    INCLUDE disk.asp
			      C ; disk.asp
			      C ;
			      C ; Low-Level Debi Debugger disk-related algorithms
			      C ;
			      C ;
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			      C ;
			      C ; Low-level disk access routines via DT/NP/RP
			      C ;
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 00005391		      C     iDEBI_open_file         PROC
			      C     ; This routine opens a file by name.
			      C     ;
			      C     ; Upon entry:   ds:[esi] - far ptr to filename
			      C     ;                    ecx - length
			      C     ;
			      C     ; Upon exit:    carry? - CLEAR if opened, SET if error
			      C     ;                  ebx - HANDLE if opened
 00005391  C3		      C         ret
 00005392		      C     iDEBI_open_file         ENDP
			      C 
			      C 
			      C 
			      C 
 00005392		      C     iDEBI_close_file        PROC
			      C     ; This routine closes a file handle.
			      C     ;
			      C     ; Upon entry:   ebx - handle
			      C     ;               ecx - bytes to read
			      C     ;               edx - starting offset in file
			      C     ;          es:[edi] - far ptr to store read data
			      C     ;
			      C     ; Upon exit:    carry? - CLEAR if read ok, SET if error
			      C     ;
 00005392		      C     iDEBI_close_file        ENDP
			      C 
			      C 
			      C 
			      C 
 00005392		      C     iDEBI_read_file         PROC
			      C     ; This routine reads the contents of a file from disk.
			      C     ;
			      C     ; Upon entry:   ebx - handle
			      C     ;               ecx - bytes to read
			      C     ;               edx - starting offset in file
			      C     ;          es:[edi] - far ptr to store read data
			      C     ;
			      C     ; Upon exit:    carry? - CLEAR if read ok, SET if error
			      C     ;
 00005392		      C     iDEBI_read_file         ENDP
			      C 
			      C 
			      C 
			      C 
 00005392		      C     iDEBI_write_file        PROC
			      C     ; This routine writes the contents of a file to disk.
			      C     ;
			      C     ; Upon entry:   ebx - handle
			      C     ;               ecx - bytes to write
			      C     ;               edx - starting offset in file
			      C     ;          ds:[esi] - far ptr to write data from
			      C     ;
			      C     ; Upon exit:    carry? - CLEAR if read ok, SET if error
			      C     ;
 00005392		      C     iDEBI_write_file        ENDP
			      C 
			      C 
			      C 
			      C 
 00005392		      C     invDEBI_search_file         PROC
			      C     ; This routine finds a file.  It searches the the DT/NP/RP for a match.
			      C     ;
			      C     ; Upon entry:   ds:[esi] - far ptr to filename to find
			      C     ;                    ecx - length
			      C     ;
			      C     ; Upon exit:    carry? - CLEAR if found, SET if error
			      C     ;
 00005392  C3		      C         ret
 00005393		      C     invDEBI_search_file         ENDP
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			      C ;
			      C ; Low-level disk access routines via DT/NP/RP
			      C ;
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C 
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			      C ;
			      C ; Internal disk access routines via TRACK/SECTOR/HEAD
			      C ;
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 00005393		      C     invDEBI_read_sector     PROC
			      C     ; This routine physically reads the contents of a sector
			      C     ;
			      C     ; Upon entry:   es:[edi] - where to store read data
			      C     ;                     cl - track
			      C     ;                     bl - sector
			      C     ;                     al - head
			      C     ;
			      C     ; Upon exit:    carry? - CLEAR if read ok, SET if error
			      C     ;
 00005393  C3		      C         ret
 00005394		      C     invDEBI_read_sector     ENDP
			      C 
			      C 
			      C 
			      C 
 00005394		      C     invDEBI_write_sector        PROC
			      C     ; This routine physically writes 512 bytes to the contents of a sector
			      C     ;
			      C     ; Upon entry:   ds:[esi] - where to write data from
			      C     ;                     cl - track
			      C     ;                     bl - sector
			      C     ;                     al - head
			      C     ;
			      C     ; Upon exit:    carry? - CLEAR if written ok, SET if error
			      C     ;
 00005394  C3		      C         ret
 00005395		      C     invDEBI_write_sector        ENDP
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			      C ;
			      C ; Internal disk access routines via TRACK/SECTOR/HEAD
			      C ;
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
			      C 
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; END - AAAAA - INCLUDE files
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=










				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; BBBBB - Interrupt handlers
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 00005395			    invDEBI_int0_handler    PROC
 00005395  6A 00		        push    0                                                   ; Fake out because this one doesn't have an error code
 00005397  50			        push    eax
 00005398  B0 20		        mov     al,20h
 0000539A  E6 20		        out     20h,al
 0000539C  B8 0000B4DF R	        mov     eax,offset int0_text
 000053A1  E9 FFFFAF08		        jmp     DEBI_debug

				    ; * Note: Each of these handlers never return from these procedure.  They call DEBI which will then execute the
				    ;         appropriate action
 000053A6			    invDEBI_int0_handler    ENDP




 000053A6			    invDEBI_int1_handler    PROC
 000053A6  6A 00		        push    0                                                   ; Fake out because this one doesn't have an error code
 000053A8  50			        push    eax
 000053A9  B0 20		        mov     al,20h
 000053AB  E6 20		        out     20h,al
 000053AD  B8 0000B4F2 R	        mov     eax,offset int1_text
 000053B2  E9 FFFFAEF7		        jmp     DEBI_debug
 000053B7			    invDEBI_int1_handler    ENDP




 000053B7			    invDEBI_int2_handler    PROC
 000053B7  6A 00		        push    0                                                   ; Fake out because this one doesn't have an error code
 000053B9  50			        push    eax
 000053BA  B0 20		        mov     al,20h
 000053BC  E6 20		        out     20h,al
 000053BE  B8 0000B504 R	        mov     eax,offset int2_text
 000053C3  E9 FFFFAEE6		        jmp     DEBI_debug
 000053C8			    invDEBI_int2_handler    ENDP




 000053C8			    invDEBI_int3_handler    PROC
 000053C8  6A 00		        push    0                                                   ; Fake out because this one doesn't have an error code
 000053CA  50			        push    eax
 000053CB  B0 20		        mov     al,20h
 000053CD  E6 20		        out     20h,al
 000053CF  B8 0000B519 R	        mov     eax,offset int3_text
 000053D4  E9 FFFFAED5		        jmp     DEBI_debug
 000053D9			    invDEBI_int3_handler    ENDP




 000053D9			    invDEBI_int4_handler    PROC
 000053D9  6A 00		        push    0                                                   ; Fake out because this one doesn't have an error code
 000053DB  50			        push    eax
 000053DC  B0 20		        mov     al,20h
 000053DE  E6 20		        out     20h,al
 000053E0  B8 0000B52A R	        mov     eax,offset int4_text
 000053E5  E9 FFFFAEC4		        jmp     DEBI_debug
 000053EA			    invDEBI_int4_handler    ENDP




 000053EA			    invDEBI_int5_handler    PROC
 000053EA  6A 00		        push    0                                                   ; Fake out because this one doesn't have an error code
 000053EC  50			        push    eax
 000053ED  B0 20		        mov     al,20h
 000053EF  E6 20		        out     20h,al
 000053F1  B8 0000B539 R	        mov     eax,offset int5_text
 000053F6  E9 FFFFAEB3		        jmp     DEBI_debug
 000053FB			    invDEBI_int5_handler    ENDP




 000053FB			    invDEBI_int6_handler    PROC
 000053FB  6A 00		        push    0                                                   ; Fake out because this one doesn't have an error code
 000053FD  50			        push    eax
 000053FE  B0 20		        mov     al,20h
 00005400  E6 20		        out     20h,al
 00005402  B8 0000B554 R	        mov     eax,offset int6_text
 00005407  E9 FFFFAEA2		        jmp     DEBI_debug
 0000540C			    invDEBI_int6_handler    ENDP




 0000540C			    invDEBI_int7_handler    PROC
				    ; This interrupt should only be called when the user is single-stepping through their code and they go from one task
				    ; to another.  Under those circumstances the operating system hasn't yet had a chance to save the contents from what
				    ; it thinks is the previous task.  Little does it know that this really is the same task. :)
				    ; Still, rather than presenting this as an error we just clear the task-switched flag in CR0 and continue processing.
				    ; This could result in errant data, but since they're stepping through with their debugger they'll know this.
 0000540C  0F 06		        clts
				;        push    0
				;        push    eax
 0000540E  50			        push    eax
 0000540F  B0 20		        mov     al,20h
 00005411  E6 20		        out     20h,al
 00005413  58			        pop     eax
				;        mov     eax,offset int7_text
				;        jmp     DEBI_debug
 00005414  CF			        iretd
 00005415			    invDEBI_int7_handler    ENDP




 00005415			    invDEBI_int8_handler    PROC
 00005415  50			        push    eax
 00005416  B0 20		        mov     al,20h
 00005418  E6 20		        out     20h,al
 0000541A  B8 0000B584 R	        mov     eax,offset int8_text
 0000541F  E9 FFFFAE8A		        jmp     DEBI_debug
 00005424			    invDEBI_int8_handler    ENDP




 00005424			    invDEBI_int9_handler    PROC
 00005424  6A 00		        push    0                                                   ; Fake out because this one doesn't have an error code
 00005426  50			        push    eax
 00005427  B0 20		        mov     al,20h
 00005429  E6 20		        out     20h,al
 0000542B  B8 0000B597 R	        mov     eax,offset int9_text
 00005430  E9 FFFFAE79		        jmp     DEBI_debug
 00005435			    invDEBI_int9_handler    ENDP




 00005435			    invDEBI_int10_handler   PROC
 00005435  50			        push    eax
 00005436  B0 20		        mov     al,20h
 00005438  E6 20		        out     20h,al
 0000543A  B8 0000B5B9 R	        mov     eax,offset int10_text
 0000543F  E9 FFFFAE6A		        jmp     DEBI_debug
 00005444			    invDEBI_int10_handler   ENDP




 00005444			    invDEBI_int11_handler   PROC
 00005444  50			        push    eax
 00005445  B0 20		        mov     al,20h
 00005447  E6 20		        out     20h,al
 00005449  B8 0000B5CB R	        mov     eax,offset int11_text
 0000544E  E9 FFFFAE5B		        jmp     DEBI_debug
 00005453			    invDEBI_int11_handler   ENDP




 00005453			    invDEBI_int12_handler   PROC
 00005453  50			        push    eax
 00005454  B0 20		        mov     al,20h
 00005456  E6 20		        out     20h,al
 00005458  B8 0000B5E5 R	        mov     eax,offset int12_text
 0000545D  E9 FFFFAE4C		        jmp     DEBI_debug
 00005462			    invDEBI_int12_handler   ENDP




 00005462			    invDEBI_int13_handler   PROC
 00005462  50			        push    eax
 00005463  B0 20		        mov     al,20h
 00005465  E6 20		        out     20h,al
 00005467  B8 0000B5F7 R	        mov     eax,offset int13_text
 0000546C  E9 FFFFAE3D		        jmp     DEBI_debug
 00005471			    invDEBI_int13_handler   ENDP




 00005471			    invDEBI_int14_handler   PROC
 00005471  50			        push    eax
 00005472  B0 20		        mov     al,20h
 00005474  E6 20		        out     20h,al
 00005476  B8 0000B616 R	        mov     eax,offset int14_text
 0000547B  E9 FFFFAE2E		        jmp     DEBI_debug
 00005480			    invDEBI_int14_handler   ENDP




 00005480			    invDEBI_int15_handler   PROC
 00005480  6A 00		        push    0                                                   ; Fake out because this one doesn't have an error code
 00005482  50			        push    eax
 00005483  B0 20		        mov     al,20h
 00005485  E6 20		        out     20h,al
 00005487  B8 0000B627 R	        mov     eax,offset int15_text
 0000548C  E9 FFFFAE1D		        jmp     DEBI_debug
 00005491			    invDEBI_int15_handler   ENDP




 00005491			    invDEBI_int16_handler   PROC
 00005491  6A 00		        push    0                                                   ; Fake out because this one doesn't have an error code
 00005493  50			        push    eax
 00005494  B0 20		        mov     al,20h
 00005496  E6 20		        out     20h,al
 00005498  B8 0000B63C R	        mov     eax,offset int16_text
 0000549D  E9 FFFFAE0C		        jmp     DEBI_debug
 000054A2			    invDEBI_int16_handler   ENDP




 000054A2			    invDEBI_int17_handler   PROC
 000054A2  50			        push    eax
 000054A3  B0 20		        mov     al,20h
 000054A5  E6 20		        out     20h,al
 000054A7  B8 0000B651 R	        mov     eax,offset int17_text
 000054AC  E9 FFFFADFD		        jmp     DEBI_debug
 000054B1			    invDEBI_int17_handler   ENDP




 000054B1			    invDEBI_int18_handler   PROC
 000054B1  6A 00		        push    0                                                   ; Fake out because this one doesn't have an error code
 000054B3  50			        push    eax
 000054B4  B0 20		        mov     al,20h
 000054B6  E6 20		        out     20h,al
 000054B8  B8 0000B667 R	        mov     eax,offset int18_text
 000054BD  E9 FFFFADEC		        jmp     DEBI_debug
 000054C2			    invDEBI_int18_handler   ENDP
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
				;
				; END - BBBBB - Interrupt handlers
				;
				;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









				    INCLUDE debidata.asp
			      C ; debidata.asp
			      C ;
			      C ; Data used by DEBI
			      C ;
			      C 
			      C 
			      C ;;============================
			      C ;; This is the screen that is the main Debi debugging screen
			      C ;
			      C ;   x,y
			      C ;  ⁄ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒø    The DEBI_screen_table relates its structure to this logical arrangement of the screen.
			      C ;  ≥0,0≥1,0≥2,0≥3,0≥4,0≥5,0≥    Each square represents a starting point for something to be displayed.  Internal logic
			      C ;  √ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ¥    during this setup ensures that things only fit where they're supposed to.
			      C ;  ≥0,1≥1,1≥2,1≥3,1≥4,1≥5,1≥
			      C ;  √ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ¥    The letter identifies which part of the screen it is (as identified by its label)
			      C ;  ≥0,2≥1,2≥2,2≥3,2≥4,2≥5,2≥
			      C ;  √ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ¥    Each cell is x=15
			      C ;  ≥0,3≥1,3≥2,3≥3,3≥4,3≥5,3≥                 y=9
			      C ;  √ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ¥
			      C ;  ≥0,4≥1,4≥2,4≥3,4≥4,4≥5,4≥
			      C ;  √ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ≈ƒƒƒ¥
			      C ;  ≥0,5≥1,5≥2,5≥3,5≥4,5≥5,5≥
			      C ;  ¿ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒ¡ƒƒƒŸ
			      C ;
			      C 
			      C 
			      C 
			      C 
			      C ; Upon entry into this algorithm no memory locations have been specified.  They will be updated during the first screen
			      C ; updating algorithm or possibly when DEBI is exited (saving the current state prior to continuing).
			      C ; Each of these items is 16-bytes in length.  One paragraph.  One happy paragraph. :)
 000054C2		      C DEBI_screen_table:
			      C ; CFSCA.2
 000054C2  01		      C                             db  _YES                                ; +00 Alterable?
 000054C3  01		      C                             db  _YES                                ; +01 Active?
 000054C4  0000		      C                             dw  0                                   ; +02 +--Nuserved
 000054C6  00000000	      C                             dd  0                                   ; +04 +_ST_OBJECT_UL_HORIZONTAL
 000054CA  00000000	      C                             dd  0                                   ; +08 +_ST_OBJECT_UL_VERTICAL
 000054CE  FFFFFFFF	      C                             dd  0ffffffffh                          ; +12 +_ST_MEMVAR_OFFSET
 000054D2  00006553 R	      C                             dd  offset DEBI_c_keyboard_objects      ; +16 +_ST_OBJECT_KBD_OFFSET
 000054D6  FFFFFFFF	      C                             dd  0ffffffffh                          ; +20 +_ST_OBJECT_MEMORY_OFFSET
 000054DA  0000656A R	      C                             dd  offset DEBI_c_mouse_objects         ; +24 +_ST_OBJECT_MOUSE_OFFSET
 000054DE  0000655D R	      C                             dd  offset DEBI_c_screen_objects        ; +28 +_ST_OBJECT_SCREEN_OFFSET
			      C ; regs.1
 000054E2  01		      C                             db  _YES                                ; +00 Alterable?
 000054E3  01		      C                             db  _YES                                ; +01 Active?
 000054E4  0000		      C                             dw  0                                   ; +02 +--Nuserved
 000054E6  00000258	      C                             dd  5*(15*8)                            ; +04 +_ST_OBJECT_UL_HORIZONTAL
 000054EA  00000000	      C                             dd  0                                   ; +08 +_ST_OBJECT_UL_VERTICAL
 000054EE  FFFFFFFF	      C                             dd  0ffffffffh                          ; +12 +_ST_MEMVAR_OFFSET
 000054F2  000056A2 R	      C                             dd  offset DEBI_keyboard_objects        ; +16 +_ST_OBJECT_KBD_OFFSET
 000054F6  FFFFFFFF	      C                             dd  0ffffffffh                          ; +20 +_ST_OBJECT_MEMORY_OFFSET
 000054FA  000095E6 R	      C                             dd  offset DEBI_p_mouse_objects         ; +24 +_ST_OBJECT_MOUSE_OFFSET
 000054FE  000093EA R	      C                             dd  offset DEBI_p_screen_objects        ; +28 +_ST_OBJECT_SCREEN_OFFSET
			      C ; fpu.2
 00005502  01		      C                             db  _YES                                ; +00 Alterable?
 00005503  01		      C                             db  _YES                                ; +01 Active?
 00005504  0000		      C                             dw  0                                   ; +02 +--Nuserved
 00005506  000001E0	      C                             dd  4*(15*8)                            ; +04 +_ST_OBJECT_UL_HORIZONTAL
 0000550A  000000B4	      C                             dd  30*6                                ; +08 +_ST_OBJECT_UL_VERTICAL
 0000550E  FFFFFFFF	      C                             dd  0ffffffffh                          ; +12 +_ST_MEMVAR_OFFSET
 00005512  000056A2 R	      C                             dd  offset DEBI_keyboard_objects        ; +16 +_ST_OBJECT_KBD_OFFSET
 00005516  FFFFFFFF	      C                             dd  0ffffffffh                          ; +20 +_ST_OBJECT_MEMORY_OFFSET
 0000551A  00009DC1 R	      C                             dd  offset DEBI_r_mouse_objects         ; +24 +_ST_OBJECT_MOUSE_OFFSET
 0000551E  00009CF9 R	      C                             dd  offset DEBI_r_screen_objects        ; +28 +_ST_OBJECT_SCREEN_OFFSET
			      C ; locals
 00005522  01		      C                             db  _YES                                ; +00 Alterable?
 00005523  01		      C                             db  _YES                                ; +01 Active?
 00005524  0000		      C                             dw  0                                   ; +02 +--Nuserved
 00005526  000001E0	      C                             dd  4*(15*8)                            ; +04 +_ST_OBJECT_UL_HORIZONTAL
 0000552A  00000000	      C                             dd  0*(13*6)                            ; +08 +_ST_OBJECT_UL_VERTICAL
 0000552E  FFFFFFFF	      C                             dd  0ffffffffh                          ; +12 +_ST_MEMVAR_OFFSET
 00005532  000056A2 R	      C                             dd  offset DEBI_keyboard_objects        ; +16 +_ST_OBJECT_KBD_OFFSET
 00005536  FFFFFFFF	      C                             dd  0ffffffffh                          ; +20 +_ST_OBJECT_MEMORY_OFFSET
 0000553A  0000872D R	      C                             dd  offset DEBI_l_mouse_objects         ; +24 +_ST_OBJECT_MOUSE_OFFSET
 0000553E  00008645 R	      C                             dd  offset DEBI_l_screen_objects        ; +28 +_ST_OBJECT_SCREEN_OFFSET
			      C ; stack
 00005542  01		      C                             db  _YES                                ; +00 Alterable?
 00005543  01		      C                             db  _YES                                ; +01 Active?
 00005544  0000		      C                             dw  0                                   ; +02 +--Nuserved
 00005546  000001E0	      C                             dd  4*(15*8)                            ; +04 +_ST_OBJECT_UL_HORIZONTAL
 0000554A  0000005A	      C                             dd  15*6                                ; +08 +_ST_OBJECT_UL_VERTICAL
 0000554E  FFFFFFFF	      C                             dd  0ffffffffh                          ; +12 +_ST_MEMVAR_OFFSET
 00005552  000056A2 R	      C                             dd  offset DEBI_keyboard_objects        ; +16 +_ST_OBJECT_KBD_OFFSET
 00005556  FFFFFFFF	      C                             dd  0ffffffffh                          ; +20 +_ST_OBJECT_MEMORY_OFFSET
 0000555A  00007F82 R	      C                             dd  offset DEBI_i_mouse_objects         ; +24 +_ST_OBJECT_MOUSE_OFFSET
 0000555E  00007E9A R	      C                             dd  offset DEBI_i_screen_objects        ; +28 +_ST_OBJECT_SCREEN_OFFSET
			      C ; mem.3
 00005562  01		      C                             db  _YES                                ; +00 Alterable?
 00005563  01		      C                             db  _YES                                ; +01 Active?
 00005564  0000		      C                             dw  0                                   ; +02 +--Nuserved
 00005566  00000000	      C                             dd  0                                   ; +04 +_ST_OBJECT_UL_HORIZONTAL
 0000556A  0000009C	      C                             dd  2*(13*6)                            ; +08 +_ST_OBJECT_UL_VERTICAL
 0000556E  FFFFFFFF	      C                             dd  0ffffffffh                          ; +12 +_ST_MEMVAR_OFFSET
 00005572  000056A2 R	      C                             dd  offset DEBI_keyboard_objects        ; +16 +_ST_OBJECT_KBD_OFFSET
 00005576  FFFFFFFF	      C                             dd  0ffffffffh                          ; +20 +_ST_OBJECT_MEMORY_OFFSET
 0000557A  00008DDD R	      C                             dd  offset DEBI_n_mouse_objects         ; +24 +_ST_OBJECT_MOUSE_OFFSET
 0000557E  00008DD0 R	      C                             dd  offset DEBI_n_screen_objects        ; +28 +_ST_OBJECT_SCREEN_OFFSET
			      C ; mem.1
 00005582  01		      C                             db  _YES                                ; +00 Alterable?
 00005583  01		      C                             db  _YES                                ; +01 Active?
 00005584  0000		      C                             dw  0                                   ; +02 +--Nuserved
 00005586  00000168	      C                             dd  3*(15*8)                            ; +04 +_ST_OBJECT_UL_HORIZONTAL
 0000558A  0000009C	      C                             dd  2*(13*6)                            ; +08 +_ST_OBJECT_UL_VERTICAL
 0000558E  FFFFFFFF	      C                             dd  0ffffffffh                          ; +12 +_ST_MEMVAR_OFFSET
 00005592  000056A2 R	      C                             dd  offset DEBI_keyboard_objects        ; +16 +_ST_OBJECT_KBD_OFFSET
 00005596  FFFFFFFF	      C                             dd  0ffffffffh                          ; +20 +_ST_OBJECT_MEMORY_OFFSET
 0000559A  00008A08 R	      C                             dd  offset DEBI_m_mouse_objects         ; +24 +_ST_OBJECT_MOUSE_OFFSET
 0000559E  000089FB R	      C                             dd  offset DEBI_m_screen_objects        ; +28 +_ST_OBJECT_SCREEN_OFFSET
			      C ; mem.2
 000055A2  01		      C                             db  _YES                                ; +00 Alterable?
 000055A3  01		      C                             db  _YES                                ; +01 Active?
 000055A4  0000		      C                             dw  0                                   ; +02 +--Nuserved
 000055A6  00000000	      C                             dd  0                                   ; +04 +_ST_OBJECT_UL_HORIZONTAL
 000055AA  000000EA	      C                             dd  3*(13*6)                            ; +08 +_ST_OBJECT_UL_VERTICAL
 000055AE  FFFFFFFF	      C                             dd  0ffffffffh                          ; +12 +_ST_MEMVAR_OFFSET
 000055B2  000056A2 R	      C                             dd  offset DEBI_keyboard_objects        ; +16 +_ST_OBJECT_KBD_OFFSET
 000055B6  FFFFFFFF	      C                             dd  0ffffffffh                          ; +20 +_ST_OBJECT_MEMORY_OFFSET
 000055BA  000076DC R	      C                             dd  offset DEBI_g_mouse_objects         ; +24 +_ST_OBJECT_MOUSE_OFFSET
 000055BE  000076CF R	      C                             dd  offset DEBI_g_screen_objects        ; +28 +_ST_OBJECT_SCREEN_OFFSET
			      C ; mem.2
 000055C2  01		      C                             db  _YES                                ; +00 Alterable?
 000055C3  01		      C                             db  _YES                                ; +01 Active?
 000055C4  0000		      C                             dw  0                                   ; +02 +--Nuserved
 000055C6  000000F0	      C                             dd  2*(15*8)                            ; +04 +_ST_OBJECT_UL_HORIZONTAL
 000055CA  000000EA	      C                             dd  3*(13*6)                            ; +08 +_ST_OBJECT_UL_VERTICAL
 000055CE  FFFFFFFF	      C                             dd  0ffffffffh                          ; +12 +_ST_MEMVAR_OFFSET
 000055D2  000056A2 R	      C                             dd  offset DEBI_keyboard_objects        ; +16 +_ST_OBJECT_KBD_OFFSET
 000055D6  FFFFFFFF	      C                             dd  0ffffffffh                          ; +20 +_ST_OBJECT_MEMORY_OFFSET
 000055DA  000076DC R	      C                             dd  offset DEBI_g_mouse_objects         ; +24 +_ST_OBJECT_MOUSE_OFFSET
 000055DE  000076CF R	      C                             dd  offset DEBI_g_screen_objects        ; +28 +_ST_OBJECT_SCREEN_OFFSET
			      C 
 000055E2  00000060 [	      C                             db  3*_ST_LENGTH dup(_NO)               ; Allow space for the maximum of 15 windows on-screen
	    00
	   ]
			      C                                                                     ; at any one time.  That's 9 above, 3 below, plus the
			      C                                                                     ; possibilty of 3 more = 15 items. :)
			      C 
 00005642 00		      C quick_watch_screen_object   db  _NO                                 ; +00 Alterable?
 00005643  01		      C                             db  _YES                                ; +01 Active?
 00005644  0000		      C                             dw  0                                   ; +02 +--Nuserved
 00005646  000001E0	      C                             dd  4*(15*8)                            ; +04 +_ST_OBJECT_UL_HORIZONTAL
 0000564A  000000EA	      C                             dd  3*(13*6)                            ; +08 +_ST_OBJECT_UL_VERTICAL
 0000564E  FFFFFFFF	      C                             dd  0ffffffffh                          ; +12 +_ST_MEMVAR_OFFSET
 00005652  000056A2 R	      C                             dd  offset DEBI_keyboard_objects        ; +16 +_ST_OBJECT_KBD_OFFSET
 00005656  FFFFFFFF	      C                             dd  0ffffffffh                          ; +20 +_ST_OBJECT_MEMORY_OFFSET
 0000565A  00008321 R	      C                             dd  offset DEBI_j_mouse_objects         ; +24 +_ST_OBJECT_MOUSE_OFFSET
 0000565E  00008314 R	      C                             dd  offset DEBI_j_screen_objects        ; +28 +_ST_OBJECT_SCREEN_OFFSET
			      C 
 00005662 00		      C query_screen_object         db  _NO                                 ; +00 Alterable?
 00005663  01		      C                             db  _YES                                ; +01 Active?
 00005664  0000		      C                             dw  0                                   ; +02 +--Nuserved
 00005666  00000000	      C                             dd  0                                   ; +04 +_ST_OBJECT_UL_HORIZONTAL
 0000566A  00000138	      C                             dd  312                                 ; +08 +_ST_OBJECT_UL_VERTICAL
 0000566E  FFFFFFFF	      C                             dd  0ffffffffh                          ; +12 +_ST_MEMVAR_OFFSET
 00005672  000056A2 R	      C                             dd  offset DEBI_keyboard_objects        ; +16 +_ST_OBJECT_KBD_OFFSET
 00005676  FFFFFFFF	      C                             dd  0ffffffffh                          ; +20 +_ST_OBJECT_MEMORY_OFFSET
 0000567A  00008533 R	      C                             dd  offset DEBI_k_mouse_objects         ; +24 +_ST_OBJECT_MOUSE_OFFSET
 0000567E  00008526 R	      C                             dd  offset DEBI_k_screen_objects        ; +28 +_ST_OBJECT_SCREEN_OFFSET
			      C 
 00005682 00		      C menu_bar_screen_object      db  _NO                                 ; +00 Alterable?
 00005683  01		      C                             db  _YES                                ; +01 Active?
 00005684  0000		      C                             dw  0                                   ; +02 +--Nuserved
 00005686  00000000	      C                             dd  0                                   ; +04 +_ST_OBJECT_UL_HORIZONTAL
 0000568A  00000156	      C                             dd  342                                 ; +08 +_ST_OBJECT_UL_VERTICAL
 0000568E  FFFFFFFF	      C                             dd  0ffffffffh                          ; +12 +_ST_MEMVAR_OFFSET
 00005692  000056A2 R	      C                             dd  offset DEBI_keyboard_objects        ; +16 +_ST_OBJECT_KBD_OFFSET
 00005696  FFFFFFFF	      C                             dd  0ffffffffh                          ; +20 +_ST_OBJECT_MEMORY_OFFSET
 0000569A  00009172 R	      C                             dd  offset DEBI_o_mouse_objects         ; +24 +_ST_OBJECT_MOUSE_OFFSET
 0000569E  0000916A R	      C                             dd  offset DEBI_o_screen_objects        ; +28 +_ST_OBJECT_SCREEN_OFFSET
 000056A2		      C DEBI_screen_table_end:
			      C 
			      C 
 000056A2		      C DEBI_keyboard_objects:
			      C     @FunctionHandlesObject  invDEBI_kbd_handler
 000056A2  07		     1C     db  _FUNCTION
 000056A3  00005260 R	     1C     dd  offset invDEBI_kbd_handler
			     1C   ; Total = 5
			      C     @End
 000056A7  FF		     1C     db  _END
			     1C   ; Total = 1
 000056A8		      C DEBI_screen_objects:
			      C     @End
 000056A8  FF		     1C     db  _END
			     1C   ; Total = 1
 000056A9		      C DEBI_mouse_objects:
			      C     @End
 000056A9  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
 000056AA		      C DEBI_general_menu:
			      C     @MenuItem               "ƒƒ Add Window ƒƒ"
 000056AA  00		     1C     db  _MENU_ITEM
 000056AB  10		     1C     db  @SizeStr("ƒƒ Add Window ƒƒ") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 000056AC  C4 C4 20 41 64    1C     db  "ƒƒ Add Window ƒƒ"
	   64 20 57 69 6E
	   64 6F 77 20 C4
	   C4
			      C     @MenuItem               "Descriptor"
 000056BC  00		     1C     db  _MENU_ITEM
 000056BD  0A		     1C     db  @SizeStr("Descriptor") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 000056BE  44 65 73 63 72    1C     db  "Descriptor"
	   69 70 74 6F 72
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_new_window_descriptor
 000056C8  01		     1C     db  _MENU_ITEM_EVENT
 000056C9  00		     1C     db  _LEFT_SINGLE_CLICK
 000056CA  00003A6A R	     1C     dd  offset invDEBI_new_window_descriptor
			      C     @MenuItem               "Regs.1"
 000056CE  00		     1C     db  _MENU_ITEM
 000056CF  06		     1C     db  @SizeStr("Regs.1") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 000056D0  52 65 67 73 2E    1C     db  "Regs.1"
	   31
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_new_window_regs_1
 000056D6  01		     1C     db  _MENU_ITEM_EVENT
 000056D7  00		     1C     db  _LEFT_SINGLE_CLICK
 000056D8  00003A7E R	     1C     dd  offset invDEBI_new_window_regs_1
			      C     @MenuItem               "Regs.3"
 000056DC  00		     1C     db  _MENU_ITEM
 000056DD  06		     1C     db  @SizeStr("Regs.3") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 000056DE  52 65 67 73 2E    1C     db  "Regs.3"
	   33
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_new_window_regs_3
 000056E4  01		     1C     db  _MENU_ITEM_EVENT
 000056E5  00		     1C     db  _LEFT_SINGLE_CLICK
 000056E6  00003A92 R	     1C     dd  offset invDEBI_new_window_regs_3
			      C     @MenuItem               "MMX"
 000056EA  00		     1C     db  _MENU_ITEM
 000056EB  03		     1C     db  @SizeStr("MMX") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 000056EC  4D 4D 58	     1C     db  "MMX"
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_new_window_mmx
 000056EF  01		     1C     db  _MENU_ITEM_EVENT
 000056F0  00		     1C     db  _LEFT_SINGLE_CLICK
 000056F1  00003AA6 R	     1C     dd  offset invDEBI_new_window_mmx
			      C     @MenuItem               "FPU.1"
 000056F5  00		     1C     db  _MENU_ITEM
 000056F6  05		     1C     db  @SizeStr("FPU.1") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 000056F7  46 50 55 2E 31    1C     db  "FPU.1"
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_new_window_fpu_1
 000056FC  01		     1C     db  _MENU_ITEM_EVENT
 000056FD  00		     1C     db  _LEFT_SINGLE_CLICK
 000056FE  00003ABA R	     1C     dd  offset invDEBI_new_window_fpu_1
			      C     @MenuItem               "FPU.2"
 00005702  00		     1C     db  _MENU_ITEM
 00005703  05		     1C     db  @SizeStr("FPU.2") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00005704  46 50 55 2E 32    1C     db  "FPU.2"
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_new_window_fpu_2
 00005709  01		     1C     db  _MENU_ITEM_EVENT
 0000570A  00		     1C     db  _LEFT_SINGLE_CLICK
 0000570B  00003ACE R	     1C     dd  offset invDEBI_new_window_fpu_2
			      C     @MenuItem               "FPU.Summary"
 0000570F  00		     1C     db  _MENU_ITEM
 00005710  0B		     1C     db  @SizeStr("FPU.Summary") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00005711  46 50 55 2E 53    1C     db  "FPU.Summary"
	   75 6D 6D 61 72
	   79
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_new_window_fpu_summary
 0000571C  01		     1C     db  _MENU_ITEM_EVENT
 0000571D  00		     1C     db  _LEFT_SINGLE_CLICK
 0000571E  00003AE2 R	     1C     dd  offset invDEBI_new_window_fpu_summary
			      C     @MenuItem               "FPU.SaveState"
 00005722  00		     1C     db  _MENU_ITEM
 00005723  0D		     1C     db  @SizeStr("FPU.SaveState") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00005724  46 50 55 2E 53    1C     db  "FPU.SaveState"
	   61 76 65 53 74
	   61 74 65
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_new_window_fpu_savestate
 00005731  01		     1C     db  _MENU_ITEM_EVENT
 00005732  00		     1C     db  _LEFT_SINGLE_CLICK
 00005733  00003AF3 R	     1C     dd  offset invDEBI_new_window_fpu_savestate
			      C     @MenuItem               "Mem.1"
 00005737  00		     1C     db  _MENU_ITEM
 00005738  05		     1C     db  @SizeStr("Mem.1") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00005739  4D 65 6D 2E 31    1C     db  "Mem.1"
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_new_window_mem_1
 0000573E  01		     1C     db  _MENU_ITEM_EVENT
 0000573F  00		     1C     db  _LEFT_SINGLE_CLICK
 00005740  00003B04 R	     1C     dd  offset invDEBI_new_window_mem_1
			      C     @MenuItem               "Mem.2"
 00005744  00		     1C     db  _MENU_ITEM
 00005745  05		     1C     db  @SizeStr("Mem.2") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00005746  4D 65 6D 2E 32    1C     db  "Mem.2"
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_new_window_mem_2
 0000574B  01		     1C     db  _MENU_ITEM_EVENT
 0000574C  00		     1C     db  _LEFT_SINGLE_CLICK
 0000574D  00003B15 R	     1C     dd  offset invDEBI_new_window_mem_2
			      C     @MenuItem               "Mem.3"
 00005751  00		     1C     db  _MENU_ITEM
 00005752  05		     1C     db  @SizeStr("Mem.3") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00005753  4D 65 6D 2E 33    1C     db  "Mem.3"
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_new_window_mem_3
 00005758  01		     1C     db  _MENU_ITEM_EVENT
 00005759  00		     1C     db  _LEFT_SINGLE_CLICK
 0000575A  00003B26 R	     1C     dd  offset invDEBI_new_window_mem_3
			      C     @MenuItem               "Mem.4"
 0000575E  00		     1C     db  _MENU_ITEM
 0000575F  05		     1C     db  @SizeStr("Mem.4") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00005760  4D 65 6D 2E 34    1C     db  "Mem.4"
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_new_window_mem_4
 00005765  01		     1C     db  _MENU_ITEM_EVENT
 00005766  00		     1C     db  _LEFT_SINGLE_CLICK
 00005767  00003B37 R	     1C     dd  offset invDEBI_new_window_mem_4
			      C     @MenuItem               "Locals"
 0000576B  00		     1C     db  _MENU_ITEM
 0000576C  06		     1C     db  @SizeStr("Locals") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000576D  4C 6F 63 61 6C    1C     db  "Locals"
	   73
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_new_window_locals
 00005773  01		     1C     db  _MENU_ITEM_EVENT
 00005774  00		     1C     db  _LEFT_SINGLE_CLICK
 00005775  00003B48 R	     1C     dd  offset invDEBI_new_window_locals
			      C     @MenuItem               "Stack"
 00005779  00		     1C     db  _MENU_ITEM
 0000577A  05		     1C     db  @SizeStr("Stack") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000577B  53 74 61 63 6B    1C     db  "Stack"
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_new_window_stack
 00005780  01		     1C     db  _MENU_ITEM_EVENT
 00005781  00		     1C     db  _LEFT_SINGLE_CLICK
 00005782  00003B59 R	     1C     dd  offset invDEBI_new_window_stack
			      C     @End
 00005786  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
			      C                                 ;          11111111112222222222333333333344444
			      C                                 ;012345678901234567890123456789012345678901234
 00005787 C9 9A CD 81 20      C DEBI_a_window               db  "…öÕÅ Descriptor ÖÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª",0
	   44 65 73 63 72
	   69 70 74 6F 72
	   20 85 CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD BB
	   00
 000057B5  20 20 20 20 20     C                             db  "                                            ∫",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 000057E3  20 20 20 20 20     C                             db  "     60  56    52  48    44  40    36  32   ∫",0
	   36 30 20 20 35
	   36 20 20 20 20
	   35 32 20 20 34
	   38 20 20 20 20
	   34 34 20 20 34
	   30 20 20 20 20
	   33 36 20 20 33
	   32 20 20 20 BA
	   00
 00005811  20 20 20 DA C2     C                             db  "   ⁄¬¬ø⁄¬¬ø  ⁄¬¬ø⁄¬¬ø  ⁄¬¬ø⁄¬¬ø  ⁄¬¬ø⁄¬¬ø   ∫",0
	   C2 BF DA C2 C2
	   BF 20 20 DA C2
	   C2 BF DA C2 C2
	   BF 20 20 DA C2
	   C2 BF DA C2 C2
	   BF 20 20 DA C2
	   C2 BF DA C2 C2
	   BF 20 20 20 BA
	   00
 0000583F  20 20 20 FA FA     C                             db  "   ˙˙˙˙˙˙˙˙  ˙˙˙˙˙˙˙˙  ˙˙˙˙˙˙˙˙  ˙˙˙˙˙˙˙˙   ∫",0
	   FA FA FA FA FA
	   FA 20 20 FA FA
	   FA FA FA FA FA
	   FA 20 20 FA FA
	   FA FA FA FA FA
	   FA 20 20 FA FA
	   FA FA FA FA FA
	   FA 20 20 20 BA
	   00
 0000586D  20 20 20 FA FA     C                             db  "   ˙˙˙˙˙˙˙˙  ˙˙˙˙˙˙˙˙  ˙˙˙˙˙˙˙˙  ˙˙˙˙˙˙˙˙   ∫",0
	   FA FA FA FA FA
	   FA 20 20 FA FA
	   FA FA FA FA FA
	   FA 20 20 FA FA
	   FA FA FA FA FA
	   FA 20 20 FA FA
	   FA FA FA FA FA
	   FA 20 20 20 BA
	   00
 0000589B  20 20 20 C0 C1     C                             db  "   ¿¡¡Ÿ¿¡¡Ÿ  ¿¡¡Ÿ¿¡¡Ÿ  ¿¡¡Ÿ¿¡¡Ÿ  ¿¡¡Ÿ¿¡¡Ÿ   ∫",0
	   C1 D9 C0 C1 C1
	   D9 20 20 C0 C1
	   C1 D9 C0 C1 C1
	   D9 20 20 C0 C1
	   C1 D9 C0 C1 C1
	   D9 20 20 C0 C1
	   C1 D9 C0 C1 C1
	   D9 20 20 20 BA
	   00
 000058C9  20 20 20 20 20     C                             db  "     28  24    20  16    12   8     4   0   ∫",0
	   32 38 20 20 32
	   34 20 20 20 20
	   32 30 20 20 31
	   36 20 20 20 20
	   31 32 20 20 20
	   38 20 20 20 20
	   20 34 20 20 20
	   30 20 20 20 BA
	   00
 000058F7  20 20 20 20 20     C                             db  "                                            ∫",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00005925  FF		      C                             db  255
			      C 
			      C ; * Note:  Refer to debi_mac.asp for information on these macros.  Basically they correctly arrange the variables in the required
			      C ;          sizes (bytes, words, dwords) and expand the X & Y coordinates to x*8 and y*8.
			      C 
 00005926  0168		      C                             dw  45 * FONT_X
 00005928  0035		      C                             dw  9  * FONT_Y - 1
 0000592A		      C DEBI_a_screen_objects:
			      C ;REMEMBER, objects may not line up with above (it's recently modified)
			      C     @DrawWindow             DEBI_a_window
			     1C ; Draws the window for whatever item is specified
 0000592A  FD		     1C     db  _DRAW_WINDOW
 0000592B  00005787 R	     1C     dd  offset DEBI_a_window
			     1C   ; Total = 5
			      C     @ObjectMemSize          12+8
			     1C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
 0000592F  00		     1C     db  _OBJECT_MEM_SIZE
 00005930  14		     1C     db  12+8
			     1C   ; Total = 2
			      C     @LoadTemp               _FAR_MEMORY_PTR,  0
			     1C ; Loads a temporary value from this item's portion of _sDEBI_objects memory
			     1C ;
			     1C ;       TYPE - indicates what type of temporary variable is being loaded
			     1C ;    LOFFSET - offset in local memory where the pointer is taken from (usually 0 indicating the first item in temp space)
			     1C ;
 00005931  02		     1C     db  _LOAD_TEMP
 00005932  00		     1C     db  _FAR_MEMORY_PTR
 00005933  00000000	     1C     dd  0
			     1C   ; Total = 6
			      C     @DisplayTemp_relative   _UPPER_NIBBLE,  7, 7+12,  2, 4
			     1C ; Used to display some data from a temporary value.  Prior to use an @LoadTemp must've been issued to setup the far pointer to
			     1C ; access the memory.
			     1C ;
			     1C ;       TYPE - indicates what type of variable is being displayed
			     1C ; TEMPOFFSET - offset relative to the @LoadTemp far ptr
			     1C ;    LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;          X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;          Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005937  03		     1C     db  _DISPLAY
 00005938  00		     1C     db  _TEMP_RELATIVE
 00005939  00		     1C     db  _UPPER_NIBBLE
 0000593A  0007		     1C     dw  7
 0000593C  13		     1C     db  7+12
 0000593D  00000010	     1C     dd  2 * FONT_X
 00005941  00000018	     1C     dd  4 * FONT_Y
 00005945  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayTemp_relative   _LOWER_NIBBLE,  7, 7+12,  7, 4
			     1C ; Used to display some data from a temporary value.  Prior to use an @LoadTemp must've been issued to setup the far pointer to
			     1C ; access the memory.
			     1C ;
			     1C ;       TYPE - indicates what type of variable is being displayed
			     1C ; TEMPOFFSET - offset relative to the @LoadTemp far ptr
			     1C ;    LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;          X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;          Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005947  03		     1C     db  _DISPLAY
 00005948  00		     1C     db  _TEMP_RELATIVE
 00005949  01		     1C     db  _LOWER_NIBBLE
 0000594A  0007		     1C     dw  7
 0000594C  13		     1C     db  7+12
 0000594D  00000038	     1C     dd  7 * FONT_X
 00005951  00000018	     1C     dd  4 * FONT_Y
 00005955  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayTemp_relative   _UPPER_NIBBLE,  6, 6+12, 12, 4
			     1C ; Used to display some data from a temporary value.  Prior to use an @LoadTemp must've been issued to setup the far pointer to
			     1C ; access the memory.
			     1C ;
			     1C ;       TYPE - indicates what type of variable is being displayed
			     1C ; TEMPOFFSET - offset relative to the @LoadTemp far ptr
			     1C ;    LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;          X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;          Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005957  03		     1C     db  _DISPLAY
 00005958  00		     1C     db  _TEMP_RELATIVE
 00005959  00		     1C     db  _UPPER_NIBBLE
 0000595A  0006		     1C     dw  6
 0000595C  12		     1C     db  6+12
 0000595D  00000060	     1C     dd  12 * FONT_X
 00005961  00000018	     1C     dd  4 * FONT_Y
 00005965  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayTemp_relative   _LOWER_NIBBLE,  6, 6+12, 17, 4
			     1C ; Used to display some data from a temporary value.  Prior to use an @LoadTemp must've been issued to setup the far pointer to
			     1C ; access the memory.
			     1C ;
			     1C ;       TYPE - indicates what type of variable is being displayed
			     1C ; TEMPOFFSET - offset relative to the @LoadTemp far ptr
			     1C ;    LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;          X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;          Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005967  03		     1C     db  _DISPLAY
 00005968  00		     1C     db  _TEMP_RELATIVE
 00005969  01		     1C     db  _LOWER_NIBBLE
 0000596A  0006		     1C     dw  6
 0000596C  12		     1C     db  6+12
 0000596D  00000088	     1C     dd  17 * FONT_X
 00005971  00000018	     1C     dd  4 * FONT_Y
 00005975  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayTemp_relative   _UPPER_NIBBLE,  5, 5+12, 22, 4
			     1C ; Used to display some data from a temporary value.  Prior to use an @LoadTemp must've been issued to setup the far pointer to
			     1C ; access the memory.
			     1C ;
			     1C ;       TYPE - indicates what type of variable is being displayed
			     1C ; TEMPOFFSET - offset relative to the @LoadTemp far ptr
			     1C ;    LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;          X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;          Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005977  03		     1C     db  _DISPLAY
 00005978  00		     1C     db  _TEMP_RELATIVE
 00005979  00		     1C     db  _UPPER_NIBBLE
 0000597A  0005		     1C     dw  5
 0000597C  11		     1C     db  5+12
 0000597D  000000B0	     1C     dd  22 * FONT_X
 00005981  00000018	     1C     dd  4 * FONT_Y
 00005985  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayTemp_relative   _LOWER_NIBBLE,  5, 5+12, 27, 4
			     1C ; Used to display some data from a temporary value.  Prior to use an @LoadTemp must've been issued to setup the far pointer to
			     1C ; access the memory.
			     1C ;
			     1C ;       TYPE - indicates what type of variable is being displayed
			     1C ; TEMPOFFSET - offset relative to the @LoadTemp far ptr
			     1C ;    LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;          X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;          Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005987  03		     1C     db  _DISPLAY
 00005988  00		     1C     db  _TEMP_RELATIVE
 00005989  01		     1C     db  _LOWER_NIBBLE
 0000598A  0005		     1C     dw  5
 0000598C  11		     1C     db  5+12
 0000598D  000000D8	     1C     dd  27 * FONT_X
 00005991  00000018	     1C     dd  4 * FONT_Y
 00005995  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayTemp_relative   _UPPER_NIBBLE,  4, 4+12, 32, 4
			     1C ; Used to display some data from a temporary value.  Prior to use an @LoadTemp must've been issued to setup the far pointer to
			     1C ; access the memory.
			     1C ;
			     1C ;       TYPE - indicates what type of variable is being displayed
			     1C ; TEMPOFFSET - offset relative to the @LoadTemp far ptr
			     1C ;    LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;          X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;          Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005997  03		     1C     db  _DISPLAY
 00005998  00		     1C     db  _TEMP_RELATIVE
 00005999  00		     1C     db  _UPPER_NIBBLE
 0000599A  0004		     1C     dw  4
 0000599C  10		     1C     db  4+12
 0000599D  00000100	     1C     dd  32 * FONT_X
 000059A1  00000018	     1C     dd  4 * FONT_Y
 000059A5  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayTemp_relative   _LOWER_NIBBLE,  4, 4+12, 37, 4
			     1C ; Used to display some data from a temporary value.  Prior to use an @LoadTemp must've been issued to setup the far pointer to
			     1C ; access the memory.
			     1C ;
			     1C ;       TYPE - indicates what type of variable is being displayed
			     1C ; TEMPOFFSET - offset relative to the @LoadTemp far ptr
			     1C ;    LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;          X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;          Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000059A7  03		     1C     db  _DISPLAY
 000059A8  00		     1C     db  _TEMP_RELATIVE
 000059A9  01		     1C     db  _LOWER_NIBBLE
 000059AA  0004		     1C     dw  4
 000059AC  10		     1C     db  4+12
 000059AD  00000128	     1C     dd  37 * FONT_X
 000059B1  00000018	     1C     dd  4 * FONT_Y
 000059B5  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayTemp_relative   _UPPER_NIBBLE,  3, 3+12,  2, 5
			     1C ; Used to display some data from a temporary value.  Prior to use an @LoadTemp must've been issued to setup the far pointer to
			     1C ; access the memory.
			     1C ;
			     1C ;       TYPE - indicates what type of variable is being displayed
			     1C ; TEMPOFFSET - offset relative to the @LoadTemp far ptr
			     1C ;    LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;          X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;          Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000059B7  03		     1C     db  _DISPLAY
 000059B8  00		     1C     db  _TEMP_RELATIVE
 000059B9  00		     1C     db  _UPPER_NIBBLE
 000059BA  0003		     1C     dw  3
 000059BC  0F		     1C     db  3+12
 000059BD  00000010	     1C     dd  2 * FONT_X
 000059C1  0000001E	     1C     dd  5 * FONT_Y
 000059C5  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayTemp_relative   _LOWER_NIBBLE,  3, 3+12,  7, 5
			     1C ; Used to display some data from a temporary value.  Prior to use an @LoadTemp must've been issued to setup the far pointer to
			     1C ; access the memory.
			     1C ;
			     1C ;       TYPE - indicates what type of variable is being displayed
			     1C ; TEMPOFFSET - offset relative to the @LoadTemp far ptr
			     1C ;    LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;          X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;          Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000059C7  03		     1C     db  _DISPLAY
 000059C8  00		     1C     db  _TEMP_RELATIVE
 000059C9  01		     1C     db  _LOWER_NIBBLE
 000059CA  0003		     1C     dw  3
 000059CC  0F		     1C     db  3+12
 000059CD  00000038	     1C     dd  7 * FONT_X
 000059D1  0000001E	     1C     dd  5 * FONT_Y
 000059D5  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayTemp_relative   _UPPER_NIBBLE,  2, 2+12, 12, 5
			     1C ; Used to display some data from a temporary value.  Prior to use an @LoadTemp must've been issued to setup the far pointer to
			     1C ; access the memory.
			     1C ;
			     1C ;       TYPE - indicates what type of variable is being displayed
			     1C ; TEMPOFFSET - offset relative to the @LoadTemp far ptr
			     1C ;    LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;          X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;          Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000059D7  03		     1C     db  _DISPLAY
 000059D8  00		     1C     db  _TEMP_RELATIVE
 000059D9  00		     1C     db  _UPPER_NIBBLE
 000059DA  0002		     1C     dw  2
 000059DC  0E		     1C     db  2+12
 000059DD  00000060	     1C     dd  12 * FONT_X
 000059E1  0000001E	     1C     dd  5 * FONT_Y
 000059E5  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayTemp_relative   _LOWER_NIBBLE,  2, 2+12, 17, 5
			     1C ; Used to display some data from a temporary value.  Prior to use an @LoadTemp must've been issued to setup the far pointer to
			     1C ; access the memory.
			     1C ;
			     1C ;       TYPE - indicates what type of variable is being displayed
			     1C ; TEMPOFFSET - offset relative to the @LoadTemp far ptr
			     1C ;    LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;          X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;          Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000059E7  03		     1C     db  _DISPLAY
 000059E8  00		     1C     db  _TEMP_RELATIVE
 000059E9  01		     1C     db  _LOWER_NIBBLE
 000059EA  0002		     1C     dw  2
 000059EC  0E		     1C     db  2+12
 000059ED  00000088	     1C     dd  17 * FONT_X
 000059F1  0000001E	     1C     dd  5 * FONT_Y
 000059F5  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayTemp_relative   _UPPER_NIBBLE,  1, 1+12, 22, 5
			     1C ; Used to display some data from a temporary value.  Prior to use an @LoadTemp must've been issued to setup the far pointer to
			     1C ; access the memory.
			     1C ;
			     1C ;       TYPE - indicates what type of variable is being displayed
			     1C ; TEMPOFFSET - offset relative to the @LoadTemp far ptr
			     1C ;    LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;          X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;          Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000059F7  03		     1C     db  _DISPLAY
 000059F8  00		     1C     db  _TEMP_RELATIVE
 000059F9  00		     1C     db  _UPPER_NIBBLE
 000059FA  0001		     1C     dw  1
 000059FC  0D		     1C     db  1+12
 000059FD  000000B0	     1C     dd  22 * FONT_X
 00005A01  0000001E	     1C     dd  5 * FONT_Y
 00005A05  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayTemp_relative   _LOWER_NIBBLE,  1, 1+12, 27, 5
			     1C ; Used to display some data from a temporary value.  Prior to use an @LoadTemp must've been issued to setup the far pointer to
			     1C ; access the memory.
			     1C ;
			     1C ;       TYPE - indicates what type of variable is being displayed
			     1C ; TEMPOFFSET - offset relative to the @LoadTemp far ptr
			     1C ;    LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;          X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;          Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005A07  03		     1C     db  _DISPLAY
 00005A08  00		     1C     db  _TEMP_RELATIVE
 00005A09  01		     1C     db  _LOWER_NIBBLE
 00005A0A  0001		     1C     dw  1
 00005A0C  0D		     1C     db  1+12
 00005A0D  000000D8	     1C     dd  27 * FONT_X
 00005A11  0000001E	     1C     dd  5 * FONT_Y
 00005A15  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayTemp_relative   _UPPER_NIBBLE,  0, 0+12, 32, 5
			     1C ; Used to display some data from a temporary value.  Prior to use an @LoadTemp must've been issued to setup the far pointer to
			     1C ; access the memory.
			     1C ;
			     1C ;       TYPE - indicates what type of variable is being displayed
			     1C ; TEMPOFFSET - offset relative to the @LoadTemp far ptr
			     1C ;    LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;          X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;          Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005A17  03		     1C     db  _DISPLAY
 00005A18  00		     1C     db  _TEMP_RELATIVE
 00005A19  00		     1C     db  _UPPER_NIBBLE
 00005A1A  0000		     1C     dw  0
 00005A1C  0C		     1C     db  0+12
 00005A1D  00000100	     1C     dd  32 * FONT_X
 00005A21  0000001E	     1C     dd  5 * FONT_Y
 00005A25  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayTemp_relative   _LOWER_NIBBLE,  0, 0+12, 37, 5
			     1C ; Used to display some data from a temporary value.  Prior to use an @LoadTemp must've been issued to setup the far pointer to
			     1C ; access the memory.
			     1C ;
			     1C ;       TYPE - indicates what type of variable is being displayed
			     1C ; TEMPOFFSET - offset relative to the @LoadTemp far ptr
			     1C ;    LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;          X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;          Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005A27  03		     1C     db  _DISPLAY
 00005A28  00		     1C     db  _TEMP_RELATIVE
 00005A29  01		     1C     db  _LOWER_NIBBLE
 00005A2A  0000		     1C     dw  0
 00005A2C  0C		     1C     db  0+12
 00005A2D  00000128	     1C     dd  37 * FONT_X
 00005A31  0000001E	     1C     dd  5 * FONT_Y
 00005A35  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @End
 00005A37  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C                           ; x1, y1, x2, y2, function() that handles it when this item is clicked
			      C ALIGN
 00005A38		      C DEBI_a_mouse_objects:
			      C     @Left_single_click       1,  0,  1,  0, invDEBI_object_close
			     1C ; Used when a left single-click is recognized on these coordinates
 00005A38  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 00005A39  00000008	     1C     dd  1 * FONT_X                 ; +1
 00005A3D  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00005A41  0000000F	     1C     dd  (1 * FONT_X) + FONT_X - 1  ; +9
 00005A45  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00005A49  0000510B R	     1C     dd  invDEBI_object_close                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00005A4D  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00005A51  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00005A53  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      3,  0, 16,  0, invDEBI_descriptor_right_click
			     1C ; Used when a right single-click is recognized on these coordinates
 00005A54  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 00005A55  00000018	     1C     dd  3 * FONT_X                 ; +1
 00005A59  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00005A5D  00000087	     1C     dd  (16 * FONT_X) + FONT_X - 1  ; +9
 00005A61  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00005A65  000039C0 R	     1C     dd  invDEBI_descriptor_right_click                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00005A69  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00005A6D  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00005A6F  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         0,  0, 44,  0, invDEBI_object_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 00005A70  02		     1C     db  _LEFT_DRAG_START            ; +0
 00005A71  00000000	     1C     dd  0 * FONT_X                 ; +1
 00005A75  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00005A79  00000167	     1C     dd  (44 * FONT_X) + FONT_X - 1  ; +9
 00005A7D  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00005A81  00003BE5 R	     1C     dd  invDEBI_object_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00005A85  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00005A89  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00005A8B  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   1,  4, 42,  5, 12, invDEBI_descriptor_hover
			     1C ; Used when the mouse is hovering over these coordinates
 00005A8C  0A		     1C     db  _HOVER                      ; +0
 00005A8D  00000008	     1C     dd  1 * FONT_X                 ; +1
 00005A91  00000018	     1C     dd  4 * FONT_Y                 ; +5
 00005A95  00000157	     1C     dd  (42 * FONT_X) + FONT_X - 1  ; +9
 00005A99  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 00005A9D  000050D5 R	     1C     dd  invDEBI_descriptor_hover                        ; +17
 00005AA1  000C		     1C     dw  lowword(offset 12)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00005AA3  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @End
 00005AA8  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
			      C 
			      C                                 ;          11111111112222222222333333333344444
			      C                                 ;012345678901234567890123456789012345678901234
 00005AA9 C9 9A CD 81 20      C DEBI_b_window               db  "…öÕÅ Regs.3 ÖÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª",0
	   52 65 67 73 2E
	   33 20 85 CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD BB
	   00
 00005AD7  20 20 65 61 78     C                             db  "  eax ˙˙˙˙.˙˙.˙˙   ds ˙˙˙˙   ÆerrorØ ˙˙˙˙˙˙˙˙ ∫",0
	   20 FA FA FA FA
	   2E FA FA 2E FA
	   FA 20 20 20 64
	   73 20 FA FA FA
	   FA 20 20 20 AE
	   65 72 72 6F 72
	   AF 20 FA FA FA
	   FA FA FA FA FA
	   20 BA 00
 00005B07  20 20 65 62 78     C                             db  "  ebx ˙˙˙˙.˙˙.˙˙   es ˙˙˙˙  eflags ˙˙˙˙˙˙˙˙ ∫",0
	   20 FA FA FA FA
	   2E FA FA 2E FA
	   FA 20 20 20 65
	   73 20 FA FA FA
	   FA 20 20 65 66
	   6C 61 67 73 20
	   FA FA FA FA FA
	   FA FA FA 20 BA
	   00
 00005B35  20 20 65 63 78     C                             db  "  ecx ˙˙˙˙.˙˙.˙˙   fs ˙˙˙˙   √ nt˙ of˙ acf˙ ∫",0
	   20 FA FA FA FA
	   2E FA FA 2E FA
	   FA 20 20 20 66
	   73 20 FA FA FA
	   FA 20 20 20 C3
	   20 6E 74 FA 20
	   6F 66 FA 20 61
	   63 66 FA 20 BA
	   00
 00005B63  20 20 65 64 78     C                             db  "  edx ˙˙˙˙.˙˙.˙˙   gs ˙˙˙˙   √ pf˙ sf˙  if˙ ∫",0
	   20 FA FA FA FA
	   2E FA FA 2E FA
	   FA 20 20 20 67
	   73 20 FA FA FA
	   FA 20 20 20 C3
	   20 70 66 FA 20
	   73 66 FA 20 20
	   69 66 FA 20 BA
	   00
 00005B91  20 20 65 73 69     C                             db  "  esi ˙˙˙˙.˙˙˙˙              ¿ df˙ zf˙  cf˙ ∫",0
	   20 FA FA FA FA
	   2E FA FA FA FA
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 C0
	   20 64 66 FA 20
	   7A 66 FA 20 20
	   63 66 FA 20 BA
	   00
 00005BBF  20 20 65 64 69     C                             db  "  edi ˙˙˙˙.˙˙˙˙    ss ˙˙˙˙                  ∫",0
	   20 FA FA FA FA
	   2E FA FA FA FA
	   20 20 20 20 73
	   73 20 FA FA FA
	   FA 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00005BED  20 AE 64 61 74     C                             db  " ÆdataØ ˙˙˙˙˙˙˙˙    esp ˙˙˙˙˙˙˙˙   cs ˙˙˙˙    ∫",0
	   61 AF 20 FA FA
	   FA FA FA FA FA
	   FA 20 20 20 20
	   65 73 70 20 FA
	   FA FA FA FA FA
	   FA FA 20 20 20
	   63 73 20 FA FA
	   FA FA 20 20 20
	   20 BA 00
 00005C1D  20 20 AE 69 6D     C                             db  "  ÆimmØ ˙˙˙˙˙˙˙˙    ebp ˙˙˙˙˙˙˙˙  eip ˙˙˙˙˙˙˙˙∫",0
	   6D AF 20 FA FA
	   FA FA FA FA FA
	   FA 20 20 20 20
	   65 62 70 20 FA
	   FA FA FA FA FA
	   FA FA 20 20 65
	   69 70 20 FA FA
	   FA FA FA FA FA
	   FA BA 00
 00005C4D  FF		      C                             db  255
			      C 
 00005C4E  0168		      C                             dw  45 * FONT_X
 00005C50  0035		      C                             dw  9  * FONT_Y - 1
 00005C52		      C DEBI_b_screen_objects:
			      C     @DrawWindow                   DEBI_b_window
			     1C ; Draws the window for whatever item is specified
 00005C52  FD		     1C     db  _DRAW_WINDOW
 00005C53  00005AA9 R	     1C     dd  offset DEBI_b_window
			     1C   ; Total = 5
			      C     @ObjectMemSize       64
			     1C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
 00005C57  00		     1C     db  _OBJECT_MEM_SIZE
 00005C58  40		     1C     db  64
			     1C   ; Total = 2
			      C     @DisplayEBP_relative _16,     46, 2, 6, 1                       ; upper 16-bits of eax
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005C59  03		     1C     db  _DISPLAY            ; +0
 00005C5A  01		     1C     db  _EBP_RELATIVE       ; +1
 00005C5B  04		     1C     db  _16                ; +2
 00005C5C  002E		     1C     dw  46           ; +3
 00005C5E  02		     1C     db  2             ; +5
 00005C5F  00000030	     1C     dd  6 * FONT_X          ; +6
 00005C63  00000006	     1C     dd  1 * FONT_Y          ; +10
 00005C67  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _8,      45, 1,11, 1                       ; ah
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005C69  03		     1C     db  _DISPLAY            ; +0
 00005C6A  01		     1C     db  _EBP_RELATIVE       ; +1
 00005C6B  03		     1C     db  _8                ; +2
 00005C6C  002D		     1C     dw  45           ; +3
 00005C6E  01		     1C     db  1             ; +5
 00005C6F  00000058	     1C     dd  11 * FONT_X          ; +6
 00005C73  00000006	     1C     dd  1 * FONT_Y          ; +10
 00005C77  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _8,      44, 0,14, 1                       ; al
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005C79  03		     1C     db  _DISPLAY            ; +0
 00005C7A  01		     1C     db  _EBP_RELATIVE       ; +1
 00005C7B  03		     1C     db  _8                ; +2
 00005C7C  002C		     1C     dw  44           ; +3
 00005C7E  00		     1C     db  0             ; +5
 00005C7F  00000070	     1C     dd  14 * FONT_X          ; +6
 00005C83  00000006	     1C     dd  1 * FONT_Y          ; +10
 00005C87  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative _16,     42, 6, 6, 2                       ; upper 16-bits of ebx
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005C89  03		     1C     db  _DISPLAY            ; +0
 00005C8A  01		     1C     db  _EBP_RELATIVE       ; +1
 00005C8B  04		     1C     db  _16                ; +2
 00005C8C  002A		     1C     dw  42           ; +3
 00005C8E  06		     1C     db  6             ; +5
 00005C8F  00000030	     1C     dd  6 * FONT_X          ; +6
 00005C93  0000000C	     1C     dd  2 * FONT_Y          ; +10
 00005C97  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _8,      41, 5,11, 2                       ; bh
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005C99  03		     1C     db  _DISPLAY            ; +0
 00005C9A  01		     1C     db  _EBP_RELATIVE       ; +1
 00005C9B  03		     1C     db  _8                ; +2
 00005C9C  0029		     1C     dw  41           ; +3
 00005C9E  05		     1C     db  5             ; +5
 00005C9F  00000058	     1C     dd  11 * FONT_X          ; +6
 00005CA3  0000000C	     1C     dd  2 * FONT_Y          ; +10
 00005CA7  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _8,      40, 4,14, 2                       ; bl
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005CA9  03		     1C     db  _DISPLAY            ; +0
 00005CAA  01		     1C     db  _EBP_RELATIVE       ; +1
 00005CAB  03		     1C     db  _8                ; +2
 00005CAC  0028		     1C     dw  40           ; +3
 00005CAE  04		     1C     db  4             ; +5
 00005CAF  00000070	     1C     dd  14 * FONT_X          ; +6
 00005CB3  0000000C	     1C     dd  2 * FONT_Y          ; +10
 00005CB7  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative _16,     38,10, 6, 3                       ; upper 16-bits of ecx
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005CB9  03		     1C     db  _DISPLAY            ; +0
 00005CBA  01		     1C     db  _EBP_RELATIVE       ; +1
 00005CBB  04		     1C     db  _16                ; +2
 00005CBC  0026		     1C     dw  38           ; +3
 00005CBE  0A		     1C     db  10             ; +5
 00005CBF  00000030	     1C     dd  6 * FONT_X          ; +6
 00005CC3  00000012	     1C     dd  3 * FONT_Y          ; +10
 00005CC7  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _8,      37, 9,11, 3                       ; ch
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005CC9  03		     1C     db  _DISPLAY            ; +0
 00005CCA  01		     1C     db  _EBP_RELATIVE       ; +1
 00005CCB  03		     1C     db  _8                ; +2
 00005CCC  0025		     1C     dw  37           ; +3
 00005CCE  09		     1C     db  9             ; +5
 00005CCF  00000058	     1C     dd  11 * FONT_X          ; +6
 00005CD3  00000012	     1C     dd  3 * FONT_Y          ; +10
 00005CD7  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _8,      36, 8,14, 3                       ; cl
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005CD9  03		     1C     db  _DISPLAY            ; +0
 00005CDA  01		     1C     db  _EBP_RELATIVE       ; +1
 00005CDB  03		     1C     db  _8                ; +2
 00005CDC  0024		     1C     dw  36           ; +3
 00005CDE  08		     1C     db  8             ; +5
 00005CDF  00000070	     1C     dd  14 * FONT_X          ; +6
 00005CE3  00000012	     1C     dd  3 * FONT_Y          ; +10
 00005CE7  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative _16,     34,14, 6, 4                       ; upper 16-bits of edx
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005CE9  03		     1C     db  _DISPLAY            ; +0
 00005CEA  01		     1C     db  _EBP_RELATIVE       ; +1
 00005CEB  04		     1C     db  _16                ; +2
 00005CEC  0022		     1C     dw  34           ; +3
 00005CEE  0E		     1C     db  14             ; +5
 00005CEF  00000030	     1C     dd  6 * FONT_X          ; +6
 00005CF3  00000018	     1C     dd  4 * FONT_Y          ; +10
 00005CF7  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _8,      33,13,11, 4                       ; dh
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005CF9  03		     1C     db  _DISPLAY            ; +0
 00005CFA  01		     1C     db  _EBP_RELATIVE       ; +1
 00005CFB  03		     1C     db  _8                ; +2
 00005CFC  0021		     1C     dw  33           ; +3
 00005CFE  0D		     1C     db  13             ; +5
 00005CFF  00000058	     1C     dd  11 * FONT_X          ; +6
 00005D03  00000018	     1C     dd  4 * FONT_Y          ; +10
 00005D07  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _8,      32,12,14, 4                       ; dl
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005D09  03		     1C     db  _DISPLAY            ; +0
 00005D0A  01		     1C     db  _EBP_RELATIVE       ; +1
 00005D0B  03		     1C     db  _8                ; +2
 00005D0C  0020		     1C     dw  32           ; +3
 00005D0E  0C		     1C     db  12             ; +5
 00005D0F  00000070	     1C     dd  14 * FONT_X          ; +6
 00005D13  00000018	     1C     dd  4 * FONT_Y          ; +10
 00005D17  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative _16,     30,18, 6, 5                       ; upper 16-bits of esi
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005D19  03		     1C     db  _DISPLAY            ; +0
 00005D1A  01		     1C     db  _EBP_RELATIVE       ; +1
 00005D1B  04		     1C     db  _16                ; +2
 00005D1C  001E		     1C     dw  30           ; +3
 00005D1E  12		     1C     db  18             ; +5
 00005D1F  00000030	     1C     dd  6 * FONT_X          ; +6
 00005D23  0000001E	     1C     dd  5 * FONT_Y          ; +10
 00005D27  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _16,     28,16,11, 5                       ; si
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005D29  03		     1C     db  _DISPLAY            ; +0
 00005D2A  01		     1C     db  _EBP_RELATIVE       ; +1
 00005D2B  04		     1C     db  _16                ; +2
 00005D2C  001C		     1C     dw  28           ; +3
 00005D2E  10		     1C     db  16             ; +5
 00005D2F  00000058	     1C     dd  11 * FONT_X          ; +6
 00005D33  0000001E	     1C     dd  5 * FONT_Y          ; +10
 00005D37  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative _16,     26,22, 6, 6                       ; upper 16-bits of edi
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005D39  03		     1C     db  _DISPLAY            ; +0
 00005D3A  01		     1C     db  _EBP_RELATIVE       ; +1
 00005D3B  04		     1C     db  _16                ; +2
 00005D3C  001A		     1C     dw  26           ; +3
 00005D3E  16		     1C     db  22             ; +5
 00005D3F  00000030	     1C     dd  6 * FONT_X          ; +6
 00005D43  00000024	     1C     dd  6 * FONT_Y          ; +10
 00005D47  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _16,     24,20,11, 6                       ; di
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005D49  03		     1C     db  _DISPLAY            ; +0
 00005D4A  01		     1C     db  _EBP_RELATIVE       ; +1
 00005D4B  04		     1C     db  _16                ; +2
 00005D4C  0018		     1C     dw  24           ; +3
 00005D4E  14		     1C     db  20             ; +5
 00005D4F  00000058	     1C     dd  11 * FONT_X          ; +6
 00005D53  00000024	     1C     dd  6 * FONT_Y          ; +10
 00005D57  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative _16,     20,24,22, 1                       ; ds
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005D59  03		     1C     db  _DISPLAY            ; +0
 00005D5A  01		     1C     db  _EBP_RELATIVE       ; +1
 00005D5B  04		     1C     db  _16                ; +2
 00005D5C  0014		     1C     dw  20           ; +3
 00005D5E  18		     1C     db  24             ; +5
 00005D5F  000000B0	     1C     dd  22 * FONT_X          ; +6
 00005D63  00000006	     1C     dd  1 * FONT_Y          ; +10
 00005D67  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _16,     16,28,22, 2                       ; es
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005D69  03		     1C     db  _DISPLAY            ; +0
 00005D6A  01		     1C     db  _EBP_RELATIVE       ; +1
 00005D6B  04		     1C     db  _16                ; +2
 00005D6C  0010		     1C     dw  16           ; +3
 00005D6E  1C		     1C     db  28             ; +5
 00005D6F  000000B0	     1C     dd  22 * FONT_X          ; +6
 00005D73  0000000C	     1C     dd  2 * FONT_Y          ; +10
 00005D77  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _16,     12,32,22, 3                       ; fs
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005D79  03		     1C     db  _DISPLAY            ; +0
 00005D7A  01		     1C     db  _EBP_RELATIVE       ; +1
 00005D7B  04		     1C     db  _16                ; +2
 00005D7C  000C		     1C     dw  12           ; +3
 00005D7E  20		     1C     db  32             ; +5
 00005D7F  000000B0	     1C     dd  22 * FONT_X          ; +6
 00005D83  00000012	     1C     dd  3 * FONT_Y          ; +10
 00005D87  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _16,      8,36,22, 4                       ; gs
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005D89  03		     1C     db  _DISPLAY            ; +0
 00005D8A  01		     1C     db  _EBP_RELATIVE       ; +1
 00005D8B  04		     1C     db  _16                ; +2
 00005D8C  0008		     1C     dw  8           ; +3
 00005D8E  24		     1C     db  36             ; +5
 00005D8F  000000B0	     1C     dd  22 * FONT_X          ; +6
 00005D93  00000018	     1C     dd  4 * FONT_Y          ; +10
 00005D97  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _16,      4,40,22, 6                       ; ss
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005D99  03		     1C     db  _DISPLAY            ; +0
 00005D9A  01		     1C     db  _EBP_RELATIVE       ; +1
 00005D9B  04		     1C     db  _16                ; +2
 00005D9C  0004		     1C     dw  4           ; +3
 00005D9E  28		     1C     db  40             ; +5
 00005D9F  000000B0	     1C     dd  22 * FONT_X          ; +6
 00005DA3  00000024	     1C     dd  6 * FONT_Y          ; +10
 00005DA7  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _32,     -4,44,22, 7                       ; esp
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005DA9  03		     1C     db  _DISPLAY            ; +0
 00005DAA  01		     1C     db  _EBP_RELATIVE       ; +1
 00005DAB  05		     1C     db  _32                ; +2
 00005DAC  FFFC		     1C     dw  -4           ; +3
 00005DAE  2C		     1C     db  44             ; +5
 00005DAF  000000B0	     1C     dd  22 * FONT_X          ; +6
 00005DB3  0000002A	     1C     dd  7 * FONT_Y          ; +10
 00005DB7  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _32,      0,48,22, 8                       ; ebp
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005DB9  03		     1C     db  _DISPLAY            ; +0
 00005DBA  01		     1C     db  _EBP_RELATIVE       ; +1
 00005DBB  05		     1C     db  _32                ; +2
 00005DBC  0000		     1C     dw  0           ; +3
 00005DBE  30		     1C     db  48             ; +5
 00005DBF  000000B0	     1C     dd  22 * FONT_X          ; +6
 00005DC3  00000030	     1C     dd  8 * FONT_Y          ; +10
 00005DC7  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _16,     56,52,36, 7                       ; cs
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005DC9  03		     1C     db  _DISPLAY            ; +0
 00005DCA  01		     1C     db  _EBP_RELATIVE       ; +1
 00005DCB  04		     1C     db  _16                ; +2
 00005DCC  0038		     1C     dw  56           ; +3
 00005DCE  34		     1C     db  52             ; +5
 00005DCF  00000120	     1C     dd  36 * FONT_X          ; +6
 00005DD3  0000002A	     1C     dd  7 * FONT_Y          ; +10
 00005DD7  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _32,     52,56,36, 8                       ; eip
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005DD9  03		     1C     db  _DISPLAY            ; +0
 00005DDA  01		     1C     db  _EBP_RELATIVE       ; +1
 00005DDB  05		     1C     db  _32                ; +2
 00005DDC  0034		     1C     dw  52           ; +3
 00005DDE  38		     1C     db  56             ; +5
 00005DDF  00000120	     1C     dd  36 * FONT_X          ; +6
 00005DE3  00000030	     1C     dd  8 * FONT_Y          ; +10
 00005DE7  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative _32,     48,48,35, 1                       ; <error code>
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005DE9  03		     1C     db  _DISPLAY            ; +0
 00005DEA  01		     1C     db  _EBP_RELATIVE       ; +1
 00005DEB  05		     1C     db  _32                ; +2
 00005DEC  0030		     1C     dw  48           ; +3
 00005DEE  30		     1C     db  48             ; +5
 00005DEF  00000118	     1C     dd  35 * FONT_X          ; +6
 00005DF3  00000006	     1C     dd  1 * FONT_Y          ; +10
 00005DF7  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _32,     60,60,35, 2                       ; eflags
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00005DF9  03		     1C     db  _DISPLAY            ; +0
 00005DFA  01		     1C     db  _EBP_RELATIVE       ; +1
 00005DFB  05		     1C     db  _32                ; +2
 00005DFC  003C		     1C     dw  60           ; +3
 00005DFE  3C		     1C     db  60             ; +5
 00005DFF  00000118	     1C     dd  35 * FONT_X          ; +6
 00005E03  0000000C	     1C     dd  2 * FONT_Y          ; +10
 00005E07  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_flag              60,64, _EFLAGS_NT, 31, 3, "nt"
			     1C ; Used to display a flag.  Note that the EBP reference is an offset on the stack, the use_bit represents the bit pattern for the flag
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;   USE_BIT - Indicates which bit in the DWORD quantity is to be examined
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to display, note the last character is used to inidcate whether the flag is up  or down 
			     1C ;
 00005E09  03		     1C     db  _DISPLAY
 00005E0A  04		     1C     db  _EBP_RELATIVE_EFLAG
 00005E0B  003C		     1C     dw  60
 00005E0D  40		     1C     db  64
 00005E0E  00004000	     1C     dd  1 SHL _EFLAGS_NT           ; Get the bit pattern to extract this one bit
 00005E12  000000F8	     1C     dd  31 * FONT_X
 00005E16  00000012	     1C     dd  3 * FONT_Y
 00005E1A  03		     1C     db  @SizeStr("nt") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 00005E1B  6E 74 19	     1C     db  "nt"
 00005E1E  00		     1C     db  0                       ; Null terminate the string (for display purposes)
			     1C   ; Total = <varies per item>
			      C     @DisplayEBP_flag              60,64, _EFLAGS_PF, 31, 4, "pf"
			     1C ; Used to display a flag.  Note that the EBP reference is an offset on the stack, the use_bit represents the bit pattern for the flag
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;   USE_BIT - Indicates which bit in the DWORD quantity is to be examined
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to display, note the last character is used to inidcate whether the flag is up  or down 
			     1C ;
 00005E1F  03		     1C     db  _DISPLAY
 00005E20  04		     1C     db  _EBP_RELATIVE_EFLAG
 00005E21  003C		     1C     dw  60
 00005E23  40		     1C     db  64
 00005E24  00000004	     1C     dd  1 SHL _EFLAGS_PF           ; Get the bit pattern to extract this one bit
 00005E28  000000F8	     1C     dd  31 * FONT_X
 00005E2C  00000018	     1C     dd  4 * FONT_Y
 00005E30  03		     1C     db  @SizeStr("pf") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 00005E31  70 66 19	     1C     db  "pf"
 00005E34  00		     1C     db  0                       ; Null terminate the string (for display purposes)
			     1C   ; Total = <varies per item>
			      C     @DisplayEBP_flag              60,64, _EFLAGS_DF, 31, 5, "df"
			     1C ; Used to display a flag.  Note that the EBP reference is an offset on the stack, the use_bit represents the bit pattern for the flag
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;   USE_BIT - Indicates which bit in the DWORD quantity is to be examined
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to display, note the last character is used to inidcate whether the flag is up  or down 
			     1C ;
 00005E35  03		     1C     db  _DISPLAY
 00005E36  04		     1C     db  _EBP_RELATIVE_EFLAG
 00005E37  003C		     1C     dw  60
 00005E39  40		     1C     db  64
 00005E3A  00000400	     1C     dd  1 SHL _EFLAGS_DF           ; Get the bit pattern to extract this one bit
 00005E3E  000000F8	     1C     dd  31 * FONT_X
 00005E42  0000001E	     1C     dd  5 * FONT_Y
 00005E46  03		     1C     db  @SizeStr("df") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 00005E47  64 66 19	     1C     db  "df"
 00005E4A  00		     1C     db  0                       ; Null terminate the string (for display purposes)
			     1C   ; Total = <varies per item>
			      C     @DisplayEBP_flag              60,64, _EFLAGS_OF, 35, 3, "of"
			     1C ; Used to display a flag.  Note that the EBP reference is an offset on the stack, the use_bit represents the bit pattern for the flag
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;   USE_BIT - Indicates which bit in the DWORD quantity is to be examined
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to display, note the last character is used to inidcate whether the flag is up  or down 
			     1C ;
 00005E4B  03		     1C     db  _DISPLAY
 00005E4C  04		     1C     db  _EBP_RELATIVE_EFLAG
 00005E4D  003C		     1C     dw  60
 00005E4F  40		     1C     db  64
 00005E50  00000800	     1C     dd  1 SHL _EFLAGS_OF           ; Get the bit pattern to extract this one bit
 00005E54  00000118	     1C     dd  35 * FONT_X
 00005E58  00000012	     1C     dd  3 * FONT_Y
 00005E5C  03		     1C     db  @SizeStr("of") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 00005E5D  6F 66 19	     1C     db  "of"
 00005E60  00		     1C     db  0                       ; Null terminate the string (for display purposes)
			     1C   ; Total = <varies per item>
			      C     @DisplayEBP_flag              60,64, _EFLAGS_SF, 35, 4, "sf"
			     1C ; Used to display a flag.  Note that the EBP reference is an offset on the stack, the use_bit represents the bit pattern for the flag
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;   USE_BIT - Indicates which bit in the DWORD quantity is to be examined
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to display, note the last character is used to inidcate whether the flag is up  or down 
			     1C ;
 00005E61  03		     1C     db  _DISPLAY
 00005E62  04		     1C     db  _EBP_RELATIVE_EFLAG
 00005E63  003C		     1C     dw  60
 00005E65  40		     1C     db  64
 00005E66  00000080	     1C     dd  1 SHL _EFLAGS_SF           ; Get the bit pattern to extract this one bit
 00005E6A  00000118	     1C     dd  35 * FONT_X
 00005E6E  00000018	     1C     dd  4 * FONT_Y
 00005E72  03		     1C     db  @SizeStr("sf") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 00005E73  73 66 19	     1C     db  "sf"
 00005E76  00		     1C     db  0                       ; Null terminate the string (for display purposes)
			     1C   ; Total = <varies per item>
			      C     @DisplayEBP_flag              60,64, _EFLAGS_ZF, 35, 5, "zf"
			     1C ; Used to display a flag.  Note that the EBP reference is an offset on the stack, the use_bit represents the bit pattern for the flag
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;   USE_BIT - Indicates which bit in the DWORD quantity is to be examined
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to display, note the last character is used to inidcate whether the flag is up  or down 
			     1C ;
 00005E77  03		     1C     db  _DISPLAY
 00005E78  04		     1C     db  _EBP_RELATIVE_EFLAG
 00005E79  003C		     1C     dw  60
 00005E7B  40		     1C     db  64
 00005E7C  00000040	     1C     dd  1 SHL _EFLAGS_ZF           ; Get the bit pattern to extract this one bit
 00005E80  00000118	     1C     dd  35 * FONT_X
 00005E84  0000001E	     1C     dd  5 * FONT_Y
 00005E88  03		     1C     db  @SizeStr("zf") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 00005E89  7A 66 19	     1C     db  "zf"
 00005E8C  00		     1C     db  0                       ; Null terminate the string (for display purposes)
			     1C   ; Total = <varies per item>
			      C     @DisplayEBP_flag              60,64,_EFLAGS_ACF, 39, 3, "acf"
			     1C ; Used to display a flag.  Note that the EBP reference is an offset on the stack, the use_bit represents the bit pattern for the flag
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;   USE_BIT - Indicates which bit in the DWORD quantity is to be examined
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to display, note the last character is used to inidcate whether the flag is up  or down 
			     1C ;
 00005E8D  03		     1C     db  _DISPLAY
 00005E8E  04		     1C     db  _EBP_RELATIVE_EFLAG
 00005E8F  003C		     1C     dw  60
 00005E91  40		     1C     db  64
 00005E92  00000010	     1C     dd  1 SHL _EFLAGS_ACF           ; Get the bit pattern to extract this one bit
 00005E96  00000138	     1C     dd  39 * FONT_X
 00005E9A  00000012	     1C     dd  3 * FONT_Y
 00005E9E  04		     1C     db  @SizeStr("acf") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 00005E9F  61 63 66 19	     1C     db  "acf"
 00005EA3  00		     1C     db  0                       ; Null terminate the string (for display purposes)
			     1C   ; Total = <varies per item>
			      C     @DisplayEBP_flag              60,64, _EFLAGS_IF, 40, 4, "if"
			     1C ; Used to display a flag.  Note that the EBP reference is an offset on the stack, the use_bit represents the bit pattern for the flag
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;   USE_BIT - Indicates which bit in the DWORD quantity is to be examined
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to display, note the last character is used to inidcate whether the flag is up  or down 
			     1C ;
 00005EA4  03		     1C     db  _DISPLAY
 00005EA5  04		     1C     db  _EBP_RELATIVE_EFLAG
 00005EA6  003C		     1C     dw  60
 00005EA8  40		     1C     db  64
 00005EA9  00000200	     1C     dd  1 SHL _EFLAGS_IF           ; Get the bit pattern to extract this one bit
 00005EAD  00000140	     1C     dd  40 * FONT_X
 00005EB1  00000018	     1C     dd  4 * FONT_Y
 00005EB5  03		     1C     db  @SizeStr("if") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 00005EB6  69 66 19	     1C     db  "if"
 00005EB9  00		     1C     db  0                       ; Null terminate the string (for display purposes)
			     1C   ; Total = <varies per item>
			      C     @DisplayEBP_flag              60,64, _EFLAGS_CF, 40, 5, "cf"
			     1C ; Used to display a flag.  Note that the EBP reference is an offset on the stack, the use_bit represents the bit pattern for the flag
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;   USE_BIT - Indicates which bit in the DWORD quantity is to be examined
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to display, note the last character is used to inidcate whether the flag is up  or down 
			     1C ;
 00005EBA  03		     1C     db  _DISPLAY
 00005EBB  04		     1C     db  _EBP_RELATIVE_EFLAG
 00005EBC  003C		     1C     dw  60
 00005EBE  40		     1C     db  64
 00005EBF  00000001	     1C     dd  1 SHL _EFLAGS_CF           ; Get the bit pattern to extract this one bit
 00005EC3  00000140	     1C     dd  40 * FONT_X
 00005EC7  0000001E	     1C     dd  5 * FONT_Y
 00005ECB  03		     1C     db  @SizeStr("cf") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 00005ECC  63 66 19	     1C     db  "cf"
 00005ECF  00		     1C     db  0                       ; Null terminate the string (for display purposes)
			     1C   ; Total = <varies per item>
			      C     @ObjectPostDisplay   _32,      1, 7, "data"
			     1C ; Used to display an object after all of the objects have been displayed.  This is done because this object references something
			     1C ; that is calculated in another window.  The data item is identified by name (string) and may or may not be displayed once the
			     1C ; entire processing has been completed.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to look for.  Other windows will issue @ObjectPostObject that will be searched
			     1C ;
 00005ED0  05		     1C     db  _POST_DISPLAY
 00005ED1  05		     1C     db  _32
 00005ED2  00000008	     1C     dd  1 * FONT_X
 00005ED6  0000002A	     1C     dd  7 * FONT_Y
 00005EDA  04		     1C     db  @SizeStr("data") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 00005EDB  64 61 74 61	     1C     db  "data"
			     1C   ; Total = <varies per item>
			      C     @ObjectPostDisplay   _32,      2, 8, "imm"
			     1C ; Used to display an object after all of the objects have been displayed.  This is done because this object references something
			     1C ; that is calculated in another window.  The data item is identified by name (string) and may or may not be displayed once the
			     1C ; entire processing has been completed.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to look for.  Other windows will issue @ObjectPostObject that will be searched
			     1C ;
 00005EDF  05		     1C     db  _POST_DISPLAY
 00005EE0  05		     1C     db  _32
 00005EE1  00000010	     1C     dd  2 * FONT_X
 00005EE5  00000030	     1C     dd  8 * FONT_Y
 00005EE9  03		     1C     db  @SizeStr("imm") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 00005EEA  69 6D 6D	     1C     db  "imm"
			     1C   ; Total = <varies per item>
			      C     @End
 00005EED  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C                           ; x1, y1, x2, y2, function() that handles it when this item is clicked
			      C ALIGN
 00005EEE		      C DEBI_b_mouse_objects:
			      C     @Left_single_click       1,  0,  1,  0, invDEBI_object_close
			     1C ; Used when a left single-click is recognized on these coordinates
 00005EEE  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 00005EEF  00000008	     1C     dd  1 * FONT_X                 ; +1
 00005EF3  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00005EF7  0000000F	     1C     dd  (1 * FONT_X) + FONT_X - 1  ; +9
 00005EFB  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00005EFF  0000510B R	     1C     dd  invDEBI_object_close                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00005F03  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00005F07  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00005F09  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      3,  0, 12,  0, invDEBI_reg_3_right_click
			     1C ; Used when a right single-click is recognized on these coordinates
 00005F0A  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 00005F0B  00000018	     1C     dd  3 * FONT_X                 ; +1
 00005F0F  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00005F13  00000067	     1C     dd  (12 * FONT_X) + FONT_X - 1  ; +9
 00005F17  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00005F1B  000039C0 R	     1C     dd  invDEBI_reg_3_right_click                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00005F1F  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00005F23  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00005F25  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         0,  0, 44,  0, invDEBI_object_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 00005F26  02		     1C     db  _LEFT_DRAG_START            ; +0
 00005F27  00000000	     1C     dd  0 * FONT_X                 ; +1
 00005F2B  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00005F2F  00000167	     1C     dd  (44 * FONT_X) + FONT_X - 1  ; +9
 00005F33  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00005F37  00003BE5 R	     1C     dd  invDEBI_object_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00005F3B  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00005F3F  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00005F41  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Abandon_if_not          6,  1, 43,  8
			     1C ; Used in a lengthy list.  If the coordinates are not within this range then the rest of the lengthy list is not checked
 00005F42  0C		     1C     db  _ABANDON_IF_NOT             ; +0
 00005F43  00000030	     1C     dd  6 * FONT_X                 ; +1
 00005F47  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00005F4B  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 00005F4F  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00005F53  0000000B [	     1C     db  11 dup(0ffh)                ; +17
	    FF
	   ]
			     1C   ; Total = 28
			      C     @Hover                   6,  1, 15,  1, 44, invDEBI_quick_watch_show_EBP_relative_32                        ; eax
			     1C ; Used when the mouse is hovering over these coordinates
 00005F5E  0A		     1C     db  _HOVER                      ; +0
 00005F5F  00000030	     1C     dd  6 * FONT_X                 ; +1
 00005F63  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00005F67  0000007F	     1C     dd  (15 * FONT_X) + FONT_X - 1  ; +9
 00005F6B  0000000B	     1C     dd  (1 * FONT_Y) + FONT_Y - 1  ; +13
 00005F6F  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 00005F73  002C		     1C     dw  lowword(offset 44)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00005F75  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  2, 15,  2, 40, invDEBI_quick_watch_show_EBP_relative_32                        ; ebx
			     1C ; Used when the mouse is hovering over these coordinates
 00005F7A  0A		     1C     db  _HOVER                      ; +0
 00005F7B  00000030	     1C     dd  6 * FONT_X                 ; +1
 00005F7F  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 00005F83  0000007F	     1C     dd  (15 * FONT_X) + FONT_X - 1  ; +9
 00005F87  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 00005F8B  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 00005F8F  0028		     1C     dw  lowword(offset 40)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00005F91  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  3, 15,  3, 36, invDEBI_quick_watch_show_EBP_relative_32                        ; ecx
			     1C ; Used when the mouse is hovering over these coordinates
 00005F96  0A		     1C     db  _HOVER                      ; +0
 00005F97  00000030	     1C     dd  6 * FONT_X                 ; +1
 00005F9B  00000012	     1C     dd  3 * FONT_Y                 ; +5
 00005F9F  0000007F	     1C     dd  (15 * FONT_X) + FONT_X - 1  ; +9
 00005FA3  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 00005FA7  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 00005FAB  0024		     1C     dw  lowword(offset 36)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00005FAD  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  4, 15,  4, 32, invDEBI_quick_watch_show_EBP_relative_32                        ; edx
			     1C ; Used when the mouse is hovering over these coordinates
 00005FB2  0A		     1C     db  _HOVER                      ; +0
 00005FB3  00000030	     1C     dd  6 * FONT_X                 ; +1
 00005FB7  00000018	     1C     dd  4 * FONT_Y                 ; +5
 00005FBB  0000007F	     1C     dd  (15 * FONT_X) + FONT_X - 1  ; +9
 00005FBF  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 00005FC3  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 00005FC7  0020		     1C     dw  lowword(offset 32)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00005FC9  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  5, 15,  5, 28, invDEBI_quick_watch_show_EBP_relative_32                        ; esi
			     1C ; Used when the mouse is hovering over these coordinates
 00005FCE  0A		     1C     db  _HOVER                      ; +0
 00005FCF  00000030	     1C     dd  6 * FONT_X                 ; +1
 00005FD3  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 00005FD7  0000007F	     1C     dd  (15 * FONT_X) + FONT_X - 1  ; +9
 00005FDB  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 00005FDF  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 00005FE3  001C		     1C     dw  lowword(offset 28)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00005FE5  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  6, 15,  6, 24, invDEBI_quick_watch_show_EBP_relative_32                        ; edi
			     1C ; Used when the mouse is hovering over these coordinates
 00005FEA  0A		     1C     db  _HOVER                      ; +0
 00005FEB  00000030	     1C     dd  6 * FONT_X                 ; +1
 00005FEF  00000024	     1C     dd  6 * FONT_Y                 ; +5
 00005FF3  0000007F	     1C     dd  (15 * FONT_X) + FONT_X - 1  ; +9
 00005FF7  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 00005FFB  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 00005FFF  0018		     1C     dw  lowword(offset 24)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006001  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  22,  1, 25,  1, 20, invDEBI_quick_watch_show_EBP_relative_selector                  ; ds
			     1C ; Used when the mouse is hovering over these coordinates
 00006006  0A		     1C     db  _HOVER                      ; +0
 00006007  000000B0	     1C     dd  22 * FONT_X                 ; +1
 0000600B  00000006	     1C     dd  1 * FONT_Y                 ; +5
 0000600F  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 00006013  0000000B	     1C     dd  (1 * FONT_Y) + FONT_Y - 1  ; +13
 00006017  00002D70 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_selector                        ; +17
 0000601B  0014		     1C     dw  lowword(offset 20)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000601D  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  22,  2, 25,  2, 16, invDEBI_quick_watch_show_EBP_relative_selector                  ; es
			     1C ; Used when the mouse is hovering over these coordinates
 00006022  0A		     1C     db  _HOVER                      ; +0
 00006023  000000B0	     1C     dd  22 * FONT_X                 ; +1
 00006027  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 0000602B  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 0000602F  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 00006033  00002D70 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_selector                        ; +17
 00006037  0010		     1C     dw  lowword(offset 16)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006039  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  22,  3, 25,  3, 12, invDEBI_quick_watch_show_EBP_relative_selector                  ; fs
			     1C ; Used when the mouse is hovering over these coordinates
 0000603E  0A		     1C     db  _HOVER                      ; +0
 0000603F  000000B0	     1C     dd  22 * FONT_X                 ; +1
 00006043  00000012	     1C     dd  3 * FONT_Y                 ; +5
 00006047  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 0000604B  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 0000604F  00002D70 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_selector                        ; +17
 00006053  000C		     1C     dw  lowword(offset 12)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006055  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  22,  4, 25,  4,  8, invDEBI_quick_watch_show_EBP_relative_selector                  ; gs
			     1C ; Used when the mouse is hovering over these coordinates
 0000605A  0A		     1C     db  _HOVER                      ; +0
 0000605B  000000B0	     1C     dd  22 * FONT_X                 ; +1
 0000605F  00000018	     1C     dd  4 * FONT_Y                 ; +5
 00006063  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 00006067  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 0000606B  00002D70 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_selector                        ; +17
 0000606F  0008		     1C     dw  lowword(offset 8)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006071  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  22,  6, 25,  6,  4, invDEBI_quick_watch_show_EBP_relative_selector                  ; ss
			     1C ; Used when the mouse is hovering over these coordinates
 00006076  0A		     1C     db  _HOVER                      ; +0
 00006077  000000B0	     1C     dd  22 * FONT_X                 ; +1
 0000607B  00000024	     1C     dd  6 * FONT_Y                 ; +5
 0000607F  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 00006083  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 00006087  00002D70 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_selector                        ; +17
 0000608B  0004		     1C     dw  lowword(offset 4)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000608D  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  22,  7, 29,  7, -4, invDEBI_quick_watch_show_EBP_relative_32                        ; esp
			     1C ; Used when the mouse is hovering over these coordinates
 00006092  0A		     1C     db  _HOVER                      ; +0
 00006093  000000B0	     1C     dd  22 * FONT_X                 ; +1
 00006097  0000002A	     1C     dd  7 * FONT_Y                 ; +5
 0000609B  000000EF	     1C     dd  (29 * FONT_X) + FONT_X - 1  ; +9
 0000609F  0000002F	     1C     dd  (7 * FONT_Y) + FONT_Y - 1  ; +13
 000060A3  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 000060A7  FFFC		     1C     dw  lowword(offset -4)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000060A9  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  22,  8, 29,  8,  0, invDEBI_quick_watch_show_EBP_relative_32                        ; ebp
			     1C ; Used when the mouse is hovering over these coordinates
 000060AE  0A		     1C     db  _HOVER                      ; +0
 000060AF  000000B0	     1C     dd  22 * FONT_X                 ; +1
 000060B3  00000030	     1C     dd  8 * FONT_Y                 ; +5
 000060B7  000000EF	     1C     dd  (29 * FONT_X) + FONT_X - 1  ; +9
 000060BB  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 000060BF  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 000060C3  0000		     1C     dw  lowword(offset 0)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000060C5  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  36,  7, 39,  7, 56, invDEBI_quick_watch_show_EBP_relative_selector                  ; cs
			     1C ; Used when the mouse is hovering over these coordinates
 000060CA  0A		     1C     db  _HOVER                      ; +0
 000060CB  00000120	     1C     dd  36 * FONT_X                 ; +1
 000060CF  0000002A	     1C     dd  7 * FONT_Y                 ; +5
 000060D3  0000013F	     1C     dd  (39 * FONT_X) + FONT_X - 1  ; +9
 000060D7  0000002F	     1C     dd  (7 * FONT_Y) + FONT_Y - 1  ; +13
 000060DB  00002D70 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_selector                        ; +17
 000060DF  0038		     1C     dw  lowword(offset 56)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000060E1  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  36,  8, 43,  8, 52, invDEBI_quick_watch_show_EBP_relative_32                        ; eip
			     1C ; Used when the mouse is hovering over these coordinates
 000060E6  0A		     1C     db  _HOVER                      ; +0
 000060E7  00000120	     1C     dd  36 * FONT_X                 ; +1
 000060EB  00000030	     1C     dd  8 * FONT_Y                 ; +5
 000060EF  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 000060F3  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 000060F7  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 000060FB  0034		     1C     dw  lowword(offset 52)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000060FD  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  35,  2, 42,  2, 60, invDEBI_quick_watch_show_EBP_relative_32                        ; eflags
			     1C ; Used when the mouse is hovering over these coordinates
 00006102  0A		     1C     db  _HOVER                      ; +0
 00006103  00000118	     1C     dd  35 * FONT_X                 ; +1
 00006107  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 0000610B  00000157	     1C     dd  (42 * FONT_X) + FONT_X - 1  ; +9
 0000610F  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 00006113  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 00006117  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006119  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  31,  3, 33,  3, 60, invDEBI_quick_watch_show_EBP_relative_eflags, _EFLAGS_NT
			     1C ; Used when the mouse is hovering over these coordinates
 0000611E  0A		     1C     db  _HOVER                      ; +0
 0000611F  000000F8	     1C     dd  31 * FONT_X                 ; +1
 00006123  00000012	     1C     dd  3 * FONT_Y                 ; +5
 00006127  0000010F	     1C     dd  (33 * FONT_X) + FONT_X - 1  ; +9
 0000612B  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 0000612F  000050ED R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_eflags                        ; +17
 00006133  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_NT>
 00006135  000E		     1C         dw  _EFLAGS_NT                   ; +23
 00006137  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  31,  4, 33,  4, 60, invDEBI_quick_watch_show_EBP_relative_eflags, _EFLAGS_PF
			     1C ; Used when the mouse is hovering over these coordinates
 0000613A  0A		     1C     db  _HOVER                      ; +0
 0000613B  000000F8	     1C     dd  31 * FONT_X                 ; +1
 0000613F  00000018	     1C     dd  4 * FONT_Y                 ; +5
 00006143  0000010F	     1C     dd  (33 * FONT_X) + FONT_X - 1  ; +9
 00006147  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 0000614B  000050ED R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_eflags                        ; +17
 0000614F  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_PF>
 00006151  0002		     1C         dw  _EFLAGS_PF                   ; +23
 00006153  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  31,  5, 33,  5, 60, invDEBI_quick_watch_show_EBP_relative_eflags, _EFLAGS_DF
			     1C ; Used when the mouse is hovering over these coordinates
 00006156  0A		     1C     db  _HOVER                      ; +0
 00006157  000000F8	     1C     dd  31 * FONT_X                 ; +1
 0000615B  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 0000615F  0000010F	     1C     dd  (33 * FONT_X) + FONT_X - 1  ; +9
 00006163  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 00006167  000050ED R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_eflags                        ; +17
 0000616B  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_DF>
 0000616D  000A		     1C         dw  _EFLAGS_DF                   ; +23
 0000616F  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  35,  3, 37,  3, 60, invDEBI_quick_watch_show_EBP_relative_eflags, _EFLAGS_OF
			     1C ; Used when the mouse is hovering over these coordinates
 00006172  0A		     1C     db  _HOVER                      ; +0
 00006173  00000118	     1C     dd  35 * FONT_X                 ; +1
 00006177  00000012	     1C     dd  3 * FONT_Y                 ; +5
 0000617B  0000012F	     1C     dd  (37 * FONT_X) + FONT_X - 1  ; +9
 0000617F  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 00006183  000050ED R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_eflags                        ; +17
 00006187  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_OF>
 00006189  000B		     1C         dw  _EFLAGS_OF                   ; +23
 0000618B  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  35,  4, 37,  4, 60, invDEBI_quick_watch_show_EBP_relative_eflags, _EFLAGS_SF
			     1C ; Used when the mouse is hovering over these coordinates
 0000618E  0A		     1C     db  _HOVER                      ; +0
 0000618F  00000118	     1C     dd  35 * FONT_X                 ; +1
 00006193  00000018	     1C     dd  4 * FONT_Y                 ; +5
 00006197  0000012F	     1C     dd  (37 * FONT_X) + FONT_X - 1  ; +9
 0000619B  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 0000619F  000050ED R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_eflags                        ; +17
 000061A3  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_SF>
 000061A5  0007		     1C         dw  _EFLAGS_SF                   ; +23
 000061A7  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  35,  5, 37,  5, 60, invDEBI_quick_watch_show_EBP_relative_eflags, _EFLAGS_ZF
			     1C ; Used when the mouse is hovering over these coordinates
 000061AA  0A		     1C     db  _HOVER                      ; +0
 000061AB  00000118	     1C     dd  35 * FONT_X                 ; +1
 000061AF  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 000061B3  0000012F	     1C     dd  (37 * FONT_X) + FONT_X - 1  ; +9
 000061B7  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 000061BB  000050ED R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_eflags                        ; +17
 000061BF  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_ZF>
 000061C1  0006		     1C         dw  _EFLAGS_ZF                   ; +23
 000061C3  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  39,  3, 42,  3, 60, invDEBI_quick_watch_show_EBP_relative_eflags, _EFLAGS_ACF
			     1C ; Used when the mouse is hovering over these coordinates
 000061C6  0A		     1C     db  _HOVER                      ; +0
 000061C7  00000138	     1C     dd  39 * FONT_X                 ; +1
 000061CB  00000012	     1C     dd  3 * FONT_Y                 ; +5
 000061CF  00000157	     1C     dd  (42 * FONT_X) + FONT_X - 1  ; +9
 000061D3  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 000061D7  000050ED R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_eflags                        ; +17
 000061DB  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_ACF>
 000061DD  0004		     1C         dw  _EFLAGS_ACF                   ; +23
 000061DF  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  40,  4, 42,  4, 60, invDEBI_quick_watch_show_EBP_relative_eflags, _EFLAGS_IF
			     1C ; Used when the mouse is hovering over these coordinates
 000061E2  0A		     1C     db  _HOVER                      ; +0
 000061E3  00000140	     1C     dd  40 * FONT_X                 ; +1
 000061E7  00000018	     1C     dd  4 * FONT_Y                 ; +5
 000061EB  00000157	     1C     dd  (42 * FONT_X) + FONT_X - 1  ; +9
 000061EF  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 000061F3  000050ED R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_eflags                        ; +17
 000061F7  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_IF>
 000061F9  0009		     1C         dw  _EFLAGS_IF                   ; +23
 000061FB  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  40,  5, 42,  5, 60, invDEBI_quick_watch_show_EBP_relative_eflags, _EFLAGS_CF
			     1C ; Used when the mouse is hovering over these coordinates
 000061FE  0A		     1C     db  _HOVER                      ; +0
 000061FF  00000140	     1C     dd  40 * FONT_X                 ; +1
 00006203  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 00006207  00000157	     1C     dd  (42 * FONT_X) + FONT_X - 1  ; +9
 0000620B  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 0000620F  000050ED R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_eflags                        ; +17
 00006213  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_CF>
 00006215  0000		     1C         dw  _EFLAGS_CF                   ; +23
 00006217  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                    6,  1, 15,  1, 44, edit_dword                                                      ; eax
			     1C ; Used when a left-click is recognized on an item that can be edited
 0000621A  0B		     1C     db  _EDIT                       ; +0
 0000621B  00000030	     1C     dd  6 * FONT_X                 ; +1
 0000621F  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00006223  0000007F	     1C     dd  (15 * FONT_X) + FONT_X - 1  ; +9
 00006227  0000000B	     1C     dd  (1 * FONT_Y) + FONT_Y - 1  ; +13
 0000622B  0000B76A R	     1C     dd  edit_dword                        ; +17
 0000622F  002C		     1C     dw  lowword(offset 44)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006231  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                    6,  2, 15,  2, 40, edit_dword                                                      ; ebx
			     1C ; Used when a left-click is recognized on an item that can be edited
 00006236  0B		     1C     db  _EDIT                       ; +0
 00006237  00000030	     1C     dd  6 * FONT_X                 ; +1
 0000623B  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 0000623F  0000007F	     1C     dd  (15 * FONT_X) + FONT_X - 1  ; +9
 00006243  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 00006247  0000B76A R	     1C     dd  edit_dword                        ; +17
 0000624B  0028		     1C     dw  lowword(offset 40)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000624D  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                    6,  3, 15,  3, 36, edit_dword                                                      ; ecx
			     1C ; Used when a left-click is recognized on an item that can be edited
 00006252  0B		     1C     db  _EDIT                       ; +0
 00006253  00000030	     1C     dd  6 * FONT_X                 ; +1
 00006257  00000012	     1C     dd  3 * FONT_Y                 ; +5
 0000625B  0000007F	     1C     dd  (15 * FONT_X) + FONT_X - 1  ; +9
 0000625F  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 00006263  0000B76A R	     1C     dd  edit_dword                        ; +17
 00006267  0024		     1C     dw  lowword(offset 36)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006269  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                    6,  4, 15,  4, 32, edit_dword                                                      ; edx
			     1C ; Used when a left-click is recognized on an item that can be edited
 0000626E  0B		     1C     db  _EDIT                       ; +0
 0000626F  00000030	     1C     dd  6 * FONT_X                 ; +1
 00006273  00000018	     1C     dd  4 * FONT_Y                 ; +5
 00006277  0000007F	     1C     dd  (15 * FONT_X) + FONT_X - 1  ; +9
 0000627B  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 0000627F  0000B76A R	     1C     dd  edit_dword                        ; +17
 00006283  0020		     1C     dw  lowword(offset 32)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006285  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                    6,  5, 15,  5, 28, edit_dword                                                      ; esi
			     1C ; Used when a left-click is recognized on an item that can be edited
 0000628A  0B		     1C     db  _EDIT                       ; +0
 0000628B  00000030	     1C     dd  6 * FONT_X                 ; +1
 0000628F  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 00006293  0000007F	     1C     dd  (15 * FONT_X) + FONT_X - 1  ; +9
 00006297  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 0000629B  0000B76A R	     1C     dd  edit_dword                        ; +17
 0000629F  001C		     1C     dw  lowword(offset 28)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000062A1  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                    6,  6, 15,  6, 24, edit_dword                                                      ; edi
			     1C ; Used when a left-click is recognized on an item that can be edited
 000062A6  0B		     1C     db  _EDIT                       ; +0
 000062A7  00000030	     1C     dd  6 * FONT_X                 ; +1
 000062AB  00000024	     1C     dd  6 * FONT_Y                 ; +5
 000062AF  0000007F	     1C     dd  (15 * FONT_X) + FONT_X - 1  ; +9
 000062B3  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 000062B7  0000B76A R	     1C     dd  edit_dword                        ; +17
 000062BB  0018		     1C     dw  lowword(offset 24)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000062BD  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   22,  1, 25,  1, 20, edit_word                                                       ; ds
			     1C ; Used when a left-click is recognized on an item that can be edited
 000062C2  0B		     1C     db  _EDIT                       ; +0
 000062C3  000000B0	     1C     dd  22 * FONT_X                 ; +1
 000062C7  00000006	     1C     dd  1 * FONT_Y                 ; +5
 000062CB  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 000062CF  0000000B	     1C     dd  (1 * FONT_Y) + FONT_Y - 1  ; +13
 000062D3  0000B768 R	     1C     dd  edit_word                        ; +17
 000062D7  0014		     1C     dw  lowword(offset 20)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000062D9  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   22,  2, 25,  2, 16, edit_word                                                       ; es
			     1C ; Used when a left-click is recognized on an item that can be edited
 000062DE  0B		     1C     db  _EDIT                       ; +0
 000062DF  000000B0	     1C     dd  22 * FONT_X                 ; +1
 000062E3  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 000062E7  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 000062EB  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 000062EF  0000B768 R	     1C     dd  edit_word                        ; +17
 000062F3  0010		     1C     dw  lowword(offset 16)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000062F5  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   22,  3, 25,  3, 12, edit_word                                                       ; fs
			     1C ; Used when a left-click is recognized on an item that can be edited
 000062FA  0B		     1C     db  _EDIT                       ; +0
 000062FB  000000B0	     1C     dd  22 * FONT_X                 ; +1
 000062FF  00000012	     1C     dd  3 * FONT_Y                 ; +5
 00006303  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 00006307  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 0000630B  0000B768 R	     1C     dd  edit_word                        ; +17
 0000630F  000C		     1C     dw  lowword(offset 12)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006311  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   22,  4, 25,  4,  8, edit_word                                                       ; gs
			     1C ; Used when a left-click is recognized on an item that can be edited
 00006316  0B		     1C     db  _EDIT                       ; +0
 00006317  000000B0	     1C     dd  22 * FONT_X                 ; +1
 0000631B  00000018	     1C     dd  4 * FONT_Y                 ; +5
 0000631F  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 00006323  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 00006327  0000B768 R	     1C     dd  edit_word                        ; +17
 0000632B  0008		     1C     dw  lowword(offset 8)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000632D  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   22,  6, 25,  6,  4, edit_word                                                       ; ss
			     1C ; Used when a left-click is recognized on an item that can be edited
 00006332  0B		     1C     db  _EDIT                       ; +0
 00006333  000000B0	     1C     dd  22 * FONT_X                 ; +1
 00006337  00000024	     1C     dd  6 * FONT_Y                 ; +5
 0000633B  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 0000633F  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 00006343  0000B768 R	     1C     dd  edit_word                        ; +17
 00006347  0004		     1C     dw  lowword(offset 4)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006349  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   22,  7, 29,  7, -4, edit_dword                                                      ; esp
			     1C ; Used when a left-click is recognized on an item that can be edited
 0000634E  0B		     1C     db  _EDIT                       ; +0
 0000634F  000000B0	     1C     dd  22 * FONT_X                 ; +1
 00006353  0000002A	     1C     dd  7 * FONT_Y                 ; +5
 00006357  000000EF	     1C     dd  (29 * FONT_X) + FONT_X - 1  ; +9
 0000635B  0000002F	     1C     dd  (7 * FONT_Y) + FONT_Y - 1  ; +13
 0000635F  0000B76A R	     1C     dd  edit_dword                        ; +17
 00006363  FFFC		     1C     dw  lowword(offset -4)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006365  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   22,  8, 29,  8,  0, edit_dword                                                      ; ebp
			     1C ; Used when a left-click is recognized on an item that can be edited
 0000636A  0B		     1C     db  _EDIT                       ; +0
 0000636B  000000B0	     1C     dd  22 * FONT_X                 ; +1
 0000636F  00000030	     1C     dd  8 * FONT_Y                 ; +5
 00006373  000000EF	     1C     dd  (29 * FONT_X) + FONT_X - 1  ; +9
 00006377  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 0000637B  0000B76A R	     1C     dd  edit_dword                        ; +17
 0000637F  0000		     1C     dw  lowword(offset 0)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006381  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   36,  7, 39,  7, 56, edit_word                                                       ; cs
			     1C ; Used when a left-click is recognized on an item that can be edited
 00006386  0B		     1C     db  _EDIT                       ; +0
 00006387  00000120	     1C     dd  36 * FONT_X                 ; +1
 0000638B  0000002A	     1C     dd  7 * FONT_Y                 ; +5
 0000638F  0000013F	     1C     dd  (39 * FONT_X) + FONT_X - 1  ; +9
 00006393  0000002F	     1C     dd  (7 * FONT_Y) + FONT_Y - 1  ; +13
 00006397  0000B768 R	     1C     dd  edit_word                        ; +17
 0000639B  0038		     1C     dw  lowword(offset 56)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000639D  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   36,  8, 43,  8, 52, edit_dword                                                      ; eip
			     1C ; Used when a left-click is recognized on an item that can be edited
 000063A2  0B		     1C     db  _EDIT                       ; +0
 000063A3  00000120	     1C     dd  36 * FONT_X                 ; +1
 000063A7  00000030	     1C     dd  8 * FONT_Y                 ; +5
 000063AB  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 000063AF  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 000063B3  0000B76A R	     1C     dd  edit_dword                        ; +17
 000063B7  0034		     1C     dw  lowword(offset 52)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000063B9  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   35,  2, 42,  2, 60, edit_dword                                                      ; eflags
			     1C ; Used when a left-click is recognized on an item that can be edited
 000063BE  0B		     1C     db  _EDIT                       ; +0
 000063BF  00000118	     1C     dd  35 * FONT_X                 ; +1
 000063C3  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 000063C7  00000157	     1C     dd  (42 * FONT_X) + FONT_X - 1  ; +9
 000063CB  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 000063CF  0000B76A R	     1C     dd  edit_dword                        ; +17
 000063D3  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000063D5  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   31,  3, 33,  3, 60, edit_flags, _EFLAGS_NT
			     1C ; Used when a left-click is recognized on an item that can be edited
 000063DA  0B		     1C     db  _EDIT                       ; +0
 000063DB  000000F8	     1C     dd  31 * FONT_X                 ; +1
 000063DF  00000012	     1C     dd  3 * FONT_Y                 ; +5
 000063E3  0000010F	     1C     dd  (33 * FONT_X) + FONT_X - 1  ; +9
 000063E7  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 000063EB  0000B76E R	     1C     dd  edit_flags                        ; +17
 000063EF  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_NT>
 000063F1  000E		     1C         dw  _EFLAGS_NT                   ; +23
 000063F3  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   31,  4, 33,  4, 60, edit_flags, _EFLAGS_PF
			     1C ; Used when a left-click is recognized on an item that can be edited
 000063F6  0B		     1C     db  _EDIT                       ; +0
 000063F7  000000F8	     1C     dd  31 * FONT_X                 ; +1
 000063FB  00000018	     1C     dd  4 * FONT_Y                 ; +5
 000063FF  0000010F	     1C     dd  (33 * FONT_X) + FONT_X - 1  ; +9
 00006403  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 00006407  0000B76E R	     1C     dd  edit_flags                        ; +17
 0000640B  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_PF>
 0000640D  0002		     1C         dw  _EFLAGS_PF                   ; +23
 0000640F  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   31,  5, 33,  5, 60, edit_flags, _EFLAGS_DF
			     1C ; Used when a left-click is recognized on an item that can be edited
 00006412  0B		     1C     db  _EDIT                       ; +0
 00006413  000000F8	     1C     dd  31 * FONT_X                 ; +1
 00006417  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 0000641B  0000010F	     1C     dd  (33 * FONT_X) + FONT_X - 1  ; +9
 0000641F  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 00006423  0000B76E R	     1C     dd  edit_flags                        ; +17
 00006427  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_DF>
 00006429  000A		     1C         dw  _EFLAGS_DF                   ; +23
 0000642B  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   35,  3, 37,  3, 60, edit_flags, _EFLAGS_OF
			     1C ; Used when a left-click is recognized on an item that can be edited
 0000642E  0B		     1C     db  _EDIT                       ; +0
 0000642F  00000118	     1C     dd  35 * FONT_X                 ; +1
 00006433  00000012	     1C     dd  3 * FONT_Y                 ; +5
 00006437  0000012F	     1C     dd  (37 * FONT_X) + FONT_X - 1  ; +9
 0000643B  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 0000643F  0000B76E R	     1C     dd  edit_flags                        ; +17
 00006443  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_OF>
 00006445  000B		     1C         dw  _EFLAGS_OF                   ; +23
 00006447  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   35,  4, 37,  4, 60, edit_flags, _EFLAGS_SF
			     1C ; Used when a left-click is recognized on an item that can be edited
 0000644A  0B		     1C     db  _EDIT                       ; +0
 0000644B  00000118	     1C     dd  35 * FONT_X                 ; +1
 0000644F  00000018	     1C     dd  4 * FONT_Y                 ; +5
 00006453  0000012F	     1C     dd  (37 * FONT_X) + FONT_X - 1  ; +9
 00006457  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 0000645B  0000B76E R	     1C     dd  edit_flags                        ; +17
 0000645F  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_SF>
 00006461  0007		     1C         dw  _EFLAGS_SF                   ; +23
 00006463  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   35,  5, 37,  5, 60, edit_flags, _EFLAGS_ZF
			     1C ; Used when a left-click is recognized on an item that can be edited
 00006466  0B		     1C     db  _EDIT                       ; +0
 00006467  00000118	     1C     dd  35 * FONT_X                 ; +1
 0000646B  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 0000646F  0000012F	     1C     dd  (37 * FONT_X) + FONT_X - 1  ; +9
 00006473  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 00006477  0000B76E R	     1C     dd  edit_flags                        ; +17
 0000647B  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_ZF>
 0000647D  0006		     1C         dw  _EFLAGS_ZF                   ; +23
 0000647F  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   39,  3, 42,  3, 60, edit_flags, _EFLAGS_ACF
			     1C ; Used when a left-click is recognized on an item that can be edited
 00006482  0B		     1C     db  _EDIT                       ; +0
 00006483  00000138	     1C     dd  39 * FONT_X                 ; +1
 00006487  00000012	     1C     dd  3 * FONT_Y                 ; +5
 0000648B  00000157	     1C     dd  (42 * FONT_X) + FONT_X - 1  ; +9
 0000648F  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 00006493  0000B76E R	     1C     dd  edit_flags                        ; +17
 00006497  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_ACF>
 00006499  0004		     1C         dw  _EFLAGS_ACF                   ; +23
 0000649B  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   40,  4, 42,  4, 60, edit_flags, _EFLAGS_IF
			     1C ; Used when a left-click is recognized on an item that can be edited
 0000649E  0B		     1C     db  _EDIT                       ; +0
 0000649F  00000140	     1C     dd  40 * FONT_X                 ; +1
 000064A3  00000018	     1C     dd  4 * FONT_Y                 ; +5
 000064A7  00000157	     1C     dd  (42 * FONT_X) + FONT_X - 1  ; +9
 000064AB  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 000064AF  0000B76E R	     1C     dd  edit_flags                        ; +17
 000064B3  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_IF>
 000064B5  0009		     1C         dw  _EFLAGS_IF                   ; +23
 000064B7  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   40,  5, 42,  5, 60, edit_flags, _EFLAGS_CF
			     1C ; Used when a left-click is recognized on an item that can be edited
 000064BA  0B		     1C     db  _EDIT                       ; +0
 000064BB  00000140	     1C     dd  40 * FONT_X                 ; +1
 000064BF  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 000064C3  00000157	     1C     dd  (42 * FONT_X) + FONT_X - 1  ; +9
 000064C7  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 000064CB  0000B76E R	     1C     dd  edit_flags                        ; +17
 000064CF  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_CF>
 000064D1  0000		     1C         dw  _EFLAGS_CF                   ; +23
 000064D3  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @End
 000064D6  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
			      C                                 ;   00000000-112233445566.. mov     dx,fs:[esi+ebx+00eeddcc]
			      C                                 ;          11111111112222222222333333333344444444445555555555
			      C                                 ;012345678901234567890123456789012345678901234567890123456789
 000064D7 C9 9A CD 81 20      C DEBI_c_window               db  "…öÕÅ CFSCA.2 ÖÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª",0
	   43 46 53 43 41
	   2E 32 20 85 CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD BB
	   00
 00006514  CC CC CC CC 20     C                             db  "ÃÃÃÃ                                                       ∫",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00006551  FE 18	      C                             db  254,24
			      C 
 00006553		      C DEBI_c_keyboard_objects:
			      C     @FunctionHandlesObject  invDEBI_CFSCA_kbd_handler
 00006553  07		     1C     db  _FUNCTION
 00006554  000050D4 R	     1C     dd  offset invDEBI_CFSCA_kbd_handler
			     1C   ; Total = 5
			      C     @End
 00006558  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
 00006559  01E0		      C                             dw  60 * FONT_X
 0000655B  009B		      C                             dw  26 * FONT_Y - 1
 0000655D		      C DEBI_c_screen_objects:
			      C     @DrawWindow             DEBI_c_window
			     1C ; Draws the window for whatever item is specified
 0000655D  FD		     1C     db  _DRAW_WINDOW
 0000655E  000064D7 R	     1C     dd  offset DEBI_c_window
			     1C   ; Total = 5
			      C     @ObjectMemSize          4
			     1C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
 00006562  00		     1C     db  _OBJECT_MEM_SIZE
 00006563  04		     1C     db  4
			     1C   ; Total = 2
			      C     @FunctionHandlesObject  invDEBI_cfsca_2_window
 00006564  07		     1C     db  _FUNCTION
 00006565  00004FB8 R	     1C     dd  offset invDEBI_cfsca_2_window
			     1C   ; Total = 5
			      C     @End
 00006569  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C ALIGN
 0000656A		      C DEBI_c_mouse_objects:
			      C     @Left_single_click       1,  0,  1,  0, invDEBI_object_close
			     1C ; Used when a left single-click is recognized on these coordinates
 0000656A  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000656B  00000008	     1C     dd  1 * FONT_X                 ; +1
 0000656F  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00006573  0000000F	     1C     dd  (1 * FONT_X) + FONT_X - 1  ; +9
 00006577  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 0000657B  0000510B R	     1C     dd  invDEBI_object_close                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 0000657F  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00006583  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00006585  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      3,  0, 13,  0, invDEBI_cfsca_2_right_click
			     1C ; Used when a right single-click is recognized on these coordinates
 00006586  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 00006587  00000018	     1C     dd  3 * FONT_X                 ; +1
 0000658B  00000000	     1C     dd  0 * FONT_Y                 ; +5
 0000658F  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00006593  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00006597  000039C5 R	     1C     dd  invDEBI_cfsca_2_right_click                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 0000659B  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000659F  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 000065A1  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         0,  0, 59,  0, invDEBI_object_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 000065A2  02		     1C     db  _LEFT_DRAG_START            ; +0
 000065A3  00000000	     1C     dd  0 * FONT_X                 ; +1
 000065A7  00000000	     1C     dd  0 * FONT_Y                 ; +5
 000065AB  000001DF	     1C     dd  (59 * FONT_X) + FONT_X - 1  ; +9
 000065AF  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 000065B3  00003BE5 R	     1C     dd  invDEBI_object_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 000065B7  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 000065BB  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 000065BD  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @End
 000065BE  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
			      C                                 ;   00000000-112233445566.. mov     dx,fs:[esi+ebx+00eeddcc]
			      C                                 ;          11111111112222222222333333333344444444445555555555
			      C                                 ;012345678901234567890123456789012345678901234567890123456789
 000065BF C9 9A CD 81 20      C DEBI_d_window               db  "…öÕÅ CFSCA.3 ÖÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª",0
	   43 46 53 43 41
	   2E 33 20 85 CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD BB
	   00
 000065FC  CC CC CC CC 20     C                             db  "ÃÃÃÃ                                                       ∫",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00006639  FE 25	      C                             db  254, 37
			      C 
 0000663B		      C DEBI_d_keyboard_objects:
			      C     @FunctionHandlesObject  invDEBI_CFSCA_kbd_handler
 0000663B  07		     1C     db  _FUNCTION
 0000663C  000050D4 R	     1C     dd  offset invDEBI_CFSCA_kbd_handler
			     1C   ; Total = 5
			      C     @End
 00006640  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
 00006641  01E0		      C                             dw  60 * FONT_X
 00006643  00E9		      C                             dw  39 * FONT_Y - 1
 00006645		      C DEBI_d_screen_objects:
			      C     @DrawWindow             DEBI_d_window
			     1C ; Draws the window for whatever item is specified
 00006645  FD		     1C     db  _DRAW_WINDOW
 00006646  000065BF R	     1C     dd  offset DEBI_d_window
			     1C   ; Total = 5
			      C     @ObjectMemSize          4
			     1C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
 0000664A  00		     1C     db  _OBJECT_MEM_SIZE
 0000664B  04		     1C     db  4
			     1C   ; Total = 2
			      C     @FunctionHandlesObject  invDEBI_cfsca_3_window
 0000664C  07		     1C     db  _FUNCTION
 0000664D  00004FC1 R	     1C     dd  offset invDEBI_cfsca_3_window
			     1C   ; Total = 5
			      C     @End
 00006651  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C ALIGN
 00006652		      C DEBI_d_mouse_objects:
			      C     @Left_single_click       1,  0,  1,  0, invDEBI_object_close
			     1C ; Used when a left single-click is recognized on these coordinates
 00006652  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 00006653  00000008	     1C     dd  1 * FONT_X                 ; +1
 00006657  00000000	     1C     dd  0 * FONT_Y                 ; +5
 0000665B  0000000F	     1C     dd  (1 * FONT_X) + FONT_X - 1  ; +9
 0000665F  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00006663  0000510B R	     1C     dd  invDEBI_object_close                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00006667  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000666B  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000666D  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      3,  0, 13,  0, invDEBI_cfsca_3_right_click
			     1C ; Used when a right single-click is recognized on these coordinates
 0000666E  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 0000666F  00000018	     1C     dd  3 * FONT_X                 ; +1
 00006673  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00006677  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 0000667B  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 0000667F  000039C5 R	     1C     dd  invDEBI_cfsca_3_right_click                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00006683  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00006687  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00006689  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         0,  0, 59,  0, invDEBI_object_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 0000668A  02		     1C     db  _LEFT_DRAG_START            ; +0
 0000668B  00000000	     1C     dd  0 * FONT_X                 ; +1
 0000668F  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00006693  000001DF	     1C     dd  (59 * FONT_X) + FONT_X - 1  ; +9
 00006697  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 0000669B  00003BE5 R	     1C     dd  invDEBI_object_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 0000669F  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 000066A3  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 000066A5  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @End
 000066A6  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
			      C 
			      C                                 ;          11111111112222222222333333333344444
			      C                                 ;012345678901234567890123456789012345678901234
 000066A7 C9 9A CD 81 20      C DEBI_e_window               db  "…öÕÅ FPU.Summary ÖÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª",0
	   46 50 55 2E 53
	   75 6D 6D 61 72
	   79 20 85 CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD BB
	   00
 000066D5  73 74 37 20 FA     C                             db  "st7 ˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥   cw ˙˙˙˙.˙˙˙˙   ∫",0
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   B3 20 20 20 63
	   77 20 FA FA FA
	   FA 2E FA FA FA
	   FA 20 20 20 BA
	   00
 00006703  73 74 36 20 FA     C                             db  "st6 ˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥   sw ˙˙˙˙.˙˙˙˙   ∫",0
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   B3 20 20 20 73
	   77 20 FA FA FA
	   FA 2E FA FA FA
	   FA 20 20 20 BA
	   00
 00006731  73 74 35 20 FA     C                             db  "st5 ˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥   tw ˙˙˙˙.˙˙˙˙   ∫",0
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   B3 20 20 20 74
	   77 20 FA FA FA
	   FA 2E FA FA FA
	   FA 20 20 20 BA
	   00
 0000675F  73 74 34 20 FA     C                             db  "st4 ˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥  fcs ˙˙˙˙.˙˙˙˙   ∫",0
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   B3 20 20 66 63
	   73 20 FA FA FA
	   FA 2E FA FA FA
	   FA 20 20 20 BA
	   00
 0000678D  73 74 33 20 FA     C                             db  "st3 ˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥ feip ˙˙˙˙˙˙˙˙    ∫",0
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   B3 20 66 65 69
	   70 20 FA FA FA
	   FA FA FA FA FA
	   20 20 20 20 BA
	   00
 000067BB  73 74 32 20 FA     C                             db  "st2 ˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥  fds ˙˙˙˙.˙˙˙˙   ∫",0
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   B3 20 20 66 64
	   73 20 FA FA FA
	   FA 2E FA FA FA
	   FA 20 20 20 BA
	   00
 000067E9  73 74 31 20 FA     C                             db  "st1 ˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥ fesi ˙˙˙˙˙˙˙˙    ∫",0
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   B3 20 66 65 73
	   69 20 FA FA FA
	   FA FA FA FA FA
	   20 20 20 20 BA
	   00
 00006817  73 74 30 20 FA     C                             db  "st0 ˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥ Æ11011Ø˙˙˙ ˙˙˙˙˙˙˙˙∫",0
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   B3 20 AE 31 31
	   30 31 31 AF FA
	   FA FA 20 FA FA
	   FA FA FA FA FA
	   FA BA 00
 00006847  FF		      C                             db  255
			      C 
 00006848  0168		      C                             dw  45 * FONT_X
 0000684A  0035		      C                             dw  9  * FONT_Y - 1
 0000684C		      C DEBI_e_screen_objects:
			      C     @DrawWindow             DEBI_e_window
			     1C ; Draws the window for whatever item is specified
 0000684C  FD		     1C     db  _DRAW_WINDOW
 0000684D  000066A7 R	     1C     dd  offset DEBI_e_window
			     1C   ; Total = 5
			      C     @ObjectMemSize          108
			     1C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
 00006851  00		     1C     db  _OBJECT_MEM_SIZE
 00006852  6C		     1C     db  108
			     1C   ; Total = 2
			      C     @DisplayEBP_relative    _16,            (-200 + 002h), 002h, 32, 1                                      ; upper 16-bits of cw
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00006853  03		     1C     db  _DISPLAY            ; +0
 00006854  01		     1C     db  _EBP_RELATIVE       ; +1
 00006855  04		     1C     db  _16                ; +2
 00006856  FF3A		     1C     dw  (-200 + 002h)           ; +3
 00006858  02		     1C     db  002h             ; +5
 00006859  00000100	     1C     dd  32 * FONT_X          ; +6
 0000685D  00000006	     1C     dd  1 * FONT_Y          ; +10
 00006861  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16,            (-200 + 000h), 000h, 37, 1                                      ; lower 16-bits of cw
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00006863  03		     1C     db  _DISPLAY            ; +0
 00006864  01		     1C     db  _EBP_RELATIVE       ; +1
 00006865  04		     1C     db  _16                ; +2
 00006866  FF38		     1C     dw  (-200 + 000h)           ; +3
 00006868  00		     1C     db  000h             ; +5
 00006869  00000128	     1C     dd  37 * FONT_X          ; +6
 0000686D  00000006	     1C     dd  1 * FONT_Y          ; +10
 00006871  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _16,            (-200 + 006h), 006h, 32, 2                                      ; upper 16-bits of sw
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00006873  03		     1C     db  _DISPLAY            ; +0
 00006874  01		     1C     db  _EBP_RELATIVE       ; +1
 00006875  04		     1C     db  _16                ; +2
 00006876  FF3E		     1C     dw  (-200 + 006h)           ; +3
 00006878  06		     1C     db  006h             ; +5
 00006879  00000100	     1C     dd  32 * FONT_X          ; +6
 0000687D  0000000C	     1C     dd  2 * FONT_Y          ; +10
 00006881  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16,            (-200 + 004h), 004h, 37, 2                                      ; lower 16-bits of sw
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00006883  03		     1C     db  _DISPLAY            ; +0
 00006884  01		     1C     db  _EBP_RELATIVE       ; +1
 00006885  04		     1C     db  _16                ; +2
 00006886  FF3C		     1C     dw  (-200 + 004h)           ; +3
 00006888  04		     1C     db  004h             ; +5
 00006889  00000128	     1C     dd  37 * FONT_X          ; +6
 0000688D  0000000C	     1C     dd  2 * FONT_Y          ; +10
 00006891  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _16,            (-200 + 00ah), 00ah, 32, 3                                      ; upper 16-bits of tw
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00006893  03		     1C     db  _DISPLAY            ; +0
 00006894  01		     1C     db  _EBP_RELATIVE       ; +1
 00006895  04		     1C     db  _16                ; +2
 00006896  FF42		     1C     dw  (-200 + 00ah)           ; +3
 00006898  0A		     1C     db  00ah             ; +5
 00006899  00000100	     1C     dd  32 * FONT_X          ; +6
 0000689D  00000012	     1C     dd  3 * FONT_Y          ; +10
 000068A1  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16,            (-200 + 008h), 008h, 37, 3                                      ; lower 16-bits of tw
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000068A3  03		     1C     db  _DISPLAY            ; +0
 000068A4  01		     1C     db  _EBP_RELATIVE       ; +1
 000068A5  04		     1C     db  _16                ; +2
 000068A6  FF40		     1C     dw  (-200 + 008h)           ; +3
 000068A8  08		     1C     db  008h             ; +5
 000068A9  00000128	     1C     dd  37 * FONT_X          ; +6
 000068AD  00000012	     1C     dd  3 * FONT_Y          ; +10
 000068B1  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _16,            (-200 + 012h), 012h, 32, 4                                      ; upper 16-bits of fcs
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000068B3  03		     1C     db  _DISPLAY            ; +0
 000068B4  01		     1C     db  _EBP_RELATIVE       ; +1
 000068B5  04		     1C     db  _16                ; +2
 000068B6  FF4A		     1C     dw  (-200 + 012h)           ; +3
 000068B8  12		     1C     db  012h             ; +5
 000068B9  00000100	     1C     dd  32 * FONT_X          ; +6
 000068BD  00000018	     1C     dd  4 * FONT_Y          ; +10
 000068C1  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16,            (-200 + 010h), 010h, 37, 4                                      ; lower 16-bits of fcs
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000068C3  03		     1C     db  _DISPLAY            ; +0
 000068C4  01		     1C     db  _EBP_RELATIVE       ; +1
 000068C5  04		     1C     db  _16                ; +2
 000068C6  FF48		     1C     dw  (-200 + 010h)           ; +3
 000068C8  10		     1C     db  010h             ; +5
 000068C9  00000128	     1C     dd  37 * FONT_X          ; +6
 000068CD  00000018	     1C     dd  4 * FONT_Y          ; +10
 000068D1  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _32,            (-200 + 00ch), 00ch, 32, 5                                      ; feip
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000068D3  03		     1C     db  _DISPLAY            ; +0
 000068D4  01		     1C     db  _EBP_RELATIVE       ; +1
 000068D5  05		     1C     db  _32                ; +2
 000068D6  FF44		     1C     dw  (-200 + 00ch)           ; +3
 000068D8  0C		     1C     db  00ch             ; +5
 000068D9  00000100	     1C     dd  32 * FONT_X          ; +6
 000068DD  0000001E	     1C     dd  5 * FONT_Y          ; +10
 000068E1  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _16,            (-200 + 01ah), 01ah, 32, 6                                      ; upper 16-bits of fds
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000068E3  03		     1C     db  _DISPLAY            ; +0
 000068E4  01		     1C     db  _EBP_RELATIVE       ; +1
 000068E5  04		     1C     db  _16                ; +2
 000068E6  FF52		     1C     dw  (-200 + 01ah)           ; +3
 000068E8  1A		     1C     db  01ah             ; +5
 000068E9  00000100	     1C     dd  32 * FONT_X          ; +6
 000068ED  00000024	     1C     dd  6 * FONT_Y          ; +10
 000068F1  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16,            (-200 + 018h), 018h, 37, 6                                      ; lower 16-bits of fds
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000068F3  03		     1C     db  _DISPLAY            ; +0
 000068F4  01		     1C     db  _EBP_RELATIVE       ; +1
 000068F5  04		     1C     db  _16                ; +2
 000068F6  FF50		     1C     dw  (-200 + 018h)           ; +3
 000068F8  18		     1C     db  018h             ; +5
 000068F9  00000128	     1C     dd  37 * FONT_X          ; +6
 000068FD  00000024	     1C     dd  6 * FONT_Y          ; +10
 00006901  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _32,            (-200 + 014h), 014h, 32, 7                                      ; fesi
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00006903  03		     1C     db  _DISPLAY            ; +0
 00006904  01		     1C     db  _EBP_RELATIVE       ; +1
 00006905  05		     1C     db  _32                ; +2
 00006906  FF4C		     1C     dw  (-200 + 014h)           ; +3
 00006908  14		     1C     db  014h             ; +5
 00006909  00000100	     1C     dd  32 * FONT_X          ; +6
 0000690D  0000002A	     1C     dd  7 * FONT_Y          ; +10
 00006911  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _LOWER_NIBBLE3, (-200 + 013h), 013h, 32, 8                                      ; instruction
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00006913  03		     1C     db  _DISPLAY            ; +0
 00006914  01		     1C     db  _EBP_RELATIVE       ; +1
 00006915  02		     1C     db  _LOWER_NIBBLE3                ; +2
 00006916  FF4B		     1C     dw  (-200 + 013h)           ; +3
 00006918  13		     1C     db  013h             ; +5
 00006919  00000100	     1C     dd  32 * FONT_X          ; +6
 0000691D  00000030	     1C     dd  8 * FONT_Y          ; +10
 00006921  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _BINARY8,       (-200 + 012h), 012h, 36, 8
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00006923  03		     1C     db  _DISPLAY            ; +0
 00006924  01		     1C     db  _EBP_RELATIVE       ; +1
 00006925  06		     1C     db  _BINARY8                ; +2
 00006926  FF4A		     1C     dw  (-200 + 012h)           ; +3
 00006928  12		     1C     db  012h             ; +5
 00006929  00000120	     1C     dd  36 * FONT_X          ; +6
 0000692D  00000030	     1C     dd  8 * FONT_Y          ; +10
 00006931  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _ADJ_FLOAT21,               7, 062h,  4, 1                                      ; st7
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00006933  03		     1C     db  _DISPLAY            ; +0
 00006934  01		     1C     db  _EBP_RELATIVE       ; +1
 00006935  0E		     1C     db  _ADJ_FLOAT21                ; +2
 00006936  0007		     1C     dw  7           ; +3
 00006938  62		     1C     db  062h             ; +5
 00006939  00000020	     1C     dd  4 * FONT_X          ; +6
 0000693D  00000006	     1C     dd  1 * FONT_Y          ; +10
 00006941  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT21,               6, 058h,  4, 2                                      ; st6
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00006943  03		     1C     db  _DISPLAY            ; +0
 00006944  01		     1C     db  _EBP_RELATIVE       ; +1
 00006945  0E		     1C     db  _ADJ_FLOAT21                ; +2
 00006946  0006		     1C     dw  6           ; +3
 00006948  58		     1C     db  058h             ; +5
 00006949  00000020	     1C     dd  4 * FONT_X          ; +6
 0000694D  0000000C	     1C     dd  2 * FONT_Y          ; +10
 00006951  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT21,               5, 04eh,  4, 3                                      ; st5
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00006953  03		     1C     db  _DISPLAY            ; +0
 00006954  01		     1C     db  _EBP_RELATIVE       ; +1
 00006955  0E		     1C     db  _ADJ_FLOAT21                ; +2
 00006956  0005		     1C     dw  5           ; +3
 00006958  4E		     1C     db  04eh             ; +5
 00006959  00000020	     1C     dd  4 * FONT_X          ; +6
 0000695D  00000012	     1C     dd  3 * FONT_Y          ; +10
 00006961  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT21,               4, 044h,  4, 4                                      ; st4
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00006963  03		     1C     db  _DISPLAY            ; +0
 00006964  01		     1C     db  _EBP_RELATIVE       ; +1
 00006965  0E		     1C     db  _ADJ_FLOAT21                ; +2
 00006966  0004		     1C     dw  4           ; +3
 00006968  44		     1C     db  044h             ; +5
 00006969  00000020	     1C     dd  4 * FONT_X          ; +6
 0000696D  00000018	     1C     dd  4 * FONT_Y          ; +10
 00006971  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT21,               3, 03ah,  4, 5                                      ; st3
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00006973  03		     1C     db  _DISPLAY            ; +0
 00006974  01		     1C     db  _EBP_RELATIVE       ; +1
 00006975  0E		     1C     db  _ADJ_FLOAT21                ; +2
 00006976  0003		     1C     dw  3           ; +3
 00006978  3A		     1C     db  03ah             ; +5
 00006979  00000020	     1C     dd  4 * FONT_X          ; +6
 0000697D  0000001E	     1C     dd  5 * FONT_Y          ; +10
 00006981  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT21,               2, 030h,  4, 6                                      ; st2
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00006983  03		     1C     db  _DISPLAY            ; +0
 00006984  01		     1C     db  _EBP_RELATIVE       ; +1
 00006985  0E		     1C     db  _ADJ_FLOAT21                ; +2
 00006986  0002		     1C     dw  2           ; +3
 00006988  30		     1C     db  030h             ; +5
 00006989  00000020	     1C     dd  4 * FONT_X          ; +6
 0000698D  00000024	     1C     dd  6 * FONT_Y          ; +10
 00006991  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT21,               1, 026h,  4, 7                                      ; st1
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00006993  03		     1C     db  _DISPLAY            ; +0
 00006994  01		     1C     db  _EBP_RELATIVE       ; +1
 00006995  0E		     1C     db  _ADJ_FLOAT21                ; +2
 00006996  0001		     1C     dw  1           ; +3
 00006998  26		     1C     db  026h             ; +5
 00006999  00000020	     1C     dd  4 * FONT_X          ; +6
 0000699D  0000002A	     1C     dd  7 * FONT_Y          ; +10
 000069A1  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT21,               0, 01ch,  4, 8                                      ; st0
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000069A3  03		     1C     db  _DISPLAY            ; +0
 000069A4  01		     1C     db  _EBP_RELATIVE       ; +1
 000069A5  0E		     1C     db  _ADJ_FLOAT21                ; +2
 000069A6  0000		     1C     dw  0           ; +3
 000069A8  1C		     1C     db  01ch             ; +5
 000069A9  00000020	     1C     dd  4 * FONT_X          ; +6
 000069AD  00000030	     1C     dd  8 * FONT_Y          ; +10
 000069B1  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @End
 000069B3  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C                           ; x1, y1, x2, y2, function() that handles it when this item is clicked
			      C ALIGN
 000069B4		      C DEBI_e_mouse_objects:
			      C     @Left_single_click       1,  0,  1,  0, invDEBI_object_close
			     1C ; Used when a left single-click is recognized on these coordinates
 000069B4  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 000069B5  00000008	     1C     dd  1 * FONT_X                 ; +1
 000069B9  00000000	     1C     dd  0 * FONT_Y                 ; +5
 000069BD  0000000F	     1C     dd  (1 * FONT_X) + FONT_X - 1  ; +9
 000069C1  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 000069C5  0000510B R	     1C     dd  invDEBI_object_close                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 000069C9  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 000069CD  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 000069CF  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      3,  0, 17,  0, invDEBI_fpu_summary_right_click
			     1C ; Used when a right single-click is recognized on these coordinates
 000069D0  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 000069D1  00000018	     1C     dd  3 * FONT_X                 ; +1
 000069D5  00000000	     1C     dd  0 * FONT_Y                 ; +5
 000069D9  0000008F	     1C     dd  (17 * FONT_X) + FONT_X - 1  ; +9
 000069DD  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 000069E1  000039C0 R	     1C     dd  invDEBI_fpu_summary_right_click                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 000069E5  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 000069E9  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 000069EB  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         0,  0, 44,  0, invDEBI_object_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 000069EC  02		     1C     db  _LEFT_DRAG_START            ; +0
 000069ED  00000000	     1C     dd  0 * FONT_X                 ; +1
 000069F1  00000000	     1C     dd  0 * FONT_Y                 ; +5
 000069F5  00000167	     1C     dd  (44 * FONT_X) + FONT_X - 1  ; +9
 000069F9  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 000069FD  00003BE5 R	     1C     dd  invDEBI_object_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00006A01  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00006A05  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00006A07  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         4,  1, 24,  8, invDEBI_stx_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 00006A08  02		     1C     db  _LEFT_DRAG_START            ; +0
 00006A09  00000020	     1C     dd  4 * FONT_X                 ; +1
 00006A0D  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00006A11  000000C7	     1C     dd  (24 * FONT_X) + FONT_X - 1  ; +9
 00006A15  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00006A19  00003CDE R	     1C     dd  invDEBI_stx_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00006A1D  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00006A21  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00006A23  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_stop          4,  1, 24,  8, invDEBI_stx_drag_stop
			     1C ; Used when a left-drag is stopped if it started in these coordinates
 00006A24  03		     1C     db  _LEFT_DRAG_STOP             ; +0
 00006A25  00000020	     1C     dd  4 * FONT_X                 ; +1
 00006A29  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00006A2D  000000C7	     1C     dd  (24 * FONT_X) + FONT_X - 1  ; +9
 00006A31  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00006A35  00003D85 R	     1C     dd  invDEBI_stx_drag_stop                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00006A39  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00006A3D  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00006A3F  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      4,  1, 24,  8, invDEBI_fpu_menu
			     1C ; Used when a right single-click is recognized on these coordinates
 00006A40  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 00006A41  00000020	     1C     dd  4 * FONT_X                 ; +1
 00006A45  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00006A49  000000C7	     1C     dd  (24 * FONT_X) + FONT_X - 1  ; +9
 00006A4D  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00006A51  00002554 R	     1C     dd  invDEBI_fpu_menu                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00006A55  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00006A59  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00006A5B  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Abandon_if_not          4,  1, 43,  8
			     1C ; Used in a lengthy list.  If the coordinates are not within this range then the rest of the lengthy list is not checked
 00006A5C  0C		     1C     db  _ABANDON_IF_NOT             ; +0
 00006A5D  00000020	     1C     dd  4 * FONT_X                 ; +1
 00006A61  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00006A65  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 00006A69  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00006A6D  0000000B [	     1C     db  11 dup(0ffh)                ; +17
	    FF
	   ]
			     1C   ; Total = 28
			      C     @Hover                   4,  1, 24,  1, (-200 + 98), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00006A78  0A		     1C     db  _HOVER                      ; +0
 00006A79  00000020	     1C     dd  4 * FONT_X                 ; +1
 00006A7D  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00006A81  000000C7	     1C     dd  (24 * FONT_X) + FONT_X - 1  ; +9
 00006A85  0000000B	     1C     dd  (1 * FONT_Y) + FONT_Y - 1  ; +13
 00006A89  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00006A8D  FF9A		     1C     dw  lowword(offset (-200 + 98))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006A8F  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   4,  2, 24,  2, (-200 + 88), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00006A94  0A		     1C     db  _HOVER                      ; +0
 00006A95  00000020	     1C     dd  4 * FONT_X                 ; +1
 00006A99  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 00006A9D  000000C7	     1C     dd  (24 * FONT_X) + FONT_X - 1  ; +9
 00006AA1  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 00006AA5  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00006AA9  FF90		     1C     dw  lowword(offset (-200 + 88))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006AAB  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   4,  3, 24,  3, (-200 + 78), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00006AB0  0A		     1C     db  _HOVER                      ; +0
 00006AB1  00000020	     1C     dd  4 * FONT_X                 ; +1
 00006AB5  00000012	     1C     dd  3 * FONT_Y                 ; +5
 00006AB9  000000C7	     1C     dd  (24 * FONT_X) + FONT_X - 1  ; +9
 00006ABD  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 00006AC1  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00006AC5  FF86		     1C     dw  lowword(offset (-200 + 78))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006AC7  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   4,  4, 24,  4, (-200 + 68), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00006ACC  0A		     1C     db  _HOVER                      ; +0
 00006ACD  00000020	     1C     dd  4 * FONT_X                 ; +1
 00006AD1  00000018	     1C     dd  4 * FONT_Y                 ; +5
 00006AD5  000000C7	     1C     dd  (24 * FONT_X) + FONT_X - 1  ; +9
 00006AD9  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 00006ADD  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00006AE1  FF7C		     1C     dw  lowword(offset (-200 + 68))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006AE3  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   4,  5, 24,  5, (-200 + 58), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00006AE8  0A		     1C     db  _HOVER                      ; +0
 00006AE9  00000020	     1C     dd  4 * FONT_X                 ; +1
 00006AED  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 00006AF1  000000C7	     1C     dd  (24 * FONT_X) + FONT_X - 1  ; +9
 00006AF5  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 00006AF9  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00006AFD  FF72		     1C     dw  lowword(offset (-200 + 58))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006AFF  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   4,  6, 24,  6, (-200 + 48), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00006B04  0A		     1C     db  _HOVER                      ; +0
 00006B05  00000020	     1C     dd  4 * FONT_X                 ; +1
 00006B09  00000024	     1C     dd  6 * FONT_Y                 ; +5
 00006B0D  000000C7	     1C     dd  (24 * FONT_X) + FONT_X - 1  ; +9
 00006B11  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 00006B15  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00006B19  FF68		     1C     dw  lowword(offset (-200 + 48))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006B1B  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   4,  7, 24,  7, (-200 + 38), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00006B20  0A		     1C     db  _HOVER                      ; +0
 00006B21  00000020	     1C     dd  4 * FONT_X                 ; +1
 00006B25  0000002A	     1C     dd  7 * FONT_Y                 ; +5
 00006B29  000000C7	     1C     dd  (24 * FONT_X) + FONT_X - 1  ; +9
 00006B2D  0000002F	     1C     dd  (7 * FONT_Y) + FONT_Y - 1  ; +13
 00006B31  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00006B35  FF5E		     1C     dw  lowword(offset (-200 + 38))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006B37  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   4,  8, 24,  8, (-200 + 28), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00006B3C  0A		     1C     db  _HOVER                      ; +0
 00006B3D  00000020	     1C     dd  4 * FONT_X                 ; +1
 00006B41  00000030	     1C     dd  8 * FONT_Y                 ; +5
 00006B45  000000C7	     1C     dd  (24 * FONT_X) + FONT_X - 1  ; +9
 00006B49  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00006B4D  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00006B51  FF54		     1C     dw  lowword(offset (-200 + 28))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006B53  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  32,  1, 40,  1, (-200 + 00), invDEBI_quick_watch_show_fpu_cw
			     1C ; Used when the mouse is hovering over these coordinates
 00006B58  0A		     1C     db  _HOVER                      ; +0
 00006B59  00000100	     1C     dd  32 * FONT_X                 ; +1
 00006B5D  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00006B61  00000147	     1C     dd  (40 * FONT_X) + FONT_X - 1  ; +9
 00006B65  0000000B	     1C     dd  (1 * FONT_Y) + FONT_Y - 1  ; +13
 00006B69  00002FEB R	     1C     dd  invDEBI_quick_watch_show_fpu_cw                        ; +17
 00006B6D  FF38		     1C     dw  lowword(offset (-200 + 00))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006B6F  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  32,  2, 40,  2, (-200 + 04), invDEBI_quick_watch_show_fpu_sw
			     1C ; Used when the mouse is hovering over these coordinates
 00006B74  0A		     1C     db  _HOVER                      ; +0
 00006B75  00000100	     1C     dd  32 * FONT_X                 ; +1
 00006B79  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 00006B7D  00000147	     1C     dd  (40 * FONT_X) + FONT_X - 1  ; +9
 00006B81  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 00006B85  00003109 R	     1C     dd  invDEBI_quick_watch_show_fpu_sw                        ; +17
 00006B89  FF3C		     1C     dw  lowword(offset (-200 + 04))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006B8B  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  32,  3, 40,  3, (-200 + 08), invDEBI_quick_watch_show_fpu_tw
			     1C ; Used when the mouse is hovering over these coordinates
 00006B90  0A		     1C     db  _HOVER                      ; +0
 00006B91  00000100	     1C     dd  32 * FONT_X                 ; +1
 00006B95  00000012	     1C     dd  3 * FONT_Y                 ; +5
 00006B99  00000147	     1C     dd  (40 * FONT_X) + FONT_X - 1  ; +9
 00006B9D  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 00006BA1  0000322B R	     1C     dd  invDEBI_quick_watch_show_fpu_tw                        ; +17
 00006BA5  FF40		     1C     dw  lowword(offset (-200 + 08))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006BA7  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  32,  4, 39,  4, (-200 + 68), invDEBI_quick_watch_show_selector
			     1C ; Used when the mouse is hovering over these coordinates
 00006BAC  0A		     1C     db  _HOVER                      ; +0
 00006BAD  00000100	     1C     dd  32 * FONT_X                 ; +1
 00006BB1  00000018	     1C     dd  4 * FONT_Y                 ; +5
 00006BB5  0000013F	     1C     dd  (39 * FONT_X) + FONT_X - 1  ; +9
 00006BB9  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 00006BBD  000050F3 R	     1C     dd  invDEBI_quick_watch_show_selector                        ; +17
 00006BC1  FF7C		     1C     dw  lowword(offset (-200 + 68))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006BC3  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  32,  5, 40,  5, (-200 + 58), invDEBI_quick_watch_show_EBP_relative_32
			     1C ; Used when the mouse is hovering over these coordinates
 00006BC8  0A		     1C     db  _HOVER                      ; +0
 00006BC9  00000100	     1C     dd  32 * FONT_X                 ; +1
 00006BCD  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 00006BD1  00000147	     1C     dd  (40 * FONT_X) + FONT_X - 1  ; +9
 00006BD5  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 00006BD9  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 00006BDD  FF72		     1C     dw  lowword(offset (-200 + 58))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006BDF  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  32,  6, 39,  6, (-200 + 48), invDEBI_quick_watch_show_selector
			     1C ; Used when the mouse is hovering over these coordinates
 00006BE4  0A		     1C     db  _HOVER                      ; +0
 00006BE5  00000100	     1C     dd  32 * FONT_X                 ; +1
 00006BE9  00000024	     1C     dd  6 * FONT_Y                 ; +5
 00006BED  0000013F	     1C     dd  (39 * FONT_X) + FONT_X - 1  ; +9
 00006BF1  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 00006BF5  000050F3 R	     1C     dd  invDEBI_quick_watch_show_selector                        ; +17
 00006BF9  FF68		     1C     dw  lowword(offset (-200 + 48))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006BFB  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  32,  7, 40,  7, (-200 + 38), invDEBI_quick_watch_show_EBP_relative_32
			     1C ; Used when the mouse is hovering over these coordinates
 00006C00  0A		     1C     db  _HOVER                      ; +0
 00006C01  00000100	     1C     dd  32 * FONT_X                 ; +1
 00006C05  0000002A	     1C     dd  7 * FONT_Y                 ; +5
 00006C09  00000147	     1C     dd  (40 * FONT_X) + FONT_X - 1  ; +9
 00006C0D  0000002F	     1C     dd  (7 * FONT_Y) + FONT_Y - 1  ; +13
 00006C11  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 00006C15  FF5E		     1C     dw  lowword(offset (-200 + 38))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006C17  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  32,  8, 43,  8, (-200 + 28), invDEBI_quick_watch_show_fpu_opcode
			     1C ; Used when the mouse is hovering over these coordinates
 00006C1C  0A		     1C     db  _HOVER                      ; +0
 00006C1D  00000100	     1C     dd  32 * FONT_X                 ; +1
 00006C21  00000030	     1C     dd  8 * FONT_Y                 ; +5
 00006C25  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 00006C29  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00006C2D  000032AF R	     1C     dd  invDEBI_quick_watch_show_fpu_opcode                        ; +17
 00006C31  FF54		     1C     dw  lowword(offset (-200 + 28))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00006C33  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @End
 00006C38  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
 00006C39		      C DEBI_fpu_menu:
			      C     @MenuItem               "finit"
 00006C39  00		     1C     db  _MENU_ITEM
 00006C3A  05		     1C     db  @SizeStr("finit") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00006C3B  66 69 6E 69 74    1C     db  "finit"
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_fpu_finit
 00006C40  01		     1C     db  _MENU_ITEM_EVENT
 00006C41  00		     1C     db  _LEFT_SINGLE_CLICK
 00006C42  000025BA R	     1C     dd  offset invDEBI_fpu_finit
			      C     @MenuItem               "fchs"
 00006C46  00		     1C     db  _MENU_ITEM
 00006C47  04		     1C     db  @SizeStr("fchs") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00006C48  66 63 68 73	     1C     db  "fchs"
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_fpu_swap_sign
 00006C4C  01		     1C     db  _MENU_ITEM_EVENT
 00006C4D  00		     1C     db  _LEFT_SINGLE_CLICK
 00006C4E  00002683 R	     1C     dd  offset invDEBI_fpu_swap_sign
			      C     @MenuItem               "ffree"
 00006C52  00		     1C     db  _MENU_ITEM
 00006C53  05		     1C     db  @SizeStr("ffree") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00006C54  66 66 72 65 65    1C     db  "ffree"
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_fpu_ffree
 00006C59  01		     1C     db  _MENU_ITEM_EVENT
 00006C5A  00		     1C     db  _LEFT_SINGLE_CLICK
 00006C5B  00002713 R	     1C     dd  offset invDEBI_fpu_ffree
			      C     @MenuBar
 00006C5F  02		     1C     db  _MENU_BAR
			      C     @MenuItem               "+0.00000"
 00006C60  00		     1C     db  _MENU_ITEM
 00006C61  08		     1C     db  @SizeStr("+0.00000") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00006C62  2B 30 2E 30 30    1C     db  "+0.00000"
	   30 30 30
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_fpu_force_0
 00006C6A  01		     1C     db  _MENU_ITEM_EVENT
 00006C6B  00		     1C     db  _LEFT_SINGLE_CLICK
 00006C6C  00002639 R	     1C     dd  offset invDEBI_fpu_force_0
			      C     @MenuItem               "+1.00000"
 00006C70  00		     1C     db  _MENU_ITEM
 00006C71  08		     1C     db  @SizeStr("+1.00000") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00006C72  2B 31 2E 30 30    1C     db  "+1.00000"
	   30 30 30
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_fpu_force_1
 00006C7A  01		     1C     db  _MENU_ITEM_EVENT
 00006C7B  00		     1C     db  _LEFT_SINGLE_CLICK
 00006C7C  00002645 R	     1C     dd  offset invDEBI_fpu_force_1
			      C     @MenuItem               "+10.0000"
 00006C80  00		     1C     db  _MENU_ITEM
 00006C81  08		     1C     db  @SizeStr("+10.0000") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00006C82  2B 31 30 2E 30    1C     db  "+10.0000"
	   30 30 30
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_fpu_force_10
 00006C8A  01		     1C     db  _MENU_ITEM_EVENT
 00006C8B  00		     1C     db  _LEFT_SINGLE_CLICK
 00006C8C  00002651 R	     1C     dd  offset invDEBI_fpu_force_10
			      C     @MenuItem               "pi"
 00006C90  00		     1C     db  _MENU_ITEM
 00006C91  02		     1C     db  @SizeStr("pi") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00006C92  70 69	     1C     db  "pi"
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_fpu_force_pi
 00006C94  01		     1C     db  _MENU_ITEM_EVENT
 00006C95  00		     1C     db  _LEFT_SINGLE_CLICK
 00006C96  00002666 R	     1C     dd  offset invDEBI_fpu_force_pi
			      C     @MenuBar
 00006C9A  02		     1C     db  _MENU_BAR
			      C     @MenuItem               "fldz"
 00006C9B  00		     1C     db  _MENU_ITEM
 00006C9C  04		     1C     db  @SizeStr("fldz") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00006C9D  66 6C 64 7A	     1C     db  "fldz"
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_fpu_fld_0
 00006CA1  01		     1C     db  _MENU_ITEM_EVENT
 00006CA2  00		     1C     db  _LEFT_SINGLE_CLICK
 00006CA3  000026A2 R	     1C     dd  offset invDEBI_fpu_fld_0
			      C     @MenuItem               "fld1"
 00006CA7  00		     1C     db  _MENU_ITEM
 00006CA8  04		     1C     db  @SizeStr("fld1") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00006CA9  66 6C 64 31	     1C     db  "fld1"
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_fpu_fld_1
 00006CAD  01		     1C     db  _MENU_ITEM_EVENT
 00006CAE  00		     1C     db  _LEFT_SINGLE_CLICK
 00006CAF  000026BC R	     1C     dd  offset invDEBI_fpu_fld_1
			      C     @MenuItem               "fld +10.0000"
 00006CB3  00		     1C     db  _MENU_ITEM
 00006CB4  0C		     1C     db  @SizeStr("fld +10.0000") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00006CB5  66 6C 64 20 2B    1C     db  "fld +10.0000"
	   31 30 2E 30 30
	   30 30
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_fpu_fld_10
 00006CC1  01		     1C     db  _MENU_ITEM_EVENT
 00006CC2  00		     1C     db  _LEFT_SINGLE_CLICK
 00006CC3  000026D6 R	     1C     dd  offset invDEBI_fpu_fld_10
			      C     @MenuItem               "fldpi"
 00006CC7  00		     1C     db  _MENU_ITEM
 00006CC8  05		     1C     db  @SizeStr("fldpi") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00006CC9  66 6C 64 70 69    1C     db  "fldpi"
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_fpu_fld_pi
 00006CCE  01		     1C     db  _MENU_ITEM_EVENT
 00006CCF  00		     1C     db  _LEFT_SINGLE_CLICK
 00006CD0  000026F9 R	     1C     dd  offset invDEBI_fpu_fld_pi
			      C     @MenuBar
 00006CD4  02		     1C     db  _MENU_BAR
			      C     @MenuItem               "fmulp st1,st0"
 00006CD5  00		     1C     db  _MENU_ITEM
 00006CD6  0D		     1C     db  @SizeStr("fmulp st1,st0") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00006CD7  66 6D 75 6C 70    1C     db  "fmulp st1,st0"
	   20 73 74 31 2C
	   73 74 30
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_fpu_fmulp
 00006CE4  01		     1C     db  _MENU_ITEM_EVENT
 00006CE5  00		     1C     db  _LEFT_SINGLE_CLICK
 00006CE6  00002731 R	     1C     dd  offset invDEBI_fpu_fmulp
			      C     @MenuItem               "fdivp st1,st0"
 00006CEA  00		     1C     db  _MENU_ITEM
 00006CEB  0D		     1C     db  @SizeStr("fdivp st1,st0") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00006CEC  66 64 69 76 70    1C     db  "fdivp st1,st0"
	   20 73 74 31 2C
	   73 74 30
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_fpu_fdivp
 00006CF9  01		     1C     db  _MENU_ITEM_EVENT
 00006CFA  00		     1C     db  _LEFT_SINGLE_CLICK
 00006CFB  0000274B R	     1C     dd  offset invDEBI_fpu_fdivp
			      C     @MenuItem               "fdivp st0,st1"
 00006CFF  00		     1C     db  _MENU_ITEM
 00006D00  0D		     1C     db  @SizeStr("fdivp st0,st1") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00006D01  66 64 69 76 70    1C     db  "fdivp st0,st1"
	   20 73 74 30 2C
	   73 74 31
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_fpu_fdivrp
 00006D0E  01		     1C     db  _MENU_ITEM_EVENT
 00006D0F  00		     1C     db  _LEFT_SINGLE_CLICK
 00006D10  00002765 R	     1C     dd  offset invDEBI_fpu_fdivrp
			      C     @MenuBar
 00006D14  02		     1C     db  _MENU_BAR
			      C     @MenuItem               "fsave"
 00006D15  00		     1C     db  _MENU_ITEM
 00006D16  05		     1C     db  @SizeStr("fsave") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00006D17  66 73 61 76 65    1C     db  "fsave"
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_fpu_save
 00006D1C  01		     1C     db  _MENU_ITEM_EVENT
 00006D1D  00		     1C     db  _LEFT_SINGLE_CLICK
 00006D1E  0000277F R	     1C     dd  offset invDEBI_fpu_save
			      C     @MenuItem               "frstor"
 00006D22  00		     1C     db  _MENU_ITEM
 00006D23  06		     1C     db  @SizeStr("frstor") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00006D24  66 72 73 74 6F    1C     db  "frstor"
	   72
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_fpu_restore
 00006D2A  01		     1C     db  _MENU_ITEM_EVENT
 00006D2B  00		     1C     db  _LEFT_SINGLE_CLICK
 00006D2C  00002792 R	     1C     dd  offset invDEBI_fpu_restore
			      C     @End
 00006D30  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
			      C                                 ;          11111111112222222222333333333344444
			      C                                 ;012345678901234567890123456789012345678901234
 00006D31 C9 9A CD 81 20      C DEBI_f_window               db  "…öÕÅ FPU.SaveState ÖÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª",0
	   46 50 55 2E 53
	   61 76 65 53 74
	   61 74 65 20 85
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD BB
	   00
 00006D5F  2B 30 30 B4 20     C                             db  "+00¥    null.cw ˙˙˙˙.˙˙˙˙                   ∫",0
	   20 20 20 6E 75
	   6C 6C 2E 63 77
	   20 FA FA FA FA
	   2E FA FA FA FA
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00006D8D  2B 30 34 B4 20     C                             db  "+04¥    null.sw ˙˙˙˙.˙˙˙˙  Control Word (cw)∫",0
	   20 20 20 6E 75
	   6C 6C 2E 73 77
	   20 FA FA FA FA
	   2E FA FA FA FA
	   20 20 43 6F 6E
	   74 72 6F 6C 20
	   57 6F 72 64 20
	   28 63 77 29 BA
	   00
 00006DBB  2B 30 38 B4 20     C                             db  "+08¥    null.tw ˙˙˙˙.˙˙˙˙   ÆxxxxØRcPcÆxxØPUOZDI∫",0
	   20 20 20 6E 75
	   6C 6C 2E 74 77
	   20 FA FA FA FA
	   2E FA FA FA FA
	   20 20 20 AE 78
	   78 78 78 AF 52
	   63 50 63 AE 78
	   78 AF 50 55 4F
	   5A 44 49 BA 00
 00006DED  2B 30 63 B4 20     C                             db  "+0c¥       feip ˙˙˙˙˙˙˙˙    ˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙∫",0
	   20 20 20 20 20
	   20 66 65 69 70
	   20 FA FA FA FA
	   FA FA FA FA 20
	   20 20 20 FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA BA
	   00
 00006E1B  2B 31 30 B4 6E     C                             db  "+10¥null.op.fcs ˙˙˙˙.˙˙˙˙                   ∫",0
	   75 6C 6C 2E 6F
	   70 2E 66 63 73
	   20 FA FA FA FA
	   2E FA FA FA FA
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00006E49  2B 31 34 B4 20     C                             db  "+14¥       fesi ˙˙˙˙˙˙˙˙    Status Word (sw)∫",0
	   20 20 20 20 20
	   20 66 65 73 69
	   20 FA FA FA FA
	   FA FA FA FA 20
	   20 20 20 53 74
	   61 74 75 73 20
	   57 6F 72 64 20
	   28 73 77 29 BA
	   00
 00006E77  2B 31 38 B4 20     C                             db  "+18¥   null.fds ˙˙˙˙.˙˙˙˙   B3tos210ESPUOZDI∫",0
	   20 20 6E 75 6C
	   6C 2E 66 64 73
	   20 FA FA FA FA
	   2E FA FA FA FA
	   20 20 20 42 33
	   74 6F 73 32 31
	   30 45 53 50 55
	   4F 5A 44 49 BA
	   00
 00006EA5  20 20 20 B4 20     C                             db  "   ¥                        ˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙∫",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA BA
	   00
 00006ED3  2B 36 32 B4 37     C                             db  "+62¥7 ˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥                 ∫",0
	   20 FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA B3 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00006F01  2B 35 38 B4 36     C                             db  "+58¥6 ˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥   Tag Word (tw) ∫",0
	   20 FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA B3 20 20 20
	   54 61 67 20 57
	   6F 72 64 20 28
	   74 77 29 20 BA
	   00
 00006F2F  2B 34 33 B4 35     C                             db  "+43¥5 ˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥ 7766554433221100∫",0
	   20 FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA B3 20 37 37
	   36 36 35 35 34
	   34 33 33 32 32
	   31 31 30 30 BA
	   00
 00006F5D  2B 34 34 B4 34     C                             db  "+44¥4 ˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥ ˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA B3 20 FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA BA
	   00
 00006F8B  2B 33 61 B4 33     C                             db  "+3a¥3 ˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥                 ∫",0
	   20 FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA B3 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00006FB9  2B 33 30 B4 32     C                             db  "+30¥2 ˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥     Opcode (op) ∫",0
	   20 FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA B3 20 20 20
	   20 20 4F 70 63
	   6F 64 65 20 28
	   6F 70 29 20 BA
	   00
 00006FE7  2B 32 36 B4 31     C                             db  "+26¥1 ˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥ Æ11011Ø˙˙˙˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA B3 20 AE 31
	   31 30 31 31 AF
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA BA 00
 00007017  2B 31 63 B4 30     C                             db  "+1c¥0 ˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥                 ∫",0
	   20 FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA B3 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00007045  FF		      C                             db  255
			      C 
 00007046  0168		      C                             dw  45 * FONT_X
 00007048  006B		      C                             dw  18 * FONT_Y - 1
 0000704A		      C DEBI_f_screen_objects:
			      C     @DrawWindow             DEBI_f_window
			     1C ; Draws the window for whatever item is specified
 0000704A  FD		     1C     db  _DRAW_WINDOW
 0000704B  00006D31 R	     1C     dd  offset DEBI_f_window
			     1C   ; Total = 5
			      C     @ObjectMemSize          108
			     1C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
 0000704F  00		     1C     db  _OBJECT_MEM_SIZE
 00007050  6C		     1C     db  108
			     1C   ; Total = 2
			      C     @DisplayEBP_relative    _16,        (-200 + 002h), 002h, 16, 1                                          ; upper 16-bits of cw
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007051  03		     1C     db  _DISPLAY            ; +0
 00007052  01		     1C     db  _EBP_RELATIVE       ; +1
 00007053  04		     1C     db  _16                ; +2
 00007054  FF3A		     1C     dw  (-200 + 002h)           ; +3
 00007056  02		     1C     db  002h             ; +5
 00007057  00000080	     1C     dd  16 * FONT_X          ; +6
 0000705B  00000006	     1C     dd  1 * FONT_Y          ; +10
 0000705F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16,        (-200 + 000h), 000h, 16, 1                                          ; lower 16-bits of cw
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007061  03		     1C     db  _DISPLAY            ; +0
 00007062  01		     1C     db  _EBP_RELATIVE       ; +1
 00007063  04		     1C     db  _16                ; +2
 00007064  FF38		     1C     dw  (-200 + 000h)           ; +3
 00007066  00		     1C     db  000h             ; +5
 00007067  00000080	     1C     dd  16 * FONT_X          ; +6
 0000706B  00000006	     1C     dd  1 * FONT_Y          ; +10
 0000706F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _16,        (-200 + 006h), 006h, 16, 2                                          ; upper 16-bits of sw
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007071  03		     1C     db  _DISPLAY            ; +0
 00007072  01		     1C     db  _EBP_RELATIVE       ; +1
 00007073  04		     1C     db  _16                ; +2
 00007074  FF3E		     1C     dw  (-200 + 006h)           ; +3
 00007076  06		     1C     db  006h             ; +5
 00007077  00000080	     1C     dd  16 * FONT_X          ; +6
 0000707B  0000000C	     1C     dd  2 * FONT_Y          ; +10
 0000707F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16,        (-200 + 004h), 004h, 16, 2                                          ; lower 16-bits of sw
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007081  03		     1C     db  _DISPLAY            ; +0
 00007082  01		     1C     db  _EBP_RELATIVE       ; +1
 00007083  04		     1C     db  _16                ; +2
 00007084  FF3C		     1C     dw  (-200 + 004h)           ; +3
 00007086  04		     1C     db  004h             ; +5
 00007087  00000080	     1C     dd  16 * FONT_X          ; +6
 0000708B  0000000C	     1C     dd  2 * FONT_Y          ; +10
 0000708F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _16,        (-200 + 00ah), 00ah, 16, 3                                          ; upper 16-bits of tw
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007091  03		     1C     db  _DISPLAY            ; +0
 00007092  01		     1C     db  _EBP_RELATIVE       ; +1
 00007093  04		     1C     db  _16                ; +2
 00007094  FF42		     1C     dw  (-200 + 00ah)           ; +3
 00007096  0A		     1C     db  00ah             ; +5
 00007097  00000080	     1C     dd  16 * FONT_X          ; +6
 0000709B  00000012	     1C     dd  3 * FONT_Y          ; +10
 0000709F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16,        (-200 + 008h), 008h, 16, 3                                          ; lower 16-bits of tw
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000070A1  03		     1C     db  _DISPLAY            ; +0
 000070A2  01		     1C     db  _EBP_RELATIVE       ; +1
 000070A3  04		     1C     db  _16                ; +2
 000070A4  FF40		     1C     dw  (-200 + 008h)           ; +3
 000070A6  08		     1C     db  008h             ; +5
 000070A7  00000080	     1C     dd  16 * FONT_X          ; +6
 000070AB  00000012	     1C     dd  3 * FONT_Y          ; +10
 000070AF  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _32,        (-200 + 010h), 010h, 16, 4                                          ; feip
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000070B1  03		     1C     db  _DISPLAY            ; +0
 000070B2  01		     1C     db  _EBP_RELATIVE       ; +1
 000070B3  05		     1C     db  _32                ; +2
 000070B4  FF48		     1C     dw  (-200 + 010h)           ; +3
 000070B6  10		     1C     db  010h             ; +5
 000070B7  00000080	     1C     dd  16 * FONT_X          ; +6
 000070BB  00000018	     1C     dd  4 * FONT_Y          ; +10
 000070BF  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _16,        (-200 + 012h), 012h, 16, 5                                          ; opcode
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000070C1  03		     1C     db  _DISPLAY            ; +0
 000070C2  01		     1C     db  _EBP_RELATIVE       ; +1
 000070C3  04		     1C     db  _16                ; +2
 000070C4  FF4A		     1C     dw  (-200 + 012h)           ; +3
 000070C6  12		     1C     db  012h             ; +5
 000070C7  00000080	     1C     dd  16 * FONT_X          ; +6
 000070CB  0000001E	     1C     dd  5 * FONT_Y          ; +10
 000070CF  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16,        (-200 + 00ch), 00ch, 16, 5                                          ; fcs
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000070D1  03		     1C     db  _DISPLAY            ; +0
 000070D2  01		     1C     db  _EBP_RELATIVE       ; +1
 000070D3  04		     1C     db  _16                ; +2
 000070D4  FF44		     1C     dw  (-200 + 00ch)           ; +3
 000070D6  0C		     1C     db  00ch             ; +5
 000070D7  00000080	     1C     dd  16 * FONT_X          ; +6
 000070DB  0000001E	     1C     dd  5 * FONT_Y          ; +10
 000070DF  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _32,        (-200 + 014h), 014h, 16, 6                                          ; fesi
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000070E1  03		     1C     db  _DISPLAY            ; +0
 000070E2  01		     1C     db  _EBP_RELATIVE       ; +1
 000070E3  05		     1C     db  _32                ; +2
 000070E4  FF4C		     1C     dw  (-200 + 014h)           ; +3
 000070E6  14		     1C     db  014h             ; +5
 000070E7  00000080	     1C     dd  16 * FONT_X          ; +6
 000070EB  00000024	     1C     dd  6 * FONT_Y          ; +10
 000070EF  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _16,        (-200 + 01ah), 01ah, 16, 7                                          ; upper 16-bits of fds
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000070F1  03		     1C     db  _DISPLAY            ; +0
 000070F2  01		     1C     db  _EBP_RELATIVE       ; +1
 000070F3  04		     1C     db  _16                ; +2
 000070F4  FF52		     1C     dw  (-200 + 01ah)           ; +3
 000070F6  1A		     1C     db  01ah             ; +5
 000070F7  00000080	     1C     dd  16 * FONT_X          ; +6
 000070FB  0000002A	     1C     dd  7 * FONT_Y          ; +10
 000070FF  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16,        (-200 + 018h), 018h, 16, 7                                          ; lower 16-bits of fds
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007101  03		     1C     db  _DISPLAY            ; +0
 00007102  01		     1C     db  _EBP_RELATIVE       ; +1
 00007103  04		     1C     db  _16                ; +2
 00007104  FF50		     1C     dw  (-200 + 018h)           ; +3
 00007106  18		     1C     db  018h             ; +5
 00007107  00000080	     1C     dd  16 * FONT_X          ; +6
 0000710B  0000002A	     1C     dd  7 * FONT_Y          ; +10
 0000710F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _TBYTE,     (-200 + 062h), 062h,  6, 10                                         ; st7
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007111  03		     1C     db  _DISPLAY            ; +0
 00007112  01		     1C     db  _EBP_RELATIVE       ; +1
 00007113  0B		     1C     db  _TBYTE                ; +2
 00007114  FF9A		     1C     dw  (-200 + 062h)           ; +3
 00007116  62		     1C     db  062h             ; +5
 00007117  00000030	     1C     dd  6 * FONT_X          ; +6
 0000711B  0000003C	     1C     dd  10 * FONT_Y          ; +10
 0000711F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _TBYTE,     (-200 + 058h), 058h,  6, 11                                         ; st6
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007121  03		     1C     db  _DISPLAY            ; +0
 00007122  01		     1C     db  _EBP_RELATIVE       ; +1
 00007123  0B		     1C     db  _TBYTE                ; +2
 00007124  FF90		     1C     dw  (-200 + 058h)           ; +3
 00007126  58		     1C     db  058h             ; +5
 00007127  00000030	     1C     dd  6 * FONT_X          ; +6
 0000712B  00000042	     1C     dd  11 * FONT_Y          ; +10
 0000712F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _TBYTE,     (-200 + 04eh), 04eh,  6, 12                                         ; st5
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007131  03		     1C     db  _DISPLAY            ; +0
 00007132  01		     1C     db  _EBP_RELATIVE       ; +1
 00007133  0B		     1C     db  _TBYTE                ; +2
 00007134  FF86		     1C     dw  (-200 + 04eh)           ; +3
 00007136  4E		     1C     db  04eh             ; +5
 00007137  00000030	     1C     dd  6 * FONT_X          ; +6
 0000713B  00000048	     1C     dd  12 * FONT_Y          ; +10
 0000713F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _TBYTE,     (-200 + 044h), 044h,  6, 13                                         ; st4
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007141  03		     1C     db  _DISPLAY            ; +0
 00007142  01		     1C     db  _EBP_RELATIVE       ; +1
 00007143  0B		     1C     db  _TBYTE                ; +2
 00007144  FF7C		     1C     dw  (-200 + 044h)           ; +3
 00007146  44		     1C     db  044h             ; +5
 00007147  00000030	     1C     dd  6 * FONT_X          ; +6
 0000714B  0000004E	     1C     dd  13 * FONT_Y          ; +10
 0000714F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _TBYTE,     (-200 + 03ah), 03ah,  6, 14                                         ; st3
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007151  03		     1C     db  _DISPLAY            ; +0
 00007152  01		     1C     db  _EBP_RELATIVE       ; +1
 00007153  0B		     1C     db  _TBYTE                ; +2
 00007154  FF72		     1C     dw  (-200 + 03ah)           ; +3
 00007156  3A		     1C     db  03ah             ; +5
 00007157  00000030	     1C     dd  6 * FONT_X          ; +6
 0000715B  00000054	     1C     dd  14 * FONT_Y          ; +10
 0000715F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _TBYTE,     (-200 + 030h), 030h,  6, 15                                         ; st2
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007161  03		     1C     db  _DISPLAY            ; +0
 00007162  01		     1C     db  _EBP_RELATIVE       ; +1
 00007163  0B		     1C     db  _TBYTE                ; +2
 00007164  FF68		     1C     dw  (-200 + 030h)           ; +3
 00007166  30		     1C     db  030h             ; +5
 00007167  00000030	     1C     dd  6 * FONT_X          ; +6
 0000716B  0000005A	     1C     dd  15 * FONT_Y          ; +10
 0000716F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _TBYTE,     (-200 + 026h), 026h,  6, 16                                         ; st1
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007171  03		     1C     db  _DISPLAY            ; +0
 00007172  01		     1C     db  _EBP_RELATIVE       ; +1
 00007173  0B		     1C     db  _TBYTE                ; +2
 00007174  FF5E		     1C     dw  (-200 + 026h)           ; +3
 00007176  26		     1C     db  026h             ; +5
 00007177  00000030	     1C     dd  6 * FONT_X          ; +6
 0000717B  00000060	     1C     dd  16 * FONT_Y          ; +10
 0000717F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _TBYTE,     (-200 + 01ch), 01ch,  6, 17                                         ; st0
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007181  03		     1C     db  _DISPLAY            ; +0
 00007182  01		     1C     db  _EBP_RELATIVE       ; +1
 00007183  0B		     1C     db  _TBYTE                ; +2
 00007184  FF54		     1C     dw  (-200 + 01ch)           ; +3
 00007186  1C		     1C     db  01ch             ; +5
 00007187  00000030	     1C     dd  6 * FONT_X          ; +6
 0000718B  00000066	     1C     dd  17 * FONT_Y          ; +10
 0000718F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _BINARY16,  (-200 + 000h), 000h, 28, 4
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007191  03		     1C     db  _DISPLAY            ; +0
 00007192  01		     1C     db  _EBP_RELATIVE       ; +1
 00007193  08		     1C     db  _BINARY16                ; +2
 00007194  FF38		     1C     dw  (-200 + 000h)           ; +3
 00007196  00		     1C     db  000h             ; +5
 00007197  000000E0	     1C     dd  28 * FONT_X          ; +6
 0000719B  00000018	     1C     dd  4 * FONT_Y          ; +10
 0000719F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _BINARY16,  (-200 + 004h), 004h, 28, 8
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000071A1  03		     1C     db  _DISPLAY            ; +0
 000071A2  01		     1C     db  _EBP_RELATIVE       ; +1
 000071A3  08		     1C     db  _BINARY16                ; +2
 000071A4  FF3C		     1C     dw  (-200 + 004h)           ; +3
 000071A6  04		     1C     db  004h             ; +5
 000071A7  000000E0	     1C     dd  28 * FONT_X          ; +6
 000071AB  00000030	     1C     dd  8 * FONT_Y          ; +10
 000071AF  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _BINARY16,  (-200 + 008h), 008h, 28, 12
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000071B1  03		     1C     db  _DISPLAY            ; +0
 000071B2  01		     1C     db  _EBP_RELATIVE       ; +1
 000071B3  08		     1C     db  _BINARY16                ; +2
 000071B4  FF40		     1C     dw  (-200 + 008h)           ; +3
 000071B6  08		     1C     db  008h             ; +5
 000071B7  000000E0	     1C     dd  28 * FONT_X          ; +6
 000071BB  00000048	     1C     dd  12 * FONT_Y          ; +10
 000071BF  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _BINARY11,  (-200 + 00ch), 00ch, 33, 15
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000071C1  03		     1C     db  _DISPLAY            ; +0
 000071C2  01		     1C     db  _EBP_RELATIVE       ; +1
 000071C3  07		     1C     db  _BINARY11                ; +2
 000071C4  FF44		     1C     dw  (-200 + 00ch)           ; +3
 000071C6  0C		     1C     db  00ch             ; +5
 000071C7  00000108	     1C     dd  33 * FONT_X          ; +6
 000071CB  0000005A	     1C     dd  15 * FONT_Y          ; +10
 000071CF  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @End
 000071D1  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C                           ; x1, y1, x2, y2, function() that handles it when this item is clicked
			      C ALIGN
 000071D2		      C DEBI_f_mouse_objects:
			      C     @Left_single_click       1,  0,  1,  0, invDEBI_object_close
			     1C ; Used when a left single-click is recognized on these coordinates
 000071D2  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 000071D3  00000008	     1C     dd  1 * FONT_X                 ; +1
 000071D7  00000000	     1C     dd  0 * FONT_Y                 ; +5
 000071DB  0000000F	     1C     dd  (1 * FONT_X) + FONT_X - 1  ; +9
 000071DF  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 000071E3  0000510B R	     1C     dd  invDEBI_object_close                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 000071E7  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 000071EB  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 000071ED  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      3,  0, 17,  0, invDEBI_fpu_save_state_right_click
			     1C ; Used when a right single-click is recognized on these coordinates
 000071EE  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 000071EF  00000018	     1C     dd  3 * FONT_X                 ; +1
 000071F3  00000000	     1C     dd  0 * FONT_Y                 ; +5
 000071F7  0000008F	     1C     dd  (17 * FONT_X) + FONT_X - 1  ; +9
 000071FB  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 000071FF  000039C0 R	     1C     dd  invDEBI_fpu_save_state_right_click                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00007203  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00007207  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00007209  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         0,  0, 44,  0, invDEBI_object_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 0000720A  02		     1C     db  _LEFT_DRAG_START            ; +0
 0000720B  00000000	     1C     dd  0 * FONT_X                 ; +1
 0000720F  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00007213  00000167	     1C     dd  (44 * FONT_X) + FONT_X - 1  ; +9
 00007217  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 0000721B  00003BE5 R	     1C     dd  invDEBI_object_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 0000721F  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00007223  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00007225  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         6,  9, 25, 16, invDEBI_stx_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 00007226  02		     1C     db  _LEFT_DRAG_START            ; +0
 00007227  00000030	     1C     dd  6 * FONT_X                 ; +1
 0000722B  00000036	     1C     dd  9 * FONT_Y                 ; +5
 0000722F  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 00007233  00000065	     1C     dd  (16 * FONT_Y) + FONT_Y - 1  ; +13
 00007237  00003CDE R	     1C     dd  invDEBI_stx_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 0000723B  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000723F  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00007241  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_stop          6,  9, 25, 16, invDEBI_stx_drag_stop
			     1C ; Used when a left-drag is stopped if it started in these coordinates
 00007242  03		     1C     db  _LEFT_DRAG_STOP             ; +0
 00007243  00000030	     1C     dd  6 * FONT_X                 ; +1
 00007247  00000036	     1C     dd  9 * FONT_Y                 ; +5
 0000724B  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 0000724F  00000065	     1C     dd  (16 * FONT_Y) + FONT_Y - 1  ; +13
 00007253  00003D85 R	     1C     dd  invDEBI_stx_drag_stop                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00007257  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000725B  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000725D  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      6,  9, 25, 16, invDEBI_fpu_menu
			     1C ; Used when a right single-click is recognized on these coordinates
 0000725E  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 0000725F  00000030	     1C     dd  6 * FONT_X                 ; +1
 00007263  00000036	     1C     dd  9 * FONT_Y                 ; +5
 00007267  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 0000726B  00000065	     1C     dd  (16 * FONT_Y) + FONT_Y - 1  ; +13
 0000726F  00002554 R	     1C     dd  invDEBI_fpu_menu                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00007273  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00007277  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00007279  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  16,  1, 24,  1, (-200 + 00), invDEBI_quick_watch_show_fpu_cw
			     1C ; Used when the mouse is hovering over these coordinates
 0000727A  0A		     1C     db  _HOVER                      ; +0
 0000727B  00000080	     1C     dd  16 * FONT_X                 ; +1
 0000727F  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00007283  000000C7	     1C     dd  (24 * FONT_X) + FONT_X - 1  ; +9
 00007287  0000000B	     1C     dd  (1 * FONT_Y) + FONT_Y - 1  ; +13
 0000728B  00002FEB R	     1C     dd  invDEBI_quick_watch_show_fpu_cw                        ; +17
 0000728F  FF38		     1C     dw  lowword(offset (-200 + 00))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00007291  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  16,  2, 24,  2, (-200 + 04), invDEBI_quick_watch_show_fpu_sw
			     1C ; Used when the mouse is hovering over these coordinates
 00007296  0A		     1C     db  _HOVER                      ; +0
 00007297  00000080	     1C     dd  16 * FONT_X                 ; +1
 0000729B  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 0000729F  000000C7	     1C     dd  (24 * FONT_X) + FONT_X - 1  ; +9
 000072A3  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 000072A7  00003109 R	     1C     dd  invDEBI_quick_watch_show_fpu_sw                        ; +17
 000072AB  FF3C		     1C     dw  lowword(offset (-200 + 04))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000072AD  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  16,  3, 24,  3, (-200 + 08), invDEBI_quick_watch_show_fpu_tw
			     1C ; Used when the mouse is hovering over these coordinates
 000072B2  0A		     1C     db  _HOVER                      ; +0
 000072B3  00000080	     1C     dd  16 * FONT_X                 ; +1
 000072B7  00000012	     1C     dd  3 * FONT_Y                 ; +5
 000072BB  000000C7	     1C     dd  (24 * FONT_X) + FONT_X - 1  ; +9
 000072BF  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 000072C3  0000322B R	     1C     dd  invDEBI_quick_watch_show_fpu_tw                        ; +17
 000072C7  FF40		     1C     dw  lowword(offset (-200 + 08))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000072C9  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   16,  1, 24,  1, (-200 + 98), edit_word
			     1C ; Used when a left-click is recognized on an item that can be edited
 000072CE  0B		     1C     db  _EDIT                       ; +0
 000072CF  00000080	     1C     dd  16 * FONT_X                 ; +1
 000072D3  00000006	     1C     dd  1 * FONT_Y                 ; +5
 000072D7  000000C7	     1C     dd  (24 * FONT_X) + FONT_X - 1  ; +9
 000072DB  0000000B	     1C     dd  (1 * FONT_Y) + FONT_Y - 1  ; +13
 000072DF  0000B768 R	     1C     dd  edit_word                        ; +17
 000072E3  FF9A		     1C     dw  lowword(offset (-200 + 98))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000072E5  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   16,  2, 24,  2, (-200 + 88), edit_word
			     1C ; Used when a left-click is recognized on an item that can be edited
 000072EA  0B		     1C     db  _EDIT                       ; +0
 000072EB  00000080	     1C     dd  16 * FONT_X                 ; +1
 000072EF  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 000072F3  000000C7	     1C     dd  (24 * FONT_X) + FONT_X - 1  ; +9
 000072F7  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 000072FB  0000B768 R	     1C     dd  edit_word                        ; +17
 000072FF  FF90		     1C     dw  lowword(offset (-200 + 88))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00007301  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   16,  3, 24,  3, (-200 + 78), edit_word
			     1C ; Used when a left-click is recognized on an item that can be edited
 00007306  0B		     1C     db  _EDIT                       ; +0
 00007307  00000080	     1C     dd  16 * FONT_X                 ; +1
 0000730B  00000012	     1C     dd  3 * FONT_Y                 ; +5
 0000730F  000000C7	     1C     dd  (24 * FONT_X) + FONT_X - 1  ; +9
 00007313  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 00007317  0000B768 R	     1C     dd  edit_word                        ; +17
 0000731B  FF86		     1C     dw  lowword(offset (-200 + 78))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000731D  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  16,  4, 23,  4, (-200 + 68), invDEBI_quick_watch_show_EBP_relative_32
			     1C ; Used when the mouse is hovering over these coordinates
 00007322  0A		     1C     db  _HOVER                      ; +0
 00007323  00000080	     1C     dd  16 * FONT_X                 ; +1
 00007327  00000018	     1C     dd  4 * FONT_Y                 ; +5
 0000732B  000000BF	     1C     dd  (23 * FONT_X) + FONT_X - 1  ; +9
 0000732F  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 00007333  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 00007337  FF7C		     1C     dw  lowword(offset (-200 + 68))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00007339  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  16,  5, 24,  5, (-200 + 58), invDEBI_quick_watch_show_32_selector_separated
			     1C ; Used when the mouse is hovering over these coordinates
 0000733E  0A		     1C     db  _HOVER                      ; +0
 0000733F  00000080	     1C     dd  16 * FONT_X                 ; +1
 00007343  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 00007347  000000C7	     1C     dd  (24 * FONT_X) + FONT_X - 1  ; +9
 0000734B  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 0000734F  00005105 R	     1C     dd  invDEBI_quick_watch_show_32_selector_separated                        ; +17
 00007353  FF72		     1C     dw  lowword(offset (-200 + 58))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00007355  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  16,  6, 23,  6, (-200 + 48), invDEBI_quick_watch_show_EBP_relative_32
			     1C ; Used when the mouse is hovering over these coordinates
 0000735A  0A		     1C     db  _HOVER                      ; +0
 0000735B  00000080	     1C     dd  16 * FONT_X                 ; +1
 0000735F  00000024	     1C     dd  6 * FONT_Y                 ; +5
 00007363  000000BF	     1C     dd  (23 * FONT_X) + FONT_X - 1  ; +9
 00007367  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 0000736B  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 0000736F  FF68		     1C     dw  lowword(offset (-200 + 48))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00007371  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  16,  7, 24,  7, (-200 + 38), invDEBI_quick_watch_show_32_selector_separated
			     1C ; Used when the mouse is hovering over these coordinates
 00007376  0A		     1C     db  _HOVER                      ; +0
 00007377  00000080	     1C     dd  16 * FONT_X                 ; +1
 0000737B  0000002A	     1C     dd  7 * FONT_Y                 ; +5
 0000737F  000000C7	     1C     dd  (24 * FONT_X) + FONT_X - 1  ; +9
 00007383  0000002F	     1C     dd  (7 * FONT_Y) + FONT_Y - 1  ; +13
 00007387  00005105 R	     1C     dd  invDEBI_quick_watch_show_32_selector_separated                        ; +17
 0000738B  FF5E		     1C     dw  lowword(offset (-200 + 38))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000738D  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  28,  4, 43,  4, (-200 + 00), invDEBI_quick_watch_show_fpu_cw
			     1C ; Used when the mouse is hovering over these coordinates
 00007392  0A		     1C     db  _HOVER                      ; +0
 00007393  000000E0	     1C     dd  28 * FONT_X                 ; +1
 00007397  00000018	     1C     dd  4 * FONT_Y                 ; +5
 0000739B  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 0000739F  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 000073A3  00002FEB R	     1C     dd  invDEBI_quick_watch_show_fpu_cw                        ; +17
 000073A7  FF38		     1C     dw  lowword(offset (-200 + 00))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000073A9  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  28,  8, 43,  8, (-200 + 04), invDEBI_quick_watch_show_fpu_sw
			     1C ; Used when the mouse is hovering over these coordinates
 000073AE  0A		     1C     db  _HOVER                      ; +0
 000073AF  000000E0	     1C     dd  28 * FONT_X                 ; +1
 000073B3  00000030	     1C     dd  8 * FONT_Y                 ; +5
 000073B7  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 000073BB  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 000073BF  00003109 R	     1C     dd  invDEBI_quick_watch_show_fpu_sw                        ; +17
 000073C3  FF3C		     1C     dw  lowword(offset (-200 + 04))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000073C5  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  28, 12, 43, 12, (-200 + 08), invDEBI_quick_watch_show_fpu_tw
			     1C ; Used when the mouse is hovering over these coordinates
 000073CA  0A		     1C     db  _HOVER                      ; +0
 000073CB  000000E0	     1C     dd  28 * FONT_X                 ; +1
 000073CF  00000048	     1C     dd  12 * FONT_Y                 ; +5
 000073D3  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 000073D7  0000004D	     1C     dd  (12 * FONT_Y) + FONT_Y - 1  ; +13
 000073DB  0000322B R	     1C     dd  invDEBI_quick_watch_show_fpu_tw                        ; +17
 000073DF  FF40		     1C     dw  lowword(offset (-200 + 08))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000073E1  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   28,  4, 43,  4, (-200 + 98), edit_binary_32
			     1C ; Used when a left-click is recognized on an item that can be edited
 000073E6  0B		     1C     db  _EDIT                       ; +0
 000073E7  000000E0	     1C     dd  28 * FONT_X                 ; +1
 000073EB  00000018	     1C     dd  4 * FONT_Y                 ; +5
 000073EF  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 000073F3  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 000073F7  0000B76C R	     1C     dd  edit_binary_32                        ; +17
 000073FB  FF9A		     1C     dw  lowword(offset (-200 + 98))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000073FD  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   28,  8, 43,  8, (-200 + 88), edit_binary_32
			     1C ; Used when a left-click is recognized on an item that can be edited
 00007402  0B		     1C     db  _EDIT                       ; +0
 00007403  000000E0	     1C     dd  28 * FONT_X                 ; +1
 00007407  00000030	     1C     dd  8 * FONT_Y                 ; +5
 0000740B  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 0000740F  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00007413  0000B76C R	     1C     dd  edit_binary_32                        ; +17
 00007417  FF90		     1C     dw  lowword(offset (-200 + 88))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00007419  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Edit                   28, 12, 43, 12, (-200 + 78), edit_binary_32
			     1C ; Used when a left-click is recognized on an item that can be edited
 0000741E  0B		     1C     db  _EDIT                       ; +0
 0000741F  000000E0	     1C     dd  28 * FONT_X                 ; +1
 00007423  00000048	     1C     dd  12 * FONT_Y                 ; +5
 00007427  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 0000742B  0000004D	     1C     dd  (12 * FONT_Y) + FONT_Y - 1  ; +13
 0000742F  0000B76C R	     1C     dd  edit_binary_32                        ; +17
 00007433  FF86		     1C     dw  lowword(offset (-200 + 78))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00007435  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  33, 15, 43, 15, (-200 + 28), invDEBI_quick_watch_show_fpu_opcode
			     1C ; Used when the mouse is hovering over these coordinates
 0000743A  0A		     1C     db  _HOVER                      ; +0
 0000743B  00000108	     1C     dd  33 * FONT_X                 ; +1
 0000743F  0000005A	     1C     dd  15 * FONT_Y                 ; +5
 00007443  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 00007447  0000005F	     1C     dd  (15 * FONT_Y) + FONT_Y - 1  ; +13
 0000744B  000032AF R	     1C     dd  invDEBI_quick_watch_show_fpu_opcode                        ; +17
 0000744F  FF54		     1C     dw  lowword(offset (-200 + 28))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00007451  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  9, 25,  9, (-200 + 98), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00007456  0A		     1C     db  _HOVER                      ; +0
 00007457  00000030	     1C     dd  6 * FONT_X                 ; +1
 0000745B  00000036	     1C     dd  9 * FONT_Y                 ; +5
 0000745F  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 00007463  0000003B	     1C     dd  (9 * FONT_Y) + FONT_Y - 1  ; +13
 00007467  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 0000746B  FF9A		     1C     dw  lowword(offset (-200 + 98))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000746D  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6, 10, 25, 10, (-200 + 88), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00007472  0A		     1C     db  _HOVER                      ; +0
 00007473  00000030	     1C     dd  6 * FONT_X                 ; +1
 00007477  0000003C	     1C     dd  10 * FONT_Y                 ; +5
 0000747B  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 0000747F  00000041	     1C     dd  (10 * FONT_Y) + FONT_Y - 1  ; +13
 00007483  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00007487  FF90		     1C     dw  lowword(offset (-200 + 88))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00007489  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6, 11, 25, 11, (-200 + 78), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 0000748E  0A		     1C     db  _HOVER                      ; +0
 0000748F  00000030	     1C     dd  6 * FONT_X                 ; +1
 00007493  00000042	     1C     dd  11 * FONT_Y                 ; +5
 00007497  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 0000749B  00000047	     1C     dd  (11 * FONT_Y) + FONT_Y - 1  ; +13
 0000749F  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 000074A3  FF86		     1C     dw  lowword(offset (-200 + 78))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000074A5  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6, 12, 25, 12, (-200 + 68), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 000074AA  0A		     1C     db  _HOVER                      ; +0
 000074AB  00000030	     1C     dd  6 * FONT_X                 ; +1
 000074AF  00000048	     1C     dd  12 * FONT_Y                 ; +5
 000074B3  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 000074B7  0000004D	     1C     dd  (12 * FONT_Y) + FONT_Y - 1  ; +13
 000074BB  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 000074BF  FF7C		     1C     dw  lowword(offset (-200 + 68))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000074C1  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6, 13, 25, 13, (-200 + 58), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 000074C6  0A		     1C     db  _HOVER                      ; +0
 000074C7  00000030	     1C     dd  6 * FONT_X                 ; +1
 000074CB  0000004E	     1C     dd  13 * FONT_Y                 ; +5
 000074CF  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 000074D3  00000053	     1C     dd  (13 * FONT_Y) + FONT_Y - 1  ; +13
 000074D7  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 000074DB  FF72		     1C     dw  lowword(offset (-200 + 58))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000074DD  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6, 14, 25, 14, (-200 + 48), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 000074E2  0A		     1C     db  _HOVER                      ; +0
 000074E3  00000030	     1C     dd  6 * FONT_X                 ; +1
 000074E7  00000054	     1C     dd  14 * FONT_Y                 ; +5
 000074EB  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 000074EF  00000059	     1C     dd  (14 * FONT_Y) + FONT_Y - 1  ; +13
 000074F3  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 000074F7  FF68		     1C     dw  lowword(offset (-200 + 48))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000074F9  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6, 15, 25, 15, (-200 + 38), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 000074FE  0A		     1C     db  _HOVER                      ; +0
 000074FF  00000030	     1C     dd  6 * FONT_X                 ; +1
 00007503  0000005A	     1C     dd  15 * FONT_Y                 ; +5
 00007507  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 0000750B  0000005F	     1C     dd  (15 * FONT_Y) + FONT_Y - 1  ; +13
 0000750F  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00007513  FF5E		     1C     dw  lowword(offset (-200 + 38))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00007515  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6, 16, 25, 16, (-200 + 28), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 0000751A  0A		     1C     db  _HOVER                      ; +0
 0000751B  00000030	     1C     dd  6 * FONT_X                 ; +1
 0000751F  00000060	     1C     dd  16 * FONT_Y                 ; +5
 00007523  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 00007527  00000065	     1C     dd  (16 * FONT_Y) + FONT_Y - 1  ; +13
 0000752B  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 0000752F  FF54		     1C     dw  lowword(offset (-200 + 28))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00007531  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @End
 00007536  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
			      C                                 ;          11111111112222222222
			      C                                 ;012345678901234567890123456789
 00007537 C9 9A CD 81 20      C DEBI_g_window               db  "…öÕÅ Mem.2 ÖÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª",0      ; 0
	   4D 65 6D 2E 32
	   20 85 CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD BB
	   00
 00007556  20 20 20 20 20     C                             db  "                             ∫",0      ; 1
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00007575  20 20 20 20 20     C                             db  "                             ∫",0      ; 2
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00007594  20 20 20 20 20     C                             db  "                             ∫",0      ; 3
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 000075B3  20 20 20 20 20     C                             db  "                             ∫",0      ; 4
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 000075D2  20 20 20 20 20     C                             db  "                             ∫",0      ; 5
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 000075F1  20 20 20 20 20     C                             db  "                             ∫",0      ; 6
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00007610  20 20 20 20 20     C                             db  "                             ∫",0      ; 7
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 0000762F  20 20 20 20 20     C                             db  "                             ∫",0      ; 8
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 0000764E  20 20 20 20 20     C                             db  "                             ∫",0      ; 9
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 0000766D  20 20 20 20 20     C                             db  "                             ∫",0      ; 10
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 0000768C  20 20 20 20 20     C                             db  "                             ∫",0      ; 11
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 000076AB  20 20 20 20 20     C                             db  "                             ∫",0      ; 12
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 000076CA  FF		      C                             db  255
			      C                                                                     ;                  the editable variable should be)
 000076CB  00F0		      C                             dw  30 * FONT_X
 000076CD  004D		      C                             dw  13 * FONT_Y - 1
 000076CF		      C DEBI_g_screen_objects:
			      C     @DrawWindow             DEBI_g_window
			     1C ; Draws the window for whatever item is specified
 000076CF  FD		     1C     db  _DRAW_WINDOW
 000076D0  00007537 R	     1C     dd  offset DEBI_g_window
			     1C   ; Total = 5
			      C     @ObjectMemSize          4+2+96              ; +4 is for PTR, +2 is for offset, +96 is for data
			     1C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
 000076D4  00		     1C     db  _OBJECT_MEM_SIZE
 000076D5  66		     1C     db  4+2+96
			     1C   ; Total = 2
			      C     @FunctionHandlesObject  invDEBI_mem2_window
 000076D6  07		     1C     db  _FUNCTION
 000076D7  000032EB R	     1C     dd  offset invDEBI_mem2_window
			     1C   ; Total = 5
			      C     @End
 000076DB  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C                           ; x1, y1, x2, y2, function() that handles it when this item is clicked
			      C ALIGN
 000076DC		      C DEBI_g_mouse_objects:
			      C     @Left_single_click       1,  0,  1,  0, invDEBI_object_close
			     1C ; Used when a left single-click is recognized on these coordinates
 000076DC  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 000076DD  00000008	     1C     dd  1 * FONT_X                 ; +1
 000076E1  00000000	     1C     dd  0 * FONT_Y                 ; +5
 000076E5  0000000F	     1C     dd  (1 * FONT_X) + FONT_X - 1  ; +9
 000076E9  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 000076ED  0000510B R	     1C     dd  invDEBI_object_close                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 000076F1  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 000076F5  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 000076F7  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_single_click       3,  0, 11,  0, invDEBI_address_expression
			     1C ; Used when a left single-click is recognized on these coordinates
 000076F8  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 000076F9  00000018	     1C     dd  3 * FONT_X                 ; +1
 000076FD  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00007701  0000005F	     1C     dd  (11 * FONT_X) + FONT_X - 1  ; +9
 00007705  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00007709  00005156 R	     1C     dd  invDEBI_address_expression                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 0000770D  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00007711  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00007713  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      3,  0, 11,  0, invDEBI_mem_2_right_click
			     1C ; Used when a right single-click is recognized on these coordinates
 00007714  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 00007715  00000018	     1C     dd  3 * FONT_X                 ; +1
 00007719  00000000	     1C     dd  0 * FONT_Y                 ; +5
 0000771D  0000005F	     1C     dd  (11 * FONT_X) + FONT_X - 1  ; +9
 00007721  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00007725  000039C0 R	     1C     dd  invDEBI_mem_2_right_click                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00007729  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000772D  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000772F  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         0,  0, 29,  0, invDEBI_object_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 00007730  02		     1C     db  _LEFT_DRAG_START            ; +0
 00007731  00000000	     1C     dd  0 * FONT_X                 ; +1
 00007735  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00007739  000000EF	     1C     dd  (29 * FONT_X) + FONT_X - 1  ; +9
 0000773D  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00007741  00003BE5 R	     1C     dd  invDEBI_object_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00007745  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00007749  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000774B  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Abandon_if_not          6,  1, 28, 12
			     1C ; Used in a lengthy list.  If the coordinates are not within this range then the rest of the lengthy list is not checked
 0000774C  0C		     1C     db  _ABANDON_IF_NOT             ; +0
 0000774D  00000030	     1C     dd  6 * FONT_X                 ; +1
 00007751  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00007755  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 00007759  0000004D	     1C     dd  (12 * FONT_Y) + FONT_Y - 1  ; +13
 0000775D  0000000B [	     1C     db  11 dup(0ffh)                ; +17
	    FF
	   ]
			     1C   ; Total = 28
			      C     @Hover                   6,  1, 13,  1, 00+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00007768  0A		     1C     db  _HOVER                      ; +0
 00007769  00000030	     1C     dd  6 * FONT_X                 ; +1
 0000776D  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00007771  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00007775  0000000B	     1C     dd  (1 * FONT_Y) + FONT_Y - 1  ; +13
 00007779  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 0000777D  0006		     1C     dw  lowword(offset 00+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000777F  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  21,  1, 28,  1, 04+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00007784  0A		     1C     db  _HOVER                      ; +0
 00007785  000000A8	     1C     dd  21 * FONT_X                 ; +1
 00007789  00000006	     1C     dd  1 * FONT_Y                 ; +5
 0000778D  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 00007791  0000000B	     1C     dd  (1 * FONT_Y) + FONT_Y - 1  ; +13
 00007795  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00007799  000A		     1C     dw  lowword(offset 04+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000779B  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  2, 13,  2, 08+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 000077A0  0A		     1C     db  _HOVER                      ; +0
 000077A1  00000030	     1C     dd  6 * FONT_X                 ; +1
 000077A5  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 000077A9  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 000077AD  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 000077B1  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 000077B5  000E		     1C     dw  lowword(offset 08+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000077B7  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  21,  2, 28,  2, 12+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 000077BC  0A		     1C     db  _HOVER                      ; +0
 000077BD  000000A8	     1C     dd  21 * FONT_X                 ; +1
 000077C1  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 000077C5  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 000077C9  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 000077CD  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 000077D1  0012		     1C     dw  lowword(offset 12+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000077D3  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  3, 13,  3, 16+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 000077D8  0A		     1C     db  _HOVER                      ; +0
 000077D9  00000030	     1C     dd  6 * FONT_X                 ; +1
 000077DD  00000012	     1C     dd  3 * FONT_Y                 ; +5
 000077E1  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 000077E5  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 000077E9  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 000077ED  0016		     1C     dw  lowword(offset 16+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000077EF  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  21,  3, 28,  3, 20+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 000077F4  0A		     1C     db  _HOVER                      ; +0
 000077F5  000000A8	     1C     dd  21 * FONT_X                 ; +1
 000077F9  00000012	     1C     dd  3 * FONT_Y                 ; +5
 000077FD  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 00007801  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 00007805  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00007809  001A		     1C     dw  lowword(offset 20+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000780B  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  4, 13,  4, 24+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00007810  0A		     1C     db  _HOVER                      ; +0
 00007811  00000030	     1C     dd  6 * FONT_X                 ; +1
 00007815  00000018	     1C     dd  4 * FONT_Y                 ; +5
 00007819  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 0000781D  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 00007821  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00007825  001E		     1C     dw  lowword(offset 24+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00007827  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  21,  4, 28,  4, 28+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 0000782C  0A		     1C     db  _HOVER                      ; +0
 0000782D  000000A8	     1C     dd  21 * FONT_X                 ; +1
 00007831  00000018	     1C     dd  4 * FONT_Y                 ; +5
 00007835  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 00007839  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 0000783D  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00007841  0022		     1C     dw  lowword(offset 28+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00007843  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  5, 13,  5, 32+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00007848  0A		     1C     db  _HOVER                      ; +0
 00007849  00000030	     1C     dd  6 * FONT_X                 ; +1
 0000784D  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 00007851  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00007855  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 00007859  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 0000785D  0026		     1C     dw  lowword(offset 32+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000785F  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  21,  5, 28,  5, 36+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00007864  0A		     1C     db  _HOVER                      ; +0
 00007865  000000A8	     1C     dd  21 * FONT_X                 ; +1
 00007869  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 0000786D  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 00007871  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 00007875  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00007879  002A		     1C     dw  lowword(offset 36+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000787B  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  6, 13,  6, 40+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00007880  0A		     1C     db  _HOVER                      ; +0
 00007881  00000030	     1C     dd  6 * FONT_X                 ; +1
 00007885  00000024	     1C     dd  6 * FONT_Y                 ; +5
 00007889  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 0000788D  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 00007891  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00007895  002E		     1C     dw  lowword(offset 40+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00007897  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  21,  6, 28,  6, 44+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 0000789C  0A		     1C     db  _HOVER                      ; +0
 0000789D  000000A8	     1C     dd  21 * FONT_X                 ; +1
 000078A1  00000024	     1C     dd  6 * FONT_Y                 ; +5
 000078A5  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 000078A9  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 000078AD  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 000078B1  0032		     1C     dw  lowword(offset 44+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000078B3  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  7, 13,  7, 48+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 000078B8  0A		     1C     db  _HOVER                      ; +0
 000078B9  00000030	     1C     dd  6 * FONT_X                 ; +1
 000078BD  0000002A	     1C     dd  7 * FONT_Y                 ; +5
 000078C1  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 000078C5  0000002F	     1C     dd  (7 * FONT_Y) + FONT_Y - 1  ; +13
 000078C9  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 000078CD  0036		     1C     dw  lowword(offset 48+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000078CF  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  21,  7, 28,  7, 52+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 000078D4  0A		     1C     db  _HOVER                      ; +0
 000078D5  000000A8	     1C     dd  21 * FONT_X                 ; +1
 000078D9  0000002A	     1C     dd  7 * FONT_Y                 ; +5
 000078DD  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 000078E1  0000002F	     1C     dd  (7 * FONT_Y) + FONT_Y - 1  ; +13
 000078E5  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 000078E9  003A		     1C     dw  lowword(offset 52+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000078EB  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  8, 13,  8, 56+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 000078F0  0A		     1C     db  _HOVER                      ; +0
 000078F1  00000030	     1C     dd  6 * FONT_X                 ; +1
 000078F5  00000030	     1C     dd  8 * FONT_Y                 ; +5
 000078F9  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 000078FD  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00007901  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00007905  003E		     1C     dw  lowword(offset 56+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00007907  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  21,  8, 28,  8, 60+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 0000790C  0A		     1C     db  _HOVER                      ; +0
 0000790D  000000A8	     1C     dd  21 * FONT_X                 ; +1
 00007911  00000030	     1C     dd  8 * FONT_Y                 ; +5
 00007915  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 00007919  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 0000791D  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00007921  0042		     1C     dw  lowword(offset 60+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00007923  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  8, 13,  9, 64+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00007928  0A		     1C     db  _HOVER                      ; +0
 00007929  00000030	     1C     dd  6 * FONT_X                 ; +1
 0000792D  00000030	     1C     dd  8 * FONT_Y                 ; +5
 00007931  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00007935  0000003B	     1C     dd  (9 * FONT_Y) + FONT_Y - 1  ; +13
 00007939  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 0000793D  0046		     1C     dw  lowword(offset 64+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000793F  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  21,  8, 28,  9, 68+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00007944  0A		     1C     db  _HOVER                      ; +0
 00007945  000000A8	     1C     dd  21 * FONT_X                 ; +1
 00007949  00000030	     1C     dd  8 * FONT_Y                 ; +5
 0000794D  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 00007951  0000003B	     1C     dd  (9 * FONT_Y) + FONT_Y - 1  ; +13
 00007955  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00007959  004A		     1C     dw  lowword(offset 68+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000795B  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  8, 13, 10, 72+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00007960  0A		     1C     db  _HOVER                      ; +0
 00007961  00000030	     1C     dd  6 * FONT_X                 ; +1
 00007965  00000030	     1C     dd  8 * FONT_Y                 ; +5
 00007969  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 0000796D  00000041	     1C     dd  (10 * FONT_Y) + FONT_Y - 1  ; +13
 00007971  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00007975  004E		     1C     dw  lowword(offset 72+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00007977  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  21,  8, 28, 10, 76+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 0000797C  0A		     1C     db  _HOVER                      ; +0
 0000797D  000000A8	     1C     dd  21 * FONT_X                 ; +1
 00007981  00000030	     1C     dd  8 * FONT_Y                 ; +5
 00007985  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 00007989  00000041	     1C     dd  (10 * FONT_Y) + FONT_Y - 1  ; +13
 0000798D  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00007991  0052		     1C     dw  lowword(offset 76+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00007993  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  8, 13, 11, 80+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00007998  0A		     1C     db  _HOVER                      ; +0
 00007999  00000030	     1C     dd  6 * FONT_X                 ; +1
 0000799D  00000030	     1C     dd  8 * FONT_Y                 ; +5
 000079A1  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 000079A5  00000047	     1C     dd  (11 * FONT_Y) + FONT_Y - 1  ; +13
 000079A9  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 000079AD  0056		     1C     dw  lowword(offset 80+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000079AF  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  21,  8, 28, 11, 84+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 000079B4  0A		     1C     db  _HOVER                      ; +0
 000079B5  000000A8	     1C     dd  21 * FONT_X                 ; +1
 000079B9  00000030	     1C     dd  8 * FONT_Y                 ; +5
 000079BD  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 000079C1  00000047	     1C     dd  (11 * FONT_Y) + FONT_Y - 1  ; +13
 000079C5  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 000079C9  005A		     1C     dw  lowword(offset 84+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000079CB  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  8, 13, 12, 88+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 000079D0  0A		     1C     db  _HOVER                      ; +0
 000079D1  00000030	     1C     dd  6 * FONT_X                 ; +1
 000079D5  00000030	     1C     dd  8 * FONT_Y                 ; +5
 000079D9  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 000079DD  0000004D	     1C     dd  (12 * FONT_Y) + FONT_Y - 1  ; +13
 000079E1  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 000079E5  005E		     1C     dw  lowword(offset 88+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000079E7  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  21,  8, 28, 12, 92+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 000079EC  0A		     1C     db  _HOVER                      ; +0
 000079ED  000000A8	     1C     dd  21 * FONT_X                 ; +1
 000079F1  00000030	     1C     dd  8 * FONT_Y                 ; +5
 000079F5  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 000079F9  0000004D	     1C     dd  (12 * FONT_Y) + FONT_Y - 1  ; +13
 000079FD  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00007A01  0062		     1C     dw  lowword(offset 92+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00007A03  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @End
 00007A08  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
			      C 
			      C                                 ;          11111111112222222222333333333344444444445555555555
			      C                                 ;012345678901234567890123456789012345678901234567890123456789
 00007A09 C9 9A CD 81 20      C DEBI_h_window               db  "…öÕÅ Mem.4 ÖÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª",0        ; 0
	   4D 65 6D 2E 34
	   20 85 CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD BB
	   00
 00007A46  20 20 20 20 20     C                             db  "                                                           ∫",0        ; 1
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00007A83  20 20 20 20 20     C                             db  "                                                           ∫",0        ; 2
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00007AC0  20 20 20 20 20     C                             db  "                                                           ∫",0        ; 3
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00007AFD  20 20 20 20 20     C                             db  "                                                           ∫",0        ; 4
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00007B3A  20 20 20 20 20     C                             db  "                                                           ∫",0        ; 5
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00007B77  20 20 20 20 20     C                             db  "                                                           ∫",0        ; 6
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00007BB4  20 20 20 20 20     C                             db  "                                                           ∫",0        ; 7
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00007BF1  20 20 20 20 20     C                             db  "                                                           ∫",0        ; 8
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00007C2E  20 20 20 20 20     C                             db  "                                                           ∫",0        ; 9
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00007C6B  20 20 20 20 20     C                             db  "                                                           ∫",0        ; 10
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00007CA8  20 20 20 20 20     C                             db  "                                                           ∫",0        ; 11
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00007CE5  20 20 20 20 20     C                             db  "                                                           ∫",0        ; 12
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00007D22  FF		      C                             db  255
			      C 
 00007D23  01E0		      C                             dw  60 * FONT_X
 00007D25  004D		      C                             dw  13 * FONT_Y - 1
 00007D27		      C DEBI_h_screen_objects:
			      C     @DrawWindow             DEBI_h_window
			     1C ; Draws the window for whatever item is specified
 00007D27  FD		     1C     db  _DRAW_WINDOW
 00007D28  00007A09 R	     1C     dd  offset DEBI_h_window
			     1C   ; Total = 5
			      C     @ObjectMemSize          4+2+208             ; +4 is for PTR, +2 is for offset, +208 is for data
			     1C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
 00007D2C  00		     1C     db  _OBJECT_MEM_SIZE
 00007D2D  D6		     1C     db  4+2+208
			     1C   ; Total = 2
			      C     @FunctionHandlesObject  invDEBI_mem4_window
 00007D2E  07		     1C     db  _FUNCTION
 00007D2F  00003307 R	     1C     dd  offset invDEBI_mem4_window
			     1C   ; Total = 5
			      C     @End
 00007D33  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C                           ; x1, y1, x2, y2, function() that handles it when this item is clicked
			      C ALIGN
 00007D34		      C DEBI_h_mouse_objects:
			      C     @Left_single_click       1,  0,  1,  0, invDEBI_object_close
			     1C ; Used when a left single-click is recognized on these coordinates
 00007D34  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 00007D35  00000008	     1C     dd  1 * FONT_X                 ; +1
 00007D39  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00007D3D  0000000F	     1C     dd  (1 * FONT_X) + FONT_X - 1  ; +9
 00007D41  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00007D45  0000510B R	     1C     dd  invDEBI_object_close                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00007D49  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00007D4D  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00007D4F  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      3,  0, 11,  0, invDEBI_mem_4_right_click
			     1C ; Used when a right single-click is recognized on these coordinates
 00007D50  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 00007D51  00000018	     1C     dd  3 * FONT_X                 ; +1
 00007D55  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00007D59  0000005F	     1C     dd  (11 * FONT_X) + FONT_X - 1  ; +9
 00007D5D  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00007D61  000039C0 R	     1C     dd  invDEBI_mem_4_right_click                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00007D65  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00007D69  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00007D6B  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_single_click       3,  0, 11,  0, invDEBI_address_expression
			     1C ; Used when a left single-click is recognized on these coordinates
 00007D6C  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 00007D6D  00000018	     1C     dd  3 * FONT_X                 ; +1
 00007D71  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00007D75  0000005F	     1C     dd  (11 * FONT_X) + FONT_X - 1  ; +9
 00007D79  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00007D7D  00005156 R	     1C     dd  invDEBI_address_expression                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00007D81  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00007D85  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00007D87  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         0,  0, 44,  0, invDEBI_object_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 00007D88  02		     1C     db  _LEFT_DRAG_START            ; +0
 00007D89  00000000	     1C     dd  0 * FONT_X                 ; +1
 00007D8D  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00007D91  00000167	     1C     dd  (44 * FONT_X) + FONT_X - 1  ; +9
 00007D95  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00007D99  00003BE5 R	     1C     dd  invDEBI_object_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00007D9D  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00007DA1  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00007DA3  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @End
 00007DA4  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
			      C 
			      C                                 ;          11111
			      C                                 ;012345678901234
 00007DA5 C9 9A CD 81 20      C DEBI_i_window               db  "…öÕÅ Stack ÖÕÕª",0
	   53 74 61 63 6B
	   20 85 CD CD BB
	   00
 00007DB5  2B 30 30 33 34     C                             db  "+0034 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00007DC5  2B 30 30 33 30     C                             db  "+0030 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00007DD5  2B 30 30 32 63     C                             db  "+002c ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00007DE5  2B 30 30 32 38     C                             db  "+0028 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00007DF5  2B 30 30 32 34     C                             db  "+0024 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00007E05  2B 30 30 32 30     C                             db  "+0020 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00007E15  2B 30 30 31 63     C                             db  "+001c ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00007E25  2B 30 30 31 38     C                             db  "+0018 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00007E35  2B 30 30 31 34     C                             db  "+0014 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00007E45  2B 30 30 31 30     C                             db  "+0010 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00007E55  2B 30 30 30 63     C                             db  "+000c ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00007E65  2B 30 30 30 38     C                             db  "+0008 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00007E75  2B 30 30 30 34     C                             db  "+0004 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00007E85  2B 30 30 30 30     C                             db  "+0000 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00007E95  FF		      C                             db  255
			      C 
 00007E96  0078		      C                             dw  15 * FONT_X
 00007E98  0059		      C                             dw  15 * FONT_Y - 1
 00007E9A		      C DEBI_i_screen_objects:
			      C     @DrawWindow             DEBI_i_window
			     1C ; Draws the window for whatever item is specified
 00007E9A  FD		     1C     db  _DRAW_WINDOW
 00007E9B  00007DA5 R	     1C     dd  offset DEBI_i_window
			     1C   ; Total = 5
			      C     @ObjectMemSize          32
			     1C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
 00007E9F  00		     1C     db  _OBJECT_MEM_SIZE
 00007EA0  20		     1C     db  32
			     1C   ; Total = 2
			      C     @DisplayESP_through_EBP_relative   _32,  34h, 28, 6, 1
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007EA1  03		     1C     db  _DISPLAY
 00007EA2  03		     1C     db  _ESP_THROUGH_EBP_RELATIVE
 00007EA3  05		     1C     db  _32
 00007EA4  0034		     1C     dw  34h
 00007EA6  1C		     1C     db  28
 00007EA7  00000030	     1C     dd  6 * FONT_X
 00007EAB  00000006	     1C     dd  1 * FONT_Y
 00007EAF  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayESP_through_EBP_relative   _32,  30h, 28, 6, 2
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007EB1  03		     1C     db  _DISPLAY
 00007EB2  03		     1C     db  _ESP_THROUGH_EBP_RELATIVE
 00007EB3  05		     1C     db  _32
 00007EB4  0030		     1C     dw  30h
 00007EB6  1C		     1C     db  28
 00007EB7  00000030	     1C     dd  6 * FONT_X
 00007EBB  0000000C	     1C     dd  2 * FONT_Y
 00007EBF  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayESP_through_EBP_relative   _32,  2ch, 28, 6, 3
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007EC1  03		     1C     db  _DISPLAY
 00007EC2  03		     1C     db  _ESP_THROUGH_EBP_RELATIVE
 00007EC3  05		     1C     db  _32
 00007EC4  002C		     1C     dw  2ch
 00007EC6  1C		     1C     db  28
 00007EC7  00000030	     1C     dd  6 * FONT_X
 00007ECB  00000012	     1C     dd  3 * FONT_Y
 00007ECF  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayESP_through_EBP_relative   _32,  28h, 28, 6, 4
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007ED1  03		     1C     db  _DISPLAY
 00007ED2  03		     1C     db  _ESP_THROUGH_EBP_RELATIVE
 00007ED3  05		     1C     db  _32
 00007ED4  0028		     1C     dw  28h
 00007ED6  1C		     1C     db  28
 00007ED7  00000030	     1C     dd  6 * FONT_X
 00007EDB  00000018	     1C     dd  4 * FONT_Y
 00007EDF  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayESP_through_EBP_relative   _32,  24h, 28, 6, 5
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007EE1  03		     1C     db  _DISPLAY
 00007EE2  03		     1C     db  _ESP_THROUGH_EBP_RELATIVE
 00007EE3  05		     1C     db  _32
 00007EE4  0024		     1C     dw  24h
 00007EE6  1C		     1C     db  28
 00007EE7  00000030	     1C     dd  6 * FONT_X
 00007EEB  0000001E	     1C     dd  5 * FONT_Y
 00007EEF  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayESP_through_EBP_relative   _32,  20h, 28, 6, 6
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007EF1  03		     1C     db  _DISPLAY
 00007EF2  03		     1C     db  _ESP_THROUGH_EBP_RELATIVE
 00007EF3  05		     1C     db  _32
 00007EF4  0020		     1C     dw  20h
 00007EF6  1C		     1C     db  28
 00007EF7  00000030	     1C     dd  6 * FONT_X
 00007EFB  00000024	     1C     dd  6 * FONT_Y
 00007EFF  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayESP_through_EBP_relative   _32,  1ch, 28, 6, 7
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007F01  03		     1C     db  _DISPLAY
 00007F02  03		     1C     db  _ESP_THROUGH_EBP_RELATIVE
 00007F03  05		     1C     db  _32
 00007F04  001C		     1C     dw  1ch
 00007F06  1C		     1C     db  28
 00007F07  00000030	     1C     dd  6 * FONT_X
 00007F0B  0000002A	     1C     dd  7 * FONT_Y
 00007F0F  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayESP_through_EBP_relative   _32,  18h, 24, 6, 8
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007F11  03		     1C     db  _DISPLAY
 00007F12  03		     1C     db  _ESP_THROUGH_EBP_RELATIVE
 00007F13  05		     1C     db  _32
 00007F14  0018		     1C     dw  18h
 00007F16  18		     1C     db  24
 00007F17  00000030	     1C     dd  6 * FONT_X
 00007F1B  00000030	     1C     dd  8 * FONT_Y
 00007F1F  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayESP_through_EBP_relative   _32,  14h, 20, 6, 9
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007F21  03		     1C     db  _DISPLAY
 00007F22  03		     1C     db  _ESP_THROUGH_EBP_RELATIVE
 00007F23  05		     1C     db  _32
 00007F24  0014		     1C     dw  14h
 00007F26  14		     1C     db  20
 00007F27  00000030	     1C     dd  6 * FONT_X
 00007F2B  00000036	     1C     dd  9 * FONT_Y
 00007F2F  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayESP_through_EBP_relative   _32,  10h, 16, 6,10
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007F31  03		     1C     db  _DISPLAY
 00007F32  03		     1C     db  _ESP_THROUGH_EBP_RELATIVE
 00007F33  05		     1C     db  _32
 00007F34  0010		     1C     dw  10h
 00007F36  10		     1C     db  16
 00007F37  00000030	     1C     dd  6 * FONT_X
 00007F3B  0000003C	     1C     dd  10 * FONT_Y
 00007F3F  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayESP_through_EBP_relative   _32,  0ch, 12, 6,11
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007F41  03		     1C     db  _DISPLAY
 00007F42  03		     1C     db  _ESP_THROUGH_EBP_RELATIVE
 00007F43  05		     1C     db  _32
 00007F44  000C		     1C     dw  0ch
 00007F46  0C		     1C     db  12
 00007F47  00000030	     1C     dd  6 * FONT_X
 00007F4B  00000042	     1C     dd  11 * FONT_Y
 00007F4F  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayESP_through_EBP_relative   _32,  08h,  8, 6,12
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007F51  03		     1C     db  _DISPLAY
 00007F52  03		     1C     db  _ESP_THROUGH_EBP_RELATIVE
 00007F53  05		     1C     db  _32
 00007F54  0008		     1C     dw  08h
 00007F56  08		     1C     db  8
 00007F57  00000030	     1C     dd  6 * FONT_X
 00007F5B  00000048	     1C     dd  12 * FONT_Y
 00007F5F  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayESP_through_EBP_relative   _32,  04h,  4, 6,13
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007F61  03		     1C     db  _DISPLAY
 00007F62  03		     1C     db  _ESP_THROUGH_EBP_RELATIVE
 00007F63  05		     1C     db  _32
 00007F64  0004		     1C     dw  04h
 00007F66  04		     1C     db  4
 00007F67  00000030	     1C     dd  6 * FONT_X
 00007F6B  0000004E	     1C     dd  13 * FONT_Y
 00007F6F  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayESP_through_EBP_relative   _32,  00h,  0, 6,14
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00007F71  03		     1C     db  _DISPLAY
 00007F72  03		     1C     db  _ESP_THROUGH_EBP_RELATIVE
 00007F73  05		     1C     db  _32
 00007F74  0000		     1C     dw  00h
 00007F76  00		     1C     db  0
 00007F77  00000030	     1C     dd  6 * FONT_X
 00007F7B  00000054	     1C     dd  14 * FONT_Y
 00007F7F  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @End
 00007F81  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C ALIGN
 00007F82		      C DEBI_i_mouse_objects:
			      C     @Left_single_click       1,  0,  1,  0, invDEBI_object_close
			     1C ; Used when a left single-click is recognized on these coordinates
 00007F82  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 00007F83  00000008	     1C     dd  1 * FONT_X                 ; +1
 00007F87  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00007F8B  0000000F	     1C     dd  (1 * FONT_X) + FONT_X - 1  ; +9
 00007F8F  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00007F93  0000510B R	     1C     dd  invDEBI_object_close                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00007F97  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00007F9B  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00007F9D  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      3,  0, 11,  0, invDEBI_stack_right_click
			     1C ; Used when a right single-click is recognized on these coordinates
 00007F9E  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 00007F9F  00000018	     1C     dd  3 * FONT_X                 ; +1
 00007FA3  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00007FA7  0000005F	     1C     dd  (11 * FONT_X) + FONT_X - 1  ; +9
 00007FAB  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00007FAF  000039C0 R	     1C     dd  invDEBI_stack_right_click                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00007FB3  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00007FB7  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00007FB9  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         0,  0, 14,  0, invDEBI_object_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 00007FBA  02		     1C     db  _LEFT_DRAG_START            ; +0
 00007FBB  00000000	     1C     dd  0 * FONT_X                 ; +1
 00007FBF  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00007FC3  00000077	     1C     dd  (14 * FONT_X) + FONT_X - 1  ; +9
 00007FC7  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00007FCB  00003BE5 R	     1C     dd  invDEBI_object_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00007FCF  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00007FD3  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00007FD5  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Abandon_if_not          6,  1, 13, 14
			     1C ; Used in a lengthy list.  If the coordinates are not within this range then the rest of the lengthy list is not checked
 00007FD6  0C		     1C     db  _ABANDON_IF_NOT             ; +0
 00007FD7  00000030	     1C     dd  6 * FONT_X                 ; +1
 00007FDB  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00007FDF  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00007FE3  00000059	     1C     dd  (14 * FONT_Y) + FONT_Y - 1  ; +13
 00007FE7  0000000B [	     1C     db  11 dup(0ffh)                ; +17
	    FF
	   ]
			     1C   ; Total = 28
			      C     @Hover                   6,  1, 13,  1, 52, invDEBI_quick_watch_stack_32
			     1C ; Used when the mouse is hovering over these coordinates
 00007FF2  0A		     1C     db  _HOVER                      ; +0
 00007FF3  00000030	     1C     dd  6 * FONT_X                 ; +1
 00007FF7  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00007FFB  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00007FFF  0000000B	     1C     dd  (1 * FONT_Y) + FONT_Y - 1  ; +13
 00008003  00003283 R	     1C     dd  invDEBI_quick_watch_stack_32                        ; +17
 00008007  0034		     1C     dw  lowword(offset 52)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008009  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  2, 13,  2, 48, invDEBI_quick_watch_stack_32
			     1C ; Used when the mouse is hovering over these coordinates
 0000800E  0A		     1C     db  _HOVER                      ; +0
 0000800F  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008013  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 00008017  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 0000801B  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 0000801F  00003283 R	     1C     dd  invDEBI_quick_watch_stack_32                        ; +17
 00008023  0030		     1C     dw  lowword(offset 48)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008025  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  3, 13,  3, 44, invDEBI_quick_watch_stack_32
			     1C ; Used when the mouse is hovering over these coordinates
 0000802A  0A		     1C     db  _HOVER                      ; +0
 0000802B  00000030	     1C     dd  6 * FONT_X                 ; +1
 0000802F  00000012	     1C     dd  3 * FONT_Y                 ; +5
 00008033  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008037  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 0000803B  00003283 R	     1C     dd  invDEBI_quick_watch_stack_32                        ; +17
 0000803F  002C		     1C     dw  lowword(offset 44)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008041  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  4, 13,  4, 40, invDEBI_quick_watch_stack_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008046  0A		     1C     db  _HOVER                      ; +0
 00008047  00000030	     1C     dd  6 * FONT_X                 ; +1
 0000804B  00000018	     1C     dd  4 * FONT_Y                 ; +5
 0000804F  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008053  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 00008057  00003283 R	     1C     dd  invDEBI_quick_watch_stack_32                        ; +17
 0000805B  0028		     1C     dw  lowword(offset 40)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000805D  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  5, 13,  5, 36, invDEBI_quick_watch_stack_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008062  0A		     1C     db  _HOVER                      ; +0
 00008063  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008067  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 0000806B  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 0000806F  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 00008073  00003283 R	     1C     dd  invDEBI_quick_watch_stack_32                        ; +17
 00008077  0024		     1C     dw  lowword(offset 36)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008079  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  6, 13,  6, 32, invDEBI_quick_watch_stack_32
			     1C ; Used when the mouse is hovering over these coordinates
 0000807E  0A		     1C     db  _HOVER                      ; +0
 0000807F  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008083  00000024	     1C     dd  6 * FONT_Y                 ; +5
 00008087  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 0000808B  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 0000808F  00003283 R	     1C     dd  invDEBI_quick_watch_stack_32                        ; +17
 00008093  0020		     1C     dw  lowword(offset 32)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008095  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  7, 13,  7, 28, invDEBI_quick_watch_stack_32
			     1C ; Used when the mouse is hovering over these coordinates
 0000809A  0A		     1C     db  _HOVER                      ; +0
 0000809B  00000030	     1C     dd  6 * FONT_X                 ; +1
 0000809F  0000002A	     1C     dd  7 * FONT_Y                 ; +5
 000080A3  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 000080A7  0000002F	     1C     dd  (7 * FONT_Y) + FONT_Y - 1  ; +13
 000080AB  00003283 R	     1C     dd  invDEBI_quick_watch_stack_32                        ; +17
 000080AF  001C		     1C     dw  lowword(offset 28)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000080B1  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  8, 13,  8, 24, invDEBI_quick_watch_stack_32
			     1C ; Used when the mouse is hovering over these coordinates
 000080B6  0A		     1C     db  _HOVER                      ; +0
 000080B7  00000030	     1C     dd  6 * FONT_X                 ; +1
 000080BB  00000030	     1C     dd  8 * FONT_Y                 ; +5
 000080BF  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 000080C3  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 000080C7  00003283 R	     1C     dd  invDEBI_quick_watch_stack_32                        ; +17
 000080CB  0018		     1C     dw  lowword(offset 24)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000080CD  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  9, 13,  9, 20, invDEBI_quick_watch_stack_32
			     1C ; Used when the mouse is hovering over these coordinates
 000080D2  0A		     1C     db  _HOVER                      ; +0
 000080D3  00000030	     1C     dd  6 * FONT_X                 ; +1
 000080D7  00000036	     1C     dd  9 * FONT_Y                 ; +5
 000080DB  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 000080DF  0000003B	     1C     dd  (9 * FONT_Y) + FONT_Y - 1  ; +13
 000080E3  00003283 R	     1C     dd  invDEBI_quick_watch_stack_32                        ; +17
 000080E7  0014		     1C     dw  lowword(offset 20)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000080E9  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6, 10, 13, 10, 16, invDEBI_quick_watch_stack_32
			     1C ; Used when the mouse is hovering over these coordinates
 000080EE  0A		     1C     db  _HOVER                      ; +0
 000080EF  00000030	     1C     dd  6 * FONT_X                 ; +1
 000080F3  0000003C	     1C     dd  10 * FONT_Y                 ; +5
 000080F7  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 000080FB  00000041	     1C     dd  (10 * FONT_Y) + FONT_Y - 1  ; +13
 000080FF  00003283 R	     1C     dd  invDEBI_quick_watch_stack_32                        ; +17
 00008103  0010		     1C     dw  lowword(offset 16)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008105  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6, 11, 13, 11, 12, invDEBI_quick_watch_stack_32
			     1C ; Used when the mouse is hovering over these coordinates
 0000810A  0A		     1C     db  _HOVER                      ; +0
 0000810B  00000030	     1C     dd  6 * FONT_X                 ; +1
 0000810F  00000042	     1C     dd  11 * FONT_Y                 ; +5
 00008113  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008117  00000047	     1C     dd  (11 * FONT_Y) + FONT_Y - 1  ; +13
 0000811B  00003283 R	     1C     dd  invDEBI_quick_watch_stack_32                        ; +17
 0000811F  000C		     1C     dw  lowword(offset 12)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008121  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6, 12, 13, 12, 08, invDEBI_quick_watch_stack_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008126  0A		     1C     db  _HOVER                      ; +0
 00008127  00000030	     1C     dd  6 * FONT_X                 ; +1
 0000812B  00000048	     1C     dd  12 * FONT_Y                 ; +5
 0000812F  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008133  0000004D	     1C     dd  (12 * FONT_Y) + FONT_Y - 1  ; +13
 00008137  00003283 R	     1C     dd  invDEBI_quick_watch_stack_32                        ; +17
 0000813B  0008		     1C     dw  lowword(offset 08)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000813D  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6, 13, 13, 13, 04, invDEBI_quick_watch_stack_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008142  0A		     1C     db  _HOVER                      ; +0
 00008143  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008147  0000004E	     1C     dd  13 * FONT_Y                 ; +5
 0000814B  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 0000814F  00000053	     1C     dd  (13 * FONT_Y) + FONT_Y - 1  ; +13
 00008153  00003283 R	     1C     dd  invDEBI_quick_watch_stack_32                        ; +17
 00008157  0004		     1C     dw  lowword(offset 04)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008159  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6, 14, 13, 14, 00, invDEBI_quick_watch_stack_32
			     1C ; Used when the mouse is hovering over these coordinates
 0000815E  0A		     1C     db  _HOVER                      ; +0
 0000815F  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008163  00000054	     1C     dd  14 * FONT_Y                 ; +5
 00008167  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 0000816B  00000059	     1C     dd  (14 * FONT_Y) + FONT_Y - 1  ; +13
 0000816F  00003283 R	     1C     dd  invDEBI_quick_watch_stack_32                        ; +17
 00008173  0000		     1C     dw  lowword(offset 00)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008175  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @End
 0000817A  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
			      C 
			      C                                 ;          11111111112222222222
			      C                                 ;012345678901234567890123456789
 0000817B 00		      C t_and_s_displayed           db  0
 0000817C C9 CD 80 20 51      C DEBI_j_window               db  "…ÕÄ Quick watch ÑÕÕÕÕÕÕÕÕÕÕÕÕª",0
	   75 69 63 6B 20
	   77 61 74 63 68
	   20 84 CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD BB
	   00
 0000819B 20 20 20 20 20      C quick_12                    db  "                             ∫",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 000081BA 20 20 20 20 20      C quick_11                    db  "                             ∫",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 000081D9 20 20 20 20 20      C quick_10                    db  "                             ∫",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 000081F8 20 20 20 20 20      C quick_9                     db  "                             ∫",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008217 20 20 20 20 20      C quick_8                     db  "                             ∫",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008236 20 20 20 20 20      C quick_7                     db  "                             ∫",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008255 20 20 20 20 20      C quick_6                     db  "                             ∫",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008274 20 20 20 20 20      C quick_5                     db  "                             ∫",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008293 20 20 20 20 20      C quick_4                     db  "                             ∫",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 000082B2 20 20 20 20 20      C quick_3                     db  "                             ∫",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 000082D1 20 20 20 20 20      C quick_2                     db  "                             ∫",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 000082F0 20 20 20 20 20      C quick_1                     db  "                             ∫",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 0000830F  FF		      C                             db  255
			      C 
 00008310  00F0		      C                             dw  30 * FONT_X
 00008312  004D		      C                             dw  13 * FONT_Y - 1
 00008314		      C DEBI_j_screen_objects:
			      C     @AlwaysDrawWindow       DEBI_j_window
			     1C ; Always draws the window for whatever item is specified
 00008314  FE		     1C     db  _DRAW_WINDOW_ALWAYS
 00008315  0000817C R	     1C     dd  offset DEBI_j_window
			     1C   ; Total = 5
			      C     @ObjectMemSize          0
			     1C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
 00008319  00		     1C     db  _OBJECT_MEM_SIZE
 0000831A  00		     1C     db  0
			     1C   ; Total = 2
			      C     @FunctionHandlesObject  invDEBI_quick_watch_window
 0000831B  07		     1C     db  _FUNCTION
 0000831C  0000512C R	     1C     dd  offset invDEBI_quick_watch_window
			     1C   ; Total = 5
			      C     @End
 00008320  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C ALIGN
 00008321		      C DEBI_j_mouse_objects:
			      C     @Left_single_click       2,  0, 16,  0, invDEBI_quick_watch_click
			     1C ; Used when a left single-click is recognized on these coordinates
 00008321  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 00008322  00000010	     1C     dd  2 * FONT_X                 ; +1
 00008326  00000000	     1C     dd  0 * FONT_Y                 ; +5
 0000832A  00000087	     1C     dd  (16 * FONT_X) + FONT_X - 1  ; +9
 0000832E  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00008332  0000525E R	     1C     dd  invDEBI_quick_watch_click                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00008336  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000833A  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000833C  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      2,  0, 16,  0, invDEBI_quick_watch_right_click
			     1C ; Used when a right single-click is recognized on these coordinates
 0000833D  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 0000833E  00000010	     1C     dd  2 * FONT_X                 ; +1
 00008342  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00008346  00000087	     1C     dd  (16 * FONT_X) + FONT_X - 1  ; +9
 0000834A  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 0000834E  000039C0 R	     1C     dd  invDEBI_quick_watch_right_click                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00008352  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00008356  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00008358  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @End
 00008359  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
			      C 
			      C                                 ;          11111111112222222222333333333344444444445555555555666666666677777777778888888888
			      C                                 ;012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789
 0000835A C9 CD 80 20 51      C DEBI_k_window               db  "…ÕÄ Query ÑÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª",0
	   75 65 72 79 20
	   84 CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD BB
	   00
 000083B5 20 20 20 20 20      C query_3                     db  "                                                                                         ∫",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008410 4C 6F 77 2D 4C      C query_2                     db  "Low-Level Debi(tm) Debugger for the Exodus Operating System                              ∫",0
	   65 76 65 6C 20
	   44 65 62 69 28
	   74 6D 29 20 44
	   65 62 75 67 67
	   65 72 20 66 6F
	   72 20 74 68 65
	   20 45 78 6F 64
	   75 73 20 4F 70
	   65 72 61 74 69
	   6E 67 20 53 79
	   73 74 65 6D 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 0000846B 28 63 29 20 42      C query_1                     db  "(c) Beatleworks, Inc. 10.10.2010                                                         ∫",0
	   65 61 74 6C 65
	   77 6F 72 6B 73
	   2C 20 49 6E 63
	   2E 20 31 30 2E
	   31 30 2E 32 30
	   31 30 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 000084C6  CA CA CA CA CA     C                             db  "                                                                                         º",0
	   CA CA CA CA CA
	   CA CA CA CA CA
	   CA CA CA CA CA
	   CA CA CA CA CA
	   CA CA CA CA CA
	   CA CA CA CA CA
	   CA CA CA CA CA
	   CA CA CA CA CA
	   CA CA CA CA CA
	   CA CA CA CA CA
	   CA CA CA CA CA
	   CA CA CA CA CA
	   CA CA CA CA CA
	   CA CA CA CA CA
	   CA CA CA CA CA
	   CA CA CA CA CA
	   CA CA CA CA BC
	   00
 00008521  FF		      C                             db  255
			      C 
 00008522  02D0		      C                             dw  90 * FONT_X
 00008524  001D		      C                             dw  5  * FONT_Y - 1
 00008526		      C DEBI_k_screen_objects:
			      C     @AlwaysDrawWindow       DEBI_k_window
			     1C ; Always draws the window for whatever item is specified
 00008526  FE		     1C     db  _DRAW_WINDOW_ALWAYS
 00008527  0000835A R	     1C     dd  offset DEBI_k_window
			     1C   ; Total = 5
			      C     @ObjectMemSize          0
			     1C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
 0000852B  00		     1C     db  _OBJECT_MEM_SIZE
 0000852C  00		     1C     db  0
			     1C   ; Total = 2
			      C     @FunctionHandlesObject  invDEBI_query_window
 0000852D  07		     1C     db  _FUNCTION
 0000852E  00001164 R	     1C     dd  offset invDEBI_query_window
			     1C   ; Total = 5
			      C     @End
 00008532  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C ALIGN
 00008533		      C DEBI_k_mouse_objects:
			      C     @Right_single_click      2,  0, 16,  0, invDEBI_query_right_click
			     1C ; Used when a right single-click is recognized on these coordinates
 00008533  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 00008534  00000010	     1C     dd  2 * FONT_X                 ; +1
 00008538  00000000	     1C     dd  0 * FONT_Y                 ; +5
 0000853C  00000087	     1C     dd  (16 * FONT_X) + FONT_X - 1  ; +9
 00008540  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00008544  000039C0 R	     1C     dd  invDEBI_query_right_click                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00008548  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000854C  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000854E  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @End
 0000854F  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
			      C 
			      C                                 ;          11111
			      C                                 ;012345678901234
 00008550 C9 9A CD 81 20      C DEBI_l_window               db  "…öÕÅ Locals ÖÕª",0
	   4C 6F 63 61 6C
	   73 20 85 CD BB
	   00
 00008560  20 2D 30 30 34     C                             db  " -004 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00008570  20 2D 30 30 38     C                             db  " -008 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00008580  20 2D 30 30 63     C                             db  " -00c ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00008590  20 2D 30 31 30     C                             db  " -010 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 000085A0  20 2D 30 31 34     C                             db  " -014 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 000085B0  20 2D 30 31 38     C                             db  " -018 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 000085C0  20 2D 30 31 63     C                             db  " -01c ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 000085D0  20 2D 30 32 30     C                             db  " -020 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 000085E0  20 2D 30 32 34     C                             db  " -024 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 000085F0  20 2D 30 32 38     C                             db  " -028 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00008600  20 2D 30 32 63     C                             db  " -02c ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00008610  20 2D 30 33 30     C                             db  " -030 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00008620  20 2D 30 33 34     C                             db  " -034 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00008630  20 2D 30 33 38     C                             db  " -038 ˙˙˙˙˙˙˙˙∫",0
	   20 FA FA FA FA
	   FA FA FA FA BA
	   00
 00008640  FF		      C                             db  255
			      C 
 00008641  0078		      C                             dw  15 * FONT_X
 00008643  0059		      C                             dw  15 * FONT_Y - 1
 00008645		      C DEBI_l_screen_objects:
			      C     @DrawWindow             DEBI_l_window
			     1C ; Draws the window for whatever item is specified
 00008645  FD		     1C     db  _DRAW_WINDOW
 00008646  00008550 R	     1C     dd  offset DEBI_l_window
			     1C   ; Total = 5
			      C     @ObjectMemSize          32
			     1C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
 0000864A  00		     1C     db  _OBJECT_MEM_SIZE
 0000864B  20		     1C     db  32
			     1C   ; Total = 2
			      C     @DisplayEBP_through_EBP_relative   _32, -04h,  0, 6, 1
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000864C  03		     1C     db  _DISPLAY
 0000864D  02		     1C     db  _EBP_THROUGH_EBP_RELATIVE
 0000864E  05		     1C     db  _32
 0000864F  FFFC		     1C     dw  -04h
 00008651  00		     1C     db  0
 00008652  00000030	     1C     dd  6 * FONT_X
 00008656  00000006	     1C     dd  1 * FONT_Y
 0000865A  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_through_EBP_relative   _32, -08h,  4, 6, 2
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000865C  03		     1C     db  _DISPLAY
 0000865D  02		     1C     db  _EBP_THROUGH_EBP_RELATIVE
 0000865E  05		     1C     db  _32
 0000865F  FFF8		     1C     dw  -08h
 00008661  04		     1C     db  4
 00008662  00000030	     1C     dd  6 * FONT_X
 00008666  0000000C	     1C     dd  2 * FONT_Y
 0000866A  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_through_EBP_relative   _32, -0ch,  8, 6, 3
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000866C  03		     1C     db  _DISPLAY
 0000866D  02		     1C     db  _EBP_THROUGH_EBP_RELATIVE
 0000866E  05		     1C     db  _32
 0000866F  FFF4		     1C     dw  -0ch
 00008671  08		     1C     db  8
 00008672  00000030	     1C     dd  6 * FONT_X
 00008676  00000012	     1C     dd  3 * FONT_Y
 0000867A  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_through_EBP_relative   _32, -10h, 12, 6, 4
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000867C  03		     1C     db  _DISPLAY
 0000867D  02		     1C     db  _EBP_THROUGH_EBP_RELATIVE
 0000867E  05		     1C     db  _32
 0000867F  FFF0		     1C     dw  -10h
 00008681  0C		     1C     db  12
 00008682  00000030	     1C     dd  6 * FONT_X
 00008686  00000018	     1C     dd  4 * FONT_Y
 0000868A  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_through_EBP_relative   _32, -14h, 16, 6, 5
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000868C  03		     1C     db  _DISPLAY
 0000868D  02		     1C     db  _EBP_THROUGH_EBP_RELATIVE
 0000868E  05		     1C     db  _32
 0000868F  FFEC		     1C     dw  -14h
 00008691  10		     1C     db  16
 00008692  00000030	     1C     dd  6 * FONT_X
 00008696  0000001E	     1C     dd  5 * FONT_Y
 0000869A  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_through_EBP_relative   _32, -18h, 20, 6, 6
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000869C  03		     1C     db  _DISPLAY
 0000869D  02		     1C     db  _EBP_THROUGH_EBP_RELATIVE
 0000869E  05		     1C     db  _32
 0000869F  FFE8		     1C     dw  -18h
 000086A1  14		     1C     db  20
 000086A2  00000030	     1C     dd  6 * FONT_X
 000086A6  00000024	     1C     dd  6 * FONT_Y
 000086AA  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_through_EBP_relative   _32, -1ch, 24, 6, 7
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000086AC  03		     1C     db  _DISPLAY
 000086AD  02		     1C     db  _EBP_THROUGH_EBP_RELATIVE
 000086AE  05		     1C     db  _32
 000086AF  FFE4		     1C     dw  -1ch
 000086B1  18		     1C     db  24
 000086B2  00000030	     1C     dd  6 * FONT_X
 000086B6  0000002A	     1C     dd  7 * FONT_Y
 000086BA  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_through_EBP_relative   _32, -20h, 28, 6, 8
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000086BC  03		     1C     db  _DISPLAY
 000086BD  02		     1C     db  _EBP_THROUGH_EBP_RELATIVE
 000086BE  05		     1C     db  _32
 000086BF  FFE0		     1C     dw  -20h
 000086C1  1C		     1C     db  28
 000086C2  00000030	     1C     dd  6 * FONT_X
 000086C6  00000030	     1C     dd  8 * FONT_Y
 000086CA  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_through_EBP_relative   _32, -24h, 28, 6, 9
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000086CC  03		     1C     db  _DISPLAY
 000086CD  02		     1C     db  _EBP_THROUGH_EBP_RELATIVE
 000086CE  05		     1C     db  _32
 000086CF  FFDC		     1C     dw  -24h
 000086D1  1C		     1C     db  28
 000086D2  00000030	     1C     dd  6 * FONT_X
 000086D6  00000036	     1C     dd  9 * FONT_Y
 000086DA  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_through_EBP_relative   _32, -28h, 28, 6,10
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000086DC  03		     1C     db  _DISPLAY
 000086DD  02		     1C     db  _EBP_THROUGH_EBP_RELATIVE
 000086DE  05		     1C     db  _32
 000086DF  FFD8		     1C     dw  -28h
 000086E1  1C		     1C     db  28
 000086E2  00000030	     1C     dd  6 * FONT_X
 000086E6  0000003C	     1C     dd  10 * FONT_Y
 000086EA  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_through_EBP_relative   _32, -2ch, 28, 6,11
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000086EC  03		     1C     db  _DISPLAY
 000086ED  02		     1C     db  _EBP_THROUGH_EBP_RELATIVE
 000086EE  05		     1C     db  _32
 000086EF  FFD4		     1C     dw  -2ch
 000086F1  1C		     1C     db  28
 000086F2  00000030	     1C     dd  6 * FONT_X
 000086F6  00000042	     1C     dd  11 * FONT_Y
 000086FA  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_through_EBP_relative   _32, -30h, 28, 6,12
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000086FC  03		     1C     db  _DISPLAY
 000086FD  02		     1C     db  _EBP_THROUGH_EBP_RELATIVE
 000086FE  05		     1C     db  _32
 000086FF  FFD0		     1C     dw  -30h
 00008701  1C		     1C     db  28
 00008702  00000030	     1C     dd  6 * FONT_X
 00008706  00000048	     1C     dd  12 * FONT_Y
 0000870A  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_through_EBP_relative   _32, -34h, 28, 6,13
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000870C  03		     1C     db  _DISPLAY
 0000870D  02		     1C     db  _EBP_THROUGH_EBP_RELATIVE
 0000870E  05		     1C     db  _32
 0000870F  FFCC		     1C     dw  -34h
 00008711  1C		     1C     db  28
 00008712  00000030	     1C     dd  6 * FONT_X
 00008716  0000004E	     1C     dd  13 * FONT_Y
 0000871A  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_through_EBP_relative   _32, -38h, 28, 6,14
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the EBP derived from the stack (Refer to DEBI_debug() in debi.asm for info on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000871C  03		     1C     db  _DISPLAY
 0000871D  02		     1C     db  _EBP_THROUGH_EBP_RELATIVE
 0000871E  05		     1C     db  _32
 0000871F  FFC8		     1C     dw  -38h
 00008721  1C		     1C     db  28
 00008722  00000030	     1C     dd  6 * FONT_X
 00008726  00000054	     1C     dd  14 * FONT_Y
 0000872A  0000		     1C     dw  0               ; Nuserved
			     1C   ; Total = 16
			      C     @End
 0000872C  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C ALIGN
 0000872D		      C DEBI_l_mouse_objects:
			      C     @Left_single_click       1,  0,  1,  0, invDEBI_object_close
			     1C ; Used when a left single-click is recognized on these coordinates
 0000872D  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000872E  00000008	     1C     dd  1 * FONT_X                 ; +1
 00008732  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00008736  0000000F	     1C     dd  (1 * FONT_X) + FONT_X - 1  ; +9
 0000873A  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 0000873E  0000510B R	     1C     dd  invDEBI_object_close                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00008742  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00008746  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00008748  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      3,  0, 12,  0, invDEBI_locals_right_click
			     1C ; Used when a right single-click is recognized on these coordinates
 00008749  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 0000874A  00000018	     1C     dd  3 * FONT_X                 ; +1
 0000874E  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00008752  00000067	     1C     dd  (12 * FONT_X) + FONT_X - 1  ; +9
 00008756  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 0000875A  000039C0 R	     1C     dd  invDEBI_locals_right_click                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 0000875E  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00008762  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00008764  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         0,  0, 14,  0, invDEBI_object_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 00008765  02		     1C     db  _LEFT_DRAG_START            ; +0
 00008766  00000000	     1C     dd  0 * FONT_X                 ; +1
 0000876A  00000000	     1C     dd  0 * FONT_Y                 ; +5
 0000876E  00000077	     1C     dd  (14 * FONT_X) + FONT_X - 1  ; +9
 00008772  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00008776  00003BE5 R	     1C     dd  invDEBI_object_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 0000877A  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000877E  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00008780  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Abandon_if_not          6,  1, 13, 14
			     1C ; Used in a lengthy list.  If the coordinates are not within this range then the rest of the lengthy list is not checked
 00008781  0C		     1C     db  _ABANDON_IF_NOT             ; +0
 00008782  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008786  00000006	     1C     dd  1 * FONT_Y                 ; +5
 0000878A  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 0000878E  00000059	     1C     dd  (14 * FONT_Y) + FONT_Y - 1  ; +13
 00008792  0000000B [	     1C     db  11 dup(0ffh)                ; +17
	    FF
	   ]
			     1C   ; Total = 28
			      C     @Hover                   6,  1, 13,  1,  -4, invDEBI_quick_watch_locals_32
			     1C ; Used when the mouse is hovering over these coordinates
 0000879D  0A		     1C     db  _HOVER                      ; +0
 0000879E  00000030	     1C     dd  6 * FONT_X                 ; +1
 000087A2  00000006	     1C     dd  1 * FONT_Y                 ; +5
 000087A6  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 000087AA  0000000B	     1C     dd  (1 * FONT_Y) + FONT_Y - 1  ; +13
 000087AE  00003299 R	     1C     dd  invDEBI_quick_watch_locals_32                        ; +17
 000087B2  FFFC		     1C     dw  lowword(offset -4)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000087B4  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  2, 13,  2,  -8, invDEBI_quick_watch_locals_32
			     1C ; Used when the mouse is hovering over these coordinates
 000087B9  0A		     1C     db  _HOVER                      ; +0
 000087BA  00000030	     1C     dd  6 * FONT_X                 ; +1
 000087BE  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 000087C2  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 000087C6  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 000087CA  00003299 R	     1C     dd  invDEBI_quick_watch_locals_32                        ; +17
 000087CE  FFF8		     1C     dw  lowword(offset -8)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000087D0  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  3, 13,  3, -12, invDEBI_quick_watch_locals_32
			     1C ; Used when the mouse is hovering over these coordinates
 000087D5  0A		     1C     db  _HOVER                      ; +0
 000087D6  00000030	     1C     dd  6 * FONT_X                 ; +1
 000087DA  00000012	     1C     dd  3 * FONT_Y                 ; +5
 000087DE  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 000087E2  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 000087E6  00003299 R	     1C     dd  invDEBI_quick_watch_locals_32                        ; +17
 000087EA  FFF4		     1C     dw  lowword(offset -12)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000087EC  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  4, 13,  4, -16, invDEBI_quick_watch_locals_32
			     1C ; Used when the mouse is hovering over these coordinates
 000087F1  0A		     1C     db  _HOVER                      ; +0
 000087F2  00000030	     1C     dd  6 * FONT_X                 ; +1
 000087F6  00000018	     1C     dd  4 * FONT_Y                 ; +5
 000087FA  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 000087FE  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 00008802  00003299 R	     1C     dd  invDEBI_quick_watch_locals_32                        ; +17
 00008806  FFF0		     1C     dw  lowword(offset -16)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008808  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  5, 13,  5, -20, invDEBI_quick_watch_locals_32
			     1C ; Used when the mouse is hovering over these coordinates
 0000880D  0A		     1C     db  _HOVER                      ; +0
 0000880E  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008812  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 00008816  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 0000881A  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 0000881E  00003299 R	     1C     dd  invDEBI_quick_watch_locals_32                        ; +17
 00008822  FFEC		     1C     dw  lowword(offset -20)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008824  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  6, 13,  6, -24, invDEBI_quick_watch_locals_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008829  0A		     1C     db  _HOVER                      ; +0
 0000882A  00000030	     1C     dd  6 * FONT_X                 ; +1
 0000882E  00000024	     1C     dd  6 * FONT_Y                 ; +5
 00008832  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008836  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 0000883A  00003299 R	     1C     dd  invDEBI_quick_watch_locals_32                        ; +17
 0000883E  FFE8		     1C     dw  lowword(offset -24)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008840  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  7, 13,  7, -28, invDEBI_quick_watch_locals_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008845  0A		     1C     db  _HOVER                      ; +0
 00008846  00000030	     1C     dd  6 * FONT_X                 ; +1
 0000884A  0000002A	     1C     dd  7 * FONT_Y                 ; +5
 0000884E  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008852  0000002F	     1C     dd  (7 * FONT_Y) + FONT_Y - 1  ; +13
 00008856  00003299 R	     1C     dd  invDEBI_quick_watch_locals_32                        ; +17
 0000885A  FFE4		     1C     dw  lowword(offset -28)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000885C  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  8, 13,  8, -32, invDEBI_quick_watch_locals_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008861  0A		     1C     db  _HOVER                      ; +0
 00008862  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008866  00000030	     1C     dd  8 * FONT_Y                 ; +5
 0000886A  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 0000886E  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00008872  00003299 R	     1C     dd  invDEBI_quick_watch_locals_32                        ; +17
 00008876  FFE0		     1C     dw  lowword(offset -32)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008878  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  9, 13,  9, -36, invDEBI_quick_watch_locals_32
			     1C ; Used when the mouse is hovering over these coordinates
 0000887D  0A		     1C     db  _HOVER                      ; +0
 0000887E  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008882  00000036	     1C     dd  9 * FONT_Y                 ; +5
 00008886  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 0000888A  0000003B	     1C     dd  (9 * FONT_Y) + FONT_Y - 1  ; +13
 0000888E  00003299 R	     1C     dd  invDEBI_quick_watch_locals_32                        ; +17
 00008892  FFDC		     1C     dw  lowword(offset -36)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008894  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6, 10, 13, 10, -40, invDEBI_quick_watch_locals_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008899  0A		     1C     db  _HOVER                      ; +0
 0000889A  00000030	     1C     dd  6 * FONT_X                 ; +1
 0000889E  0000003C	     1C     dd  10 * FONT_Y                 ; +5
 000088A2  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 000088A6  00000041	     1C     dd  (10 * FONT_Y) + FONT_Y - 1  ; +13
 000088AA  00003299 R	     1C     dd  invDEBI_quick_watch_locals_32                        ; +17
 000088AE  FFD8		     1C     dw  lowword(offset -40)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000088B0  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6, 11, 13, 11, -44, invDEBI_quick_watch_locals_32
			     1C ; Used when the mouse is hovering over these coordinates
 000088B5  0A		     1C     db  _HOVER                      ; +0
 000088B6  00000030	     1C     dd  6 * FONT_X                 ; +1
 000088BA  00000042	     1C     dd  11 * FONT_Y                 ; +5
 000088BE  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 000088C2  00000047	     1C     dd  (11 * FONT_Y) + FONT_Y - 1  ; +13
 000088C6  00003299 R	     1C     dd  invDEBI_quick_watch_locals_32                        ; +17
 000088CA  FFD4		     1C     dw  lowword(offset -44)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000088CC  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6, 12, 13, 12, -48, invDEBI_quick_watch_locals_32
			     1C ; Used when the mouse is hovering over these coordinates
 000088D1  0A		     1C     db  _HOVER                      ; +0
 000088D2  00000030	     1C     dd  6 * FONT_X                 ; +1
 000088D6  00000048	     1C     dd  12 * FONT_Y                 ; +5
 000088DA  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 000088DE  0000004D	     1C     dd  (12 * FONT_Y) + FONT_Y - 1  ; +13
 000088E2  00003299 R	     1C     dd  invDEBI_quick_watch_locals_32                        ; +17
 000088E6  FFD0		     1C     dw  lowword(offset -48)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000088E8  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6, 13, 13, 13, -52, invDEBI_quick_watch_locals_32
			     1C ; Used when the mouse is hovering over these coordinates
 000088ED  0A		     1C     db  _HOVER                      ; +0
 000088EE  00000030	     1C     dd  6 * FONT_X                 ; +1
 000088F2  0000004E	     1C     dd  13 * FONT_Y                 ; +5
 000088F6  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 000088FA  00000053	     1C     dd  (13 * FONT_Y) + FONT_Y - 1  ; +13
 000088FE  00003299 R	     1C     dd  invDEBI_quick_watch_locals_32                        ; +17
 00008902  FFCC		     1C     dw  lowword(offset -52)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008904  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6, 14, 13, 14, -56, invDEBI_quick_watch_locals_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008909  0A		     1C     db  _HOVER                      ; +0
 0000890A  00000030	     1C     dd  6 * FONT_X                 ; +1
 0000890E  00000054	     1C     dd  14 * FONT_Y                 ; +5
 00008912  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008916  00000059	     1C     dd  (14 * FONT_Y) + FONT_Y - 1  ; +13
 0000891A  00003299 R	     1C     dd  invDEBI_quick_watch_locals_32                        ; +17
 0000891E  FFC8		     1C     dw  lowword(offset -56)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008920  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @End
 00008925  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
			      C 
			      C                                 ;          11111
			      C                                 ;012345678901234
 00008926 C9 9A CD 81 20      C DEBI_m_window               db  "…öÕÅ Mem.1 ÖÕÕª",0     ; 0
	   4D 65 6D 2E 31
	   20 85 CD CD BB
	   00
 00008936  20 20 20 20 20     C                             db  "              ∫",0     ; 1
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008946  20 20 20 20 20     C                             db  "              ∫",0     ; 2
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008956  20 20 20 20 20     C                             db  "              ∫",0     ; 3
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008966  20 20 20 20 20     C                             db  "              ∫",0     ; 4
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008976  20 20 20 20 20     C                             db  "              ∫",0     ; 5
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008986  20 20 20 20 20     C                             db  "              ∫",0     ; 6
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008996  20 20 20 20 20     C                             db  "              ∫",0     ; 7
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 000089A6  20 20 20 20 20     C                             db  "              ∫",0     ; 8
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 000089B6  20 20 20 20 20     C                             db  "              ∫",0     ; 9
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 000089C6  20 20 20 20 20     C                             db  "              ∫",0     ; 10
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 000089D6  20 20 20 20 20     C                             db  "              ∫",0     ; 11
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 000089E6  20 20 20 20 20     C                             db  "              ∫",0     ; 12
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 000089F6  FF		      C                             db  255
			      C 
 000089F7  0078		      C                             dw  15 * FONT_X
 000089F9  004D		      C                             dw  13 * FONT_Y - 1
 000089FB		      C DEBI_m_screen_objects:
			      C     @DrawWindow             DEBI_m_window
			     1C ; Draws the window for whatever item is specified
 000089FB  FD		     1C     db  _DRAW_WINDOW
 000089FC  00008926 R	     1C     dd  offset DEBI_m_window
			     1C   ; Total = 5
			      C     @ObjectMemSize          4+2+48              ; +4 is for PTR, +2 is for offset, +48 is for data
			     1C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
 00008A00  00		     1C     db  _OBJECT_MEM_SIZE
 00008A01  36		     1C     db  4+2+48
			     1C   ; Total = 2
			      C     @FunctionHandlesObject  invDEBI_mem1_window
 00008A02  07		     1C     db  _FUNCTION
 00008A03  000032DD R	     1C     dd  offset invDEBI_mem1_window
			     1C   ; Total = 5
			      C     @End
 00008A07  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C ALIGN
 00008A08		      C DEBI_m_mouse_objects:
			      C     @Left_single_click       1,  0,  1,  0, invDEBI_object_close
			     1C ; Used when a left single-click is recognized on these coordinates
 00008A08  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 00008A09  00000008	     1C     dd  1 * FONT_X                 ; +1
 00008A0D  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00008A11  0000000F	     1C     dd  (1 * FONT_X) + FONT_X - 1  ; +9
 00008A15  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00008A19  0000510B R	     1C     dd  invDEBI_object_close                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00008A1D  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00008A21  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00008A23  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_single_click       3,  0, 11,  0, invDEBI_address_expression
			     1C ; Used when a left single-click is recognized on these coordinates
 00008A24  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 00008A25  00000018	     1C     dd  3 * FONT_X                 ; +1
 00008A29  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00008A2D  0000005F	     1C     dd  (11 * FONT_X) + FONT_X - 1  ; +9
 00008A31  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00008A35  00005156 R	     1C     dd  invDEBI_address_expression                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00008A39  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00008A3D  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00008A3F  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      3,  0, 11,  0, invDEBI_mem_1_right_click
			     1C ; Used when a right single-click is recognized on these coordinates
 00008A40  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 00008A41  00000018	     1C     dd  3 * FONT_X                 ; +1
 00008A45  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00008A49  0000005F	     1C     dd  (11 * FONT_X) + FONT_X - 1  ; +9
 00008A4D  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00008A51  000039C0 R	     1C     dd  invDEBI_mem_1_right_click                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00008A55  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00008A59  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00008A5B  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         0,  0, 14,  0, invDEBI_object_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 00008A5C  02		     1C     db  _LEFT_DRAG_START            ; +0
 00008A5D  00000000	     1C     dd  0 * FONT_X                 ; +1
 00008A61  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00008A65  00000077	     1C     dd  (14 * FONT_X) + FONT_X - 1  ; +9
 00008A69  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00008A6D  00003BE5 R	     1C     dd  invDEBI_object_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00008A71  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00008A75  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00008A77  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Abandon_if_not          6,  1, 13, 12
			     1C ; Used in a lengthy list.  If the coordinates are not within this range then the rest of the lengthy list is not checked
 00008A78  0C		     1C     db  _ABANDON_IF_NOT             ; +0
 00008A79  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008A7D  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00008A81  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008A85  0000004D	     1C     dd  (12 * FONT_Y) + FONT_Y - 1  ; +13
 00008A89  0000000B [	     1C     db  11 dup(0ffh)                ; +17
	    FF
	   ]
			     1C   ; Total = 28
			      C     @Hover                   6,  1, 13,  1,  0+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008A94  0A		     1C     db  _HOVER                      ; +0
 00008A95  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008A99  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00008A9D  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008AA1  0000000B	     1C     dd  (1 * FONT_Y) + FONT_Y - 1  ; +13
 00008AA5  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008AA9  0006		     1C     dw  lowword(offset 0+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008AAB  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  2, 13,  2,  4+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008AB0  0A		     1C     db  _HOVER                      ; +0
 00008AB1  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008AB5  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 00008AB9  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008ABD  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 00008AC1  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008AC5  000A		     1C     dw  lowword(offset 4+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008AC7  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  3, 13,  3,  8+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008ACC  0A		     1C     db  _HOVER                      ; +0
 00008ACD  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008AD1  00000012	     1C     dd  3 * FONT_Y                 ; +5
 00008AD5  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008AD9  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 00008ADD  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008AE1  000E		     1C     dw  lowword(offset 8+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008AE3  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  4, 13,  4, 12+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008AE8  0A		     1C     db  _HOVER                      ; +0
 00008AE9  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008AED  00000018	     1C     dd  4 * FONT_Y                 ; +5
 00008AF1  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008AF5  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 00008AF9  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008AFD  0012		     1C     dw  lowword(offset 12+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008AFF  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  5, 13,  5, 16+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008B04  0A		     1C     db  _HOVER                      ; +0
 00008B05  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008B09  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 00008B0D  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008B11  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 00008B15  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008B19  0016		     1C     dw  lowword(offset 16+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008B1B  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  6, 13,  6, 20+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008B20  0A		     1C     db  _HOVER                      ; +0
 00008B21  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008B25  00000024	     1C     dd  6 * FONT_Y                 ; +5
 00008B29  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008B2D  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 00008B31  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008B35  001A		     1C     dw  lowword(offset 20+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008B37  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  7, 13,  7, 24+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008B3C  0A		     1C     db  _HOVER                      ; +0
 00008B3D  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008B41  0000002A	     1C     dd  7 * FONT_Y                 ; +5
 00008B45  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008B49  0000002F	     1C     dd  (7 * FONT_Y) + FONT_Y - 1  ; +13
 00008B4D  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008B51  001E		     1C     dw  lowword(offset 24+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008B53  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  8, 13,  8, 28+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008B58  0A		     1C     db  _HOVER                      ; +0
 00008B59  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008B5D  00000030	     1C     dd  8 * FONT_Y                 ; +5
 00008B61  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008B65  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00008B69  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008B6D  0022		     1C     dw  lowword(offset 28+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008B6F  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @End
 00008B74  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
			      C 
			      C                                 ;          11111111112222222222333333333344444
			      C                                 ;012345678901234567890123456789012345678901234
 00008B75 C9 9A CD 81 20      C DEBI_n_window               db  "…öÕÅ Mem.3 ÖÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª",0       ; 0
	   4D 65 6D 2E 33
	   20 85 CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD BB
	   00
 00008BA3  20 20 20 20 20     C                             db  "                                            ∫",0       ; 1
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008BD1  20 20 20 20 20     C                             db  "                                            ∫",0       ; 2
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008BFF  20 20 20 20 20     C                             db  "                                            ∫",0       ; 3
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008C2D  20 20 20 20 20     C                             db  "                                            ∫",0       ; 4
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008C5B  20 20 20 20 20     C                             db  "                                            ∫",0       ; 5
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008C89  20 20 20 20 20     C                             db  "                                            ∫",0       ; 6
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008CB7  20 20 20 20 20     C                             db  "                                            ∫",0       ; 7
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008CE5  20 20 20 20 20     C                             db  "                                            ∫",0       ; 8
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008D13  20 20 20 20 20     C                             db  "                                            ∫",0       ; 9
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008D41  20 20 20 20 20     C                             db  "                                            ∫",0       ; 10
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008D6F  20 20 20 20 20     C                             db  "                                            ∫",0       ; 11
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008D9D  20 20 20 20 20     C                             db  "                                            ∫",0       ; 12
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 00008DCB  FF		      C                             db  255
			      C 
 00008DCC  0168		      C                             dw  45 * FONT_X
 00008DCE  004D		      C                             dw  13 * FONT_Y - 1
 00008DD0		      C DEBI_n_screen_objects:
			      C     @DrawWindow             DEBI_n_window
			     1C ; Draws the window for whatever item is specified
 00008DD0  FD		     1C     db  _DRAW_WINDOW
 00008DD1  00008B75 R	     1C     dd  offset DEBI_n_window
			     1C   ; Total = 5
			      C     @ObjectMemSize          4+2+144             ; +4 is for PTR, +2 is for offset, +144 is for data
			     1C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
 00008DD5  00		     1C     db  _OBJECT_MEM_SIZE
 00008DD6  96		     1C     db  4+2+144
			     1C   ; Total = 2
			      C     @FunctionHandlesObject  invDEBI_mem3_window
 00008DD7  07		     1C     db  _FUNCTION
 00008DD8  000032F9 R	     1C     dd  offset invDEBI_mem3_window
			     1C   ; Total = 5
			      C     @End
 00008DDC  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C ALIGN
 00008DDD		      C DEBI_n_mouse_objects:
			      C     @Left_single_click       1,  0,  1,  0, invDEBI_object_close
			     1C ; Used when a left single-click is recognized on these coordinates
 00008DDD  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 00008DDE  00000008	     1C     dd  1 * FONT_X                 ; +1
 00008DE2  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00008DE6  0000000F	     1C     dd  (1 * FONT_X) + FONT_X - 1  ; +9
 00008DEA  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00008DEE  0000510B R	     1C     dd  invDEBI_object_close                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00008DF2  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00008DF6  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00008DF8  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      3,  0, 11,  0, invDEBI_mem_3_right_click
			     1C ; Used when a right single-click is recognized on these coordinates
 00008DF9  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 00008DFA  00000018	     1C     dd  3 * FONT_X                 ; +1
 00008DFE  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00008E02  0000005F	     1C     dd  (11 * FONT_X) + FONT_X - 1  ; +9
 00008E06  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00008E0A  000039C0 R	     1C     dd  invDEBI_mem_3_right_click                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00008E0E  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00008E12  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00008E14  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_single_click       3,  0, 11,  0, invDEBI_address_expression
			     1C ; Used when a left single-click is recognized on these coordinates
 00008E15  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 00008E16  00000018	     1C     dd  3 * FONT_X                 ; +1
 00008E1A  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00008E1E  0000005F	     1C     dd  (11 * FONT_X) + FONT_X - 1  ; +9
 00008E22  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00008E26  00005156 R	     1C     dd  invDEBI_address_expression                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00008E2A  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00008E2E  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00008E30  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         0,  0, 44,  0, invDEBI_object_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 00008E31  02		     1C     db  _LEFT_DRAG_START            ; +0
 00008E32  00000000	     1C     dd  0 * FONT_X                 ; +1
 00008E36  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00008E3A  00000167	     1C     dd  (44 * FONT_X) + FONT_X - 1  ; +9
 00008E3E  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00008E42  00003BE5 R	     1C     dd  invDEBI_object_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00008E46  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00008E4A  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00008E4C  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Abandon_if_not          6,  1, 43, 12
			     1C ; Used in a lengthy list.  If the coordinates are not within this range then the rest of the lengthy list is not checked
 00008E4D  0C		     1C     db  _ABANDON_IF_NOT             ; +0
 00008E4E  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008E52  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00008E56  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 00008E5A  0000004D	     1C     dd  (12 * FONT_Y) + FONT_Y - 1  ; +13
 00008E5E  0000000B [	     1C     db  11 dup(0ffh)                ; +17
	    FF
	   ]
			     1C   ; Total = 28
			      C     @Hover                   6,  1, 13,  1,  0+6, invDEBI_quick_watch_mem_32        ; 00-28
			     1C ; Used when the mouse is hovering over these coordinates
 00008E69  0A		     1C     db  _HOVER                      ; +0
 00008E6A  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008E6E  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00008E72  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008E76  0000000B	     1C     dd  (1 * FONT_Y) + FONT_Y - 1  ; +13
 00008E7A  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008E7E  0006		     1C     dw  lowword(offset 0+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008E80  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  2, 13,  2,  4+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008E85  0A		     1C     db  _HOVER                      ; +0
 00008E86  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008E8A  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 00008E8E  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008E92  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 00008E96  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008E9A  000A		     1C     dw  lowword(offset 4+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008E9C  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  3, 13,  3,  8+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008EA1  0A		     1C     db  _HOVER                      ; +0
 00008EA2  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008EA6  00000012	     1C     dd  3 * FONT_Y                 ; +5
 00008EAA  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008EAE  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 00008EB2  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008EB6  000E		     1C     dw  lowword(offset 8+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008EB8  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  4, 13,  4, 12+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008EBD  0A		     1C     db  _HOVER                      ; +0
 00008EBE  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008EC2  00000018	     1C     dd  4 * FONT_Y                 ; +5
 00008EC6  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008ECA  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 00008ECE  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008ED2  0012		     1C     dw  lowword(offset 12+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008ED4  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  5, 13,  5, 16+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008ED9  0A		     1C     db  _HOVER                      ; +0
 00008EDA  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008EDE  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 00008EE2  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008EE6  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 00008EEA  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008EEE  0016		     1C     dw  lowword(offset 16+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008EF0  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  6, 13,  6, 20+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008EF5  0A		     1C     db  _HOVER                      ; +0
 00008EF6  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008EFA  00000024	     1C     dd  6 * FONT_Y                 ; +5
 00008EFE  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008F02  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 00008F06  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008F0A  001A		     1C     dw  lowword(offset 20+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008F0C  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  7, 13,  7, 24+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008F11  0A		     1C     db  _HOVER                      ; +0
 00008F12  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008F16  0000002A	     1C     dd  7 * FONT_Y                 ; +5
 00008F1A  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008F1E  0000002F	     1C     dd  (7 * FONT_Y) + FONT_Y - 1  ; +13
 00008F22  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008F26  001E		     1C     dw  lowword(offset 24+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008F28  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   6,  8, 13,  8, 28+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008F2D  0A		     1C     db  _HOVER                      ; +0
 00008F2E  00000030	     1C     dd  6 * FONT_X                 ; +1
 00008F32  00000030	     1C     dd  8 * FONT_Y                 ; +5
 00008F36  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00008F3A  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00008F3E  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008F42  0022		     1C     dw  lowword(offset 28+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008F44  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  21,  1, 28,  1, 32+6, invDEBI_quick_watch_mem_32        ; 32-60
			     1C ; Used when the mouse is hovering over these coordinates
 00008F49  0A		     1C     db  _HOVER                      ; +0
 00008F4A  000000A8	     1C     dd  21 * FONT_X                 ; +1
 00008F4E  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00008F52  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 00008F56  0000000B	     1C     dd  (1 * FONT_Y) + FONT_Y - 1  ; +13
 00008F5A  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008F5E  0026		     1C     dw  lowword(offset 32+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008F60  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  21,  2, 28,  2, 36+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008F65  0A		     1C     db  _HOVER                      ; +0
 00008F66  000000A8	     1C     dd  21 * FONT_X                 ; +1
 00008F6A  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 00008F6E  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 00008F72  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 00008F76  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008F7A  002A		     1C     dw  lowword(offset 36+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008F7C  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  21,  3, 28,  3, 40+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008F81  0A		     1C     db  _HOVER                      ; +0
 00008F82  000000A8	     1C     dd  21 * FONT_X                 ; +1
 00008F86  00000012	     1C     dd  3 * FONT_Y                 ; +5
 00008F8A  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 00008F8E  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 00008F92  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008F96  002E		     1C     dw  lowword(offset 40+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008F98  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  21,  4, 28,  4, 44+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008F9D  0A		     1C     db  _HOVER                      ; +0
 00008F9E  000000A8	     1C     dd  21 * FONT_X                 ; +1
 00008FA2  00000018	     1C     dd  4 * FONT_Y                 ; +5
 00008FA6  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 00008FAA  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 00008FAE  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008FB2  0032		     1C     dw  lowword(offset 44+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008FB4  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  21,  5, 28,  5, 48+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008FB9  0A		     1C     db  _HOVER                      ; +0
 00008FBA  000000A8	     1C     dd  21 * FONT_X                 ; +1
 00008FBE  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 00008FC2  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 00008FC6  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 00008FCA  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008FCE  0036		     1C     dw  lowword(offset 48+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008FD0  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  21,  6, 28,  6, 52+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008FD5  0A		     1C     db  _HOVER                      ; +0
 00008FD6  000000A8	     1C     dd  21 * FONT_X                 ; +1
 00008FDA  00000024	     1C     dd  6 * FONT_Y                 ; +5
 00008FDE  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 00008FE2  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 00008FE6  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00008FEA  003A		     1C     dw  lowword(offset 52+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00008FEC  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  21,  7, 28,  7, 56+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00008FF1  0A		     1C     db  _HOVER                      ; +0
 00008FF2  000000A8	     1C     dd  21 * FONT_X                 ; +1
 00008FF6  0000002A	     1C     dd  7 * FONT_Y                 ; +5
 00008FFA  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 00008FFE  0000002F	     1C     dd  (7 * FONT_Y) + FONT_Y - 1  ; +13
 00009002  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00009006  003E		     1C     dw  lowword(offset 56+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009008  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  21,  8, 28,  8, 60+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 0000900D  0A		     1C     db  _HOVER                      ; +0
 0000900E  000000A8	     1C     dd  21 * FONT_X                 ; +1
 00009012  00000030	     1C     dd  8 * FONT_Y                 ; +5
 00009016  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 0000901A  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 0000901E  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00009022  0042		     1C     dw  lowword(offset 60+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009024  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  36,  1, 43,  1, 64+6, invDEBI_quick_watch_mem_32        ; 64-92
			     1C ; Used when the mouse is hovering over these coordinates
 00009029  0A		     1C     db  _HOVER                      ; +0
 0000902A  00000120	     1C     dd  36 * FONT_X                 ; +1
 0000902E  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00009032  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 00009036  0000000B	     1C     dd  (1 * FONT_Y) + FONT_Y - 1  ; +13
 0000903A  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 0000903E  0046		     1C     dw  lowword(offset 64+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009040  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  36,  2, 43,  2, 68+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00009045  0A		     1C     db  _HOVER                      ; +0
 00009046  00000120	     1C     dd  36 * FONT_X                 ; +1
 0000904A  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 0000904E  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 00009052  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 00009056  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 0000905A  004A		     1C     dw  lowword(offset 68+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000905C  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  36,  3, 43,  3, 72+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00009061  0A		     1C     db  _HOVER                      ; +0
 00009062  00000120	     1C     dd  36 * FONT_X                 ; +1
 00009066  00000012	     1C     dd  3 * FONT_Y                 ; +5
 0000906A  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 0000906E  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 00009072  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00009076  004E		     1C     dw  lowword(offset 72+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009078  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  36,  4, 43,  4, 76+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 0000907D  0A		     1C     db  _HOVER                      ; +0
 0000907E  00000120	     1C     dd  36 * FONT_X                 ; +1
 00009082  00000018	     1C     dd  4 * FONT_Y                 ; +5
 00009086  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 0000908A  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 0000908E  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00009092  0052		     1C     dw  lowword(offset 76+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009094  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  36,  5, 43,  5, 80+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 00009099  0A		     1C     db  _HOVER                      ; +0
 0000909A  00000120	     1C     dd  36 * FONT_X                 ; +1
 0000909E  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 000090A2  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 000090A6  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 000090AA  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 000090AE  0056		     1C     dw  lowword(offset 80+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000090B0  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  36,  6, 43,  6, 84+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 000090B5  0A		     1C     db  _HOVER                      ; +0
 000090B6  00000120	     1C     dd  36 * FONT_X                 ; +1
 000090BA  00000024	     1C     dd  6 * FONT_Y                 ; +5
 000090BE  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 000090C2  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 000090C6  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 000090CA  005A		     1C     dw  lowword(offset 84+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000090CC  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  36,  7, 43,  7, 88+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 000090D1  0A		     1C     db  _HOVER                      ; +0
 000090D2  00000120	     1C     dd  36 * FONT_X                 ; +1
 000090D6  0000002A	     1C     dd  7 * FONT_Y                 ; +5
 000090DA  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 000090DE  0000002F	     1C     dd  (7 * FONT_Y) + FONT_Y - 1  ; +13
 000090E2  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 000090E6  005E		     1C     dw  lowword(offset 88+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000090E8  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  36,  8, 43,  8, 92+6, invDEBI_quick_watch_mem_32
			     1C ; Used when the mouse is hovering over these coordinates
 000090ED  0A		     1C     db  _HOVER                      ; +0
 000090EE  00000120	     1C     dd  36 * FONT_X                 ; +1
 000090F2  00000030	     1C     dd  8 * FONT_Y                 ; +5
 000090F6  0000015F	     1C     dd  (43 * FONT_X) + FONT_X - 1  ; +9
 000090FA  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 000090FE  000050DB R	     1C     dd  invDEBI_quick_watch_mem_32                        ; +17
 00009102  0062		     1C     dw  lowword(offset 92+6)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009104  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @End
 00009109  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
			      C 
			      C                                 ;          11111111112222222222333333333344444444445555555555666666666677777777778888888888
			      C                                 ;012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789
 0000910A 20 80 20 72 65      C DEBI_o_window               db  " Ä redraw Ñ                                   Ä continue Ñ  Ä break Ñ  Ä over Ñ  Ä step Ñ ",0
	   64 72 61 77 20
	   84 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 80 20 63 6F
	   6E 74 69 6E 75
	   65 20 84 20 20
	   80 20 62 72 65
	   61 6B 20 84 20
	   20 80 20 6F 76
	   65 72 20 84 20
	   20 80 20 73 74
	   65 70 20 84 20
	   00
 00009165  FF		      C                             db  255
			      C 
 00009166  02D0		      C                             dw  90 * FONT_X
 00009168  0005		      C                             dw  1  * FONT_Y - 1
 0000916A		      C DEBI_o_screen_objects:
			      C     @AlwaysDrawWindow       DEBI_o_window
			     1C ; Always draws the window for whatever item is specified
 0000916A  FE		     1C     db  _DRAW_WINDOW_ALWAYS
 0000916B  0000910A R	     1C     dd  offset DEBI_o_window
			     1C   ; Total = 5
			      C     @ObjectMemSize  0
			     1C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
 0000916F  00		     1C     db  _OBJECT_MEM_SIZE
 00009170  00		     1C     db  0
			     1C   ; Total = 2
			      C     @End
 00009171  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C ALIGN
 00009172		      C DEBI_o_mouse_objects:
			      C     @Immediate              _LEFT_SINGLE_CLICK,  1,  0, 10,  0, invDEBI_clear_screen_and_redraw_windows
			     1C ; Used when any click is recognized on these coordinates
			     1C ;
			     1C ;       X1 - X coordinate (in characters relative to upper-left corner of window) of the upper-left object
			     1C ;       Y1 - Y coordinate (in characters relative to upper-left corner of window) of the upper-left object
			     1C ;       X2 - X coordinate (in characters relative to upper-left corner of window) of the lower-right object
			     1C ;       Y2 - Y coordinate (in characters relative to upper-left corner of window) of the lower-right object
			     1C ;     FUNC - Function to call when this event is recognized
			     1C ;
 00009172  0E		     1C     db  _IMMEDIATE                  ; +0
 00009173  00000008	     1C     dd  1 * FONT_X                 ; +1
 00009177  00000000	     1C     dd  0 * FONT_Y                 ; +5
 0000917B  00000057	     1C     dd  (10 * FONT_X) + FONT_X - 1  ; +9
 0000917F  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00009183  000004BF R	     1C     dd  invDEBI_clear_screen_and_redraw_windows                        ; +17
 00009187  FFFF		     1C     dw  0ffffh                      ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  2 dup(0ffh)             ; +25
			     1C     ELSE
 00009189  00000004 [	     1C         db  4 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
 0000918D  00		     1C     db  _LEFT_SINGLE_CLICK                        ; +27
			     1C   ; Total = 28
			      C     @Immediate              _LEFT_SINGLE_CLICK, 46,  0, 57,  0, invDEBI_menu_continue_click
			     1C ; Used when any click is recognized on these coordinates
			     1C ;
			     1C ;       X1 - X coordinate (in characters relative to upper-left corner of window) of the upper-left object
			     1C ;       Y1 - Y coordinate (in characters relative to upper-left corner of window) of the upper-left object
			     1C ;       X2 - X coordinate (in characters relative to upper-left corner of window) of the lower-right object
			     1C ;       Y2 - Y coordinate (in characters relative to upper-left corner of window) of the lower-right object
			     1C ;     FUNC - Function to call when this event is recognized
			     1C ;
 0000918E  0E		     1C     db  _IMMEDIATE                  ; +0
 0000918F  00000170	     1C     dd  46 * FONT_X                 ; +1
 00009193  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00009197  000001CF	     1C     dd  (57 * FONT_X) + FONT_X - 1  ; +9
 0000919B  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 0000919F  00003BD1 R	     1C     dd  invDEBI_menu_continue_click                        ; +17
 000091A3  FFFF		     1C     dw  0ffffh                      ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  2 dup(0ffh)             ; +25
			     1C     ELSE
 000091A5  00000004 [	     1C         db  4 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
 000091A9  00		     1C     db  _LEFT_SINGLE_CLICK                        ; +27
			     1C   ; Total = 28
			      C     @Immediate              _LEFT_SINGLE_CLICK, 60,  0, 68,  0, invDEBI_menu_break_click
			     1C ; Used when any click is recognized on these coordinates
			     1C ;
			     1C ;       X1 - X coordinate (in characters relative to upper-left corner of window) of the upper-left object
			     1C ;       Y1 - Y coordinate (in characters relative to upper-left corner of window) of the upper-left object
			     1C ;       X2 - X coordinate (in characters relative to upper-left corner of window) of the lower-right object
			     1C ;       Y2 - Y coordinate (in characters relative to upper-left corner of window) of the lower-right object
			     1C ;     FUNC - Function to call when this event is recognized
			     1C ;
 000091AA  0E		     1C     db  _IMMEDIATE                  ; +0
 000091AB  000001E0	     1C     dd  60 * FONT_X                 ; +1
 000091AF  00000000	     1C     dd  0 * FONT_Y                 ; +5
 000091B3  00000227	     1C     dd  (68 * FONT_X) + FONT_X - 1  ; +9
 000091B7  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 000091BB  00003BDA R	     1C     dd  invDEBI_menu_break_click                        ; +17
 000091BF  FFFF		     1C     dw  0ffffh                      ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  2 dup(0ffh)             ; +25
			     1C     ELSE
 000091C1  00000004 [	     1C         db  4 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
 000091C5  00		     1C     db  _LEFT_SINGLE_CLICK                        ; +27
			     1C   ; Total = 28
			      C     @Immediate              _LEFT_SINGLE_CLICK, 71,  0, 78,  0, invDEBI_menu_over_click
			     1C ; Used when any click is recognized on these coordinates
			     1C ;
			     1C ;       X1 - X coordinate (in characters relative to upper-left corner of window) of the upper-left object
			     1C ;       Y1 - Y coordinate (in characters relative to upper-left corner of window) of the upper-left object
			     1C ;       X2 - X coordinate (in characters relative to upper-left corner of window) of the lower-right object
			     1C ;       Y2 - Y coordinate (in characters relative to upper-left corner of window) of the lower-right object
			     1C ;     FUNC - Function to call when this event is recognized
			     1C ;
 000091C6  0E		     1C     db  _IMMEDIATE                  ; +0
 000091C7  00000238	     1C     dd  71 * FONT_X                 ; +1
 000091CB  00000000	     1C     dd  0 * FONT_Y                 ; +5
 000091CF  00000277	     1C     dd  (78 * FONT_X) + FONT_X - 1  ; +9
 000091D3  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 000091D7  00003BDB R	     1C     dd  invDEBI_menu_over_click                        ; +17
 000091DB  FFFF		     1C     dw  0ffffh                      ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  2 dup(0ffh)             ; +25
			     1C     ELSE
 000091DD  00000004 [	     1C         db  4 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
 000091E1  00		     1C     db  _LEFT_SINGLE_CLICK                        ; +27
			     1C   ; Total = 28
			      C     @Immediate              _LEFT_SINGLE_CLICK, 81,  0, 88,  0, invDEBI_menu_step_click
			     1C ; Used when any click is recognized on these coordinates
			     1C ;
			     1C ;       X1 - X coordinate (in characters relative to upper-left corner of window) of the upper-left object
			     1C ;       Y1 - Y coordinate (in characters relative to upper-left corner of window) of the upper-left object
			     1C ;       X2 - X coordinate (in characters relative to upper-left corner of window) of the lower-right object
			     1C ;       Y2 - Y coordinate (in characters relative to upper-left corner of window) of the lower-right object
			     1C ;     FUNC - Function to call when this event is recognized
			     1C ;
 000091E2  0E		     1C     db  _IMMEDIATE                  ; +0
 000091E3  00000288	     1C     dd  81 * FONT_X                 ; +1
 000091E7  00000000	     1C     dd  0 * FONT_Y                 ; +5
 000091EB  000002C7	     1C     dd  (88 * FONT_X) + FONT_X - 1  ; +9
 000091EF  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 000091F3  00003BDC R	     1C     dd  invDEBI_menu_step_click                        ; +17
 000091F7  FFFF		     1C     dw  0ffffh                      ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  2 dup(0ffh)             ; +25
			     1C     ELSE
 000091F9  00000004 [	     1C         db  4 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
 000091FD  00		     1C     db  _LEFT_SINGLE_CLICK                        ; +27
			     1C   ; Total = 28
			      C     @End
 000091FE  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
			      C                                 ;          11111
			      C                                 ;012345678901234
 000091FF C9 9A CD 81 20      C DEBI_p_window               db  "…öÕÅ Regs.1 ÖÕª",0
	   52 65 67 73 2E
	   31 20 85 CD BB
	   00
 0000920F  20 20 63 73 20     C                             db  "  cs ˙˙˙˙     ∫",0
	   FA FA FA FA 20
	   20 20 20 20 BA
	   00
 0000921F  20 65 69 70 20     C                             db  " eip ˙˙˙˙˙˙˙˙ ∫",0
	   FA FA FA FA FA
	   FA FA FA 20 BA
	   00
 0000922F  C4 C4 C4 C4 C4     C                             db  "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∫",0
	   C4 C4 C4 C4 C4
	   C4 C4 C4 C4 BA
	   00
 0000923F  20 65 61 78 20     C                             db  " eax ˙˙˙˙˙˙˙˙ ∫",0
	   FA FA FA FA FA
	   FA FA FA 20 BA
	   00
 0000924F  20 65 62 78 20     C                             db  " ebx ˙˙˙˙˙˙˙˙ ∫",0
	   FA FA FA FA FA
	   FA FA FA 20 BA
	   00
 0000925F  20 65 63 78 20     C                             db  " ecx ˙˙˙˙˙˙˙˙ ∫",0
	   FA FA FA FA FA
	   FA FA FA 20 BA
	   00
 0000926F  20 65 64 78 20     C                             db  " edx ˙˙˙˙˙˙˙˙ ∫",0
	   FA FA FA FA FA
	   FA FA FA 20 BA
	   00
 0000927F  20 65 73 69 20     C                             db  " esi ˙˙˙˙˙˙˙˙ ∫",0
	   FA FA FA FA FA
	   FA FA FA 20 BA
	   00
 0000928F  20 65 64 69 20     C                             db  " edi ˙˙˙˙˙˙˙˙ ∫",0
	   FA FA FA FA FA
	   FA FA FA 20 BA
	   00
 0000929F  C4 C4 C4 C4 C4     C                             db  "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∫",0
	   C4 C4 C4 C4 C4
	   C4 C4 C4 C4 BA
	   00
 000092AF  20 20 64 73 20     C                             db  "  ds ˙˙˙˙     ∫",0
	   FA FA FA FA 20
	   20 20 20 20 BA
	   00
 000092BF  20 20 65 73 20     C                             db  "  es ˙˙˙˙     ∫",0
	   FA FA FA FA 20
	   20 20 20 20 BA
	   00
 000092CF  20 20 66 73 20     C                             db  "  fs ˙˙˙˙     ∫",0
	   FA FA FA FA 20
	   20 20 20 20 BA
	   00
 000092DF  20 20 67 73 20     C                             db  "  gs ˙˙˙˙     ∫",0
	   FA FA FA FA 20
	   20 20 20 20 BA
	   00
 000092EF  20 20 73 73 20     C                             db  "  ss ˙˙˙˙     ∫",0
	   FA FA FA FA 20
	   20 20 20 20 BA
	   00
 000092FF  20 65 73 70 20     C                             db  " esp ˙˙˙˙˙˙˙˙ ∫",0
	   FA FA FA FA FA
	   FA FA FA 20 BA
	   00
 0000930F  20 65 62 70 20     C                             db  " ebp ˙˙˙˙˙˙˙˙ ∫",0
	   FA FA FA FA FA
	   FA FA FA 20 BA
	   00
 0000931F  C4 C4 C4 C4 C4     C                             db  "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∫",0
	   C4 C4 C4 C4 C4
	   C4 C4 C4 C4 BA
	   00
 0000932F  20 65 66 6C 61     C                             db  " eflags       ∫",0
	   67 73 20 20 20
	   20 20 20 20 BA
	   00
 0000933F  20 20 20 FA FA     C                             db  "   ˙˙˙˙˙˙˙˙   ∫",0
	   FA FA FA FA FA
	   FA 20 20 20 BA
	   00
 0000934F  C4 C4 C4 C4 C4     C                             db  "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∫",0
	   C4 C4 C4 C4 C4
	   C4 C4 C4 C4 BA
	   00
 0000935F  20 6E 74 FA 20     C                             db  " nt˙ of˙ acf˙ ∫",0
	   6F 66 FA 20 61
	   63 66 FA 20 BA
	   00
 0000936F  20 70 66 FA 20     C                             db  " pf˙ sf˙  if˙ ∫",0
	   73 66 FA 20 20
	   69 66 FA 20 BA
	   00
 0000937F  20 64 66 FA 20     C                             db  " df˙ zf˙  cf˙ ∫",0
	   7A 66 FA 20 20
	   63 66 FA 20 BA
	   00
 0000938F  C4 C4 C4 C4 C4     C                             db  "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒ∫",0
	   C4 C4 C4 C4 C4
	   C4 C4 C4 C4 BA
	   00
 0000939F  20 AE 65 72 72     C                             db  " ÆerrØ ˙˙˙˙˙˙˙˙ ∫",0
	   AF 20 FA FA FA
	   FA FA FA FA FA
	   20 BA 00
 000093B1  AE 64 61 74 61     C                             db  "ÆdataØ ˙˙˙˙˙˙˙˙ ∫",0
	   AF 20 FA FA FA
	   FA FA FA FA FA
	   20 BA 00
 000093C3  20 AE 69 6D 6D     C                             db  " ÆimmØ ˙˙˙˙˙˙˙˙ ∫",0
	   AF 20 FA FA FA
	   FA FA FA FA FA
	   20 BA 00
 000093D5  20 20 20 20 20     C                             db  "              ∫",0
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 000093E5  FF		      C                             db  255
			      C 
 000093E6  0078		      C                             dw  15 * FONT_X
 000093E8  00B3		      C                             dw  30 * FONT_Y - 1
 000093EA		      C DEBI_p_screen_objects:
			      C     @DrawWindow             DEBI_p_window
			     1C ; Draws the window for whatever item is specified
 000093EA  FD		     1C     db  _DRAW_WINDOW
 000093EB  000091FF R	     1C     dd  offset DEBI_p_window
			     1C   ; Total = 5
			      C     @ObjectMemSize      64
			     1C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
 000093EF  00		     1C     db  _OBJECT_MEM_SIZE
 000093F0  40		     1C     db  64
			     1C   ; Total = 2
			      C     @DisplayEBP_relative _16,     56,52, 5, 1                       ; cs
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000093F1  03		     1C     db  _DISPLAY            ; +0
 000093F2  01		     1C     db  _EBP_RELATIVE       ; +1
 000093F3  04		     1C     db  _16                ; +2
 000093F4  0038		     1C     dw  56           ; +3
 000093F6  34		     1C     db  52             ; +5
 000093F7  00000028	     1C     dd  5 * FONT_X          ; +6
 000093FB  00000006	     1C     dd  1 * FONT_Y          ; +10
 000093FF  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _32,     52,56, 5, 2                       ; eip
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009401  03		     1C     db  _DISPLAY            ; +0
 00009402  01		     1C     db  _EBP_RELATIVE       ; +1
 00009403  05		     1C     db  _32                ; +2
 00009404  0034		     1C     dw  52           ; +3
 00009406  38		     1C     db  56             ; +5
 00009407  00000028	     1C     dd  5 * FONT_X          ; +6
 0000940B  0000000C	     1C     dd  2 * FONT_Y          ; +10
 0000940F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _32,     44, 0, 5, 4                       ; upper 16-bits of eax
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009411  03		     1C     db  _DISPLAY            ; +0
 00009412  01		     1C     db  _EBP_RELATIVE       ; +1
 00009413  05		     1C     db  _32                ; +2
 00009414  002C		     1C     dw  44           ; +3
 00009416  00		     1C     db  0             ; +5
 00009417  00000028	     1C     dd  5 * FONT_X          ; +6
 0000941B  00000018	     1C     dd  4 * FONT_Y          ; +10
 0000941F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _32,     40, 4, 5, 5                       ; upper 16-bits of ebx
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009421  03		     1C     db  _DISPLAY            ; +0
 00009422  01		     1C     db  _EBP_RELATIVE       ; +1
 00009423  05		     1C     db  _32                ; +2
 00009424  0028		     1C     dw  40           ; +3
 00009426  04		     1C     db  4             ; +5
 00009427  00000028	     1C     dd  5 * FONT_X          ; +6
 0000942B  0000001E	     1C     dd  5 * FONT_Y          ; +10
 0000942F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _32,     36, 8, 5, 6                       ; upper 16-bits of ecx
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009431  03		     1C     db  _DISPLAY            ; +0
 00009432  01		     1C     db  _EBP_RELATIVE       ; +1
 00009433  05		     1C     db  _32                ; +2
 00009434  0024		     1C     dw  36           ; +3
 00009436  08		     1C     db  8             ; +5
 00009437  00000028	     1C     dd  5 * FONT_X          ; +6
 0000943B  00000024	     1C     dd  6 * FONT_Y          ; +10
 0000943F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _32,     32,12, 5, 7                       ; upper 16-bits of edx
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009441  03		     1C     db  _DISPLAY            ; +0
 00009442  01		     1C     db  _EBP_RELATIVE       ; +1
 00009443  05		     1C     db  _32                ; +2
 00009444  0020		     1C     dw  32           ; +3
 00009446  0C		     1C     db  12             ; +5
 00009447  00000028	     1C     dd  5 * FONT_X          ; +6
 0000944B  0000002A	     1C     dd  7 * FONT_Y          ; +10
 0000944F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _32,     28,16, 5, 8                       ; upper 16-bits of esi
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009451  03		     1C     db  _DISPLAY            ; +0
 00009452  01		     1C     db  _EBP_RELATIVE       ; +1
 00009453  05		     1C     db  _32                ; +2
 00009454  001C		     1C     dw  28           ; +3
 00009456  10		     1C     db  16             ; +5
 00009457  00000028	     1C     dd  5 * FONT_X          ; +6
 0000945B  00000030	     1C     dd  8 * FONT_Y          ; +10
 0000945F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _32,     24,20, 5, 9                       ; upper 16-bits of edi
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009461  03		     1C     db  _DISPLAY            ; +0
 00009462  01		     1C     db  _EBP_RELATIVE       ; +1
 00009463  05		     1C     db  _32                ; +2
 00009464  0018		     1C     dw  24           ; +3
 00009466  14		     1C     db  20             ; +5
 00009467  00000028	     1C     dd  5 * FONT_X          ; +6
 0000946B  00000036	     1C     dd  9 * FONT_Y          ; +10
 0000946F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _16,     20,24, 5, 11                      ; ds
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009471  03		     1C     db  _DISPLAY            ; +0
 00009472  01		     1C     db  _EBP_RELATIVE       ; +1
 00009473  04		     1C     db  _16                ; +2
 00009474  0014		     1C     dw  20           ; +3
 00009476  18		     1C     db  24             ; +5
 00009477  00000028	     1C     dd  5 * FONT_X          ; +6
 0000947B  00000042	     1C     dd  11 * FONT_Y          ; +10
 0000947F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _16,     16,28, 5, 12                      ; es
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009481  03		     1C     db  _DISPLAY            ; +0
 00009482  01		     1C     db  _EBP_RELATIVE       ; +1
 00009483  04		     1C     db  _16                ; +2
 00009484  0010		     1C     dw  16           ; +3
 00009486  1C		     1C     db  28             ; +5
 00009487  00000028	     1C     dd  5 * FONT_X          ; +6
 0000948B  00000048	     1C     dd  12 * FONT_Y          ; +10
 0000948F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _16,     12,32, 5, 13                      ; fs
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009491  03		     1C     db  _DISPLAY            ; +0
 00009492  01		     1C     db  _EBP_RELATIVE       ; +1
 00009493  04		     1C     db  _16                ; +2
 00009494  000C		     1C     dw  12           ; +3
 00009496  20		     1C     db  32             ; +5
 00009497  00000028	     1C     dd  5 * FONT_X          ; +6
 0000949B  0000004E	     1C     dd  13 * FONT_Y          ; +10
 0000949F  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _16,      8,36, 5, 14                      ; gs
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000094A1  03		     1C     db  _DISPLAY            ; +0
 000094A2  01		     1C     db  _EBP_RELATIVE       ; +1
 000094A3  04		     1C     db  _16                ; +2
 000094A4  0008		     1C     dw  8           ; +3
 000094A6  24		     1C     db  36             ; +5
 000094A7  00000028	     1C     dd  5 * FONT_X          ; +6
 000094AB  00000054	     1C     dd  14 * FONT_Y          ; +10
 000094AF  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _16,      4,40, 5, 15                      ; ss
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000094B1  03		     1C     db  _DISPLAY            ; +0
 000094B2  01		     1C     db  _EBP_RELATIVE       ; +1
 000094B3  04		     1C     db  _16                ; +2
 000094B4  0004		     1C     dw  4           ; +3
 000094B6  28		     1C     db  40             ; +5
 000094B7  00000028	     1C     dd  5 * FONT_X          ; +6
 000094BB  0000005A	     1C     dd  15 * FONT_Y          ; +10
 000094BF  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _32,     -4,44, 5, 16                      ; esp
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000094C1  03		     1C     db  _DISPLAY            ; +0
 000094C2  01		     1C     db  _EBP_RELATIVE       ; +1
 000094C3  05		     1C     db  _32                ; +2
 000094C4  FFFC		     1C     dw  -4           ; +3
 000094C6  2C		     1C     db  44             ; +5
 000094C7  00000028	     1C     dd  5 * FONT_X          ; +6
 000094CB  00000060	     1C     dd  16 * FONT_Y          ; +10
 000094CF  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _32,      0,48, 5, 17                      ; ebp
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000094D1  03		     1C     db  _DISPLAY            ; +0
 000094D2  01		     1C     db  _EBP_RELATIVE       ; +1
 000094D3  05		     1C     db  _32                ; +2
 000094D4  0000		     1C     dw  0           ; +3
 000094D6  30		     1C     db  48             ; +5
 000094D7  00000028	     1C     dd  5 * FONT_X          ; +6
 000094DB  00000066	     1C     dd  17 * FONT_Y          ; +10
 000094DF  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative _32,     60,60, 3, 20                      ; eflags
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000094E1  03		     1C     db  _DISPLAY            ; +0
 000094E2  01		     1C     db  _EBP_RELATIVE       ; +1
 000094E3  05		     1C     db  _32                ; +2
 000094E4  003C		     1C     dw  60           ; +3
 000094E6  3C		     1C     db  60             ; +5
 000094E7  00000018	     1C     dd  3 * FONT_X          ; +6
 000094EB  00000078	     1C     dd  20 * FONT_Y          ; +10
 000094EF  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_flag              60,64, _EFLAGS_NT,  1, 22, "nt"
			     1C ; Used to display a flag.  Note that the EBP reference is an offset on the stack, the use_bit represents the bit pattern for the flag
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;   USE_BIT - Indicates which bit in the DWORD quantity is to be examined
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to display, note the last character is used to inidcate whether the flag is up  or down 
			     1C ;
 000094F1  03		     1C     db  _DISPLAY
 000094F2  04		     1C     db  _EBP_RELATIVE_EFLAG
 000094F3  003C		     1C     dw  60
 000094F5  40		     1C     db  64
 000094F6  00004000	     1C     dd  1 SHL _EFLAGS_NT           ; Get the bit pattern to extract this one bit
 000094FA  00000008	     1C     dd  1 * FONT_X
 000094FE  00000084	     1C     dd  22 * FONT_Y
 00009502  03		     1C     db  @SizeStr("nt") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 00009503  6E 74 19	     1C     db  "nt"
 00009506  00		     1C     db  0                       ; Null terminate the string (for display purposes)
			     1C   ; Total = <varies per item>
			      C     @DisplayEBP_flag              60,64, _EFLAGS_PF,  1, 23, "pf"
			     1C ; Used to display a flag.  Note that the EBP reference is an offset on the stack, the use_bit represents the bit pattern for the flag
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;   USE_BIT - Indicates which bit in the DWORD quantity is to be examined
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to display, note the last character is used to inidcate whether the flag is up  or down 
			     1C ;
 00009507  03		     1C     db  _DISPLAY
 00009508  04		     1C     db  _EBP_RELATIVE_EFLAG
 00009509  003C		     1C     dw  60
 0000950B  40		     1C     db  64
 0000950C  00000004	     1C     dd  1 SHL _EFLAGS_PF           ; Get the bit pattern to extract this one bit
 00009510  00000008	     1C     dd  1 * FONT_X
 00009514  0000008A	     1C     dd  23 * FONT_Y
 00009518  03		     1C     db  @SizeStr("pf") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 00009519  70 66 19	     1C     db  "pf"
 0000951C  00		     1C     db  0                       ; Null terminate the string (for display purposes)
			     1C   ; Total = <varies per item>
			      C     @DisplayEBP_flag              60,64, _EFLAGS_DF,  1, 24, "df"
			     1C ; Used to display a flag.  Note that the EBP reference is an offset on the stack, the use_bit represents the bit pattern for the flag
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;   USE_BIT - Indicates which bit in the DWORD quantity is to be examined
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to display, note the last character is used to inidcate whether the flag is up  or down 
			     1C ;
 0000951D  03		     1C     db  _DISPLAY
 0000951E  04		     1C     db  _EBP_RELATIVE_EFLAG
 0000951F  003C		     1C     dw  60
 00009521  40		     1C     db  64
 00009522  00000400	     1C     dd  1 SHL _EFLAGS_DF           ; Get the bit pattern to extract this one bit
 00009526  00000008	     1C     dd  1 * FONT_X
 0000952A  00000090	     1C     dd  24 * FONT_Y
 0000952E  03		     1C     db  @SizeStr("df") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000952F  64 66 19	     1C     db  "df"
 00009532  00		     1C     db  0                       ; Null terminate the string (for display purposes)
			     1C   ; Total = <varies per item>
			      C     @DisplayEBP_flag              60,64, _EFLAGS_OF,  5, 22, "of"
			     1C ; Used to display a flag.  Note that the EBP reference is an offset on the stack, the use_bit represents the bit pattern for the flag
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;   USE_BIT - Indicates which bit in the DWORD quantity is to be examined
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to display, note the last character is used to inidcate whether the flag is up  or down 
			     1C ;
 00009533  03		     1C     db  _DISPLAY
 00009534  04		     1C     db  _EBP_RELATIVE_EFLAG
 00009535  003C		     1C     dw  60
 00009537  40		     1C     db  64
 00009538  00000800	     1C     dd  1 SHL _EFLAGS_OF           ; Get the bit pattern to extract this one bit
 0000953C  00000028	     1C     dd  5 * FONT_X
 00009540  00000084	     1C     dd  22 * FONT_Y
 00009544  03		     1C     db  @SizeStr("of") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 00009545  6F 66 19	     1C     db  "of"
 00009548  00		     1C     db  0                       ; Null terminate the string (for display purposes)
			     1C   ; Total = <varies per item>
			      C     @DisplayEBP_flag              60,64, _EFLAGS_SF,  5, 23, "sf"
			     1C ; Used to display a flag.  Note that the EBP reference is an offset on the stack, the use_bit represents the bit pattern for the flag
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;   USE_BIT - Indicates which bit in the DWORD quantity is to be examined
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to display, note the last character is used to inidcate whether the flag is up  or down 
			     1C ;
 00009549  03		     1C     db  _DISPLAY
 0000954A  04		     1C     db  _EBP_RELATIVE_EFLAG
 0000954B  003C		     1C     dw  60
 0000954D  40		     1C     db  64
 0000954E  00000080	     1C     dd  1 SHL _EFLAGS_SF           ; Get the bit pattern to extract this one bit
 00009552  00000028	     1C     dd  5 * FONT_X
 00009556  0000008A	     1C     dd  23 * FONT_Y
 0000955A  03		     1C     db  @SizeStr("sf") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000955B  73 66 19	     1C     db  "sf"
 0000955E  00		     1C     db  0                       ; Null terminate the string (for display purposes)
			     1C   ; Total = <varies per item>
			      C     @DisplayEBP_flag              60,64, _EFLAGS_ZF,  5, 24, "zf"
			     1C ; Used to display a flag.  Note that the EBP reference is an offset on the stack, the use_bit represents the bit pattern for the flag
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;   USE_BIT - Indicates which bit in the DWORD quantity is to be examined
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to display, note the last character is used to inidcate whether the flag is up  or down 
			     1C ;
 0000955F  03		     1C     db  _DISPLAY
 00009560  04		     1C     db  _EBP_RELATIVE_EFLAG
 00009561  003C		     1C     dw  60
 00009563  40		     1C     db  64
 00009564  00000040	     1C     dd  1 SHL _EFLAGS_ZF           ; Get the bit pattern to extract this one bit
 00009568  00000028	     1C     dd  5 * FONT_X
 0000956C  00000090	     1C     dd  24 * FONT_Y
 00009570  03		     1C     db  @SizeStr("zf") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 00009571  7A 66 19	     1C     db  "zf"
 00009574  00		     1C     db  0                       ; Null terminate the string (for display purposes)
			     1C   ; Total = <varies per item>
			      C     @DisplayEBP_flag              60,64,_EFLAGS_ACF,  9, 22, "acf"
			     1C ; Used to display a flag.  Note that the EBP reference is an offset on the stack, the use_bit represents the bit pattern for the flag
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;   USE_BIT - Indicates which bit in the DWORD quantity is to be examined
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to display, note the last character is used to inidcate whether the flag is up  or down 
			     1C ;
 00009575  03		     1C     db  _DISPLAY
 00009576  04		     1C     db  _EBP_RELATIVE_EFLAG
 00009577  003C		     1C     dw  60
 00009579  40		     1C     db  64
 0000957A  00000010	     1C     dd  1 SHL _EFLAGS_ACF           ; Get the bit pattern to extract this one bit
 0000957E  00000048	     1C     dd  9 * FONT_X
 00009582  00000084	     1C     dd  22 * FONT_Y
 00009586  04		     1C     db  @SizeStr("acf") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 00009587  61 63 66 19	     1C     db  "acf"
 0000958B  00		     1C     db  0                       ; Null terminate the string (for display purposes)
			     1C   ; Total = <varies per item>
			      C     @DisplayEBP_flag              60,64, _EFLAGS_IF, 10, 23, "if"
			     1C ; Used to display a flag.  Note that the EBP reference is an offset on the stack, the use_bit represents the bit pattern for the flag
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;   USE_BIT - Indicates which bit in the DWORD quantity is to be examined
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to display, note the last character is used to inidcate whether the flag is up  or down 
			     1C ;
 0000958C  03		     1C     db  _DISPLAY
 0000958D  04		     1C     db  _EBP_RELATIVE_EFLAG
 0000958E  003C		     1C     dw  60
 00009590  40		     1C     db  64
 00009591  00000200	     1C     dd  1 SHL _EFLAGS_IF           ; Get the bit pattern to extract this one bit
 00009595  00000050	     1C     dd  10 * FONT_X
 00009599  0000008A	     1C     dd  23 * FONT_Y
 0000959D  03		     1C     db  @SizeStr("if") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000959E  69 66 19	     1C     db  "if"
 000095A1  00		     1C     db  0                       ; Null terminate the string (for display purposes)
			     1C   ; Total = <varies per item>
			      C     @DisplayEBP_flag              60,64, _EFLAGS_CF, 10, 24, "cf"
			     1C ; Used to display a flag.  Note that the EBP reference is an offset on the stack, the use_bit represents the bit pattern for the flag
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;   USE_BIT - Indicates which bit in the DWORD quantity is to be examined
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to display, note the last character is used to inidcate whether the flag is up  or down 
			     1C ;
 000095A2  03		     1C     db  _DISPLAY
 000095A3  04		     1C     db  _EBP_RELATIVE_EFLAG
 000095A4  003C		     1C     dw  60
 000095A6  40		     1C     db  64
 000095A7  00000001	     1C     dd  1 SHL _EFLAGS_CF           ; Get the bit pattern to extract this one bit
 000095AB  00000050	     1C     dd  10 * FONT_X
 000095AF  00000090	     1C     dd  24 * FONT_Y
 000095B3  03		     1C     db  @SizeStr("cf") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 000095B4  63 66 19	     1C     db  "cf"
 000095B7  00		     1C     db  0                       ; Null terminate the string (for display purposes)
			     1C   ; Total = <varies per item>
			      C     @DisplayEBP_relative _32,     48,48, 5,26                       ; <error code>
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000095B8  03		     1C     db  _DISPLAY            ; +0
 000095B9  01		     1C     db  _EBP_RELATIVE       ; +1
 000095BA  05		     1C     db  _32                ; +2
 000095BB  0030		     1C     dw  48           ; +3
 000095BD  30		     1C     db  48             ; +5
 000095BE  00000028	     1C     dd  5 * FONT_X          ; +6
 000095C2  0000009C	     1C     dd  26 * FONT_Y          ; +10
 000095C6  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @ObjectPostDisplay   _32,      5, 25, "data"
			     1C ; Used to display an object after all of the objects have been displayed.  This is done because this object references something
			     1C ; that is calculated in another window.  The data item is identified by name (string) and may or may not be displayed once the
			     1C ; entire processing has been completed.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to look for.  Other windows will issue @ObjectPostObject that will be searched
			     1C ;
 000095C8  05		     1C     db  _POST_DISPLAY
 000095C9  05		     1C     db  _32
 000095CA  00000028	     1C     dd  5 * FONT_X
 000095CE  00000096	     1C     dd  25 * FONT_Y
 000095D2  04		     1C     db  @SizeStr("data") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 000095D3  64 61 74 61	     1C     db  "data"
			     1C   ; Total = <varies per item>
			      C     @ObjectPostDisplay   _32,      5, 26, "imm"
			     1C ; Used to display an object after all of the objects have been displayed.  This is done because this object references something
			     1C ; that is calculated in another window.  The data item is identified by name (string) and may or may not be displayed once the
			     1C ; entire processing has been completed.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;    STRING - The string to look for.  Other windows will issue @ObjectPostObject that will be searched
			     1C ;
 000095D7  05		     1C     db  _POST_DISPLAY
 000095D8  05		     1C     db  _32
 000095D9  00000028	     1C     dd  5 * FONT_X
 000095DD  0000009C	     1C     dd  26 * FONT_Y
 000095E1  03		     1C     db  @SizeStr("imm") - 2    ; The -2 is for the quotes, @SizeStr("test") returns 6
 000095E2  69 6D 6D	     1C     db  "imm"
			     1C   ; Total = <varies per item>
			      C     @End
 000095E5  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C ALIGN
 000095E6		      C DEBI_p_mouse_objects:
			      C     @Left_single_click       1,  0,  1,  0, invDEBI_object_close
			     1C ; Used when a left single-click is recognized on these coordinates
 000095E6  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 000095E7  00000008	     1C     dd  1 * FONT_X                 ; +1
 000095EB  00000000	     1C     dd  0 * FONT_Y                 ; +5
 000095EF  0000000F	     1C     dd  (1 * FONT_X) + FONT_X - 1  ; +9
 000095F3  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 000095F7  0000510B R	     1C     dd  invDEBI_object_close                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 000095FB  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 000095FF  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00009601  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      3,  0, 12,  0, invDEBI_reg_1_right_click
			     1C ; Used when a right single-click is recognized on these coordinates
 00009602  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 00009603  00000018	     1C     dd  3 * FONT_X                 ; +1
 00009607  00000000	     1C     dd  0 * FONT_Y                 ; +5
 0000960B  00000067	     1C     dd  (12 * FONT_X) + FONT_X - 1  ; +9
 0000960F  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00009613  000039C0 R	     1C     dd  invDEBI_reg_1_right_click                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00009617  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000961B  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000961D  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         0,  0, 14,  0, invDEBI_object_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 0000961E  02		     1C     db  _LEFT_DRAG_START            ; +0
 0000961F  00000000	     1C     dd  0 * FONT_X                 ; +1
 00009623  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00009627  00000077	     1C     dd  (14 * FONT_X) + FONT_X - 1  ; +9
 0000962B  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 0000962F  00003BE5 R	     1C     dd  invDEBI_object_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00009633  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00009637  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00009639  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Abandon_if_not          1,  1, 13, 29
			     1C ; Used in a lengthy list.  If the coordinates are not within this range then the rest of the lengthy list is not checked
 0000963A  0C		     1C     db  _ABANDON_IF_NOT             ; +0
 0000963B  00000008	     1C     dd  1 * FONT_X                 ; +1
 0000963F  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00009643  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00009647  000000B3	     1C     dd  (29 * FONT_Y) + FONT_Y - 1  ; +13
 0000964B  0000000B [	     1C     db  11 dup(0ffh)                ; +17
	    FF
	   ]
			     1C   ; Total = 28
			      C     @Hover                   5,  1,  8,  1, 56, invDEBI_quick_watch_show_EBP_relative_selector                  ; cs
			     1C ; Used when the mouse is hovering over these coordinates
 00009656  0A		     1C     db  _HOVER                      ; +0
 00009657  00000028	     1C     dd  5 * FONT_X                 ; +1
 0000965B  00000006	     1C     dd  1 * FONT_Y                 ; +5
 0000965F  00000047	     1C     dd  (8 * FONT_X) + FONT_X - 1  ; +9
 00009663  0000000B	     1C     dd  (1 * FONT_Y) + FONT_Y - 1  ; +13
 00009667  00002D70 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_selector                        ; +17
 0000966B  0038		     1C     dw  lowword(offset 56)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000966D  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   5,  2, 12,  2, 52, invDEBI_quick_watch_show_EBP_relative_32                        ; eip
			     1C ; Used when the mouse is hovering over these coordinates
 00009672  0A		     1C     db  _HOVER                      ; +0
 00009673  00000028	     1C     dd  5 * FONT_X                 ; +1
 00009677  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 0000967B  00000067	     1C     dd  (12 * FONT_X) + FONT_X - 1  ; +9
 0000967F  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 00009683  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 00009687  0034		     1C     dw  lowword(offset 52)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009689  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   5,  4, 12,  4, 44, invDEBI_quick_watch_show_EBP_relative_32                        ; eax
			     1C ; Used when the mouse is hovering over these coordinates
 0000968E  0A		     1C     db  _HOVER                      ; +0
 0000968F  00000028	     1C     dd  5 * FONT_X                 ; +1
 00009693  00000018	     1C     dd  4 * FONT_Y                 ; +5
 00009697  00000067	     1C     dd  (12 * FONT_X) + FONT_X - 1  ; +9
 0000969B  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 0000969F  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 000096A3  002C		     1C     dw  lowword(offset 44)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000096A5  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   5,  5, 12,  5, 40, invDEBI_quick_watch_show_EBP_relative_32                        ; ebx
			     1C ; Used when the mouse is hovering over these coordinates
 000096AA  0A		     1C     db  _HOVER                      ; +0
 000096AB  00000028	     1C     dd  5 * FONT_X                 ; +1
 000096AF  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 000096B3  00000067	     1C     dd  (12 * FONT_X) + FONT_X - 1  ; +9
 000096B7  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 000096BB  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 000096BF  0028		     1C     dw  lowword(offset 40)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000096C1  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   5,  6, 12,  6, 36, invDEBI_quick_watch_show_EBP_relative_32                        ; ecx
			     1C ; Used when the mouse is hovering over these coordinates
 000096C6  0A		     1C     db  _HOVER                      ; +0
 000096C7  00000028	     1C     dd  5 * FONT_X                 ; +1
 000096CB  00000024	     1C     dd  6 * FONT_Y                 ; +5
 000096CF  00000067	     1C     dd  (12 * FONT_X) + FONT_X - 1  ; +9
 000096D3  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 000096D7  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 000096DB  0024		     1C     dw  lowword(offset 36)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000096DD  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   5,  7, 12,  7, 32, invDEBI_quick_watch_show_EBP_relative_32                        ; edx
			     1C ; Used when the mouse is hovering over these coordinates
 000096E2  0A		     1C     db  _HOVER                      ; +0
 000096E3  00000028	     1C     dd  5 * FONT_X                 ; +1
 000096E7  0000002A	     1C     dd  7 * FONT_Y                 ; +5
 000096EB  00000067	     1C     dd  (12 * FONT_X) + FONT_X - 1  ; +9
 000096EF  0000002F	     1C     dd  (7 * FONT_Y) + FONT_Y - 1  ; +13
 000096F3  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 000096F7  0020		     1C     dw  lowword(offset 32)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000096F9  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   5,  8, 12,  8, 28, invDEBI_quick_watch_show_EBP_relative_32                        ; esi
			     1C ; Used when the mouse is hovering over these coordinates
 000096FE  0A		     1C     db  _HOVER                      ; +0
 000096FF  00000028	     1C     dd  5 * FONT_X                 ; +1
 00009703  00000030	     1C     dd  8 * FONT_Y                 ; +5
 00009707  00000067	     1C     dd  (12 * FONT_X) + FONT_X - 1  ; +9
 0000970B  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 0000970F  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 00009713  001C		     1C     dw  lowword(offset 28)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009715  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   5,  9, 12,  9, 24, invDEBI_quick_watch_show_EBP_relative_32                        ; edi
			     1C ; Used when the mouse is hovering over these coordinates
 0000971A  0A		     1C     db  _HOVER                      ; +0
 0000971B  00000028	     1C     dd  5 * FONT_X                 ; +1
 0000971F  00000036	     1C     dd  9 * FONT_Y                 ; +5
 00009723  00000067	     1C     dd  (12 * FONT_X) + FONT_X - 1  ; +9
 00009727  0000003B	     1C     dd  (9 * FONT_Y) + FONT_Y - 1  ; +13
 0000972B  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 0000972F  0018		     1C     dw  lowword(offset 24)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009731  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   5, 11,  8, 11, 20, invDEBI_quick_watch_show_EBP_relative_selector                  ; ds
			     1C ; Used when the mouse is hovering over these coordinates
 00009736  0A		     1C     db  _HOVER                      ; +0
 00009737  00000028	     1C     dd  5 * FONT_X                 ; +1
 0000973B  00000042	     1C     dd  11 * FONT_Y                 ; +5
 0000973F  00000047	     1C     dd  (8 * FONT_X) + FONT_X - 1  ; +9
 00009743  00000047	     1C     dd  (11 * FONT_Y) + FONT_Y - 1  ; +13
 00009747  00002D70 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_selector                        ; +17
 0000974B  0014		     1C     dw  lowword(offset 20)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000974D  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   5, 12,  8, 12, 16, invDEBI_quick_watch_show_EBP_relative_selector                  ; es
			     1C ; Used when the mouse is hovering over these coordinates
 00009752  0A		     1C     db  _HOVER                      ; +0
 00009753  00000028	     1C     dd  5 * FONT_X                 ; +1
 00009757  00000048	     1C     dd  12 * FONT_Y                 ; +5
 0000975B  00000047	     1C     dd  (8 * FONT_X) + FONT_X - 1  ; +9
 0000975F  0000004D	     1C     dd  (12 * FONT_Y) + FONT_Y - 1  ; +13
 00009763  00002D70 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_selector                        ; +17
 00009767  0010		     1C     dw  lowword(offset 16)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009769  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   5, 13,  8, 13, 12, invDEBI_quick_watch_show_EBP_relative_selector                  ; fs
			     1C ; Used when the mouse is hovering over these coordinates
 0000976E  0A		     1C     db  _HOVER                      ; +0
 0000976F  00000028	     1C     dd  5 * FONT_X                 ; +1
 00009773  0000004E	     1C     dd  13 * FONT_Y                 ; +5
 00009777  00000047	     1C     dd  (8 * FONT_X) + FONT_X - 1  ; +9
 0000977B  00000053	     1C     dd  (13 * FONT_Y) + FONT_Y - 1  ; +13
 0000977F  00002D70 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_selector                        ; +17
 00009783  000C		     1C     dw  lowword(offset 12)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009785  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   5, 14,  8, 14,  8, invDEBI_quick_watch_show_EBP_relative_selector                  ; gs
			     1C ; Used when the mouse is hovering over these coordinates
 0000978A  0A		     1C     db  _HOVER                      ; +0
 0000978B  00000028	     1C     dd  5 * FONT_X                 ; +1
 0000978F  00000054	     1C     dd  14 * FONT_Y                 ; +5
 00009793  00000047	     1C     dd  (8 * FONT_X) + FONT_X - 1  ; +9
 00009797  00000059	     1C     dd  (14 * FONT_Y) + FONT_Y - 1  ; +13
 0000979B  00002D70 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_selector                        ; +17
 0000979F  0008		     1C     dw  lowword(offset 8)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000097A1  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   5, 15,  8, 15,  4, invDEBI_quick_watch_show_EBP_relative_selector                  ; ss
			     1C ; Used when the mouse is hovering over these coordinates
 000097A6  0A		     1C     db  _HOVER                      ; +0
 000097A7  00000028	     1C     dd  5 * FONT_X                 ; +1
 000097AB  0000005A	     1C     dd  15 * FONT_Y                 ; +5
 000097AF  00000047	     1C     dd  (8 * FONT_X) + FONT_X - 1  ; +9
 000097B3  0000005F	     1C     dd  (15 * FONT_Y) + FONT_Y - 1  ; +13
 000097B7  00002D70 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_selector                        ; +17
 000097BB  0004		     1C     dw  lowword(offset 4)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000097BD  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   5, 16, 12, 16, -4, invDEBI_quick_watch_show_EBP_relative_32                        ; esp
			     1C ; Used when the mouse is hovering over these coordinates
 000097C2  0A		     1C     db  _HOVER                      ; +0
 000097C3  00000028	     1C     dd  5 * FONT_X                 ; +1
 000097C7  00000060	     1C     dd  16 * FONT_Y                 ; +5
 000097CB  00000067	     1C     dd  (12 * FONT_X) + FONT_X - 1  ; +9
 000097CF  00000065	     1C     dd  (16 * FONT_Y) + FONT_Y - 1  ; +13
 000097D3  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 000097D7  FFFC		     1C     dw  lowword(offset -4)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000097D9  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   5, 17, 12, 17,  0, invDEBI_quick_watch_show_EBP_relative_32                        ; ebp
			     1C ; Used when the mouse is hovering over these coordinates
 000097DE  0A		     1C     db  _HOVER                      ; +0
 000097DF  00000028	     1C     dd  5 * FONT_X                 ; +1
 000097E3  00000066	     1C     dd  17 * FONT_Y                 ; +5
 000097E7  00000067	     1C     dd  (12 * FONT_X) + FONT_X - 1  ; +9
 000097EB  0000006B	     1C     dd  (17 * FONT_Y) + FONT_Y - 1  ; +13
 000097EF  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 000097F3  0000		     1C     dw  lowword(offset 0)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 000097F5  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   3, 20, 10, 20, 60, invDEBI_quick_watch_show_EBP_relative_32                        ; eflags
			     1C ; Used when the mouse is hovering over these coordinates
 000097FA  0A		     1C     db  _HOVER                      ; +0
 000097FB  00000018	     1C     dd  3 * FONT_X                 ; +1
 000097FF  00000078	     1C     dd  20 * FONT_Y                 ; +5
 00009803  00000057	     1C     dd  (10 * FONT_X) + FONT_X - 1  ; +9
 00009807  0000007D	     1C     dd  (20 * FONT_Y) + FONT_Y - 1  ; +13
 0000980B  00002FA0 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_32                        ; +17
 0000980F  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009811  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   1, 21,  3, 22, 60, invDEBI_quick_watch_show_EBP_relative_eflags, _EFLAGS_NT
			     1C ; Used when the mouse is hovering over these coordinates
 00009816  0A		     1C     db  _HOVER                      ; +0
 00009817  00000008	     1C     dd  1 * FONT_X                 ; +1
 0000981B  0000007E	     1C     dd  21 * FONT_Y                 ; +5
 0000981F  0000001F	     1C     dd  (3 * FONT_X) + FONT_X - 1  ; +9
 00009823  00000089	     1C     dd  (22 * FONT_Y) + FONT_Y - 1  ; +13
 00009827  000050ED R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_eflags                        ; +17
 0000982B  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_NT>
 0000982D  000E		     1C         dw  _EFLAGS_NT                   ; +23
 0000982F  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   1, 22,  3, 23, 60, invDEBI_quick_watch_show_EBP_relative_eflags, _EFLAGS_PF
			     1C ; Used when the mouse is hovering over these coordinates
 00009832  0A		     1C     db  _HOVER                      ; +0
 00009833  00000008	     1C     dd  1 * FONT_X                 ; +1
 00009837  00000084	     1C     dd  22 * FONT_Y                 ; +5
 0000983B  0000001F	     1C     dd  (3 * FONT_X) + FONT_X - 1  ; +9
 0000983F  0000008F	     1C     dd  (23 * FONT_Y) + FONT_Y - 1  ; +13
 00009843  000050ED R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_eflags                        ; +17
 00009847  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_PF>
 00009849  0002		     1C         dw  _EFLAGS_PF                   ; +23
 0000984B  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   1, 23,  3, 24, 60, invDEBI_quick_watch_show_EBP_relative_eflags, _EFLAGS_DF
			     1C ; Used when the mouse is hovering over these coordinates
 0000984E  0A		     1C     db  _HOVER                      ; +0
 0000984F  00000008	     1C     dd  1 * FONT_X                 ; +1
 00009853  0000008A	     1C     dd  23 * FONT_Y                 ; +5
 00009857  0000001F	     1C     dd  (3 * FONT_X) + FONT_X - 1  ; +9
 0000985B  00000095	     1C     dd  (24 * FONT_Y) + FONT_Y - 1  ; +13
 0000985F  000050ED R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_eflags                        ; +17
 00009863  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_DF>
 00009865  000A		     1C         dw  _EFLAGS_DF                   ; +23
 00009867  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   5, 21,  7, 22, 60, invDEBI_quick_watch_show_EBP_relative_eflags, _EFLAGS_OF
			     1C ; Used when the mouse is hovering over these coordinates
 0000986A  0A		     1C     db  _HOVER                      ; +0
 0000986B  00000028	     1C     dd  5 * FONT_X                 ; +1
 0000986F  0000007E	     1C     dd  21 * FONT_Y                 ; +5
 00009873  0000003F	     1C     dd  (7 * FONT_X) + FONT_X - 1  ; +9
 00009877  00000089	     1C     dd  (22 * FONT_Y) + FONT_Y - 1  ; +13
 0000987B  000050ED R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_eflags                        ; +17
 0000987F  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_OF>
 00009881  000B		     1C         dw  _EFLAGS_OF                   ; +23
 00009883  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   5, 22,  7, 23, 60, invDEBI_quick_watch_show_EBP_relative_eflags, _EFLAGS_SF
			     1C ; Used when the mouse is hovering over these coordinates
 00009886  0A		     1C     db  _HOVER                      ; +0
 00009887  00000028	     1C     dd  5 * FONT_X                 ; +1
 0000988B  00000084	     1C     dd  22 * FONT_Y                 ; +5
 0000988F  0000003F	     1C     dd  (7 * FONT_X) + FONT_X - 1  ; +9
 00009893  0000008F	     1C     dd  (23 * FONT_Y) + FONT_Y - 1  ; +13
 00009897  000050ED R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_eflags                        ; +17
 0000989B  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_SF>
 0000989D  0007		     1C         dw  _EFLAGS_SF                   ; +23
 0000989F  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   5, 23,  7, 24, 60, invDEBI_quick_watch_show_EBP_relative_eflags, _EFLAGS_ZF
			     1C ; Used when the mouse is hovering over these coordinates
 000098A2  0A		     1C     db  _HOVER                      ; +0
 000098A3  00000028	     1C     dd  5 * FONT_X                 ; +1
 000098A7  0000008A	     1C     dd  23 * FONT_Y                 ; +5
 000098AB  0000003F	     1C     dd  (7 * FONT_X) + FONT_X - 1  ; +9
 000098AF  00000095	     1C     dd  (24 * FONT_Y) + FONT_Y - 1  ; +13
 000098B3  000050ED R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_eflags                        ; +17
 000098B7  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_ZF>
 000098B9  0006		     1C         dw  _EFLAGS_ZF                   ; +23
 000098BB  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   9, 21, 12, 22, 60, invDEBI_quick_watch_show_EBP_relative_eflags, _EFLAGS_ACF
			     1C ; Used when the mouse is hovering over these coordinates
 000098BE  0A		     1C     db  _HOVER                      ; +0
 000098BF  00000048	     1C     dd  9 * FONT_X                 ; +1
 000098C3  0000007E	     1C     dd  21 * FONT_Y                 ; +5
 000098C7  00000067	     1C     dd  (12 * FONT_X) + FONT_X - 1  ; +9
 000098CB  00000089	     1C     dd  (22 * FONT_Y) + FONT_Y - 1  ; +13
 000098CF  000050ED R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_eflags                        ; +17
 000098D3  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_ACF>
 000098D5  0004		     1C         dw  _EFLAGS_ACF                   ; +23
 000098D7  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  10, 22, 12, 23, 60, invDEBI_quick_watch_show_EBP_relative_eflags, _EFLAGS_IF
			     1C ; Used when the mouse is hovering over these coordinates
 000098DA  0A		     1C     db  _HOVER                      ; +0
 000098DB  00000050	     1C     dd  10 * FONT_X                 ; +1
 000098DF  00000084	     1C     dd  22 * FONT_Y                 ; +5
 000098E3  00000067	     1C     dd  (12 * FONT_X) + FONT_X - 1  ; +9
 000098E7  0000008F	     1C     dd  (23 * FONT_Y) + FONT_Y - 1  ; +13
 000098EB  000050ED R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_eflags                        ; +17
 000098EF  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_IF>
 000098F1  0009		     1C         dw  _EFLAGS_IF                   ; +23
 000098F3  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  10, 23, 12, 24, 60, invDEBI_quick_watch_show_EBP_relative_eflags, _EFLAGS_CF
			     1C ; Used when the mouse is hovering over these coordinates
 000098F6  0A		     1C     db  _HOVER                      ; +0
 000098F7  00000050	     1C     dd  10 * FONT_X                 ; +1
 000098FB  0000008A	     1C     dd  23 * FONT_Y                 ; +5
 000098FF  00000067	     1C     dd  (12 * FONT_X) + FONT_X - 1  ; +9
 00009903  00000095	     1C     dd  (24 * FONT_Y) + FONT_Y - 1  ; +13
 00009907  000050ED R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_eflags                        ; +17
 0000990B  003C		     1C     dw  lowword(offset 60)     ; +21
			     1C     IFNB <_EFLAGS_CF>
 0000990D  0000		     1C         dw  _EFLAGS_CF                   ; +23
 0000990F  00000003 [	     1C         db  3 dup(0ffh)             ; +25
	    FF
	   ]
			     1C     ELSE
			     1C         db  5 dup(0ffh)             ; +23
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @End
 00009912  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
			      C 
			      C                                 ;          11111
			      C                                 ;012345678901234
 00009913 C9 9A CD 81 20      C DEBI_q_window               db  "…öÕÅ FPU.1 ÖÕÕª",0
	   46 50 55 2E 31
	   20 85 CD CD BB
	   00
 00009923  FA FA FA FA FA     C                             db  "˙˙˙˙˙˙˙˙˙˙˙˙˙˙∫",0                                                         ; st0
	   FA FA FA FA FA
	   FA FA FA FA BA
	   00
 00009933  FA FA FA FA FA     C                             db  "˙˙˙˙˙˙˙˙˙˙˙˙˙˙∫",0                                                         ; st1
	   FA FA FA FA FA
	   FA FA FA FA BA
	   00
 00009943  FA FA FA FA FA     C                             db  "˙˙˙˙˙˙˙˙˙˙˙˙˙˙∫",0                                                         ; st2
	   FA FA FA FA FA
	   FA FA FA FA BA
	   00
 00009953  FA FA FA FA FA     C                             db  "˙˙˙˙˙˙˙˙˙˙˙˙˙˙∫",0                                                         ; st3
	   FA FA FA FA FA
	   FA FA FA FA BA
	   00
 00009963  FA FA FA FA FA     C                             db  "˙˙˙˙˙˙˙˙˙˙˙˙˙˙∫",0                                                         ; st4
	   FA FA FA FA FA
	   FA FA FA FA BA
	   00
 00009973  FA FA FA FA FA     C                             db  "˙˙˙˙˙˙˙˙˙˙˙˙˙˙∫",0                                                         ; st5
	   FA FA FA FA FA
	   FA FA FA FA BA
	   00
 00009983  FA FA FA FA FA     C                             db  "˙˙˙˙˙˙˙˙˙˙˙˙˙˙∫",0                                                         ; st6
	   FA FA FA FA FA
	   FA FA FA FA BA
	   00
 00009993  FA FA FA FA FA     C                             db  "˙˙˙˙˙˙˙˙˙˙˙˙˙˙∫",0                                                         ; st7
	   FA FA FA FA FA
	   FA FA FA FA BA
	   00
 000099A3  FF		      C                             db  255
			      C 
 000099A4  0078		      C                             dw  15 * FONT_X
 000099A6  0035		      C                             dw  9  * FONT_Y - 1
 000099A8		      C DEBI_q_screen_objects:
			      C     @DrawWindow             DEBI_q_window
			     1C ; Draws the window for whatever item is specified
 000099A8  FD		     1C     db  _DRAW_WINDOW
 000099A9  00009913 R	     1C     dd  offset DEBI_q_window
			     1C   ; Total = 5
			      C     @ObjectMemSize          108
			     1C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
 000099AD  00		     1C     db  _OBJECT_MEM_SIZE
 000099AE  6C		     1C     db  108
			     1C   ; Total = 2
			      C     @DisplayEBP_relative    _ADJ_FLOAT14,   7, 062h,  0, 1                                                  ; st7
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000099AF  03		     1C     db  _DISPLAY            ; +0
 000099B0  01		     1C     db  _EBP_RELATIVE       ; +1
 000099B1  0C		     1C     db  _ADJ_FLOAT14                ; +2
 000099B2  0007		     1C     dw  7           ; +3
 000099B4  62		     1C     db  062h             ; +5
 000099B5  00000000	     1C     dd  0 * FONT_X          ; +6
 000099B9  00000006	     1C     dd  1 * FONT_Y          ; +10
 000099BD  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT14,   6, 058h,  0, 2                                                  ; st6
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000099BF  03		     1C     db  _DISPLAY            ; +0
 000099C0  01		     1C     db  _EBP_RELATIVE       ; +1
 000099C1  0C		     1C     db  _ADJ_FLOAT14                ; +2
 000099C2  0006		     1C     dw  6           ; +3
 000099C4  58		     1C     db  058h             ; +5
 000099C5  00000000	     1C     dd  0 * FONT_X          ; +6
 000099C9  0000000C	     1C     dd  2 * FONT_Y          ; +10
 000099CD  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT14,   5, 04eh,  0, 3                                                  ; st5
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000099CF  03		     1C     db  _DISPLAY            ; +0
 000099D0  01		     1C     db  _EBP_RELATIVE       ; +1
 000099D1  0C		     1C     db  _ADJ_FLOAT14                ; +2
 000099D2  0005		     1C     dw  5           ; +3
 000099D4  4E		     1C     db  04eh             ; +5
 000099D5  00000000	     1C     dd  0 * FONT_X          ; +6
 000099D9  00000012	     1C     dd  3 * FONT_Y          ; +10
 000099DD  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT14,   4, 044h,  0, 4                                                  ; st4
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000099DF  03		     1C     db  _DISPLAY            ; +0
 000099E0  01		     1C     db  _EBP_RELATIVE       ; +1
 000099E1  0C		     1C     db  _ADJ_FLOAT14                ; +2
 000099E2  0004		     1C     dw  4           ; +3
 000099E4  44		     1C     db  044h             ; +5
 000099E5  00000000	     1C     dd  0 * FONT_X          ; +6
 000099E9  00000018	     1C     dd  4 * FONT_Y          ; +10
 000099ED  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT14,   3, 03ah,  0, 5                                                  ; st3
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000099EF  03		     1C     db  _DISPLAY            ; +0
 000099F0  01		     1C     db  _EBP_RELATIVE       ; +1
 000099F1  0C		     1C     db  _ADJ_FLOAT14                ; +2
 000099F2  0003		     1C     dw  3           ; +3
 000099F4  3A		     1C     db  03ah             ; +5
 000099F5  00000000	     1C     dd  0 * FONT_X          ; +6
 000099F9  0000001E	     1C     dd  5 * FONT_Y          ; +10
 000099FD  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT14,   2, 030h,  0, 6                                                  ; st2
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 000099FF  03		     1C     db  _DISPLAY            ; +0
 00009A00  01		     1C     db  _EBP_RELATIVE       ; +1
 00009A01  0C		     1C     db  _ADJ_FLOAT14                ; +2
 00009A02  0002		     1C     dw  2           ; +3
 00009A04  30		     1C     db  030h             ; +5
 00009A05  00000000	     1C     dd  0 * FONT_X          ; +6
 00009A09  00000024	     1C     dd  6 * FONT_Y          ; +10
 00009A0D  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT14,   1, 026h,  0, 7                                                  ; st1
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009A0F  03		     1C     db  _DISPLAY            ; +0
 00009A10  01		     1C     db  _EBP_RELATIVE       ; +1
 00009A11  0C		     1C     db  _ADJ_FLOAT14                ; +2
 00009A12  0001		     1C     dw  1           ; +3
 00009A14  26		     1C     db  026h             ; +5
 00009A15  00000000	     1C     dd  0 * FONT_X          ; +6
 00009A19  0000002A	     1C     dd  7 * FONT_Y          ; +10
 00009A1D  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT14,   0, 01ch,  0, 8                                                  ; st0
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009A1F  03		     1C     db  _DISPLAY            ; +0
 00009A20  01		     1C     db  _EBP_RELATIVE       ; +1
 00009A21  0C		     1C     db  _ADJ_FLOAT14                ; +2
 00009A22  0000		     1C     dw  0           ; +3
 00009A24  1C		     1C     db  01ch             ; +5
 00009A25  00000000	     1C     dd  0 * FONT_X          ; +6
 00009A29  00000030	     1C     dd  8 * FONT_Y          ; +10
 00009A2D  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @End
 00009A2F  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C ALIGN
 00009A30		      C DEBI_q_mouse_objects:
			      C     @Left_single_click       1,  0,  1,  0, invDEBI_object_close
			     1C ; Used when a left single-click is recognized on these coordinates
 00009A30  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 00009A31  00000008	     1C     dd  1 * FONT_X                 ; +1
 00009A35  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00009A39  0000000F	     1C     dd  (1 * FONT_X) + FONT_X - 1  ; +9
 00009A3D  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00009A41  0000510B R	     1C     dd  invDEBI_object_close                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00009A45  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00009A49  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00009A4B  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      3,  0, 11,  0, invDEBI_fpu_1_right_click
			     1C ; Used when a right single-click is recognized on these coordinates
 00009A4C  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 00009A4D  00000018	     1C     dd  3 * FONT_X                 ; +1
 00009A51  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00009A55  0000005F	     1C     dd  (11 * FONT_X) + FONT_X - 1  ; +9
 00009A59  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00009A5D  000039C0 R	     1C     dd  invDEBI_fpu_1_right_click                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00009A61  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00009A65  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00009A67  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         0,  0, 14,  0, invDEBI_object_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 00009A68  02		     1C     db  _LEFT_DRAG_START            ; +0
 00009A69  00000000	     1C     dd  0 * FONT_X                 ; +1
 00009A6D  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00009A71  00000077	     1C     dd  (14 * FONT_X) + FONT_X - 1  ; +9
 00009A75  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00009A79  00003BE5 R	     1C     dd  invDEBI_object_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00009A7D  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00009A81  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00009A83  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         0,  1, 14,  8, invDEBI_stx_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 00009A84  02		     1C     db  _LEFT_DRAG_START            ; +0
 00009A85  00000000	     1C     dd  0 * FONT_X                 ; +1
 00009A89  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00009A8D  00000077	     1C     dd  (14 * FONT_X) + FONT_X - 1  ; +9
 00009A91  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00009A95  00003CDE R	     1C     dd  invDEBI_stx_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00009A99  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00009A9D  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00009A9F  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_stop          0,  1, 14,  8, invDEBI_stx_drag_stop
			     1C ; Used when a left-drag is stopped if it started in these coordinates
 00009AA0  03		     1C     db  _LEFT_DRAG_STOP             ; +0
 00009AA1  00000000	     1C     dd  0 * FONT_X                 ; +1
 00009AA5  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00009AA9  00000077	     1C     dd  (14 * FONT_X) + FONT_X - 1  ; +9
 00009AAD  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00009AB1  00003D85 R	     1C     dd  invDEBI_stx_drag_stop                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00009AB5  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00009AB9  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00009ABB  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      0,  1, 13,  8, invDEBI_fpu_menu
			     1C ; Used when a right single-click is recognized on these coordinates
 00009ABC  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 00009ABD  00000000	     1C     dd  0 * FONT_X                 ; +1
 00009AC1  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00009AC5  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00009AC9  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00009ACD  00002554 R	     1C     dd  invDEBI_fpu_menu                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00009AD1  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00009AD5  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00009AD7  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Abandon_if_not          0,  1, 13,  8
			     1C ; Used in a lengthy list.  If the coordinates are not within this range then the rest of the lengthy list is not checked
 00009AD8  0C		     1C     db  _ABANDON_IF_NOT             ; +0
 00009AD9  00000000	     1C     dd  0 * FONT_X                 ; +1
 00009ADD  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00009AE1  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00009AE5  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00009AE9  0000000B [	     1C     db  11 dup(0ffh)                ; +17
	    FF
	   ]
			     1C   ; Total = 28
			      C     @Hover                   0,  1, 13,  1, (-200 + 98), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00009AF4  0A		     1C     db  _HOVER                      ; +0
 00009AF5  00000000	     1C     dd  0 * FONT_X                 ; +1
 00009AF9  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00009AFD  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00009B01  0000000B	     1C     dd  (1 * FONT_Y) + FONT_Y - 1  ; +13
 00009B05  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00009B09  FF9A		     1C     dw  lowword(offset (-200 + 98))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009B0B  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   0,  2, 13,  2, (-200 + 88), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00009B10  0A		     1C     db  _HOVER                      ; +0
 00009B11  00000000	     1C     dd  0 * FONT_X                 ; +1
 00009B15  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 00009B19  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00009B1D  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 00009B21  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00009B25  FF90		     1C     dw  lowword(offset (-200 + 88))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009B27  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   0,  3, 13,  3, (-200 + 78), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00009B2C  0A		     1C     db  _HOVER                      ; +0
 00009B2D  00000000	     1C     dd  0 * FONT_X                 ; +1
 00009B31  00000012	     1C     dd  3 * FONT_Y                 ; +5
 00009B35  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00009B39  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 00009B3D  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00009B41  FF86		     1C     dw  lowword(offset (-200 + 78))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009B43  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   0,  4, 13,  4, (-200 + 68), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00009B48  0A		     1C     db  _HOVER                      ; +0
 00009B49  00000000	     1C     dd  0 * FONT_X                 ; +1
 00009B4D  00000018	     1C     dd  4 * FONT_Y                 ; +5
 00009B51  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00009B55  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 00009B59  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00009B5D  FF7C		     1C     dw  lowword(offset (-200 + 68))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009B5F  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   0,  5, 13,  5, (-200 + 58), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00009B64  0A		     1C     db  _HOVER                      ; +0
 00009B65  00000000	     1C     dd  0 * FONT_X                 ; +1
 00009B69  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 00009B6D  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00009B71  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 00009B75  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00009B79  FF72		     1C     dw  lowword(offset (-200 + 58))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009B7B  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   0,  6, 13,  6, (-200 + 48), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00009B80  0A		     1C     db  _HOVER                      ; +0
 00009B81  00000000	     1C     dd  0 * FONT_X                 ; +1
 00009B85  00000024	     1C     dd  6 * FONT_Y                 ; +5
 00009B89  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00009B8D  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 00009B91  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00009B95  FF68		     1C     dw  lowword(offset (-200 + 48))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009B97  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   0,  7, 13,  7, (-200 + 38), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00009B9C  0A		     1C     db  _HOVER                      ; +0
 00009B9D  00000000	     1C     dd  0 * FONT_X                 ; +1
 00009BA1  0000002A	     1C     dd  7 * FONT_Y                 ; +5
 00009BA5  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00009BA9  0000002F	     1C     dd  (7 * FONT_Y) + FONT_Y - 1  ; +13
 00009BAD  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00009BB1  FF5E		     1C     dw  lowword(offset (-200 + 38))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009BB3  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   0,  8, 13,  8, (-200 + 28), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00009BB8  0A		     1C     db  _HOVER                      ; +0
 00009BB9  00000000	     1C     dd  0 * FONT_X                 ; +1
 00009BBD  00000030	     1C     dd  8 * FONT_Y                 ; +5
 00009BC1  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 00009BC5  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00009BC9  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00009BCD  FF54		     1C     dw  lowword(offset (-200 + 28))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009BCF  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @End
 00009BD4  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
			      C 
			      C 
			      C                                 ;          11111111112222222222
			      C                                 ;012345678901234567890123456789
 00009BD5 C9 9A CD 81 20      C DEBI_r_window               db  "…öÕÅ FPU.2 ÖÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª",0
	   46 50 55 2E 32
	   20 85 CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD BB
	   00
 00009BF4  73 74 37 B3 FA     C                             db  "st7≥˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥Ùtag ı∫",0                                        ; st7
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA B3
	   F4 74 61 67 20
	   F5 BA 00
 00009C15  73 74 36 B3 FA     C                             db  "st6≥˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥˙˙˙˙∫",0                                          ; st6
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA B3
	   FA FA FA FA BA
	   00
 00009C34  73 74 35 B3 FA     C                             db  "st5≥˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥Ùctrlı∫",0                                        ; st5
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA B3
	   F4 63 74 72 6C
	   F5 BA 00
 00009C55  73 74 34 B3 FA     C                             db  "st4≥˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥˙˙˙˙∫",0                                          ; st4
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA B3
	   FA FA FA FA BA
	   00
 00009C74  73 74 33 B3 FA     C                             db  "st3≥˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥Ùstatı∫",0                                        ; st3
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA B3
	   F4 73 74 61 74
	   F5 BA 00
 00009C95  73 74 32 B3 FA     C                             db  "st2≥˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥˙˙˙˙∫",0                                          ; st2
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA B3
	   FA FA FA FA BA
	   00
 00009CB4  73 74 31 B3 FA     C                             db  "st1≥˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥Ù op ı∫",0                                        ; st1
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA B3
	   F4 20 6F 70 20
	   F5 BA 00
 00009CD5  73 74 30 B3 FA     C                             db  "st0≥˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙≥˙˙˙˙∫",0                                          ; st0
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA B3
	   FA FA FA FA BA
	   00
 00009CF4  FF		      C                             db  255
			      C 
 00009CF5  00F0		      C                             dw  30 * FONT_X
 00009CF7  0035		      C                             dw  9  * FONT_Y - 1
 00009CF9		      C DEBI_r_screen_objects:
			      C     @DrawWindow             DEBI_r_window
			     1C ; Draws the window for whatever item is specified
 00009CF9  FD		     1C     db  _DRAW_WINDOW
 00009CFA  00009BD5 R	     1C     dd  offset DEBI_r_window
			     1C   ; Total = 5
			      C     @ObjectMemSize          108
			     1C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
 00009CFE  00		     1C     db  _OBJECT_MEM_SIZE
 00009CFF  6C		     1C     db  108
			     1C   ; Total = 2
			      C     @DisplayEBP_relative    _16,            (-200 + 008h), 008h, 25, 2                                      ; lower 16-bits of tw
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009D00  03		     1C     db  _DISPLAY            ; +0
 00009D01  01		     1C     db  _EBP_RELATIVE       ; +1
 00009D02  04		     1C     db  _16                ; +2
 00009D03  FF40		     1C     dw  (-200 + 008h)           ; +3
 00009D05  08		     1C     db  008h             ; +5
 00009D06  000000C8	     1C     dd  25 * FONT_X          ; +6
 00009D0A  0000000C	     1C     dd  2 * FONT_Y          ; +10
 00009D0E  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16,            (-200 + 000h), 000h, 25, 4                                      ; lower 16-bits of cw
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009D10  03		     1C     db  _DISPLAY            ; +0
 00009D11  01		     1C     db  _EBP_RELATIVE       ; +1
 00009D12  04		     1C     db  _16                ; +2
 00009D13  FF38		     1C     dw  (-200 + 000h)           ; +3
 00009D15  00		     1C     db  000h             ; +5
 00009D16  000000C8	     1C     dd  25 * FONT_X          ; +6
 00009D1A  00000018	     1C     dd  4 * FONT_Y          ; +10
 00009D1E  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16,            (-200 + 004h), 004h, 25, 6                                      ; lower 16-bits of sw
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009D20  03		     1C     db  _DISPLAY            ; +0
 00009D21  01		     1C     db  _EBP_RELATIVE       ; +1
 00009D22  04		     1C     db  _16                ; +2
 00009D23  FF3C		     1C     dw  (-200 + 004h)           ; +3
 00009D25  04		     1C     db  004h             ; +5
 00009D26  000000C8	     1C     dd  25 * FONT_X          ; +6
 00009D2A  00000024	     1C     dd  6 * FONT_Y          ; +10
 00009D2E  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _FPU_OPCODE,    (-200 + 012h), 004h, 25, 8                                      ; opcode
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009D30  03		     1C     db  _DISPLAY            ; +0
 00009D31  01		     1C     db  _EBP_RELATIVE       ; +1
 00009D32  0F		     1C     db  _FPU_OPCODE                ; +2
 00009D33  FF4A		     1C     dw  (-200 + 012h)           ; +3
 00009D35  04		     1C     db  004h             ; +5
 00009D36  000000C8	     1C     dd  25 * FONT_X          ; +6
 00009D3A  00000030	     1C     dd  8 * FONT_Y          ; +10
 00009D3E  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT20,               7, 062h,  4, 1                                      ; st7
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009D40  03		     1C     db  _DISPLAY            ; +0
 00009D41  01		     1C     db  _EBP_RELATIVE       ; +1
 00009D42  0D		     1C     db  _ADJ_FLOAT20                ; +2
 00009D43  0007		     1C     dw  7           ; +3
 00009D45  62		     1C     db  062h             ; +5
 00009D46  00000020	     1C     dd  4 * FONT_X          ; +6
 00009D4A  00000006	     1C     dd  1 * FONT_Y          ; +10
 00009D4E  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT20,               6, 058h,  4, 2                                      ; st6
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009D50  03		     1C     db  _DISPLAY            ; +0
 00009D51  01		     1C     db  _EBP_RELATIVE       ; +1
 00009D52  0D		     1C     db  _ADJ_FLOAT20                ; +2
 00009D53  0006		     1C     dw  6           ; +3
 00009D55  58		     1C     db  058h             ; +5
 00009D56  00000020	     1C     dd  4 * FONT_X          ; +6
 00009D5A  0000000C	     1C     dd  2 * FONT_Y          ; +10
 00009D5E  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT20,               5, 04eh,  4, 3                                      ; st5
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009D60  03		     1C     db  _DISPLAY            ; +0
 00009D61  01		     1C     db  _EBP_RELATIVE       ; +1
 00009D62  0D		     1C     db  _ADJ_FLOAT20                ; +2
 00009D63  0005		     1C     dw  5           ; +3
 00009D65  4E		     1C     db  04eh             ; +5
 00009D66  00000020	     1C     dd  4 * FONT_X          ; +6
 00009D6A  00000012	     1C     dd  3 * FONT_Y          ; +10
 00009D6E  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT20,               4, 044h,  4, 4                                      ; st4
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009D70  03		     1C     db  _DISPLAY            ; +0
 00009D71  01		     1C     db  _EBP_RELATIVE       ; +1
 00009D72  0D		     1C     db  _ADJ_FLOAT20                ; +2
 00009D73  0004		     1C     dw  4           ; +3
 00009D75  44		     1C     db  044h             ; +5
 00009D76  00000020	     1C     dd  4 * FONT_X          ; +6
 00009D7A  00000018	     1C     dd  4 * FONT_Y          ; +10
 00009D7E  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT20,               3, 03ah,  4, 5                                      ; st3
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009D80  03		     1C     db  _DISPLAY            ; +0
 00009D81  01		     1C     db  _EBP_RELATIVE       ; +1
 00009D82  0D		     1C     db  _ADJ_FLOAT20                ; +2
 00009D83  0003		     1C     dw  3           ; +3
 00009D85  3A		     1C     db  03ah             ; +5
 00009D86  00000020	     1C     dd  4 * FONT_X          ; +6
 00009D8A  0000001E	     1C     dd  5 * FONT_Y          ; +10
 00009D8E  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT20,               2, 030h,  4, 6                                      ; st2
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009D90  03		     1C     db  _DISPLAY            ; +0
 00009D91  01		     1C     db  _EBP_RELATIVE       ; +1
 00009D92  0D		     1C     db  _ADJ_FLOAT20                ; +2
 00009D93  0002		     1C     dw  2           ; +3
 00009D95  30		     1C     db  030h             ; +5
 00009D96  00000020	     1C     dd  4 * FONT_X          ; +6
 00009D9A  00000024	     1C     dd  6 * FONT_Y          ; +10
 00009D9E  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT20,               1, 026h,  4, 7                                      ; st1
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009DA0  03		     1C     db  _DISPLAY            ; +0
 00009DA1  01		     1C     db  _EBP_RELATIVE       ; +1
 00009DA2  0D		     1C     db  _ADJ_FLOAT20                ; +2
 00009DA3  0001		     1C     dw  1           ; +3
 00009DA5  26		     1C     db  026h             ; +5
 00009DA6  00000020	     1C     dd  4 * FONT_X          ; +6
 00009DAA  0000002A	     1C     dd  7 * FONT_Y          ; +10
 00009DAE  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _ADJ_FLOAT20,               0, 01ch,  4, 8                                      ; st0
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 00009DB0  03		     1C     db  _DISPLAY            ; +0
 00009DB1  01		     1C     db  _EBP_RELATIVE       ; +1
 00009DB2  0D		     1C     db  _ADJ_FLOAT20                ; +2
 00009DB3  0000		     1C     dw  0           ; +3
 00009DB5  1C		     1C     db  01ch             ; +5
 00009DB6  00000020	     1C     dd  4 * FONT_X          ; +6
 00009DBA  00000030	     1C     dd  8 * FONT_Y          ; +10
 00009DBE  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @End
 00009DC0  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C ALIGN
 00009DC1		      C DEBI_r_mouse_objects:
			      C     @Left_single_click       1,  0,  1,  0, invDEBI_object_close
			     1C ; Used when a left single-click is recognized on these coordinates
 00009DC1  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 00009DC2  00000008	     1C     dd  1 * FONT_X                 ; +1
 00009DC6  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00009DCA  0000000F	     1C     dd  (1 * FONT_X) + FONT_X - 1  ; +9
 00009DCE  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00009DD2  0000510B R	     1C     dd  invDEBI_object_close                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00009DD6  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00009DDA  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00009DDC  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      3,  0, 11,  0, invDEBI_fpu_2_right_click
			     1C ; Used when a right single-click is recognized on these coordinates
 00009DDD  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 00009DDE  00000018	     1C     dd  3 * FONT_X                 ; +1
 00009DE2  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00009DE6  0000005F	     1C     dd  (11 * FONT_X) + FONT_X - 1  ; +9
 00009DEA  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00009DEE  000039C0 R	     1C     dd  invDEBI_fpu_2_right_click                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00009DF2  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00009DF6  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00009DF8  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         0,  0, 29,  0, invDEBI_object_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 00009DF9  02		     1C     db  _LEFT_DRAG_START            ; +0
 00009DFA  00000000	     1C     dd  0 * FONT_X                 ; +1
 00009DFE  00000000	     1C     dd  0 * FONT_Y                 ; +5
 00009E02  000000EF	     1C     dd  (29 * FONT_X) + FONT_X - 1  ; +9
 00009E06  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 00009E0A  00003BE5 R	     1C     dd  invDEBI_object_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00009E0E  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00009E12  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00009E14  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         4,  1, 23,  8, invDEBI_stx_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 00009E15  02		     1C     db  _LEFT_DRAG_START            ; +0
 00009E16  00000020	     1C     dd  4 * FONT_X                 ; +1
 00009E1A  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00009E1E  000000BF	     1C     dd  (23 * FONT_X) + FONT_X - 1  ; +9
 00009E22  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00009E26  00003CDE R	     1C     dd  invDEBI_stx_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00009E2A  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00009E2E  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00009E30  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_stop          4,  1, 23,  8, invDEBI_stx_drag_stop
			     1C ; Used when a left-drag is stopped if it started in these coordinates
 00009E31  03		     1C     db  _LEFT_DRAG_STOP             ; +0
 00009E32  00000020	     1C     dd  4 * FONT_X                 ; +1
 00009E36  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00009E3A  000000BF	     1C     dd  (23 * FONT_X) + FONT_X - 1  ; +9
 00009E3E  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00009E42  00003D85 R	     1C     dd  invDEBI_stx_drag_stop                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00009E46  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00009E4A  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00009E4C  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      4,  1, 23,  8, invDEBI_fpu_menu
			     1C ; Used when a right single-click is recognized on these coordinates
 00009E4D  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 00009E4E  00000020	     1C     dd  4 * FONT_X                 ; +1
 00009E52  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00009E56  000000BF	     1C     dd  (23 * FONT_X) + FONT_X - 1  ; +9
 00009E5A  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00009E5E  00002554 R	     1C     dd  invDEBI_fpu_menu                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 00009E62  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 00009E66  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 00009E68  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Abandon_if_not          0,  1, 28,  8
			     1C ; Used in a lengthy list.  If the coordinates are not within this range then the rest of the lengthy list is not checked
 00009E69  0C		     1C     db  _ABANDON_IF_NOT             ; +0
 00009E6A  00000000	     1C     dd  0 * FONT_X                 ; +1
 00009E6E  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00009E72  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 00009E76  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00009E7A  0000000B [	     1C     db  11 dup(0ffh)                ; +17
	    FF
	   ]
			     1C   ; Total = 28
			      C     @Hover                   4,  1, 23,  1, (-200 + 98), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00009E85  0A		     1C     db  _HOVER                      ; +0
 00009E86  00000020	     1C     dd  4 * FONT_X                 ; +1
 00009E8A  00000006	     1C     dd  1 * FONT_Y                 ; +5
 00009E8E  000000BF	     1C     dd  (23 * FONT_X) + FONT_X - 1  ; +9
 00009E92  0000000B	     1C     dd  (1 * FONT_Y) + FONT_Y - 1  ; +13
 00009E96  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00009E9A  FF9A		     1C     dw  lowword(offset (-200 + 98))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009E9C  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   4,  2, 23,  2, (-200 + 88), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00009EA1  0A		     1C     db  _HOVER                      ; +0
 00009EA2  00000020	     1C     dd  4 * FONT_X                 ; +1
 00009EA6  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 00009EAA  000000BF	     1C     dd  (23 * FONT_X) + FONT_X - 1  ; +9
 00009EAE  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 00009EB2  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00009EB6  FF90		     1C     dw  lowword(offset (-200 + 88))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009EB8  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   4,  3, 23,  3, (-200 + 78), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00009EBD  0A		     1C     db  _HOVER                      ; +0
 00009EBE  00000020	     1C     dd  4 * FONT_X                 ; +1
 00009EC2  00000012	     1C     dd  3 * FONT_Y                 ; +5
 00009EC6  000000BF	     1C     dd  (23 * FONT_X) + FONT_X - 1  ; +9
 00009ECA  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 00009ECE  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00009ED2  FF86		     1C     dw  lowword(offset (-200 + 78))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009ED4  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   4,  4, 23,  4, (-200 + 68), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00009ED9  0A		     1C     db  _HOVER                      ; +0
 00009EDA  00000020	     1C     dd  4 * FONT_X                 ; +1
 00009EDE  00000018	     1C     dd  4 * FONT_Y                 ; +5
 00009EE2  000000BF	     1C     dd  (23 * FONT_X) + FONT_X - 1  ; +9
 00009EE6  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 00009EEA  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00009EEE  FF7C		     1C     dw  lowword(offset (-200 + 68))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009EF0  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   4,  5, 23,  5, (-200 + 58), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00009EF5  0A		     1C     db  _HOVER                      ; +0
 00009EF6  00000020	     1C     dd  4 * FONT_X                 ; +1
 00009EFA  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 00009EFE  000000BF	     1C     dd  (23 * FONT_X) + FONT_X - 1  ; +9
 00009F02  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 00009F06  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00009F0A  FF72		     1C     dw  lowword(offset (-200 + 58))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009F0C  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   4,  6, 23,  6, (-200 + 48), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00009F11  0A		     1C     db  _HOVER                      ; +0
 00009F12  00000020	     1C     dd  4 * FONT_X                 ; +1
 00009F16  00000024	     1C     dd  6 * FONT_Y                 ; +5
 00009F1A  000000BF	     1C     dd  (23 * FONT_X) + FONT_X - 1  ; +9
 00009F1E  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 00009F22  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00009F26  FF68		     1C     dw  lowword(offset (-200 + 48))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009F28  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   4,  7, 23,  7, (-200 + 38), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00009F2D  0A		     1C     db  _HOVER                      ; +0
 00009F2E  00000020	     1C     dd  4 * FONT_X                 ; +1
 00009F32  0000002A	     1C     dd  7 * FONT_Y                 ; +5
 00009F36  000000BF	     1C     dd  (23 * FONT_X) + FONT_X - 1  ; +9
 00009F3A  0000002F	     1C     dd  (7 * FONT_Y) + FONT_Y - 1  ; +13
 00009F3E  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00009F42  FF5E		     1C     dw  lowword(offset (-200 + 38))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009F44  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   4,  8, 23,  8, (-200 + 28), invDEBI_quick_watch_show_EBP_relative_80
			     1C ; Used when the mouse is hovering over these coordinates
 00009F49  0A		     1C     db  _HOVER                      ; +0
 00009F4A  00000020	     1C     dd  4 * FONT_X                 ; +1
 00009F4E  00000030	     1C     dd  8 * FONT_Y                 ; +5
 00009F52  000000BF	     1C     dd  (23 * FONT_X) + FONT_X - 1  ; +9
 00009F56  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00009F5A  000050E7 R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_80                        ; +17
 00009F5E  FF54		     1C     dw  lowword(offset (-200 + 28))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009F60  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  25,  2, 28,  2, (-200 + 08), invDEBI_quick_watch_show_fpu_tw
			     1C ; Used when the mouse is hovering over these coordinates
 00009F65  0A		     1C     db  _HOVER                      ; +0
 00009F66  000000C8	     1C     dd  25 * FONT_X                 ; +1
 00009F6A  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 00009F6E  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 00009F72  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 00009F76  0000322B R	     1C     dd  invDEBI_quick_watch_show_fpu_tw                        ; +17
 00009F7A  FF40		     1C     dw  lowword(offset (-200 + 08))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009F7C  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  25,  4, 28,  4, (-200 + 00), invDEBI_quick_watch_show_fpu_cw
			     1C ; Used when the mouse is hovering over these coordinates
 00009F81  0A		     1C     db  _HOVER                      ; +0
 00009F82  000000C8	     1C     dd  25 * FONT_X                 ; +1
 00009F86  00000018	     1C     dd  4 * FONT_Y                 ; +5
 00009F8A  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 00009F8E  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 00009F92  00002FEB R	     1C     dd  invDEBI_quick_watch_show_fpu_cw                        ; +17
 00009F96  FF38		     1C     dw  lowword(offset (-200 + 00))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009F98  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  25,  6, 28,  6, (-200 + 04), invDEBI_quick_watch_show_fpu_sw
			     1C ; Used when the mouse is hovering over these coordinates
 00009F9D  0A		     1C     db  _HOVER                      ; +0
 00009F9E  000000C8	     1C     dd  25 * FONT_X                 ; +1
 00009FA2  00000024	     1C     dd  6 * FONT_Y                 ; +5
 00009FA6  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 00009FAA  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 00009FAE  00003109 R	     1C     dd  invDEBI_quick_watch_show_fpu_sw                        ; +17
 00009FB2  FF3C		     1C     dw  lowword(offset (-200 + 04))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009FB4  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                  25,  8, 28,  8, (-200 + 18), invDEBI_quick_watch_show_fpu_opcode
			     1C ; Used when the mouse is hovering over these coordinates
 00009FB9  0A		     1C     db  _HOVER                      ; +0
 00009FBA  000000C8	     1C     dd  25 * FONT_X                 ; +1
 00009FBE  00000030	     1C     dd  8 * FONT_Y                 ; +5
 00009FC2  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 00009FC6  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 00009FCA  000032AF R	     1C     dd  invDEBI_quick_watch_show_fpu_opcode                        ; +17
 00009FCE  FF4A		     1C     dw  lowword(offset (-200 + 18))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 00009FD0  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @End
 00009FD5  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
			      C 
 00009FD6		      C DEBI_mmx_menu:
			      C     @MenuItem               "emms"
 00009FD6  00		     1C     db  _MENU_ITEM
 00009FD7  04		     1C     db  @SizeStr("emms") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00009FD8  65 6D 6D 73	     1C     db  "emms"
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_emms
 00009FDC  01		     1C     db  _MENU_ITEM_EVENT
 00009FDD  00		     1C     db  _LEFT_SINGLE_CLICK
 00009FDE  00002825 R	     1C     dd  offset invDEBI_mmx_emms
			      C     @MenuItem               "emms/0"
 00009FE2  00		     1C     db  _MENU_ITEM
 00009FE3  06		     1C     db  @SizeStr("emms/0") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00009FE4  65 6D 6D 73 2F    1C     db  "emms/0"
	   30
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_emms_zero
 00009FEA  01		     1C     db  _MENU_ITEM_EVENT
 00009FEB  00		     1C     db  _LEFT_SINGLE_CLICK
 00009FEC  0000283C R	     1C     dd  offset invDEBI_mmx_emms_zero
			      C     @MenuItem               "pnot"
 00009FF0  00		     1C     db  _MENU_ITEM
 00009FF1  04		     1C     db  @SizeStr("pnot") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00009FF2  70 6E 6F 74	     1C     db  "pnot"
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_pnot
 00009FF6  01		     1C     db  _MENU_ITEM_EVENT
 00009FF7  00		     1C     db  _LEFT_SINGLE_CLICK
 00009FF8  0000288D R	     1C     dd  offset invDEBI_mmx_pnot
			      C     @MenuBar
 00009FFC  02		     1C     db  _MENU_BAR
			      C     @MenuItem               "pror mmx,32"
 00009FFD  00		     1C     db  _MENU_ITEM
 00009FFE  0B		     1C     db  @SizeStr("pror mmx,32") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 00009FFF  70 72 6F 72 20    1C     db  "pror mmx,32"
	   6D 6D 78 2C 33
	   32
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_pror_mmx_32
 0000A00A  01		     1C     db  _MENU_ITEM_EVENT
 0000A00B  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A00C  000028A7 R	     1C     dd  offset invDEBI_mmx_pror_mmx_32
			      C     @MenuItem               "pror mmx,16"
 0000A010  00		     1C     db  _MENU_ITEM
 0000A011  0B		     1C     db  @SizeStr("pror mmx,16") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A012  70 72 6F 72 20    1C     db  "pror mmx,16"
	   6D 6D 78 2C 31
	   36
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_pror_mmx_16
 0000A01D  01		     1C     db  _MENU_ITEM_EVENT
 0000A01E  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A01F  000028CA R	     1C     dd  offset invDEBI_mmx_pror_mmx_16
			      C     @MenuItem               "pror mmx,8"
 0000A023  00		     1C     db  _MENU_ITEM
 0000A024  0A		     1C     db  @SizeStr("pror mmx,8") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A025  70 72 6F 72 20    1C     db  "pror mmx,8"
	   6D 6D 78 2C 38
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_pror_mmx_8
 0000A02F  01		     1C     db  _MENU_ITEM_EVENT
 0000A030  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A031  00002909 R	     1C     dd  offset invDEBI_mmx_pror_mmx_8
			      C     @MenuItem               "pror mmx,1"
 0000A035  00		     1C     db  _MENU_ITEM
 0000A036  0A		     1C     db  @SizeStr("pror mmx,1") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A037  70 72 6F 72 20    1C     db  "pror mmx,1"
	   6D 6D 78 2C 31
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_pror_mmx_1
 0000A041  01		     1C     db  _MENU_ITEM_EVENT
 0000A042  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A043  00002968 R	     1C     dd  offset invDEBI_mmx_pror_mmx_1
			      C     @MenuItem               "pshr mmx,1"
 0000A047  00		     1C     db  _MENU_ITEM
 0000A048  0A		     1C     db  @SizeStr("pshr mmx,1") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A049  70 73 68 72 20    1C     db  "pshr mmx,1"
	   6D 6D 78 2C 31
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_pshr_mmx_1
 0000A053  01		     1C     db  _MENU_ITEM_EVENT
 0000A054  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A055  00002988 R	     1C     dd  offset invDEBI_mmx_pshr_mmx_1
			      C     @MenuBar
 0000A059  02		     1C     db  _MENU_BAR
			      C     @MenuItem               "prol mmx,16"
 0000A05A  00		     1C     db  _MENU_ITEM
 0000A05B  0B		     1C     db  @SizeStr("prol mmx,16") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A05C  70 72 6F 6C 20    1C     db  "prol mmx,16"
	   6D 6D 78 2C 31
	   36
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_prol_mmx_16
 0000A067  01		     1C     db  _MENU_ITEM_EVENT
 0000A068  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A069  000029A2 R	     1C     dd  offset invDEBI_mmx_prol_mmx_16
			      C     @MenuItem               "prol mmx,8"
 0000A06D  00		     1C     db  _MENU_ITEM
 0000A06E  0A		     1C     db  @SizeStr("prol mmx,8") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A06F  70 72 6F 6C 20    1C     db  "prol mmx,8"
	   6D 6D 78 2C 38
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_prol_mmx_8
 0000A079  01		     1C     db  _MENU_ITEM_EVENT
 0000A07A  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A07B  000029E1 R	     1C     dd  offset invDEBI_mmx_prol_mmx_8
			      C     @MenuItem               "prol mmx,1"
 0000A07F  00		     1C     db  _MENU_ITEM
 0000A080  0A		     1C     db  @SizeStr("prol mmx,1") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A081  70 72 6F 6C 20    1C     db  "prol mmx,1"
	   6D 6D 78 2C 31
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_prol_mmx_1
 0000A08B  01		     1C     db  _MENU_ITEM_EVENT
 0000A08C  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A08D  00002A40 R	     1C     dd  offset invDEBI_mmx_prol_mmx_1
			      C     @MenuItem               "pshl mmx,1"
 0000A091  00		     1C     db  _MENU_ITEM
 0000A092  0A		     1C     db  @SizeStr("pshl mmx,1") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A093  70 73 68 6C 20    1C     db  "pshl mmx,1"
	   6D 6D 78 2C 31
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_pshl_mmx_1
 0000A09D  01		     1C     db  _MENU_ITEM_EVENT
 0000A09E  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A09F  00002A61 R	     1C     dd  offset invDEBI_mmx_pshl_mmx_1
			      C     @MenuBar
 0000A0A3  02		     1C     db  _MENU_BAR
			      C     @MenuItem               "movq mmx,0000.0000.0000.0000"
 0000A0A4  00		     1C     db  _MENU_ITEM
 0000A0A5  1C		     1C     db  @SizeStr("movq mmx,0000.0000.0000.0000") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A0A6  6D 6F 76 71 20    1C     db  "movq mmx,0000.0000.0000.0000"
	   6D 6D 78 2C 30
	   30 30 30 2E 30
	   30 30 30 2E 30
	   30 30 30 2E 30
	   30 30 30
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_movq_0000_0000_0000_0000
 0000A0C2  01		     1C     db  _MENU_ITEM_EVENT
 0000A0C3  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A0C4  00002AE4 R	     1C     dd  offset invDEBI_mmx_movq_0000_0000_0000_0000
			      C     @MenuItem               "movq mmx,ffff.ffff.ffff.ffff"
 0000A0C8  00		     1C     db  _MENU_ITEM
 0000A0C9  1C		     1C     db  @SizeStr("movq mmx,ffff.ffff.ffff.ffff") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A0CA  6D 6F 76 71 20    1C     db  "movq mmx,ffff.ffff.ffff.ffff"
	   6D 6D 78 2C 66
	   66 66 66 2E 66
	   66 66 66 2E 66
	   66 66 66 2E 66
	   66 66 66
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_movq_ffff_ffff_ffff_ffff
 0000A0E6  01		     1C     db  _MENU_ITEM_EVENT
 0000A0E7  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A0E8  00002A7B R	     1C     dd  offset invDEBI_mmx_movq_ffff_ffff_ffff_ffff
			      C     @MenuItem               "movq mmx,0000.ffff.ffff.ffff"
 0000A0EC  00		     1C     db  _MENU_ITEM
 0000A0ED  1C		     1C     db  @SizeStr("movq mmx,0000.ffff.ffff.ffff") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A0EE  6D 6F 76 71 20    1C     db  "movq mmx,0000.ffff.ffff.ffff"
	   6D 6D 78 2C 30
	   30 30 30 2E 66
	   66 66 66 2E 66
	   66 66 66 2E 66
	   66 66 66
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_movq_0000_ffff_ffff_ffff
 0000A10A  01		     1C     db  _MENU_ITEM_EVENT
 0000A10B  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A10C  00002A8A R	     1C     dd  offset invDEBI_mmx_movq_0000_ffff_ffff_ffff
			      C     @MenuItem               "movq mmx,0000.0000.ffff.ffff"
 0000A110  00		     1C     db  _MENU_ITEM
 0000A111  1C		     1C     db  @SizeStr("movq mmx,0000.0000.ffff.ffff") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A112  6D 6F 76 71 20    1C     db  "movq mmx,0000.0000.ffff.ffff"
	   6D 6D 78 2C 30
	   30 30 30 2E 30
	   30 30 30 2E 66
	   66 66 66 2E 66
	   66 66 66
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_movq_0000_0000_ffff_ffff
 0000A12E  01		     1C     db  _MENU_ITEM_EVENT
 0000A12F  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A130  00002A99 R	     1C     dd  offset invDEBI_mmx_movq_0000_0000_ffff_ffff
			      C     @MenuItem               "movq mmx,0000.0000.0000.ffff"
 0000A134  00		     1C     db  _MENU_ITEM
 0000A135  1C		     1C     db  @SizeStr("movq mmx,0000.0000.0000.ffff") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A136  6D 6F 76 71 20    1C     db  "movq mmx,0000.0000.0000.ffff"
	   6D 6D 78 2C 30
	   30 30 30 2E 30
	   30 30 30 2E 30
	   30 30 30 2E 66
	   66 66 66
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_movq_0000_0000_0000_ffff
 0000A152  01		     1C     db  _MENU_ITEM_EVENT
 0000A153  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A154  00002AA8 R	     1C     dd  offset invDEBI_mmx_movq_0000_0000_0000_ffff
			      C     @MenuItem               "movq mmx,0000.0000.0000.0fff"
 0000A158  00		     1C     db  _MENU_ITEM
 0000A159  1C		     1C     db  @SizeStr("movq mmx,0000.0000.0000.0fff") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A15A  6D 6F 76 71 20    1C     db  "movq mmx,0000.0000.0000.0fff"
	   6D 6D 78 2C 30
	   30 30 30 2E 30
	   30 30 30 2E 30
	   30 30 30 2E 30
	   66 66 66
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_movq_0000_0000_0000_0fff
 0000A176  01		     1C     db  _MENU_ITEM_EVENT
 0000A177  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A178  00002AB7 R	     1C     dd  offset invDEBI_mmx_movq_0000_0000_0000_0fff
			      C     @MenuItem               "movq mmx,0000.0000.0000.00ff"
 0000A17C  00		     1C     db  _MENU_ITEM
 0000A17D  1C		     1C     db  @SizeStr("movq mmx,0000.0000.0000.00ff") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A17E  6D 6F 76 71 20    1C     db  "movq mmx,0000.0000.0000.00ff"
	   6D 6D 78 2C 30
	   30 30 30 2E 30
	   30 30 30 2E 30
	   30 30 30 2E 30
	   30 66 66
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_movq_0000_0000_0000_00ff
 0000A19A  01		     1C     db  _MENU_ITEM_EVENT
 0000A19B  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A19C  00002AC6 R	     1C     dd  offset invDEBI_mmx_movq_0000_0000_0000_00ff
			      C     @MenuItem               "movq mmx,0000.0000.0000.000f"
 0000A1A0  00		     1C     db  _MENU_ITEM
 0000A1A1  1C		     1C     db  @SizeStr("movq mmx,0000.0000.0000.000f") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A1A2  6D 6F 76 71 20    1C     db  "movq mmx,0000.0000.0000.000f"
	   6D 6D 78 2C 30
	   30 30 30 2E 30
	   30 30 30 2E 30
	   30 30 30 2E 30
	   30 30 66
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_movq_0000_0000_0000_000f
 0000A1BE  01		     1C     db  _MENU_ITEM_EVENT
 0000A1BF  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A1C0  00002AD5 R	     1C     dd  offset invDEBI_mmx_movq_0000_0000_0000_000f
			      C     @MenuBar
 0000A1C4  02		     1C     db  _MENU_BAR
			      C     @MenuItem               "* L-pand, R-por, B-pandn"
 0000A1C5  00		     1C     db  _MENU_ITEM
 0000A1C6  18		     1C     db  @SizeStr("* L-pand, R-por, B-pandn") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A1C7  2A 20 4C 2D 70    1C     db  "* L-pand, R-por, B-pandn"
	   61 6E 64 2C 20
	   52 2D 70 6F 72
	   2C 20 42 2D 70
	   61 6E 64 6E
			      C     @MenuItem               "pand/or/andn mmx,ffff.˙˙˙˙.˙˙˙˙.˙˙˙˙"
 0000A1DF  00		     1C     db  _MENU_ITEM
 0000A1E0  24		     1C     db  @SizeStr("pand/or/andn mmx,ffff.˙˙˙˙.˙˙˙˙.˙˙˙˙") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A1E1  70 61 6E 64 2F    1C     db  "pand/or/andn mmx,ffff.˙˙˙˙.˙˙˙˙.˙˙˙˙"
	   6F 72 2F 61 6E
	   64 6E 20 6D 6D
	   78 2C 66 66 66
	   66 2E FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_pand_ffff_0000_0000_0000
 0000A205  01		     1C     db  _MENU_ITEM_EVENT
 0000A206  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A207  00002AF3 R	     1C     dd  offset invDEBI_mmx_pand_ffff_0000_0000_0000
			      C     @MenuItemEvent              _RIGHT_SINGLE_CLICK, invDEBI_mmx_por_ffff_0000_0000_0000
 0000A20B  01		     1C     db  _MENU_ITEM_EVENT
 0000A20C  04		     1C     db  _RIGHT_SINGLE_CLICK
 0000A20D  00002B98 R	     1C     dd  offset invDEBI_mmx_por_ffff_0000_0000_0000
			      C     @MenuItemEvent              _BOTH_SINGLE_CLICK, invDEBI_mmx_pandn_ffff_0000_0000_0000
 0000A211  01		     1C     db  _MENU_ITEM_EVENT
 0000A212  08		     1C     db  _BOTH_SINGLE_CLICK
 0000A213  00002C3D R	     1C     dd  offset invDEBI_mmx_pandn_ffff_0000_0000_0000
			      C     @MenuItem               "pand/or/andn mmx,˙˙˙˙.ffff.˙˙˙˙.˙˙˙˙"
 0000A217  00		     1C     db  _MENU_ITEM
 0000A218  24		     1C     db  @SizeStr("pand/or/andn mmx,˙˙˙˙.ffff.˙˙˙˙.˙˙˙˙") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A219  70 61 6E 64 2F    1C     db  "pand/or/andn mmx,˙˙˙˙.ffff.˙˙˙˙.˙˙˙˙"
	   6F 72 2F 61 6E
	   64 6E 20 6D 6D
	   78 2C FA FA FA
	   FA 2E 66 66 66
	   66 2E FA FA FA
	   FA 2E FA FA FA
	   FA
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_pand_0000_ffff_0000_0000
 0000A23D  01		     1C     db  _MENU_ITEM_EVENT
 0000A23E  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A23F  00002B02 R	     1C     dd  offset invDEBI_mmx_pand_0000_ffff_0000_0000
			      C     @MenuItemEvent              _RIGHT_SINGLE_CLICK, invDEBI_mmx_por_0000_ffff_0000_0000
 0000A243  01		     1C     db  _MENU_ITEM_EVENT
 0000A244  04		     1C     db  _RIGHT_SINGLE_CLICK
 0000A245  00002BA7 R	     1C     dd  offset invDEBI_mmx_por_0000_ffff_0000_0000
			      C     @MenuItemEvent              _BOTH_SINGLE_CLICK, invDEBI_mmx_pandn_0000_ffff_0000_0000
 0000A249  01		     1C     db  _MENU_ITEM_EVENT
 0000A24A  08		     1C     db  _BOTH_SINGLE_CLICK
 0000A24B  00002C4C R	     1C     dd  offset invDEBI_mmx_pandn_0000_ffff_0000_0000
			      C     @MenuItem               "pand/or/andn mmx,˙˙˙˙.˙˙˙˙.ffff.˙˙˙˙"
 0000A24F  00		     1C     db  _MENU_ITEM
 0000A250  24		     1C     db  @SizeStr("pand/or/andn mmx,˙˙˙˙.˙˙˙˙.ffff.˙˙˙˙") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A251  70 61 6E 64 2F    1C     db  "pand/or/andn mmx,˙˙˙˙.˙˙˙˙.ffff.˙˙˙˙"
	   6F 72 2F 61 6E
	   64 6E 20 6D 6D
	   78 2C FA FA FA
	   FA 2E FA FA FA
	   FA 2E 66 66 66
	   66 2E FA FA FA
	   FA
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_pand_0000_0000_ffff_0000
 0000A275  01		     1C     db  _MENU_ITEM_EVENT
 0000A276  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A277  00002B11 R	     1C     dd  offset invDEBI_mmx_pand_0000_0000_ffff_0000
			      C     @MenuItemEvent              _RIGHT_SINGLE_CLICK, invDEBI_mmx_por_0000_0000_ffff_0000
 0000A27B  01		     1C     db  _MENU_ITEM_EVENT
 0000A27C  04		     1C     db  _RIGHT_SINGLE_CLICK
 0000A27D  00002BB6 R	     1C     dd  offset invDEBI_mmx_por_0000_0000_ffff_0000
			      C     @MenuItemEvent              _BOTH_SINGLE_CLICK, invDEBI_mmx_pandn_0000_0000_ffff_0000
 0000A281  01		     1C     db  _MENU_ITEM_EVENT
 0000A282  08		     1C     db  _BOTH_SINGLE_CLICK
 0000A283  00002C5B R	     1C     dd  offset invDEBI_mmx_pandn_0000_0000_ffff_0000
			      C     @MenuItem               "pand/or/andn mmx,˙˙˙˙.˙˙˙˙.˙˙˙˙.ffff"
 0000A287  00		     1C     db  _MENU_ITEM
 0000A288  24		     1C     db  @SizeStr("pand/or/andn mmx,˙˙˙˙.˙˙˙˙.˙˙˙˙.ffff") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A289  70 61 6E 64 2F    1C     db  "pand/or/andn mmx,˙˙˙˙.˙˙˙˙.˙˙˙˙.ffff"
	   6F 72 2F 61 6E
	   64 6E 20 6D 6D
	   78 2C FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA 2E 66 66 66
	   66
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_pand_0000_0000_0000_ffff
 0000A2AD  01		     1C     db  _MENU_ITEM_EVENT
 0000A2AE  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A2AF  00002B20 R	     1C     dd  offset invDEBI_mmx_pand_0000_0000_0000_ffff
			      C     @MenuItemEvent              _RIGHT_SINGLE_CLICK, invDEBI_mmx_por_0000_0000_0000_ffff
 0000A2B3  01		     1C     db  _MENU_ITEM_EVENT
 0000A2B4  04		     1C     db  _RIGHT_SINGLE_CLICK
 0000A2B5  00002BC5 R	     1C     dd  offset invDEBI_mmx_por_0000_0000_0000_ffff
			      C     @MenuItemEvent              _BOTH_SINGLE_CLICK, invDEBI_mmx_pandn_0000_0000_0000_ffff
 0000A2B9  01		     1C     db  _MENU_ITEM_EVENT
 0000A2BA  08		     1C     db  _BOTH_SINGLE_CLICK
 0000A2BB  00002C6A R	     1C     dd  offset invDEBI_mmx_pandn_0000_0000_0000_ffff
			      C     @MenuItem               "pand/or/andn mmx,˙˙˙˙.˙˙˙˙.˙˙˙˙.˙fff"
 0000A2BF  00		     1C     db  _MENU_ITEM
 0000A2C0  24		     1C     db  @SizeStr("pand/or/andn mmx,˙˙˙˙.˙˙˙˙.˙˙˙˙.˙fff") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A2C1  70 61 6E 64 2F    1C     db  "pand/or/andn mmx,˙˙˙˙.˙˙˙˙.˙˙˙˙.˙fff"
	   6F 72 2F 61 6E
	   64 6E 20 6D 6D
	   78 2C FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA 66 66
	   66
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_pand_0000_0000_0000_0fff
 0000A2E5  01		     1C     db  _MENU_ITEM_EVENT
 0000A2E6  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A2E7  00002B2F R	     1C     dd  offset invDEBI_mmx_pand_0000_0000_0000_0fff
			      C     @MenuItemEvent              _RIGHT_SINGLE_CLICK, invDEBI_mmx_por_0000_0000_0000_0fff
 0000A2EB  01		     1C     db  _MENU_ITEM_EVENT
 0000A2EC  04		     1C     db  _RIGHT_SINGLE_CLICK
 0000A2ED  00002BD4 R	     1C     dd  offset invDEBI_mmx_por_0000_0000_0000_0fff
			      C     @MenuItemEvent              _BOTH_SINGLE_CLICK, invDEBI_mmx_pandn_0000_0000_0000_0fff
 0000A2F1  01		     1C     db  _MENU_ITEM_EVENT
 0000A2F2  08		     1C     db  _BOTH_SINGLE_CLICK
 0000A2F3  00002C79 R	     1C     dd  offset invDEBI_mmx_pandn_0000_0000_0000_0fff
			      C     @MenuItem               "pand/or/andn mmx,˙˙˙˙.˙˙˙˙.˙˙˙˙.˙˙ff"
 0000A2F7  00		     1C     db  _MENU_ITEM
 0000A2F8  24		     1C     db  @SizeStr("pand/or/andn mmx,˙˙˙˙.˙˙˙˙.˙˙˙˙.˙˙ff") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A2F9  70 61 6E 64 2F    1C     db  "pand/or/andn mmx,˙˙˙˙.˙˙˙˙.˙˙˙˙.˙˙ff"
	   6F 72 2F 61 6E
	   64 6E 20 6D 6D
	   78 2C FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA 66
	   66
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_pand_0000_0000_0000_00ff
 0000A31D  01		     1C     db  _MENU_ITEM_EVENT
 0000A31E  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A31F  00002B3E R	     1C     dd  offset invDEBI_mmx_pand_0000_0000_0000_00ff
			      C     @MenuItemEvent              _RIGHT_SINGLE_CLICK, invDEBI_mmx_por_0000_0000_0000_00ff
 0000A323  01		     1C     db  _MENU_ITEM_EVENT
 0000A324  04		     1C     db  _RIGHT_SINGLE_CLICK
 0000A325  00002BE3 R	     1C     dd  offset invDEBI_mmx_por_0000_0000_0000_00ff
			      C     @MenuItemEvent              _BOTH_SINGLE_CLICK, invDEBI_mmx_pandn_0000_0000_0000_00ff
 0000A329  01		     1C     db  _MENU_ITEM_EVENT
 0000A32A  08		     1C     db  _BOTH_SINGLE_CLICK
 0000A32B  00002C88 R	     1C     dd  offset invDEBI_mmx_pandn_0000_0000_0000_00ff
			      C     @MenuItem               "pand/or/andn mmx,˙˙˙˙.˙˙˙˙.˙˙˙˙.˙˙˙f"
 0000A32F  00		     1C     db  _MENU_ITEM
 0000A330  24		     1C     db  @SizeStr("pand/or/andn mmx,˙˙˙˙.˙˙˙˙.˙˙˙˙.˙˙˙f") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A331  70 61 6E 64 2F    1C     db  "pand/or/andn mmx,˙˙˙˙.˙˙˙˙.˙˙˙˙.˙˙˙f"
	   6F 72 2F 61 6E
	   64 6E 20 6D 6D
	   78 2C FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   66
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_pand_0000_0000_0000_000f
 0000A355  01		     1C     db  _MENU_ITEM_EVENT
 0000A356  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A357  00002B4D R	     1C     dd  offset invDEBI_mmx_pand_0000_0000_0000_000f
			      C     @MenuItemEvent              _RIGHT_SINGLE_CLICK, invDEBI_mmx_por_0000_0000_0000_000f
 0000A35B  01		     1C     db  _MENU_ITEM_EVENT
 0000A35C  04		     1C     db  _RIGHT_SINGLE_CLICK
 0000A35D  00002BF2 R	     1C     dd  offset invDEBI_mmx_por_0000_0000_0000_000f
			      C     @MenuItemEvent              _BOTH_SINGLE_CLICK, invDEBI_mmx_pandn_0000_0000_0000_000f
 0000A361  01		     1C     db  _MENU_ITEM_EVENT
 0000A362  08		     1C     db  _BOTH_SINGLE_CLICK
 0000A363  00002C97 R	     1C     dd  offset invDEBI_mmx_pandn_0000_0000_0000_000f
			      C     @MenuItem               "pand/or/andn mmx,ffff.ffff.˙˙˙˙.˙˙˙˙"
 0000A367  00		     1C     db  _MENU_ITEM
 0000A368  24		     1C     db  @SizeStr("pand/or/andn mmx,ffff.ffff.˙˙˙˙.˙˙˙˙") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A369  70 61 6E 64 2F    1C     db  "pand/or/andn mmx,ffff.ffff.˙˙˙˙.˙˙˙˙"
	   6F 72 2F 61 6E
	   64 6E 20 6D 6D
	   78 2C 66 66 66
	   66 2E 66 66 66
	   66 2E FA FA FA
	   FA 2E FA FA FA
	   FA
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_pand_ffff_ffff_0000_0000
 0000A38D  01		     1C     db  _MENU_ITEM_EVENT
 0000A38E  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A38F  00002B5C R	     1C     dd  offset invDEBI_mmx_pand_ffff_ffff_0000_0000
			      C     @MenuItemEvent              _RIGHT_SINGLE_CLICK, invDEBI_mmx_por_ffff_ffff_0000_0000
 0000A393  01		     1C     db  _MENU_ITEM_EVENT
 0000A394  04		     1C     db  _RIGHT_SINGLE_CLICK
 0000A395  00002C01 R	     1C     dd  offset invDEBI_mmx_por_ffff_ffff_0000_0000
			      C     @MenuItemEvent              _BOTH_SINGLE_CLICK, invDEBI_mmx_pandn_ffff_ffff_0000_0000
 0000A399  01		     1C     db  _MENU_ITEM_EVENT
 0000A39A  08		     1C     db  _BOTH_SINGLE_CLICK
 0000A39B  00002CA6 R	     1C     dd  offset invDEBI_mmx_pandn_ffff_ffff_0000_0000
			      C     @MenuItem               "pand/or/andn mmx,˙˙˙˙.˙˙˙˙.ffff.ffff"
 0000A39F  00		     1C     db  _MENU_ITEM
 0000A3A0  24		     1C     db  @SizeStr("pand/or/andn mmx,˙˙˙˙.˙˙˙˙.ffff.ffff") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A3A1  70 61 6E 64 2F    1C     db  "pand/or/andn mmx,˙˙˙˙.˙˙˙˙.ffff.ffff"
	   6F 72 2F 61 6E
	   64 6E 20 6D 6D
	   78 2C FA FA FA
	   FA 2E FA FA FA
	   FA 2E 66 66 66
	   66 2E 66 66 66
	   66
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_pand_0000_0000_ffff_ffff
 0000A3C5  01		     1C     db  _MENU_ITEM_EVENT
 0000A3C6  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A3C7  00002B6B R	     1C     dd  offset invDEBI_mmx_pand_0000_0000_ffff_ffff
			      C     @MenuItemEvent              _RIGHT_SINGLE_CLICK, invDEBI_mmx_por_0000_0000_ffff_ffff
 0000A3CB  01		     1C     db  _MENU_ITEM_EVENT
 0000A3CC  04		     1C     db  _RIGHT_SINGLE_CLICK
 0000A3CD  00002C10 R	     1C     dd  offset invDEBI_mmx_por_0000_0000_ffff_ffff
			      C     @MenuItemEvent              _BOTH_SINGLE_CLICK, invDEBI_mmx_pandn_0000_0000_ffff_ffff
 0000A3D1  01		     1C     db  _MENU_ITEM_EVENT
 0000A3D2  08		     1C     db  _BOTH_SINGLE_CLICK
 0000A3D3  00002CB5 R	     1C     dd  offset invDEBI_mmx_pandn_0000_0000_ffff_ffff
			      C     @MenuItem               "pand/or/andn mmx,ffff.˙˙˙˙.ffff.˙˙˙˙"
 0000A3D7  00		     1C     db  _MENU_ITEM
 0000A3D8  24		     1C     db  @SizeStr("pand/or/andn mmx,ffff.˙˙˙˙.ffff.˙˙˙˙") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A3D9  70 61 6E 64 2F    1C     db  "pand/or/andn mmx,ffff.˙˙˙˙.ffff.˙˙˙˙"
	   6F 72 2F 61 6E
	   64 6E 20 6D 6D
	   78 2C 66 66 66
	   66 2E FA FA FA
	   FA 2E 66 66 66
	   66 2E FA FA FA
	   FA
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_pand_ffff_0000_ffff_0000
 0000A3FD  01		     1C     db  _MENU_ITEM_EVENT
 0000A3FE  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A3FF  00002B7A R	     1C     dd  offset invDEBI_mmx_pand_ffff_0000_ffff_0000
			      C     @MenuItemEvent              _RIGHT_SINGLE_CLICK, invDEBI_mmx_por_ffff_0000_ffff_0000
 0000A403  01		     1C     db  _MENU_ITEM_EVENT
 0000A404  04		     1C     db  _RIGHT_SINGLE_CLICK
 0000A405  00002C1F R	     1C     dd  offset invDEBI_mmx_por_ffff_0000_ffff_0000
			      C     @MenuItemEvent              _BOTH_SINGLE_CLICK, invDEBI_mmx_pandn_ffff_0000_ffff_0000
 0000A409  01		     1C     db  _MENU_ITEM_EVENT
 0000A40A  08		     1C     db  _BOTH_SINGLE_CLICK
 0000A40B  00002CC4 R	     1C     dd  offset invDEBI_mmx_pandn_ffff_0000_ffff_0000
			      C     @MenuItem               "pand/or/andn mmx,˙˙˙˙.ffff.˙˙˙˙.ffff"
 0000A40F  00		     1C     db  _MENU_ITEM
 0000A410  24		     1C     db  @SizeStr("pand/or/andn mmx,˙˙˙˙.ffff.˙˙˙˙.ffff") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A411  70 61 6E 64 2F    1C     db  "pand/or/andn mmx,˙˙˙˙.ffff.˙˙˙˙.ffff"
	   6F 72 2F 61 6E
	   64 6E 20 6D 6D
	   78 2C FA FA FA
	   FA 2E 66 66 66
	   66 2E FA FA FA
	   FA 2E 66 66 66
	   66
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_mmx_pand_0000_ffff_0000_ffff
 0000A435  01		     1C     db  _MENU_ITEM_EVENT
 0000A436  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A437  00002B89 R	     1C     dd  offset invDEBI_mmx_pand_0000_ffff_0000_ffff
			      C     @MenuItemEvent              _RIGHT_SINGLE_CLICK, invDEBI_mmx_por_0000_ffff_0000_ffff
 0000A43B  01		     1C     db  _MENU_ITEM_EVENT
 0000A43C  04		     1C     db  _RIGHT_SINGLE_CLICK
 0000A43D  00002C2E R	     1C     dd  offset invDEBI_mmx_por_0000_ffff_0000_ffff
			      C     @MenuItemEvent              _BOTH_SINGLE_CLICK, invDEBI_mmx_pandn_0000_ffff_0000_ffff
 0000A441  01		     1C     db  _MENU_ITEM_EVENT
 0000A442  08		     1C     db  _BOTH_SINGLE_CLICK
 0000A443  00002CD0 R	     1C     dd  offset invDEBI_mmx_pandn_0000_ffff_0000_ffff
			      C     @End
 0000A447  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C                                 ;          11111111112222222222
			      C                                 ;012345678901234567890123456789
 0000A448 C9 9A CD 81 20      C DEBI_s_window               db  "…öÕÅ MMX ÖÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª",0
	   4D 4D 58 20 85
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD BB
	   00
 0000A467  20 20 20 6D 6D     C                             db  "   mm0 ˙˙˙˙.˙˙˙˙.˙˙˙˙.˙˙˙˙   ∫",0
	   30 20 FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA 20 20 20 BA
	   00
 0000A486  20 20 20 6D 6D     C                             db  "   mm1 ˙˙˙˙.˙˙˙˙.˙˙˙˙.˙˙˙˙   ∫",0
	   31 20 FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA 20 20 20 BA
	   00
 0000A4A5  20 20 20 6D 6D     C                             db  "   mm2 ˙˙˙˙.˙˙˙˙.˙˙˙˙.˙˙˙˙   ∫",0
	   32 20 FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA 20 20 20 BA
	   00
 0000A4C4  20 20 20 6D 6D     C                             db  "   mm3 ˙˙˙˙.˙˙˙˙.˙˙˙˙.˙˙˙˙   ∫",0
	   33 20 FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA 20 20 20 BA
	   00
 0000A4E3  20 20 20 6D 6D     C                             db  "   mm4 ˙˙˙˙.˙˙˙˙.˙˙˙˙.˙˙˙˙   ∫",0
	   34 20 FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA 20 20 20 BA
	   00
 0000A502  20 20 20 6D 6D     C                             db  "   mm5 ˙˙˙˙.˙˙˙˙.˙˙˙˙.˙˙˙˙   ∫",0
	   35 20 FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA 20 20 20 BA
	   00
 0000A521  20 20 20 6D 6D     C                             db  "   mm6 ˙˙˙˙.˙˙˙˙.˙˙˙˙.˙˙˙˙   ∫",0
	   36 20 FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA 20 20 20 BA
	   00
 0000A540  20 20 20 6D 6D     C                             db  "   mm7 ˙˙˙˙.˙˙˙˙.˙˙˙˙.˙˙˙˙   ∫",0
	   37 20 FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA 2E FA FA FA
	   FA 20 20 20 BA
	   00
 0000A55F  FF		      C                             db  255
			      C 
 0000A560  00F0		      C                             dw  30 * FONT_X
 0000A562  0035		      C                             dw  9  * FONT_Y - 1
 0000A564		      C DEBI_s_screen_objects:
			      C     @DrawWindow             DEBI_s_window
			     1C ; Draws the window for whatever item is specified
 0000A564  FD		     1C     db  _DRAW_WINDOW
 0000A565  0000A448 R	     1C     dd  offset DEBI_s_window
			     1C   ; Total = 5
			      C     @ObjectMemSize          108
			     1C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
 0000A569  00		     1C     db  _OBJECT_MEM_SIZE
 0000A56A  6C		     1C     db  108
			     1C   ; Total = 2
			      C     @DisplayEBP_relative    _16, (-200 + 28), 28,  22, 1                                                ; mm0
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A56B  03		     1C     db  _DISPLAY            ; +0
 0000A56C  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A56D  04		     1C     db  _16                ; +2
 0000A56E  FF54		     1C     dw  (-200 + 28)           ; +3
 0000A570  1C		     1C     db  28             ; +5
 0000A571  000000B0	     1C     dd  22 * FONT_X          ; +6
 0000A575  00000006	     1C     dd  1 * FONT_Y          ; +10
 0000A579  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 30), 30,  17, 1
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A57B  03		     1C     db  _DISPLAY            ; +0
 0000A57C  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A57D  04		     1C     db  _16                ; +2
 0000A57E  FF56		     1C     dw  (-200 + 30)           ; +3
 0000A580  1E		     1C     db  30             ; +5
 0000A581  00000088	     1C     dd  17 * FONT_X          ; +6
 0000A585  00000006	     1C     dd  1 * FONT_Y          ; +10
 0000A589  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 32), 32,  12, 1
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A58B  03		     1C     db  _DISPLAY            ; +0
 0000A58C  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A58D  04		     1C     db  _16                ; +2
 0000A58E  FF58		     1C     dw  (-200 + 32)           ; +3
 0000A590  20		     1C     db  32             ; +5
 0000A591  00000060	     1C     dd  12 * FONT_X          ; +6
 0000A595  00000006	     1C     dd  1 * FONT_Y          ; +10
 0000A599  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 34), 34,  7,  1
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A59B  03		     1C     db  _DISPLAY            ; +0
 0000A59C  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A59D  04		     1C     db  _16                ; +2
 0000A59E  FF5A		     1C     dw  (-200 + 34)           ; +3
 0000A5A0  22		     1C     db  34             ; +5
 0000A5A1  00000038	     1C     dd  7 * FONT_X          ; +6
 0000A5A5  00000006	     1C     dd  1 * FONT_Y          ; +10
 0000A5A9  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _16, (-200 + 38), 38,  22, 2                                                ; mm1
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A5AB  03		     1C     db  _DISPLAY            ; +0
 0000A5AC  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A5AD  04		     1C     db  _16                ; +2
 0000A5AE  FF5E		     1C     dw  (-200 + 38)           ; +3
 0000A5B0  26		     1C     db  38             ; +5
 0000A5B1  000000B0	     1C     dd  22 * FONT_X          ; +6
 0000A5B5  0000000C	     1C     dd  2 * FONT_Y          ; +10
 0000A5B9  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 40), 40,  17, 2
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A5BB  03		     1C     db  _DISPLAY            ; +0
 0000A5BC  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A5BD  04		     1C     db  _16                ; +2
 0000A5BE  FF60		     1C     dw  (-200 + 40)           ; +3
 0000A5C0  28		     1C     db  40             ; +5
 0000A5C1  00000088	     1C     dd  17 * FONT_X          ; +6
 0000A5C5  0000000C	     1C     dd  2 * FONT_Y          ; +10
 0000A5C9  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 42), 42,  12, 2
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A5CB  03		     1C     db  _DISPLAY            ; +0
 0000A5CC  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A5CD  04		     1C     db  _16                ; +2
 0000A5CE  FF62		     1C     dw  (-200 + 42)           ; +3
 0000A5D0  2A		     1C     db  42             ; +5
 0000A5D1  00000060	     1C     dd  12 * FONT_X          ; +6
 0000A5D5  0000000C	     1C     dd  2 * FONT_Y          ; +10
 0000A5D9  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 44), 44,  7,  2
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A5DB  03		     1C     db  _DISPLAY            ; +0
 0000A5DC  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A5DD  04		     1C     db  _16                ; +2
 0000A5DE  FF64		     1C     dw  (-200 + 44)           ; +3
 0000A5E0  2C		     1C     db  44             ; +5
 0000A5E1  00000038	     1C     dd  7 * FONT_X          ; +6
 0000A5E5  0000000C	     1C     dd  2 * FONT_Y          ; +10
 0000A5E9  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _16, (-200 + 48), 48,  22, 3                                                ; mm2
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A5EB  03		     1C     db  _DISPLAY            ; +0
 0000A5EC  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A5ED  04		     1C     db  _16                ; +2
 0000A5EE  FF68		     1C     dw  (-200 + 48)           ; +3
 0000A5F0  30		     1C     db  48             ; +5
 0000A5F1  000000B0	     1C     dd  22 * FONT_X          ; +6
 0000A5F5  00000012	     1C     dd  3 * FONT_Y          ; +10
 0000A5F9  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 50), 50,  17, 3
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A5FB  03		     1C     db  _DISPLAY            ; +0
 0000A5FC  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A5FD  04		     1C     db  _16                ; +2
 0000A5FE  FF6A		     1C     dw  (-200 + 50)           ; +3
 0000A600  32		     1C     db  50             ; +5
 0000A601  00000088	     1C     dd  17 * FONT_X          ; +6
 0000A605  00000012	     1C     dd  3 * FONT_Y          ; +10
 0000A609  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 52), 52,  12, 3
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A60B  03		     1C     db  _DISPLAY            ; +0
 0000A60C  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A60D  04		     1C     db  _16                ; +2
 0000A60E  FF6C		     1C     dw  (-200 + 52)           ; +3
 0000A610  34		     1C     db  52             ; +5
 0000A611  00000060	     1C     dd  12 * FONT_X          ; +6
 0000A615  00000012	     1C     dd  3 * FONT_Y          ; +10
 0000A619  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 54), 54,  7,  3
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A61B  03		     1C     db  _DISPLAY            ; +0
 0000A61C  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A61D  04		     1C     db  _16                ; +2
 0000A61E  FF6E		     1C     dw  (-200 + 54)           ; +3
 0000A620  36		     1C     db  54             ; +5
 0000A621  00000038	     1C     dd  7 * FONT_X          ; +6
 0000A625  00000012	     1C     dd  3 * FONT_Y          ; +10
 0000A629  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _16, (-200 + 58), 58,  22, 4                                                ; mm3
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A62B  03		     1C     db  _DISPLAY            ; +0
 0000A62C  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A62D  04		     1C     db  _16                ; +2
 0000A62E  FF72		     1C     dw  (-200 + 58)           ; +3
 0000A630  3A		     1C     db  58             ; +5
 0000A631  000000B0	     1C     dd  22 * FONT_X          ; +6
 0000A635  00000018	     1C     dd  4 * FONT_Y          ; +10
 0000A639  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 60), 60,  17, 4
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A63B  03		     1C     db  _DISPLAY            ; +0
 0000A63C  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A63D  04		     1C     db  _16                ; +2
 0000A63E  FF74		     1C     dw  (-200 + 60)           ; +3
 0000A640  3C		     1C     db  60             ; +5
 0000A641  00000088	     1C     dd  17 * FONT_X          ; +6
 0000A645  00000018	     1C     dd  4 * FONT_Y          ; +10
 0000A649  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 62), 62,  12, 4
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A64B  03		     1C     db  _DISPLAY            ; +0
 0000A64C  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A64D  04		     1C     db  _16                ; +2
 0000A64E  FF76		     1C     dw  (-200 + 62)           ; +3
 0000A650  3E		     1C     db  62             ; +5
 0000A651  00000060	     1C     dd  12 * FONT_X          ; +6
 0000A655  00000018	     1C     dd  4 * FONT_Y          ; +10
 0000A659  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 64), 64,  7,  4
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A65B  03		     1C     db  _DISPLAY            ; +0
 0000A65C  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A65D  04		     1C     db  _16                ; +2
 0000A65E  FF78		     1C     dw  (-200 + 64)           ; +3
 0000A660  40		     1C     db  64             ; +5
 0000A661  00000038	     1C     dd  7 * FONT_X          ; +6
 0000A665  00000018	     1C     dd  4 * FONT_Y          ; +10
 0000A669  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _16, (-200 + 68), 68,  22, 5                                                ; mm4
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A66B  03		     1C     db  _DISPLAY            ; +0
 0000A66C  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A66D  04		     1C     db  _16                ; +2
 0000A66E  FF7C		     1C     dw  (-200 + 68)           ; +3
 0000A670  44		     1C     db  68             ; +5
 0000A671  000000B0	     1C     dd  22 * FONT_X          ; +6
 0000A675  0000001E	     1C     dd  5 * FONT_Y          ; +10
 0000A679  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 70), 70,  17, 5
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A67B  03		     1C     db  _DISPLAY            ; +0
 0000A67C  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A67D  04		     1C     db  _16                ; +2
 0000A67E  FF7E		     1C     dw  (-200 + 70)           ; +3
 0000A680  46		     1C     db  70             ; +5
 0000A681  00000088	     1C     dd  17 * FONT_X          ; +6
 0000A685  0000001E	     1C     dd  5 * FONT_Y          ; +10
 0000A689  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 72), 72,  12, 5
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A68B  03		     1C     db  _DISPLAY            ; +0
 0000A68C  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A68D  04		     1C     db  _16                ; +2
 0000A68E  FF80		     1C     dw  (-200 + 72)           ; +3
 0000A690  48		     1C     db  72             ; +5
 0000A691  00000060	     1C     dd  12 * FONT_X          ; +6
 0000A695  0000001E	     1C     dd  5 * FONT_Y          ; +10
 0000A699  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 74), 74,  7,  5
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A69B  03		     1C     db  _DISPLAY            ; +0
 0000A69C  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A69D  04		     1C     db  _16                ; +2
 0000A69E  FF82		     1C     dw  (-200 + 74)           ; +3
 0000A6A0  4A		     1C     db  74             ; +5
 0000A6A1  00000038	     1C     dd  7 * FONT_X          ; +6
 0000A6A5  0000001E	     1C     dd  5 * FONT_Y          ; +10
 0000A6A9  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _16, (-200 + 78), 78,  22, 6                                                ; mm5
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A6AB  03		     1C     db  _DISPLAY            ; +0
 0000A6AC  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A6AD  04		     1C     db  _16                ; +2
 0000A6AE  FF86		     1C     dw  (-200 + 78)           ; +3
 0000A6B0  4E		     1C     db  78             ; +5
 0000A6B1  000000B0	     1C     dd  22 * FONT_X          ; +6
 0000A6B5  00000024	     1C     dd  6 * FONT_Y          ; +10
 0000A6B9  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 80), 80,  17, 6
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A6BB  03		     1C     db  _DISPLAY            ; +0
 0000A6BC  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A6BD  04		     1C     db  _16                ; +2
 0000A6BE  FF88		     1C     dw  (-200 + 80)           ; +3
 0000A6C0  50		     1C     db  80             ; +5
 0000A6C1  00000088	     1C     dd  17 * FONT_X          ; +6
 0000A6C5  00000024	     1C     dd  6 * FONT_Y          ; +10
 0000A6C9  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 82), 82,  12, 6
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A6CB  03		     1C     db  _DISPLAY            ; +0
 0000A6CC  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A6CD  04		     1C     db  _16                ; +2
 0000A6CE  FF8A		     1C     dw  (-200 + 82)           ; +3
 0000A6D0  52		     1C     db  82             ; +5
 0000A6D1  00000060	     1C     dd  12 * FONT_X          ; +6
 0000A6D5  00000024	     1C     dd  6 * FONT_Y          ; +10
 0000A6D9  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 84), 84,  7,  6
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A6DB  03		     1C     db  _DISPLAY            ; +0
 0000A6DC  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A6DD  04		     1C     db  _16                ; +2
 0000A6DE  FF8C		     1C     dw  (-200 + 84)           ; +3
 0000A6E0  54		     1C     db  84             ; +5
 0000A6E1  00000038	     1C     dd  7 * FONT_X          ; +6
 0000A6E5  00000024	     1C     dd  6 * FONT_Y          ; +10
 0000A6E9  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _16, (-200 + 88), 88,  22, 7                                                ; mm6
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A6EB  03		     1C     db  _DISPLAY            ; +0
 0000A6EC  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A6ED  04		     1C     db  _16                ; +2
 0000A6EE  FF90		     1C     dw  (-200 + 88)           ; +3
 0000A6F0  58		     1C     db  88             ; +5
 0000A6F1  000000B0	     1C     dd  22 * FONT_X          ; +6
 0000A6F5  0000002A	     1C     dd  7 * FONT_Y          ; +10
 0000A6F9  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 90), 90,  17, 7
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A6FB  03		     1C     db  _DISPLAY            ; +0
 0000A6FC  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A6FD  04		     1C     db  _16                ; +2
 0000A6FE  FF92		     1C     dw  (-200 + 90)           ; +3
 0000A700  5A		     1C     db  90             ; +5
 0000A701  00000088	     1C     dd  17 * FONT_X          ; +6
 0000A705  0000002A	     1C     dd  7 * FONT_Y          ; +10
 0000A709  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 92), 92,  12, 7
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A70B  03		     1C     db  _DISPLAY            ; +0
 0000A70C  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A70D  04		     1C     db  _16                ; +2
 0000A70E  FF94		     1C     dw  (-200 + 92)           ; +3
 0000A710  5C		     1C     db  92             ; +5
 0000A711  00000060	     1C     dd  12 * FONT_X          ; +6
 0000A715  0000002A	     1C     dd  7 * FONT_Y          ; +10
 0000A719  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 + 94), 94,  7,  7
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A71B  03		     1C     db  _DISPLAY            ; +0
 0000A71C  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A71D  04		     1C     db  _16                ; +2
 0000A71E  FF96		     1C     dw  (-200 + 94)           ; +3
 0000A720  5E		     1C     db  94             ; +5
 0000A721  00000038	     1C     dd  7 * FONT_X          ; +6
 0000A725  0000002A	     1C     dd  7 * FONT_Y          ; +10
 0000A729  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @DisplayEBP_relative    _16, (-200 + 98), 98,  22, 8                                                ; mm7
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A72B  03		     1C     db  _DISPLAY            ; +0
 0000A72C  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A72D  04		     1C     db  _16                ; +2
 0000A72E  FF9A		     1C     dw  (-200 + 98)           ; +3
 0000A730  62		     1C     db  98             ; +5
 0000A731  000000B0	     1C     dd  22 * FONT_X          ; +6
 0000A735  00000030	     1C     dd  8 * FONT_Y          ; +10
 0000A739  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 +100),100,  17, 8
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A73B  03		     1C     db  _DISPLAY            ; +0
 0000A73C  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A73D  04		     1C     db  _16                ; +2
 0000A73E  FF9C		     1C     dw  (-200 +100)           ; +3
 0000A740  64		     1C     db  100             ; +5
 0000A741  00000088	     1C     dd  17 * FONT_X          ; +6
 0000A745  00000030	     1C     dd  8 * FONT_Y          ; +10
 0000A749  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 +102),102,  12, 8
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A74B  03		     1C     db  _DISPLAY            ; +0
 0000A74C  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A74D  04		     1C     db  _16                ; +2
 0000A74E  FF9E		     1C     dw  (-200 +102)           ; +3
 0000A750  66		     1C     db  102             ; +5
 0000A751  00000060	     1C     dd  12 * FONT_X          ; +6
 0000A755  00000030	     1C     dd  8 * FONT_Y          ; +10
 0000A759  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C     @DisplayEBP_relative    _16, (-200 +104),104,  7,  8
			     1C ; Used to dipslay a dword value.  Note that the type argument specifies what kind of EBP relative item it is.
			     1C ;
			     1C ;      TYPE - indicates what type of variable is being displayed
			     1C ; EBPOFFSET - offset relative to the current EBP (Refer to DEBI_debug in debi.asm for information on stack arrangement)
			     1C ;   LOFFSET - offset in local memory where the comparison is made (to highlight if it has changed)
			     1C ;         X - X coordinate (in characters) relative to upper-left corner of window
			     1C ;         Y - Y coordinate (in characters) relative to upper-left corner of window
			     1C ;
 0000A75B  03		     1C     db  _DISPLAY            ; +0
 0000A75C  01		     1C     db  _EBP_RELATIVE       ; +1
 0000A75D  04		     1C     db  _16                ; +2
 0000A75E  FFA0		     1C     dw  (-200 +104)           ; +3
 0000A760  68		     1C     db  104             ; +5
 0000A761  00000038	     1C     dd  7 * FONT_X          ; +6
 0000A765  00000030	     1C     dd  8 * FONT_Y          ; +10
 0000A769  0000		     1C     dw  0                   ; +14, Nuserved
			     1C   ; Total = 16
			      C 
			      C     @End
 0000A76B  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C ALIGN
 0000A76C		      C DEBI_s_mouse_objects:
			      C     @Left_single_click       1,  0,  1,  0, invDEBI_object_close
			     1C ; Used when a left single-click is recognized on these coordinates
 0000A76C  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000A76D  00000008	     1C     dd  1 * FONT_X                 ; +1
 0000A771  00000000	     1C     dd  0 * FONT_Y                 ; +5
 0000A775  0000000F	     1C     dd  (1 * FONT_X) + FONT_X - 1  ; +9
 0000A779  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 0000A77D  0000510B R	     1C     dd  invDEBI_object_close                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 0000A781  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000A785  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000A787  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      3,  0,  9,  0, invDEBI_mmx_right_click
			     1C ; Used when a right single-click is recognized on these coordinates
 0000A788  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 0000A789  00000018	     1C     dd  3 * FONT_X                 ; +1
 0000A78D  00000000	     1C     dd  0 * FONT_Y                 ; +5
 0000A791  0000004F	     1C     dd  (9 * FONT_X) + FONT_X - 1  ; +9
 0000A795  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 0000A799  000039C0 R	     1C     dd  invDEBI_mmx_right_click                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 0000A79D  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000A7A1  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000A7A3  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         0,  0, 29,  0, invDEBI_object_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 0000A7A4  02		     1C     db  _LEFT_DRAG_START            ; +0
 0000A7A5  00000000	     1C     dd  0 * FONT_X                 ; +1
 0000A7A9  00000000	     1C     dd  0 * FONT_Y                 ; +5
 0000A7AD  000000EF	     1C     dd  (29 * FONT_X) + FONT_X - 1  ; +9
 0000A7B1  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 0000A7B5  00003BE5 R	     1C     dd  invDEBI_object_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 0000A7B9  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000A7BD  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000A7BF  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         7,  1, 25,  8, invDEBI_mmx_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 0000A7C0  02		     1C     db  _LEFT_DRAG_START            ; +0
 0000A7C1  00000038	     1C     dd  7 * FONT_X                 ; +1
 0000A7C5  00000006	     1C     dd  1 * FONT_Y                 ; +5
 0000A7C9  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 0000A7CD  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 0000A7D1  00003E97 R	     1C     dd  invDEBI_mmx_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 0000A7D5  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000A7D9  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000A7DB  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_stop          7,  1, 25,  8, invDEBI_mmx_drag_stop
			     1C ; Used when a left-drag is stopped if it started in these coordinates
 0000A7DC  03		     1C     db  _LEFT_DRAG_STOP             ; +0
 0000A7DD  00000038	     1C     dd  7 * FONT_X                 ; +1
 0000A7E1  00000006	     1C     dd  1 * FONT_Y                 ; +5
 0000A7E5  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 0000A7E9  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 0000A7ED  00003F3E R	     1C     dd  invDEBI_mmx_drag_stop                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 0000A7F1  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000A7F5  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000A7F7  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      7,  1, 25,  8, invDEBI_mmx_menu
			     1C ; Used when a right single-click is recognized on these coordinates
 0000A7F8  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 0000A7F9  00000038	     1C     dd  7 * FONT_X                 ; +1
 0000A7FD  00000006	     1C     dd  1 * FONT_Y                 ; +5
 0000A801  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 0000A805  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 0000A809  0000257F R	     1C     dd  invDEBI_mmx_menu                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 0000A80D  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000A811  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000A813  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Abandon_if_not          7,  1, 25,  8
			     1C ; Used in a lengthy list.  If the coordinates are not within this range then the rest of the lengthy list is not checked
 0000A814  0C		     1C     db  _ABANDON_IF_NOT             ; +0
 0000A815  00000038	     1C     dd  7 * FONT_X                 ; +1
 0000A819  00000006	     1C     dd  1 * FONT_Y                 ; +5
 0000A81D  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 0000A821  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 0000A825  0000000B [	     1C     db  11 dup(0ffh)                ; +17
	    FF
	   ]
			     1C   ; Total = 28
			      C     @Hover                   7,  1, 25,  1, (-200 + 98), invDEBI_quick_watch_show_EBP_relative_64
			     1C ; Used when the mouse is hovering over these coordinates
 0000A830  0A		     1C     db  _HOVER                      ; +0
 0000A831  00000038	     1C     dd  7 * FONT_X                 ; +1
 0000A835  00000006	     1C     dd  1 * FONT_Y                 ; +5
 0000A839  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 0000A83D  0000000B	     1C     dd  (1 * FONT_Y) + FONT_Y - 1  ; +13
 0000A841  000050FF R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_64                        ; +17
 0000A845  FF9A		     1C     dw  lowword(offset (-200 + 98))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000A847  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   7,  2, 25,  2, (-200 + 88), invDEBI_quick_watch_show_EBP_relative_64
			     1C ; Used when the mouse is hovering over these coordinates
 0000A84C  0A		     1C     db  _HOVER                      ; +0
 0000A84D  00000038	     1C     dd  7 * FONT_X                 ; +1
 0000A851  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 0000A855  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 0000A859  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 0000A85D  000050FF R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_64                        ; +17
 0000A861  FF90		     1C     dw  lowword(offset (-200 + 88))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000A863  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   7,  3, 25,  3, (-200 + 78), invDEBI_quick_watch_show_EBP_relative_64
			     1C ; Used when the mouse is hovering over these coordinates
 0000A868  0A		     1C     db  _HOVER                      ; +0
 0000A869  00000038	     1C     dd  7 * FONT_X                 ; +1
 0000A86D  00000012	     1C     dd  3 * FONT_Y                 ; +5
 0000A871  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 0000A875  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 0000A879  000050FF R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_64                        ; +17
 0000A87D  FF86		     1C     dw  lowword(offset (-200 + 78))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000A87F  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   7,  4, 25,  4, (-200 + 68), invDEBI_quick_watch_show_EBP_relative_64
			     1C ; Used when the mouse is hovering over these coordinates
 0000A884  0A		     1C     db  _HOVER                      ; +0
 0000A885  00000038	     1C     dd  7 * FONT_X                 ; +1
 0000A889  00000018	     1C     dd  4 * FONT_Y                 ; +5
 0000A88D  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 0000A891  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 0000A895  000050FF R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_64                        ; +17
 0000A899  FF7C		     1C     dw  lowword(offset (-200 + 68))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000A89B  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   7,  5, 25,  5, (-200 + 58), invDEBI_quick_watch_show_EBP_relative_64
			     1C ; Used when the mouse is hovering over these coordinates
 0000A8A0  0A		     1C     db  _HOVER                      ; +0
 0000A8A1  00000038	     1C     dd  7 * FONT_X                 ; +1
 0000A8A5  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 0000A8A9  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 0000A8AD  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 0000A8B1  000050FF R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_64                        ; +17
 0000A8B5  FF72		     1C     dw  lowword(offset (-200 + 58))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000A8B7  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   7,  6, 25,  6, (-200 + 48), invDEBI_quick_watch_show_EBP_relative_64
			     1C ; Used when the mouse is hovering over these coordinates
 0000A8BC  0A		     1C     db  _HOVER                      ; +0
 0000A8BD  00000038	     1C     dd  7 * FONT_X                 ; +1
 0000A8C1  00000024	     1C     dd  6 * FONT_Y                 ; +5
 0000A8C5  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 0000A8C9  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 0000A8CD  000050FF R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_64                        ; +17
 0000A8D1  FF68		     1C     dw  lowword(offset (-200 + 48))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000A8D3  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   7,  7, 25,  7, (-200 + 38), invDEBI_quick_watch_show_EBP_relative_64
			     1C ; Used when the mouse is hovering over these coordinates
 0000A8D8  0A		     1C     db  _HOVER                      ; +0
 0000A8D9  00000038	     1C     dd  7 * FONT_X                 ; +1
 0000A8DD  0000002A	     1C     dd  7 * FONT_Y                 ; +5
 0000A8E1  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 0000A8E5  0000002F	     1C     dd  (7 * FONT_Y) + FONT_Y - 1  ; +13
 0000A8E9  000050FF R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_64                        ; +17
 0000A8ED  FF5E		     1C     dw  lowword(offset (-200 + 38))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000A8EF  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Hover                   7,  8, 25,  8, (-200 + 28), invDEBI_quick_watch_show_EBP_relative_64
			     1C ; Used when the mouse is hovering over these coordinates
 0000A8F4  0A		     1C     db  _HOVER                      ; +0
 0000A8F5  00000038	     1C     dd  7 * FONT_X                 ; +1
 0000A8F9  00000030	     1C     dd  8 * FONT_Y                 ; +5
 0000A8FD  000000CF	     1C     dd  (25 * FONT_X) + FONT_X - 1  ; +9
 0000A901  00000035	     1C     dd  (8 * FONT_Y) + FONT_Y - 1  ; +13
 0000A905  000050FF R	     1C     dd  invDEBI_quick_watch_show_EBP_relative_64                        ; +17
 0000A909  FF54		     1C     dw  lowword(offset (-200 + 28))     ; +21
			     1C     IFNB <>
			     1C         dw                     ; +23
			     1C         db  3 dup(0ffh)             ; +25
			     1C     ELSE
 0000A90B  00000005 [	     1C         db  5 dup(0ffh)             ; +23
	    FF
	   ]
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @End
 0000A910  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
 0000A911		      C DEBI_cfsca_menu:
			      C     @MenuItem               "ƒƒ Change to ƒƒ"
 0000A911  00		     1C     db  _MENU_ITEM
 0000A912  0F		     1C     db  @SizeStr("ƒƒ Change to ƒƒ") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A913  C4 C4 20 43 68    1C     db  "ƒƒ Change to ƒƒ"
	   61 6E 67 65 20
	   74 6F 20 C4 C4
			      C     @MenuItem               "CFSCA.1"
 0000A922  00		     1C     db  _MENU_ITEM
 0000A923  07		     1C     db  @SizeStr("CFSCA.1") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A924  43 46 53 43 41    1C     db  "CFSCA.1"
	   2E 31
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_change_window_cfsca_1
 0000A92B  01		     1C     db  _MENU_ITEM_EVENT
 0000A92C  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A92D  000039CA R	     1C     dd  offset invDEBI_change_window_cfsca_1
			      C     @MenuItem               "CFSCA.2"
 0000A931  00		     1C     db  _MENU_ITEM
 0000A932  07		     1C     db  @SizeStr("CFSCA.2") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A933  43 46 53 43 41    1C     db  "CFSCA.2"
	   2E 32
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_change_window_cfsca_2
 0000A93A  01		     1C     db  _MENU_ITEM_EVENT
 0000A93B  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A93C  000039DB R	     1C     dd  offset invDEBI_change_window_cfsca_2
			      C     @MenuItem               "CFSCA.3"
 0000A940  00		     1C     db  _MENU_ITEM
 0000A941  07		     1C     db  @SizeStr("CFSCA.3") - 2      ; The -2 is for the quotes, @SizeStr("test") returns 6
 0000A942  43 46 53 43 41    1C     db  "CFSCA.3"
	   2E 33
			      C     @MenuItemEvent              _LEFT_SINGLE_CLICK, invDEBI_change_window_cfsca_3
 0000A949  01		     1C     db  _MENU_ITEM_EVENT
 0000A94A  00		     1C     db  _LEFT_SINGLE_CLICK
 0000A94B  000039EC R	     1C     dd  offset invDEBI_change_window_cfsca_3
			      C     @End
 0000A94F  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C                                 ;   00000000-112233445566.. mov     dx,fs:[esi+ebx+00eeddcc]
			      C                                 ;          11111111112222222222333333333344444444445555555555
			      C                                 ;012345678901234567890123456789012345678901234567890123456789
 0000A950 C9 9A CD 81 20      C DEBI_t_window               db  "…öÕÅ cfsca.1 ÖÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕª",0
	   63 66 73 63 61
	   2E 31 20 85 CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD CD
	   CD CD CD CD BB
	   00
 0000A98D  CC CC CC CC 20     C                             db  "ÃÃÃÃ                                                       ∫",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 BA
	   00
 0000A9CA  FE 0B	      C                             db  254,11
			      C 
 0000A9CC		      C DEBI_t_keyboard_objects:
			      C     @FunctionHandlesObject  invDEBI_CFSCA_kbd_handler
 0000A9CC  07		     1C     db  _FUNCTION
 0000A9CD  000050D4 R	     1C     dd  offset invDEBI_CFSCA_kbd_handler
			     1C   ; Total = 5
			      C     @End
 0000A9D1  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
 0000A9D2  01E0		      C                             dw  60 * FONT_X
 0000A9D4  004D		      C                             dw  13 * FONT_Y - 1
 0000A9D6		      C DEBI_t_screen_objects:
			      C     @DrawWindow             DEBI_t_window
			     1C ; Draws the window for whatever item is specified
 0000A9D6  FD		     1C     db  _DRAW_WINDOW
 0000A9D7  0000A950 R	     1C     dd  offset DEBI_t_window
			     1C   ; Total = 5
			      C     @ObjectMemSize          4
			     1C ; Indicates how big this item's block of memory is in the _sDEBI_objects memory area
 0000A9DB  00		     1C     db  _OBJECT_MEM_SIZE
 0000A9DC  04		     1C     db  4
			     1C   ; Total = 2
			      C     @FunctionHandlesObject  invDEBI_cfsca_1_window
 0000A9DD  07		     1C     db  _FUNCTION
 0000A9DE  00004FAF R	     1C     dd  offset invDEBI_cfsca_1_window
			     1C   ; Total = 5
			      C     @End
 0000A9E2  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C ALIGN
 0000A9E3		      C DEBI_t_mouse_objects:
			      C     @Left_single_click       1,  0,  1,  0, invDEBI_object_close
			     1C ; Used when a left single-click is recognized on these coordinates
 0000A9E3  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000A9E4  00000008	     1C     dd  1 * FONT_X                 ; +1
 0000A9E8  00000000	     1C     dd  0 * FONT_Y                 ; +5
 0000A9EC  0000000F	     1C     dd  (1 * FONT_X) + FONT_X - 1  ; +9
 0000A9F0  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 0000A9F4  0000510B R	     1C     dd  invDEBI_object_close                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 0000A9F8  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000A9FC  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000A9FE  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Right_single_click      3,  0, 13,  0, invDEBI_cfsca_1_right_click
			     1C ; Used when a right single-click is recognized on these coordinates
 0000A9FF  04		     1C     db  _RIGHT_SINGLE_CLICK         ; +0
 0000AA00  00000018	     1C     dd  3 * FONT_X                 ; +1
 0000AA04  00000000	     1C     dd  0 * FONT_Y                 ; +5
 0000AA08  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 0000AA0C  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 0000AA10  000039C5 R	     1C     dd  invDEBI_cfsca_1_right_click                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 0000AA14  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000AA18  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000AA1A  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_drag_start         0,  0, 59,  0, invDEBI_object_drag_start
			     1C ; Used when a left-drag is started in these coordinates
 0000AA1B  02		     1C     db  _LEFT_DRAG_START            ; +0
 0000AA1C  00000000	     1C     dd  0 * FONT_X                 ; +1
 0000AA20  00000000	     1C     dd  0 * FONT_Y                 ; +5
 0000AA24  000001DF	     1C     dd  (59 * FONT_X) + FONT_X - 1  ; +9
 0000AA28  00000005	     1C     dd  (0 * FONT_Y) + FONT_Y - 1  ; +13
 0000AA2C  00003BE5 R	     1C     dd  invDEBI_object_drag_start                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 0000AA30  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000AA34  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000AA36  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @End
 0000AA37  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C                                 ;
 0000AA38 20 20 20 20 20      C DEBI_z_window               db  "                              ",0
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   00
 0000AA57  FE 03	      C                             db  254,3
			      C 
 0000AA59		      C DEBI_z_keyboard_objects:
			      C     @End
 0000AA59  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
 0000AA5A  00F0		      C                             dw  30 * FONT_X
 0000AA5C  0011		      C                             dw  3  * FONT_Y - 1
 0000AA5E		      C DEBI_z_screen_objects:
			      C     @DrawWindow             DEBI_z_window
			     1C ; Draws the window for whatever item is specified
 0000AA5E  FD		     1C     db  _DRAW_WINDOW
 0000AA5F  0000AA38 R	     1C     dd  offset DEBI_z_window
			     1C   ; Total = 5
			      C     @FunctionHandlesObject  invDEBI_logo_window
 0000AA63  07		     1C     db  _FUNCTION
 0000AA64  000039BF R	     1C     dd  offset invDEBI_logo_window
			     1C   ; Total = 5
			      C     @End
 0000AA68  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
 0000AA69		      C DEBI_z_mouse_objects:
			      C     @End
 0000AA69  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
			      C 
			      C ;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 0000AA6A 00		      C exp_screen_object           db  _NO                                 ; +00 Alterable?
 0000AA6B  01		      C                             db  _YES                                ; +01 Active?
 0000AA6C  0000		      C                             dw  0                                   ; +02 +--Nuserved
 0000AA6E  00000000	      C                             dd  0                                   ; +04 +_ST_OBJECT_UL_HORIZONTAL (assigned internally)
 0000AA72  00000000	      C                             dd  0                                   ; +08 +_ST_OBJECT_UL_VERTICAL (assigned internally)
 0000AA76  FFFFFFFF	      C                             dd  0ffffffffh                          ; +12 +_ST_MEMVAR_OFFSET
 0000AA7A  0000AFF5 R	      C                             dd  offset exp_screen_keyboard_objects  ; +16 +_ST_OBJECT_KBD_OFFSET
 0000AA7E  FFFFFFFF	      C                             dd  0ffffffffh                          ; +20 +_ST_OBJECT_MEMORY_OFFSET
 0000AA82  0000B1EF R	      C                             dd  offset exp_screen_mouse_objects     ; +24 +_ST_OBJECT_MOUSE_OFFSET
 0000AA86  0000AFEF R	      C                             dd  offset exp_screen_screen_objects    ; +28 +_ST_OBJECT_SCREEN_OFFSET
			      C 
			      C ; The following list is used to copy memory from a window's options to local memory variables for editing
 0000AA8A 0000AFBD R	      C DEBI_exp_memvar_list        dd  offset text_22                      ; Offset of the editable variable
 0000AA8E  00000016	      C                             dd  sizeof text_22 - 1                  ; Length
 0000AA92  0000AFD4 R	      C                             dd  offset disp_22
 0000AA96  00000016	      C                             dd  sizeof disp_22 - 1
 0000AA9A  0000ABDC R	      C                             dd  offset live
 0000AA9E  00000001	      C                             dd  1
 0000AAA2  0000AC08 R	      C                             dd  offset indirect
 0000AAA6  00000001	      C                             dd  1
 0000AAAA  0000AC34 R	      C                             dd  offset show_addresses
 0000AAAE  00000001	      C                             dd  1
 0000AAB2  0000ACAC R	      C                             dd  offset ascii_char
 0000AAB6  00000001	      C                             dd  1
 0000AABA  0000ACD8 R	      C                             dd  offset _byte
 0000AABE  00000001	      C                             dd  1
 0000AAC2  0000AD04 R	      C                             dd  offset _word
 0000AAC6  00000001	      C                             dd  1
 0000AACA  0000AD30 R	      C                             dd  offset _dword
 0000AACE  00000001	      C                             dd  1
 0000AAD2  0000AD5C R	      C                             dd  offset _qword
 0000AAD6  00000001	      C                             dd  1
 0000AADA  0000AD88 R	      C                             dd  offset float32
 0000AADE  00000001	      C                             dd  1
 0000AAE2  0000ADB4 R	      C                             dd  offset float64
 0000AAE6  00000001	      C                             dd  1
 0000AAEA  0000ADE0 R	      C                             dd  offset float80
 0000AAEE  00000001	      C                             dd  1
 0000AAF2  0000AE46 R	      C                             dd  offset hexadecimal
 0000AAF6  00000001	      C                             dd  1
 0000AAFA  0000AE72 R	      C                             dd  offset decimal
 0000AAFE  00000001	      C                             dd  1
 0000AB02  0000AE9E R	      C                             dd  offset octal
 0000AB06  00000001	      C                             dd  1
 0000AB0A  0000AECA R	      C                             dd  offset binary
 0000AB0E  00000001	      C                             dd  1
 0000AB12  FFFFFFFF	      C                             dd  -1                                  ; List terminator (appears where the offset to
			      C 
			      C                                 ;          1111111111222222222233333333334
			      C                                 ;01234567890123456789012345678901234567890
 0000AB16 DA C4 C4 C4 BF      C exp_screen_window           db  "⁄ƒƒƒøÙ Address Expression to Display ı⁄ƒƒƒø",0   ; 0
	   F4 20 41 64 64
	   72 65 73 73 20
	   45 78 70 72 65
	   73 73 69 6F 6E
	   20 74 6F 20 44
	   69 73 70 6C 61
	   79 20 F5 DA C4
	   C4 C4 BF 00
 0000AB42  B4 F4 20 20 20     C                             db  "¥Ù                                       ı≥",0   ; 1
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 F5 B3 00
 0000AB6E  B4 F4 20 20 20     C                             db  "¥Ù      Address: ı                      Ùö ı≥",0   ; 2
	   20 20 20 41 64
	   64 72 65 73 73
	   3A 20 F5 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   F4 9A 20 F5 B3
	   00
 0000AB9C  B4 F4 20 44 69     C                             db  "¥Ù Displacement: ı                      Ùö ı≥",0   ; 3
	   73 70 6C 61 63
	   65 6D 65 6E 74
	   3A 20 F5 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   F4 9A 20 F5 B3
	   00
 0000ABCA  B4 F4 20 20 20     C                             db  "¥Ù               ("
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 28
 0000ABDC 20 29 20 4C 69      C live                        db  " ) Live?               ı≥",0   ; 4
	   76 65 3F 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 F5 B3
	   00
 0000ABF6  B4 F4 20 20 20     C                             db  "¥Ù               ("
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 28
 0000AC08 20 29 20 49 6E      C indirect                    db  " ) Indirect?           ı≥",0   ; 5
	   64 69 72 65 63
	   74 3F 20 20 20
	   20 20 20 20 20
	   20 20 20 F5 B3
	   00
 0000AC22  B4 F4 20 20 20     C                             db  "¥Ù               ("
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 28
 0000AC34 20 29 20 53 68      C show_addresses              db  " ) Show addresses?     ı≥",0   ; 6
	   6F 77 20 61 64
	   64 72 65 73 73
	   65 73 3F 20 20
	   20 20 20 F5 B3
	   00
 0000AC4E  B4 F4 20 20 20     C                             db  "¥Ù                                       ı≥",0   ; 7
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 F5 B3 00
 0000AC7A  B4 F4 20 57 69     C                             db  "¥Ù Window display:                       ı≥",0   ; 8
	   6E 64 6F 77 20
	   64 69 73 70 6C
	   61 79 3A 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 F5 B3 00
 0000ACA6  B4 F4 20 20 20     C                             db  "¥Ù   ("
	   28
 0000ACAC 20 29 20 41 53      C ascii_char                  db  " ) ASCII char                      ı≥",0   ; 9
	   43 49 49 20 63
	   68 61 72 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   F5 B3 00
 0000ACD2  B4 F4 20 20 20     C                             db  "¥Ù   ("
	   28
 0000ACD8 20 29 20 42 79      C _byte                       db  " ) Byte*                           ı≥",0   ; 10
	   74 65 2A 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   F5 B3 00
 0000ACFE  B4 F4 20 20 20     C                             db  "¥Ù   ("
	   28
 0000AD04 20 29 20 57 6F      C _word                       db  " ) Word*                           ı≥",0   ; 11
	   72 64 2A 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   F5 B3 00
 0000AD2A  B4 F4 20 20 20     C                             db  "¥Ù   ("
	   28
 0000AD30 20 29 20 44 77      C _dword                      db  " ) Dword*                          ı≥",0   ; 12
	   6F 72 64 2A 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   F5 B3 00
 0000AD56  B4 F4 20 20 20     C                             db  "¥Ù   ("
	   28
 0000AD5C 20 29 20 51 77      C _qword                      db  " ) Qword*                          ı≥",0   ; 13
	   6F 72 64 2A 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   F5 B3 00
 0000AD82  B4 F4 20 20 20     C                             db  "¥Ù   ("
	   28
 0000AD88 20 29 20 46 6C      C float32                     db  " ) Float32                         ı≥",0   ; 14
	   6F 61 74 33 32
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   F5 B3 00
 0000ADAE  B4 F4 20 20 20     C                             db  "¥Ù   ("
	   28
 0000ADB4 20 29 20 46 6C      C float64                     db  " ) Float64                         ı≥",0   ; 15
	   6F 61 74 36 34
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   F5 B3 00
 0000ADDA  B4 F4 20 20 20     C                             db  "¥Ù   ("
	   28
 0000ADE0 20 29 20 46 6C      C float80                     db  " ) Float80                         ı≥",0   ; 16
	   6F 61 74 38 30
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   F5 B3 00
 0000AE06  B4 F4 20 20 20     C                             db  "¥Ù                                       ı≥",0   ; 17
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 F5 B3 00
 0000AE32  B4 F4 20 2A 20     C                             db  "¥Ù * Window type:  ("
	   57 69 6E 64 6F
	   77 20 74 79 70
	   65 3A 20 20 28
 0000AE46 20 29 20 48 65      C hexadecimal                 db  " ) Hexadecimal       ı≥",0   ; 18
	   78 61 64 65 63
	   69 6D 61 6C 20
	   20 20 20 20 20
	   20 F5 B3 00
 0000AE5E  B4 F4 20 20 20     C                             db  "¥Ù                 ("
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 28
 0000AE72 20 29 20 44 65      C decimal                     db  " ) Decimal           ı≥",0   ; 19
	   63 69 6D 61 6C
	   20 20 20 20 20
	   20 20 20 20 20
	   20 F5 B3 00
 0000AE8A  B4 F4 20 20 20     C                             db  "¥Ù                 ("
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 28
 0000AE9E 20 29 20 4F 63      C octal                       db  " ) Octal             ı≥",0   ; 20
	   74 61 6C 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 F5 B3 00
 0000AEB6  B4 F4 20 20 20     C                             db  "¥Ù                 ("
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 28
 0000AECA 20 29 20 42 69      C binary                      db  " ) Binary            ı≥",0   ; 21
	   6E 61 72 79 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 F5 B3 00
 0000AEE2  B4 F4 C3 C3 C3     C                             db  "¥Ù√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√ı≥",0   ; 22
	   C3 C3 C3 C3 C3
	   C3 C3 C3 C3 C3
	   C3 C3 C3 C3 C3
	   C3 C3 C3 C3 C3
	   C3 C3 C3 C3 C3
	   C3 C3 C3 C3 C3
	   C3 C3 C3 C3 C3
	   C3 F5 B3 00
 0000AF0E  B4 F4 20 20 20     C                             db  "¥Ù                                       ı≥",0   ; 23
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 F5 B3 00
 0000AF3A  B4 F4 20 20 20     C                             db  "¥Ù          à OK å     à CANCEL å        ı≥",0   ; 24
	   20 20 20 20 20
	   20 20 88 20 4F
	   4B 20 8C 20 20
	   20 20 20 88 20
	   43 41 4E 43 45
	   4C 20 8C 20 20
	   20 20 20 20 20
	   20 F5 B3 00
 0000AF66  B4 F4 20 20 20     C                             db  "¥Ù                                       ı≥",0   ; 25
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 20 20 20 20
	   20 F5 B3 00
 0000AF92  C0 C3 C3 C3 C3     C                             db  "¿√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√√Ÿ",0   ; 26
	   C3 C3 C3 C3 C3
	   C3 C3 C3 C3 C3
	   C3 C3 C3 C3 C3
	   C3 C3 C3 C3 C3
	   C3 C3 C3 C3 C3
	   C3 C3 C3 C3 C3
	   C3 C3 C3 C3 C3
	   D9 00
 0000AFBC  FF		      C                             db  255
 = 00000028		      C _EXP_SCREEN_WIDTH           EQU 40
 = 0000001B		      C _EXP_SCREEN_HEIGHT          EQU 27
			      C 
 0000AFBD  00000016 [	      C text_22                     db  22 dup(32),0                        ; Default to an empty expression
	    20
	   ] 00
 0000AFD4  00000016 [	      C disp_22                     db  22 dup(32),0                         ; Default to an empty expression
	    20
	   ] 00
			      C 
 0000AFEB  0140		      C                             dw  40 * FONT_X
 0000AFED  00A1		      C                             dw  27 * FONT_Y - 1
 0000AFEF		      C exp_screen_screen_objects:
			      C     @AlwaysDrawWindow       exp_screen_window
			     1C ; Always draws the window for whatever item is specified
 0000AFEF  FE		     1C     db  _DRAW_WINDOW_ALWAYS
 0000AFF0  0000AB16 R	     1C     dd  offset exp_screen_window
			     1C   ; Total = 5
			      C     @End
 0000AFF4  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
 0000AFF5		      C exp_screen_keyboard_objects:
			      C     @Start
 0000AFF5  FC		     1C     db  _START
			     1C   ; Total = 1
 0000AFF6		      C exp_screen_keyboard_top_object:
 0000AFF6		      C text_22_object:
			      C     @DEBI_textbox           16,  2, 22, text_22
 0000AFF6  00		     1C     db  _KO_TEXTBOX             ; +0
 0000AFF7  00000080	     1C     dd  16 * FONT_X              ; +1
 0000AFFB  0000000C	     1C     dd  2 * FONT_Y              ; +5
 0000AFFF  00000016	     1C     dd  22                     ; +9
 0000B003  0000AFBD R	     1C     dd  offset text_22              ; +13
 0000B007  00000007 [	     1C     db  7 dup(0ffh)             ; +21
	    FF
	   ]
			     1C   ; Total = 24
			      C     @DEBI_function          38,  2,  null_function, invDEBI_clear_text_22, null_function, null_function
 0000B00E  FE		     1C     db  _KO_FUNCTION            ; +0
 0000B00F  0130		     1C     dw  38 * FONT_X              ; +1
 0000B011  000C		     1C     dw  2 * FONT_Y              ; +3
 0000B013  000050D1 R	     1C     dd  offset null_function       ; +5,  * Note:  This function is called to process a mouse request
 0000B017  000040EA R	     1C     dd  offset invDEBI_clear_text_22         ; +9,  * Note:  This function is entirely custom and is called for all screen updating
 0000B01B  000050D1 R	     1C     dd  offset null_function     ; +13, * Note:  This function is entirely custom and is called for all screen updating
 0000B01F  000050D1 R	     1C     dd  offset null_function    ; +17, * Note:  This function is entirely custom and is called for all screen updating
 0000B023  00000003 [	     1C     db  3 dup(0ffh)             ; +21
	    FF
	   ]
			     1C   ; Total = 24
 0000B026		      C disp_22_object:
			      C     @DEBI_textbox           16,  3, 22, disp_22
 0000B026  00		     1C     db  _KO_TEXTBOX             ; +0
 0000B027  00000080	     1C     dd  16 * FONT_X              ; +1
 0000B02B  00000012	     1C     dd  3 * FONT_Y              ; +5
 0000B02F  00000016	     1C     dd  22                     ; +9
 0000B033  0000AFD4 R	     1C     dd  offset disp_22              ; +13
 0000B037  00000007 [	     1C     db  7 dup(0ffh)             ; +21
	    FF
	   ]
			     1C   ; Total = 24
			      C     @DEBI_function          38,  3,  null_function, invDEBI_clear_disp_22,  null_function, null_function
 0000B03E  FE		     1C     db  _KO_FUNCTION            ; +0
 0000B03F  0130		     1C     dw  38 * FONT_X              ; +1
 0000B041  0012		     1C     dw  3 * FONT_Y              ; +3
 0000B043  000050D1 R	     1C     dd  offset null_function       ; +5,  * Note:  This function is called to process a mouse request
 0000B047  00004162 R	     1C     dd  offset invDEBI_clear_disp_22         ; +9,  * Note:  This function is entirely custom and is called for all screen updating
 0000B04B  000050D1 R	     1C     dd  offset null_function     ; +13, * Note:  This function is entirely custom and is called for all screen updating
 0000B04F  000050D1 R	     1C     dd  offset null_function    ; +17, * Note:  This function is entirely custom and is called for all screen updating
 0000B053  00000003 [	     1C     db  3 dup(0ffh)             ; +21
	    FF
	   ]
			     1C   ; Total = 24
			      C     @DEBI_checkbox          16,  4,  1, live, 1
 0000B056  01		     1C     db  _KO_CHECKBOX            ; +0
 0000B057  00000080	     1C     dd  16 * FONT_X              ; +1
 0000B05B  00000018	     1C     dd  4 * FONT_Y              ; +5
 0000B05F  00000001	     1C     dd  1                     ; +9
 0000B063  0000ABDC R	     1C     dd  offset live              ; +13
 0000B067  01		     1C     db  1                ; +17
 0000B068  00000006 [	     1C     db  6 dup(0ffh)             ; +18
	    FF
	   ]
			     1C   ; Total = 24
			      C     @DEBI_checkbox          16,  5,  1, indirect, 1
 0000B06E  01		     1C     db  _KO_CHECKBOX            ; +0
 0000B06F  00000080	     1C     dd  16 * FONT_X              ; +1
 0000B073  0000001E	     1C     dd  5 * FONT_Y              ; +5
 0000B077  00000001	     1C     dd  1                     ; +9
 0000B07B  0000AC08 R	     1C     dd  offset indirect              ; +13
 0000B07F  01		     1C     db  1                ; +17
 0000B080  00000006 [	     1C     db  6 dup(0ffh)             ; +18
	    FF
	   ]
			     1C   ; Total = 24
			      C     @DEBI_checkbox          16,  6,  1, show_addresses, 1
 0000B086  01		     1C     db  _KO_CHECKBOX            ; +0
 0000B087  00000080	     1C     dd  16 * FONT_X              ; +1
 0000B08B  00000024	     1C     dd  6 * FONT_Y              ; +5
 0000B08F  00000001	     1C     dd  1                     ; +9
 0000B093  0000AC34 R	     1C     dd  offset show_addresses              ; +13
 0000B097  01		     1C     db  1                ; +17
 0000B098  00000006 [	     1C     db  6 dup(0ffh)             ; +18
	    FF
	   ]
			     1C   ; Total = 24
			      C     @DEBI_checkbox           4,  9,  1, ascii_char, 1
 0000B09E  01		     1C     db  _KO_CHECKBOX            ; +0
 0000B09F  00000020	     1C     dd  4 * FONT_X              ; +1
 0000B0A3  00000036	     1C     dd  9 * FONT_Y              ; +5
 0000B0A7  00000001	     1C     dd  1                     ; +9
 0000B0AB  0000ACAC R	     1C     dd  offset ascii_char              ; +13
 0000B0AF  01		     1C     db  1                ; +17
 0000B0B0  00000006 [	     1C     db  6 dup(0ffh)             ; +18
	    FF
	   ]
			     1C   ; Total = 24
			      C     @DEBI_checkbox           4, 10,  1, _byte, 1
 0000B0B6  01		     1C     db  _KO_CHECKBOX            ; +0
 0000B0B7  00000020	     1C     dd  4 * FONT_X              ; +1
 0000B0BB  0000003C	     1C     dd  10 * FONT_Y              ; +5
 0000B0BF  00000001	     1C     dd  1                     ; +9
 0000B0C3  0000ACD8 R	     1C     dd  offset _byte              ; +13
 0000B0C7  01		     1C     db  1                ; +17
 0000B0C8  00000006 [	     1C     db  6 dup(0ffh)             ; +18
	    FF
	   ]
			     1C   ; Total = 24
			      C     @DEBI_checkbox           4, 11,  1, _word, 1
 0000B0CE  01		     1C     db  _KO_CHECKBOX            ; +0
 0000B0CF  00000020	     1C     dd  4 * FONT_X              ; +1
 0000B0D3  00000042	     1C     dd  11 * FONT_Y              ; +5
 0000B0D7  00000001	     1C     dd  1                     ; +9
 0000B0DB  0000AD04 R	     1C     dd  offset _word              ; +13
 0000B0DF  01		     1C     db  1                ; +17
 0000B0E0  00000006 [	     1C     db  6 dup(0ffh)             ; +18
	    FF
	   ]
			     1C   ; Total = 24
			      C     @DEBI_checkbox           4, 12,  1, _dword, 1
 0000B0E6  01		     1C     db  _KO_CHECKBOX            ; +0
 0000B0E7  00000020	     1C     dd  4 * FONT_X              ; +1
 0000B0EB  00000048	     1C     dd  12 * FONT_Y              ; +5
 0000B0EF  00000001	     1C     dd  1                     ; +9
 0000B0F3  0000AD30 R	     1C     dd  offset _dword              ; +13
 0000B0F7  01		     1C     db  1                ; +17
 0000B0F8  00000006 [	     1C     db  6 dup(0ffh)             ; +18
	    FF
	   ]
			     1C   ; Total = 24
			      C     @DEBI_checkbox           4, 13,  1, _qword, 1
 0000B0FE  01		     1C     db  _KO_CHECKBOX            ; +0
 0000B0FF  00000020	     1C     dd  4 * FONT_X              ; +1
 0000B103  0000004E	     1C     dd  13 * FONT_Y              ; +5
 0000B107  00000001	     1C     dd  1                     ; +9
 0000B10B  0000AD5C R	     1C     dd  offset _qword              ; +13
 0000B10F  01		     1C     db  1                ; +17
 0000B110  00000006 [	     1C     db  6 dup(0ffh)             ; +18
	    FF
	   ]
			     1C   ; Total = 24
			      C     @DEBI_checkbox           4, 14,  1, float32, 1
 0000B116  01		     1C     db  _KO_CHECKBOX            ; +0
 0000B117  00000020	     1C     dd  4 * FONT_X              ; +1
 0000B11B  00000054	     1C     dd  14 * FONT_Y              ; +5
 0000B11F  00000001	     1C     dd  1                     ; +9
 0000B123  0000AD88 R	     1C     dd  offset float32              ; +13
 0000B127  01		     1C     db  1                ; +17
 0000B128  00000006 [	     1C     db  6 dup(0ffh)             ; +18
	    FF
	   ]
			     1C   ; Total = 24
			      C     @DEBI_checkbox           4, 15,  1, float64, 1
 0000B12E  01		     1C     db  _KO_CHECKBOX            ; +0
 0000B12F  00000020	     1C     dd  4 * FONT_X              ; +1
 0000B133  0000005A	     1C     dd  15 * FONT_Y              ; +5
 0000B137  00000001	     1C     dd  1                     ; +9
 0000B13B  0000ADB4 R	     1C     dd  offset float64              ; +13
 0000B13F  01		     1C     db  1                ; +17
 0000B140  00000006 [	     1C     db  6 dup(0ffh)             ; +18
	    FF
	   ]
			     1C   ; Total = 24
			      C     @DEBI_checkbox           4, 16,  1, float80, 1
 0000B146  01		     1C     db  _KO_CHECKBOX            ; +0
 0000B147  00000020	     1C     dd  4 * FONT_X              ; +1
 0000B14B  00000060	     1C     dd  16 * FONT_Y              ; +5
 0000B14F  00000001	     1C     dd  1                     ; +9
 0000B153  0000ADE0 R	     1C     dd  offset float80              ; +13
 0000B157  01		     1C     db  1                ; +17
 0000B158  00000006 [	     1C     db  6 dup(0ffh)             ; +18
	    FF
	   ]
			     1C   ; Total = 24
			      C     @DEBI_checkbox          18, 18,  1, hexadecimal, 1
 0000B15E  01		     1C     db  _KO_CHECKBOX            ; +0
 0000B15F  00000090	     1C     dd  18 * FONT_X              ; +1
 0000B163  0000006C	     1C     dd  18 * FONT_Y              ; +5
 0000B167  00000001	     1C     dd  1                     ; +9
 0000B16B  0000AE46 R	     1C     dd  offset hexadecimal              ; +13
 0000B16F  01		     1C     db  1                ; +17
 0000B170  00000006 [	     1C     db  6 dup(0ffh)             ; +18
	    FF
	   ]
			     1C   ; Total = 24
			      C     @DEBI_checkbox          18, 19,  1, decimal, 1
 0000B176  01		     1C     db  _KO_CHECKBOX            ; +0
 0000B177  00000090	     1C     dd  18 * FONT_X              ; +1
 0000B17B  00000072	     1C     dd  19 * FONT_Y              ; +5
 0000B17F  00000001	     1C     dd  1                     ; +9
 0000B183  0000AE72 R	     1C     dd  offset decimal              ; +13
 0000B187  01		     1C     db  1                ; +17
 0000B188  00000006 [	     1C     db  6 dup(0ffh)             ; +18
	    FF
	   ]
			     1C   ; Total = 24
			      C     @DEBI_checkbox          18, 20,  1, octal, 1
 0000B18E  01		     1C     db  _KO_CHECKBOX            ; +0
 0000B18F  00000090	     1C     dd  18 * FONT_X              ; +1
 0000B193  00000078	     1C     dd  20 * FONT_Y              ; +5
 0000B197  00000001	     1C     dd  1                     ; +9
 0000B19B  0000AE9E R	     1C     dd  offset octal              ; +13
 0000B19F  01		     1C     db  1                ; +17
 0000B1A0  00000006 [	     1C     db  6 dup(0ffh)             ; +18
	    FF
	   ]
			     1C   ; Total = 24
			      C     @DEBI_checkbox          18, 21,  1, binary, 1
 0000B1A6  01		     1C     db  _KO_CHECKBOX            ; +0
 0000B1A7  00000090	     1C     dd  18 * FONT_X              ; +1
 0000B1AB  0000007E	     1C     dd  21 * FONT_Y              ; +5
 0000B1AF  00000001	     1C     dd  1                     ; +9
 0000B1B3  0000AECA R	     1C     dd  offset binary              ; +13
 0000B1B7  01		     1C     db  1                ; +17
 0000B1B8  00000006 [	     1C     db  6 dup(0ffh)             ; +18
	    FF
	   ]
			     1C   ; Total = 24
			      C 
			      C     @DEBI_button            11, 24,  1, invDEBI_exp_screen_ok, 2
 0000B1BE  02		     1C     db  _KO_BUTTON              ; +0
 0000B1BF  00000058	     1C     dd  11 * FONT_X              ; +1
 0000B1C3  00000090	     1C     dd  24 * FONT_Y              ; +5
 0000B1C7  00000001	     1C     dd  1                     ; +9
 0000B1CB  000049F6 R	     1C     dd  invDEBI_exp_screen_ok                    ; +13
 0000B1CF  02		     1C     db  2                ; +17
 0000B1D0  00000006 [	     1C     db  6 dup(0ffh)             ; +18
	    FF
	   ]
			     1C   ; Total = 24
			      C     @DEBI_button            22, 24,  1, invDEBI_kbd_input_cancel, 2
 0000B1D6  02		     1C     db  _KO_BUTTON              ; +0
 0000B1D7  000000B0	     1C     dd  22 * FONT_X              ; +1
 0000B1DB  00000090	     1C     dd  24 * FONT_Y              ; +5
 0000B1DF  00000001	     1C     dd  1                     ; +9
 0000B1E3  000049C8 R	     1C     dd  invDEBI_kbd_input_cancel                    ; +13
 0000B1E7  02		     1C     db  2                ; +17
 0000B1E8  00000006 [	     1C     db  6 dup(0ffh)             ; +18
	    FF
	   ]
			     1C   ; Total = 24
			      C     @End
 0000B1EE  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 
 0000B1EF		      C exp_screen_mouse_objects:
			      C     @Any_click              16, 2, 37, 2, invDEBI_object_setFocus, text_22_object
			     1C ; Used when any click is recognized on these coordinates
			     1C ;
			     1C ;       X1 - X coordinate (in characters relative to upper-left corner of window) of the upper-left object
			     1C ;       Y1 - Y coordinate (in characters relative to upper-left corner of window) of the upper-left object
			     1C ;       X2 - X coordinate (in characters relative to upper-left corner of window) of the lower-right object
			     1C ;       Y2 - Y coordinate (in characters relative to upper-left corner of window) of the lower-right object
			     1C ;     FUNC - Function to call when this event is recognized
			     1C ;
 0000B1EF  0D		     1C     db  _ANY_CLICK                  ; +0
 0000B1F0  00000080	     1C     dd  16 * FONT_X                 ; +1
 0000B1F4  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 0000B1F8  0000012F	     1C     dd  (37 * FONT_X) + FONT_X - 1  ; +9
 0000B1FC  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 0000B200  000047F2 R	     1C     dd  invDEBI_object_setFocus                        ; +17
			     1C     IFNB <text_22_object>
 0000B204  0000AFF6 R	     1C         dd  text_22_object                   ; +21
			     1C     ELSE
			     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000B208  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B20A  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Any_click              16, 3, 37, 3, invDEBI_object_setFocus, disp_22_object
			     1C ; Used when any click is recognized on these coordinates
			     1C ;
			     1C ;       X1 - X coordinate (in characters relative to upper-left corner of window) of the upper-left object
			     1C ;       Y1 - Y coordinate (in characters relative to upper-left corner of window) of the upper-left object
			     1C ;       X2 - X coordinate (in characters relative to upper-left corner of window) of the lower-right object
			     1C ;       Y2 - Y coordinate (in characters relative to upper-left corner of window) of the lower-right object
			     1C ;     FUNC - Function to call when this event is recognized
			     1C ;
 0000B20B  0D		     1C     db  _ANY_CLICK                  ; +0
 0000B20C  00000080	     1C     dd  16 * FONT_X                 ; +1
 0000B210  00000012	     1C     dd  3 * FONT_Y                 ; +5
 0000B214  0000012F	     1C     dd  (37 * FONT_X) + FONT_X - 1  ; +9
 0000B218  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 0000B21C  000047F2 R	     1C     dd  invDEBI_object_setFocus                        ; +17
			     1C     IFNB <disp_22_object>
 0000B220  0000B026 R	     1C         dd  disp_22_object                   ; +21
			     1C     ELSE
			     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000B224  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B226  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_single_click      38, 2, 38, 2, invDEBI_input_clear_var_click, text_22, 22
			     1C ; Used when a left single-click is recognized on these coordinates
 0000B227  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000B228  00000130	     1C     dd  38 * FONT_X                 ; +1
 0000B22C  0000000C	     1C     dd  2 * FONT_Y                 ; +5
 0000B230  00000137	     1C     dd  (38 * FONT_X) + FONT_X - 1  ; +9
 0000B234  00000011	     1C     dd  (2 * FONT_Y) + FONT_Y - 1  ; +13
 0000B238  0000414A R	     1C     dd  invDEBI_input_clear_var_click                        ; +17
			     1C     IFNB <text_22>
 0000B23C  0000AFBD R	     1C         dd  text_22                   ; +21
			     1C     ELSE
			     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <22>
 0000B240  0016		     1C         dw  22                   ; +25
			     1C     ELSE
			     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B242  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_single_click      38, 3, 38, 3, invDEBI_input_clear_var_click, disp_22, 22
			     1C ; Used when a left single-click is recognized on these coordinates
 0000B243  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000B244  00000130	     1C     dd  38 * FONT_X                 ; +1
 0000B248  00000012	     1C     dd  3 * FONT_Y                 ; +5
 0000B24C  00000137	     1C     dd  (38 * FONT_X) + FONT_X - 1  ; +9
 0000B250  00000017	     1C     dd  (3 * FONT_Y) + FONT_Y - 1  ; +13
 0000B254  0000414A R	     1C     dd  invDEBI_input_clear_var_click                        ; +17
			     1C     IFNB <disp_22>
 0000B258  0000AFD4 R	     1C         dd  disp_22                   ; +21
			     1C     ELSE
			     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <22>
 0000B25C  0016		     1C         dw  22                   ; +25
			     1C     ELSE
			     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B25E  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_single_click      16, 4, 24, 4, invDEBI_checkbox_mouse_handler, live
			     1C ; Used when a left single-click is recognized on these coordinates
 0000B25F  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000B260  00000080	     1C     dd  16 * FONT_X                 ; +1
 0000B264  00000018	     1C     dd  4 * FONT_Y                 ; +5
 0000B268  000000C7	     1C     dd  (24 * FONT_X) + FONT_X - 1  ; +9
 0000B26C  0000001D	     1C     dd  (4 * FONT_Y) + FONT_Y - 1  ; +13
 0000B270  000041D3 R	     1C     dd  invDEBI_checkbox_mouse_handler                        ; +17
			     1C     IFNB <live>
 0000B274  0000ABDC R	     1C         dd  live                   ; +21
			     1C     ELSE
			     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000B278  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B27A  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_single_click      16, 5, 28, 5, invDEBI_checkbox_mouse_handler, indirect
			     1C ; Used when a left single-click is recognized on these coordinates
 0000B27B  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000B27C  00000080	     1C     dd  16 * FONT_X                 ; +1
 0000B280  0000001E	     1C     dd  5 * FONT_Y                 ; +5
 0000B284  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 0000B288  00000023	     1C     dd  (5 * FONT_Y) + FONT_Y - 1  ; +13
 0000B28C  000041D3 R	     1C     dd  invDEBI_checkbox_mouse_handler                        ; +17
			     1C     IFNB <indirect>
 0000B290  0000AC08 R	     1C         dd  indirect                   ; +21
			     1C     ELSE
			     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000B294  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B296  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_single_click      16, 6, 34, 6, invDEBI_checkbox_mouse_handler, show_addresses
			     1C ; Used when a left single-click is recognized on these coordinates
 0000B297  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000B298  00000080	     1C     dd  16 * FONT_X                 ; +1
 0000B29C  00000024	     1C     dd  6 * FONT_Y                 ; +5
 0000B2A0  00000117	     1C     dd  (34 * FONT_X) + FONT_X - 1  ; +9
 0000B2A4  00000029	     1C     dd  (6 * FONT_Y) + FONT_Y - 1  ; +13
 0000B2A8  000041D3 R	     1C     dd  invDEBI_checkbox_mouse_handler                        ; +17
			     1C     IFNB <show_addresses>
 0000B2AC  0000AC34 R	     1C         dd  show_addresses                   ; +21
			     1C     ELSE
			     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000B2B0  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B2B2  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_single_click       4, 9, 17, 9, invDEBI_checkbox_mouse_handler, ascii_char
			     1C ; Used when a left single-click is recognized on these coordinates
 0000B2B3  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000B2B4  00000020	     1C     dd  4 * FONT_X                 ; +1
 0000B2B8  00000036	     1C     dd  9 * FONT_Y                 ; +5
 0000B2BC  0000008F	     1C     dd  (17 * FONT_X) + FONT_X - 1  ; +9
 0000B2C0  0000003B	     1C     dd  (9 * FONT_Y) + FONT_Y - 1  ; +13
 0000B2C4  000041D3 R	     1C     dd  invDEBI_checkbox_mouse_handler                        ; +17
			     1C     IFNB <ascii_char>
 0000B2C8  0000ACAC R	     1C         dd  ascii_char                   ; +21
			     1C     ELSE
			     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000B2CC  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B2CE  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_single_click       4,10, 12,10, invDEBI_checkbox_mouse_handler, _byte
			     1C ; Used when a left single-click is recognized on these coordinates
 0000B2CF  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000B2D0  00000020	     1C     dd  4 * FONT_X                 ; +1
 0000B2D4  0000003C	     1C     dd  10 * FONT_Y                 ; +5
 0000B2D8  00000067	     1C     dd  (12 * FONT_X) + FONT_X - 1  ; +9
 0000B2DC  00000041	     1C     dd  (10 * FONT_Y) + FONT_Y - 1  ; +13
 0000B2E0  000041D3 R	     1C     dd  invDEBI_checkbox_mouse_handler                        ; +17
			     1C     IFNB <_byte>
 0000B2E4  0000ACD8 R	     1C         dd  _byte                   ; +21
			     1C     ELSE
			     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000B2E8  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B2EA  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_single_click       4,11, 12,11, invDEBI_checkbox_mouse_handler, _word
			     1C ; Used when a left single-click is recognized on these coordinates
 0000B2EB  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000B2EC  00000020	     1C     dd  4 * FONT_X                 ; +1
 0000B2F0  00000042	     1C     dd  11 * FONT_Y                 ; +5
 0000B2F4  00000067	     1C     dd  (12 * FONT_X) + FONT_X - 1  ; +9
 0000B2F8  00000047	     1C     dd  (11 * FONT_Y) + FONT_Y - 1  ; +13
 0000B2FC  000041D3 R	     1C     dd  invDEBI_checkbox_mouse_handler                        ; +17
			     1C     IFNB <_word>
 0000B300  0000AD04 R	     1C         dd  _word                   ; +21
			     1C     ELSE
			     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000B304  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B306  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_single_click       4,12, 13,12, invDEBI_checkbox_mouse_handler, _dword
			     1C ; Used when a left single-click is recognized on these coordinates
 0000B307  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000B308  00000020	     1C     dd  4 * FONT_X                 ; +1
 0000B30C  00000048	     1C     dd  12 * FONT_Y                 ; +5
 0000B310  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 0000B314  0000004D	     1C     dd  (12 * FONT_Y) + FONT_Y - 1  ; +13
 0000B318  000041D3 R	     1C     dd  invDEBI_checkbox_mouse_handler                        ; +17
			     1C     IFNB <_dword>
 0000B31C  0000AD30 R	     1C         dd  _dword                   ; +21
			     1C     ELSE
			     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000B320  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B322  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_single_click       4,13, 13,13, invDEBI_checkbox_mouse_handler, _qword
			     1C ; Used when a left single-click is recognized on these coordinates
 0000B323  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000B324  00000020	     1C     dd  4 * FONT_X                 ; +1
 0000B328  0000004E	     1C     dd  13 * FONT_Y                 ; +5
 0000B32C  0000006F	     1C     dd  (13 * FONT_X) + FONT_X - 1  ; +9
 0000B330  00000053	     1C     dd  (13 * FONT_Y) + FONT_Y - 1  ; +13
 0000B334  000041D3 R	     1C     dd  invDEBI_checkbox_mouse_handler                        ; +17
			     1C     IFNB <_qword>
 0000B338  0000AD5C R	     1C         dd  _qword                   ; +21
			     1C     ELSE
			     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000B33C  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B33E  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C 
			      C     @Left_single_click       4,14, 14,14, invDEBI_checkbox_mouse_handler, float32
			     1C ; Used when a left single-click is recognized on these coordinates
 0000B33F  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000B340  00000020	     1C     dd  4 * FONT_X                 ; +1
 0000B344  00000054	     1C     dd  14 * FONT_Y                 ; +5
 0000B348  00000077	     1C     dd  (14 * FONT_X) + FONT_X - 1  ; +9
 0000B34C  00000059	     1C     dd  (14 * FONT_Y) + FONT_Y - 1  ; +13
 0000B350  000041D3 R	     1C     dd  invDEBI_checkbox_mouse_handler                        ; +17
			     1C     IFNB <float32>
 0000B354  0000AD88 R	     1C         dd  float32                   ; +21
			     1C     ELSE
			     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000B358  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B35A  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_single_click       4,15, 14,15, invDEBI_checkbox_mouse_handler, float64
			     1C ; Used when a left single-click is recognized on these coordinates
 0000B35B  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000B35C  00000020	     1C     dd  4 * FONT_X                 ; +1
 0000B360  0000005A	     1C     dd  15 * FONT_Y                 ; +5
 0000B364  00000077	     1C     dd  (14 * FONT_X) + FONT_X - 1  ; +9
 0000B368  0000005F	     1C     dd  (15 * FONT_Y) + FONT_Y - 1  ; +13
 0000B36C  000041D3 R	     1C     dd  invDEBI_checkbox_mouse_handler                        ; +17
			     1C     IFNB <float64>
 0000B370  0000ADB4 R	     1C         dd  float64                   ; +21
			     1C     ELSE
			     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000B374  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B376  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_single_click       4,16, 14,16, invDEBI_checkbox_mouse_handler, float80
			     1C ; Used when a left single-click is recognized on these coordinates
 0000B377  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000B378  00000020	     1C     dd  4 * FONT_X                 ; +1
 0000B37C  00000060	     1C     dd  16 * FONT_Y                 ; +5
 0000B380  00000077	     1C     dd  (14 * FONT_X) + FONT_X - 1  ; +9
 0000B384  00000065	     1C     dd  (16 * FONT_Y) + FONT_Y - 1  ; +13
 0000B388  000041D3 R	     1C     dd  invDEBI_checkbox_mouse_handler                        ; +17
			     1C     IFNB <float80>
 0000B38C  0000ADE0 R	     1C         dd  float80                   ; +21
			     1C     ELSE
			     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000B390  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B392  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C 
			      C     @Left_single_click      18,18, 32,18, invDEBI_checkbox_mouse_handler, hexadecimal
			     1C ; Used when a left single-click is recognized on these coordinates
 0000B393  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000B394  00000090	     1C     dd  18 * FONT_X                 ; +1
 0000B398  0000006C	     1C     dd  18 * FONT_Y                 ; +5
 0000B39C  00000107	     1C     dd  (32 * FONT_X) + FONT_X - 1  ; +9
 0000B3A0  00000071	     1C     dd  (18 * FONT_Y) + FONT_Y - 1  ; +13
 0000B3A4  000041D3 R	     1C     dd  invDEBI_checkbox_mouse_handler                        ; +17
			     1C     IFNB <hexadecimal>
 0000B3A8  0000AE46 R	     1C         dd  hexadecimal                   ; +21
			     1C     ELSE
			     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000B3AC  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B3AE  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_single_click      18,19, 28,19, invDEBI_checkbox_mouse_handler, decimal
			     1C ; Used when a left single-click is recognized on these coordinates
 0000B3AF  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000B3B0  00000090	     1C     dd  18 * FONT_X                 ; +1
 0000B3B4  00000072	     1C     dd  19 * FONT_Y                 ; +5
 0000B3B8  000000E7	     1C     dd  (28 * FONT_X) + FONT_X - 1  ; +9
 0000B3BC  00000077	     1C     dd  (19 * FONT_Y) + FONT_Y - 1  ; +13
 0000B3C0  000041D3 R	     1C     dd  invDEBI_checkbox_mouse_handler                        ; +17
			     1C     IFNB <decimal>
 0000B3C4  0000AE72 R	     1C         dd  decimal                   ; +21
			     1C     ELSE
			     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000B3C8  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B3CA  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_single_click      18,20, 26,20, invDEBI_checkbox_mouse_handler, octal
			     1C ; Used when a left single-click is recognized on these coordinates
 0000B3CB  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000B3CC  00000090	     1C     dd  18 * FONT_X                 ; +1
 0000B3D0  00000078	     1C     dd  20 * FONT_Y                 ; +5
 0000B3D4  000000D7	     1C     dd  (26 * FONT_X) + FONT_X - 1  ; +9
 0000B3D8  0000007D	     1C     dd  (20 * FONT_Y) + FONT_Y - 1  ; +13
 0000B3DC  000041D3 R	     1C     dd  invDEBI_checkbox_mouse_handler                        ; +17
			     1C     IFNB <octal>
 0000B3E0  0000AE9E R	     1C         dd  octal                   ; +21
			     1C     ELSE
			     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000B3E4  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B3E6  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_single_click      18,21, 27,21, invDEBI_checkbox_mouse_handler, binary
			     1C ; Used when a left single-click is recognized on these coordinates
 0000B3E7  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000B3E8  00000090	     1C     dd  18 * FONT_X                 ; +1
 0000B3EC  0000007E	     1C     dd  21 * FONT_Y                 ; +5
 0000B3F0  000000DF	     1C     dd  (27 * FONT_X) + FONT_X - 1  ; +9
 0000B3F4  00000083	     1C     dd  (21 * FONT_Y) + FONT_Y - 1  ; +13
 0000B3F8  000041D3 R	     1C     dd  invDEBI_checkbox_mouse_handler                        ; +17
			     1C     IFNB <binary>
 0000B3FC  0000AECA R	     1C         dd  binary                   ; +21
			     1C     ELSE
			     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000B400  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B402  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C 
			      C     @Left_single_click      11,24, 16,24, invDEBI_exp_screen_ok
			     1C ; Used when a left single-click is recognized on these coordinates
 0000B403  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000B404  00000058	     1C     dd  11 * FONT_X                 ; +1
 0000B408  00000090	     1C     dd  24 * FONT_Y                 ; +5
 0000B40C  00000087	     1C     dd  (16 * FONT_X) + FONT_X - 1  ; +9
 0000B410  00000095	     1C     dd  (24 * FONT_Y) + FONT_Y - 1  ; +13
 0000B414  000049F6 R	     1C     dd  invDEBI_exp_screen_ok                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 0000B418  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000B41C  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B41E  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @Left_single_click      22,24, 31,24, invDEBI_kbd_input_cancel
			     1C ; Used when a left single-click is recognized on these coordinates
 0000B41F  00		     1C     db  _LEFT_SINGLE_CLICK          ; +0
 0000B420  000000B0	     1C     dd  22 * FONT_X                 ; +1
 0000B424  00000090	     1C     dd  24 * FONT_Y                 ; +5
 0000B428  000000FF	     1C     dd  (31 * FONT_X) + FONT_X - 1  ; +9
 0000B42C  00000095	     1C     dd  (24 * FONT_Y) + FONT_Y - 1  ; +13
 0000B430  000049C8 R	     1C     dd  invDEBI_kbd_input_cancel                        ; +17
			     1C     IFNB <>
			     1C         dd                     ; +21
			     1C     ELSE
 0000B434  FFFFFFFF	     1C         dd  0ffffffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         dw                     ; +25
			     1C     ELSE
 0000B438  FFFF		     1C         dw  0ffffh
			     1C     ENDIF
			     1C     IFNB <>
			     1C         db                     ; +27
			     1C     ELSE
 0000B43A  FF		     1C         db  0ffh
			     1C     ENDIF
			     1C   ; Total = 28
			      C     @End
 0000B43B  FF		     1C     db  _END
			     1C   ; Total = 1
			      C 

				; DATA
 0000B43C 4C 6F 77 2D 4C	    driver_name                             db  "Low-Level Debi Debugger",255,"(source:debi.dbg)",0
	   65 76 65 6C 20
	   44 65 62 69 20
	   44 65 62 75 67
	   67 65 72 FF 28
	   73 6F 75 72 63
	   65 3A 64 65 62
	   69 2E 64 62 67
	   29 00
 0000B466 31 30 2E 31 30	    version                                 db  "10.10.2010 BETA",0
	   2E 32 30 31 30
	   20 42 45 54 41
	   00
 0000B476 28 63 29 20 43	    copyright                               db  "(c) Copyright Beatleworks, Inc.",0
	   6F 70 79 72 69
	   67 68 74 20 42
	   65 61 74 6C 65
	   77 6F 72 6B 73
	   2C 20 49 6E 63
	   2E 00
 0000B496 52 69 63 6B 20	    author                                  db  "Rick C. Hodgin",0
	   43 2E 20 48 6F
	   64 67 69 6E 00
 0000B4A5 44 65 62 69 20	    debi_text                               db  "Debi Debugger",0
	   44 65 62 75 67
	   67 65 72 00
 0000B4B3 28 63 29 20 42	    beatleworks_text                        db  "(c) Beatleworks, Inc. 2010",0
	   65 61 74 6C 65
	   77 6F 72 6B 73
	   2C 20 49 6E 63
	   2E 20 32 30 31
	   30 00
 0000B4CE 01			    bootup                                  db  1                   ; Changed to 0 after bootup is complete

				;    success_my_lord                         db  "DEBI.Success my lord!",0
				;    success_my_lord_clear                   db  "                     ",0
 0000B4CF 23 FA FA 20 2D	    step_over_text                          db  "#˙˙ - step over",0
	   20 73 74 65 70
	   20 6F 76 65 72
	   00
 0000B4DF 23 30 30 20 2D	    int0_text                               db  "#00 - divide error",0
	   20 64 69 76 69
	   64 65 20 65 72
	   72 6F 72 00
 0000B4F2 23 30 31 20 2D	    int1_text                               db  "#01 - single-step",0
	   20 73 69 6E 67
	   6C 65 2D 73 74
	   65 70 00
 0000B504 23 30 32 20 2D	    int2_text                               db  "#02 - no description",0
	   20 6E 6F 20 64
	   65 73 63 72 69
	   70 74 69 6F 6E
	   00
 0000B519 23 30 33 20 2D	    int3_text                               db  "#03 - breakpoint",0
	   20 62 72 65 61
	   6B 70 6F 69 6E
	   74 00
 0000B52A 23 30 34 20 2D	    int4_text                               db  "#04 - overflow",0
	   20 6F 76 65 72
	   66 6C 6F 77 00
 0000B539 23 30 35 20 2D	    int5_text                               db  "#05 - bound range exceeded",0
	   20 62 6F 75 6E
	   64 20 72 61 6E
	   67 65 20 65 78
	   63 65 65 64 65
	   64 00
 0000B554 23 30 36 20 2D	    int6_text                               db  "#06 - invalid opcode",0
	   20 69 6E 76 61
	   6C 69 64 20 6F
	   70 63 6F 64 65
	   00
 0000B569 23 30 37 20 2D	    int7_text                               db  "#07 - device not available",0
	   20 64 65 76 69
	   63 65 20 6E 6F
	   74 20 61 76 61
	   69 6C 61 62 6C
	   65 00
 0000B584 23 30 38 20 2D	    int8_text                               db  "#08 - double fault",0
	   20 64 6F 75 62
	   6C 65 20 66 61
	   75 6C 74 00
 0000B597 23 30 39 20 2D	    int9_text                               db  "#09 - coprocessor segment overrun",0
	   20 63 6F 70 72
	   6F 63 65 73 73
	   6F 72 20 73 65
	   67 6D 65 6E 74
	   20 6F 76 65 72
	   72 75 6E 00
 0000B5B9 23 31 30 20 2D	    int10_text                              db  "#10 - invalid tss",0
	   20 69 6E 76 61
	   6C 69 64 20 74
	   73 73 00
 0000B5CB 23 31 31 20 2D	    int11_text                              db  "#11 - segment not present",0
	   20 73 65 67 6D
	   65 6E 74 20 6E
	   6F 74 20 70 72
	   65 73 65 6E 74
	   00
 0000B5E5 23 31 32 20 2D	    int12_text                              db  "#12 - stack fault",0
	   20 73 74 61 63
	   6B 20 66 61 75
	   6C 74 00
 0000B5F7 23 31 33 20 2D	    int13_text                              db  "#13 - general protection fault",0
	   20 67 65 6E 65
	   72 61 6C 20 70
	   72 6F 74 65 63
	   74 69 6F 6E 20
	   66 61 75 6C 74
	   00
 0000B616 23 31 34 20 2D	    int14_text                              db  "#14 - page fault",0
	   20 70 61 67 65
	   20 66 61 75 6C
	   74 00
 0000B627 23 31 35 20 2D	    int15_text                              db  "#15 - no description",0
	   20 6E 6F 20 64
	   65 73 63 72 69
	   70 74 69 6F 6E
	   00
 0000B63C 23 31 36 20 2D	    int16_text                              db  "#16 - floating point",0
	   20 66 6C 6F 61
	   74 69 6E 67 20
	   70 6F 69 6E 74
	   00
 0000B651 23 31 37 20 2D	    int17_text                              db  "#17 - alignment check",0
	   20 61 6C 69 67
	   6E 6D 65 6E 74
	   20 63 68 65 63
	   6B 00
 0000B667 23 31 38 20 2D	    int18_text                              db  "#18 - machine check",0
	   20 6D 61 63 68
	   69 6E 65 20 63
	   68 65 63 6B 00

 0000B67B C4 C4 C4 C4 C4	    quick_watch_divider                     db  "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ",0
	   C4 C4 C4 C4 C4
	   C4 C4 C4 C4 C4
	   C4 C4 C4 C4 C4
	   C4 C4 C4 C4 C4
	   C4 C4 C4 C4 00
 0000B699 1B 6E 65 61 72	    round_to_nearest                        db  "nearest ",0
	   65 73 74 1A 00
 0000B6A3 1B 64 6F 77 6E	    round_down                              db  "down",0
	   00
 0000B6A9 75 70 1A 00		    round_up                                db  "up ",0
 0000B6AD 7C 63 68 6F 70	    round_truncate                          db  "|chop|",0
	   7C 00
 0000B6B4 32 34 2D 62 69	    precision_single                        db  "24-bit [w/1]",0
	   74 20 5B 77 2F
	   31 5D 00
 0000B6C1 5B 70 72 65 63	    precision_reserved                      db  "[precision: 01b]",0
	   69 73 69 6F 6E
	   3A 20 30 31 62
	   5D 00
 0000B6D2 35 33 2D 62 69	    precision_double                        db  "53-bit [w/1]",0
	   74 20 5B 77 2F
	   31 5D 00
 0000B6DF 36 34 2D 62 69	    precision_extended                      db  "64-bit",0
	   74 00
 0000B6E6 70 72 65 63 69	    precision_text                          db  "precision",0
	   73 69 6F 6E 00
 0000B6F0 75 6E 64 65 72	    underflow_text                          db  "underflow",0
	   66 6C 6F 77 00
 0000B6FA 6F 76 65 72 66	    overflow_text                           db  "overflow",0
	   6C 6F 77 00
 0000B703 64 69 76 69 64	    divide_by_zero_text                     db  "divide-by-zero",0
	   65 2D 62 79 2D
	   7A 65 72 6F 00
 0000B712 64 65 6E 6F 72	    denormalized_text                       db  "denormalized",0
	   6D 61 6C 69 7A
	   65 64 00
 0000B71F 69 6E 76 61 6C	    invalid_text                            db  "invalid operation",0
	   69 64 20 6F 70
	   65 72 61 74 69
	   6F 6E 00
 0000B731 65 72 72 6F 72	    error_summary                           db  "error summary",0
	   20 73 75 6D 6D
	   61 72 79 00
 0000B73F 73 74 61 63 6B	    stack_fault                             db  "stack fault",0
	   20 66 61 75 6C
	   74 00
 0000B74B 62 75 73 79		    busy                                    db  "busy"
 0000B74F 76 61 6C 69 64	    tag_valid                               db  "valid",0
	   00
 0000B755 7A 65 72 6F 00	    tag_zero                                db  "zero",0
 0000B75A 69 6E 76 61 6C	    tag_special                             db  "invalid",0
	   69 64 00
 0000B762 65 6D 70 74 79	    tag_empty                               db  "empty",0
	   00


				                                           ; type, number_of_bits
 0000B768 00 10			    edit_word                               db  0, 16               ; type=0 indicates hexidecimal editing
 0000B76A 00 20			    edit_dword                              db  0, 32               ; type=1 indicates binary editing
 0000B76C 01 20			    edit_binary_32                          db  1, 32               ; number_of_bits indicates how many bits are to be modified
 0000B76E 01 01			    edit_flags                              db  1,  1

 0000B770 FFFFFFFF		    instruction_offset                      dd  -1
 0000B774 FFFFFFFF		    instruction_length                      dd  -1
 0000B778 00			    step_over                               db  0
 0000B779 FFFFFFFF		    step_offset                             dd  -1
 0000B77D 00			    step_replaced_byte                      db  0

 0000B77E 00			    break_here_var                          db  0
 0000B77F 0000			    data_segment                            dw  0
 0000B781 00			    disable_mouse                           db  0
 0000B782 00			    disable_kbd                             db  0
 0000B783 00			    disable_timer                           db  0
 0000B784 00			    debug_levels                            db  0
 0000B785 00			    debug_screen_shown                      db  0
 0000B786 00			    force_screen_redraw                     db  0
 0000B787 00			    debi_ok_to_quit                         db  0
 0000B788 00000000		    object_mode                             dd  0                   ; 0-root, 1-a popup, menu or dialogue
 0000B78C 00000000		    kbd_object                              dd  0
 0000B790 00000000		    save_kbd_object                         dd  0
 0000B794 FFFFFFFF		    kbd_focus                               dd  -1
 0000B798 00000000		    mouse_objects                           dd  0
 0000B79C 00000000		    screen_object                           dd  0
 0000B7A0 00000000		    draw_menu                               dd  0
 0000B7A4 00000000		    menu_queue                              dd  0
 0000B7A8 FF			    last_menu_item                          db  0ffh
 0000B7A9 00000000		    dragging_something                      dd  0
 0000B7AD 00000000		    dragging_x                              dd  0
 0000B7B1 00000000		    dragging_y                              dd  0
 0000B7B5 00000000		    dragging_height                         dd  0
 0000B7B9 00000000		    dragging_width                          dd  0
 0000B7BD 00000000		    dragging_offset_x                       dd  0
 0000B7C1 00000000		    dragging_offset_y                       dd  0
 0000B7C5 00000000		    dragging_snap_x                         dd  0
 0000B7C9 00000000		    dragging_snap_y                         dd  0
 0000B7CD 00000000		    dragging_last_x                         dd  0
 0000B7D1 00000000		    dragging_last_y                         dd  0
 0000B7D5 00000000		    dragging_skipped                        dd  0
 0000B7D9 00000000		    dragging_esi                            dd  0
 0000B7DD 00000000		    dragging_edi                            dd  0
 0000B7E1 00000000		    dragging_object                         dd  0
 0000B7E5 0000015E		    mouse_current_x                         dd  350
 0000B7E9 00000096		    mouse_current_y                         dd  150
 0000B7ED FFFFFFFF		    mouse_hovering_x                        dd  -1
 0000B7F1 FFFFFFFF		    mouse_hovering_y                        dd  -1
 0000B7F5 FFFFFFFF		    mouse_hovering_count                    dd  -1
 0000B7F9 FFFFFFFF		    mouse_clicking_count                    dd  -1
 0000B7FD FFFFFFFF		    mouse_immediate_count                   dd  -1
 0000B801 00			    mouse_last_event                        db  0
 0000B802 00000000		    mouse_status                            dd  0                   ; Is mouse displayed?  1-Yes, 0-No
 0000B806 00000000		    mouse_processing                        dd  0                   ; Is this program processing?  1-Yes, 0-No
 0000B80A 00000000		    mouse_last_buttons                      dd  0                   ; Button status from previous packet
 0000B80E 00000000		    mouse_last_button_left                  dd  0
 0000B812 00000000		    mouse_last_button_right                 dd  0
 0000B816 00000000		    mouse_button_left                       dd  0
 0000B81A 00000000		    mouse_button_right                      dd  0
 0000B81E 00000000		    mouse_left_dragging                     dd  0
 0000B822 00000000		    mouse_right_dragging                    dd  0
				;    mouse_left_delta_x                      dd  0
				;    mouse_left_delta_y                      dd  0
				;    mouse_right_delta_x                     dd  0
				;    mouse_right_delta_y                     dd  0
 0000B826 00000000		    mouse_right_click_x_start               dd  0
 0000B82A 00000000		    mouse_right_click_y_start               dd  0
 0000B82E 00000000		    mouse_left_click_x_start                dd  0
 0000B832 00000000		    mouse_left_click_y_start                dd  0
 0000B836 00000000		    mouse_right_click_x_stop                dd  0
 0000B83A 00000000		    mouse_right_click_y_stop                dd  0
 0000B83E 00000000		    mouse_left_click_x_stop                 dd  0
 0000B842 00000000		    mouse_left_click_y_stop                 dd  0
 0000B846 00000000		    mouse_right_click                       dd  0
 0000B84A 00000000		    mouse_left_click                        dd  0
 0000B84E 00000000		    mouse_both_click                        dd  0
 0000B852 00000005		    vertical_dragging_threshold             dd  5
 0000B856 0000000A		    horizontal_dragging_threshold           dd  10
 0000B85A 01			    mouse_allowed                           db  1                   ; Are mouse pointer read/write operations allowed?  1-Yes, 0-No
 0000B85B  00000010 [		    mouse_save_area                         dd  16 dup(0)           ; 64 bytes
	    00000000
	   ]
 0000B89B 00000000		    timer_interface_count                   dd  0
 0000B89F 00000000		    screen_saver_count                      dd  0
 0000B8A3 00			    screen_saver                            db  0
 0000B8A4 0000000F		    cursor_x                                dd  15
 0000B8A8 0000000F		    cursor_y                                dd  15
 0000B8AC 00000000		    cursor_count                            dd  0
 0000B8B0 00			    cursor                                  db  0
 0000B8B1 01			    force_cursor_off                        db  1
 0000B8B2 00			    force_func_windows                      db  _NO

 0000B8B3 00000000		    general_menu_esi                        dd  0
 0000B8B7 00000000		    general_menu_edi                        dd  0
 0000B8BB 01			    menu_restore_screen_after               db  _YES

 0000B8BC 00000000		    mem_ul_x                                dd  0                   ; Used by the mem.x window algorithms for displaying data
 0000B8C0 00000000		    mem_ul_y                                dd  0
 0000B8C4 00000000		    mem_width                               dd  0
 0000B8C8 00000000		    mem_height                              dd  0
 0000B8CC 00000000		    mem_segment                             dd  0                   ; Seg:Offset+Disp to display
 0000B8D0 00000000		    mem_offset                              dd  0
 0000B8D4 00000000		    mem_displacement                        dd  0
 0000B8D8 00000000		    mem_limit                               dd  0                   ; Limit for Seg
 0000B8DC 00000000		    mem_temp_x                              dd  0
 0000B8E0 00000000		    mem_max_x                               dd  0

 0000B8E4 00000000		    fpu_esi                                 dd  0                   ; esi when this function was called
 0000B8E8 00000000		    fpu_edi                                 dd  0                   ; edi
 0000B8EC 00000000		    fpu_x                                   dd  0                   ; mouse X coord where right-click happened
 0000B8F0 00000000		    fpu_y                                   dd  0                   ; mouse Y coord
 0000B8F4 00000000		    fpu_data                                dd  0                   ; miscellaneous data
 0000B8F8 00000000		    fpu_source                              dd  0
 0000B8FC 00000000		    fpu_dest                                dd  0

 0000B900 00000000		    exp_esi                                 dd  0
 0000B904 00000000		    exp_edi                                 dd  0

				  ; Textbox related items
 0000B908 00000000		    textbox_x                               dd  0
 0000B90C 00000000		    textbox_y                               dd  0
 0000B910 00000000		    textbox_offset                          dd  0
 0000B914 00000000		    textbox_sel_start                       dd  0
 0000B918 00000000		    textbox_sel_end                         dd  0

				  ; Checkbox related items
 0000B91C 00000000		    checkbox_x                              dd  0
 0000B920 00000000		    checkbox_y                              dd  0
 0000B924 00000000		    checkbox_offset                         dd  0                   ; How far from left-side is the actual checkbox?

				  ; Button related items
 0000B928 00000000		    button_x                                dd  0
 0000B92C 00000000		    button_y                                dd  0
 0000B930 00000000		    button_offset                           dd  0                   ; How far from left-side is the actual text on the button?

				  ; Function related items
 0000B934 00000000		    function_x                              dd  0
 0000B938 00000000		    function_y                              dd  0

 0000B93C FFFFFFFF		    insert_mode                             dd  ON                  ; Default to insert mode

				    ; CFSCA variables
 0000B940 FFFFFFFF		    single_step_history                     dd  -1
 0000B944 00000000		    single_step_top                         dd  0
 0000B948 00000000		    single_step_end                         dd  0

				  ; Variables used for FPU conversion
 0000B94C  00000068 [		    FPU_fsave_scratch                       db  104 dup(0)
	    00
	   ]
 0000B9B4  0000005B [		    trash_string                            db  91 dup(0)           ; Used various places
	    00
	   ]
 0000BA0F 00000000		    trash_dword                             dd  0
 0000BA13  0000000A [		    trash_10_bytes                          dd  10 dup(0)
	    00000000
	   ]
 0000BA3B 00000000		    trash_counter                           dd  0

 0000BA3F 0000			    FPCtrl                                  dw  0
 0000BA41 0000			    FPStat                                  dw  0
 0000BA43 00000000		    exponent                                dd  0
 0000BA47 00000000		    signed_digits                           dd  0
 0000BA4B 0000000A		    number10                                dd  10
 0000BA4F 00000000		    digit                                   dd  0
 0000BA53 20 AE 3C 75 6E	    bad_number0                             db  " Æ<unsupported>Ø",0
	   73 75 70 70 6F
	   72 74 65 64 3E
	   AF 00
 0000BA64 20 AE 3C 6E 61	    bad_number1                             db  " Æ<nan>Ø",0
	   6E 3E AF 00
 0000BA6D 20 AE 3C 2D 75	    bad_number2                             db  " Æ<-unsupported>Ø",0
	   6E 73 75 70 70
	   6F 72 74 65 64
	   3E AF 00
 0000BA7F 20 AE 3C 2D 6E	    bad_number3                             db  " Æ<-nan>Ø",0
	   61 6E 3E AF 00
				;   bad_number4                             db  " Æ<+normal>Ø",0
 0000BA89 20 AE 3C 2B 69	    bad_number5                             db  " Æ<+infinity>Ø",0
	   6E 66 69 6E 69
	   74 79 3E AF 00
				;   bad_number6                             db  " Æ<-normal>Ø",0
 0000BA98 20 AE 3C 2D 69	    bad_number7                             db  " Æ<-infinity>Ø",0
	   6E 66 69 6E 69
	   74 79 3E AF 00
				;   bad_number8                             db  " Æ<+zero>Ø",0
 0000BAA7 20 AE 3C 65 6D	    bad_number9                             db  " Æ<empty>Ø",0
	   70 74 79 3E AF
	   00
				;   bad_number10                            db  " Æ<-zero>Ø",0
 0000BAB2 20 AE 3C 2D 65	    bad_number11                            db  " Æ<-empty>Ø",0
	   6D 70 74 79 3E
	   AF 00
 0000BABE 20 AE 3C 64 65	    bad_number12                            db  " Æ<denormals>Ø",0
	   6E 6F 72 6D 61
	   6C 73 3E AF 00
 0000BACD 20 AE 3C 75 6E	    bad_number13                            db  " Æ<unknown>Ø",0
	   6B 6E 6F 77 6E
	   3E AF 00
 0000BADA 20 AE 3C 2D 64	    bad_number14                            db  " Æ<-denormals>Ø",0
	   65 6E 6F 72 6D
	   61 6C 73 3E AF
	   00
 0000BAEA 20 AE 3C 65 6D	    number_empty                            db  " Æ<empty>Ø",0
	   70 74 79 3E AF
	   00

 0000BAF5 03 65 61 78 09	    reg_list                                db  3,"eax", _EAX, _STACK_EAX
	   2C
 0000BAFB  03 65 62 78 0D	                                            db  3,"ebx", _EBX, _STACK_EBX
	   28
 0000BB01  03 65 63 78 11	                                            db  3,"ecx", _ECX, _STACK_ECX
	   24
 0000BB07  03 65 64 78 15	                                            db  3,"edx", _EDX, _STACK_EDX
	   20
 0000BB0D  03 65 73 69 17	                                            db  3,"esi", _ESI, _STACK_ESI
	   1C
 0000BB13  03 65 64 69 19	                                            db  3,"edi", _EDI, _STACK_EDI
	   18
 0000BB19  03 65 62 70 1D	                                            db  3,"ebp", _EBP, _STACK_EBP
	   00
 0000BB1F  03 65 73 70 1F	                                            db  3,"esp", _ESP, _STACK_ESP
	   FC
 0000BB25  03 65 69 70 1B	                                            db  3,"eip", _EIP, _STACK_EIP
	   34
 0000BB2B  06 65 66 6C 61	                                            db  6,"eflags", _EFLAGS, _STACK_EFLAGS
	   67 73 20 3C
 0000BB34  05 65 63 6F 64	                                            db  5,"ecode", _ECODE, _STACK_ERROR_CODE
	   65 21 30
 0000BB3C  02 63 73 00 38	                                            db  2,"cs", _CS, _STACK_CS
 0000BB41  02 64 73 01 14	                                            db  2,"ds", _DS, _STACK_DS
 0000BB46  02 65 73 02 10	                                            db  2,"es", _ES, _STACK_ES          ; Note, must appear after esi (because of es)
 0000BB4B  02 66 73 03 0C	                                            db  2,"fs", _FS, _STACK_FS
 0000BB50  02 67 73 04 08	                                            db  2,"gs", _GS, _STACK_GS
 0000BB55  02 73 73 05 04	                                            db  2,"ss", _SS, _STACK_SS
 0000BB5A  02 61 6C 06 2C	                                            db  2,"al", _AL, _STACK_AL
 0000BB5F  02 62 6C 0A 28	                                            db  2,"bl", _BL, _STACK_BL
 0000BB64  02 63 6C 0E 24	                                            db  2,"cl", _CL, _STACK_CL
 0000BB69  02 64 6C 12 20	                                            db  2,"dl", _DL, _STACK_DL
 0000BB6E  02 61 68 07 2D	                                            db  2,"ah", _AH, _STACK_AH
 0000BB73  02 62 68 0B 29	                                            db  2,"bh", _BH, _STACK_BH
 0000BB78  02 63 68 0F 25	                                            db  2,"ch", _CH, _STACK_CH
 0000BB7D  02 64 68 13 21	                                            db  2,"dh", _DH, _STACK_DH
 0000BB82  02 61 78 08 2C	                                            db  2,"ax", _AX, _STACK_AX
 0000BB87  02 62 78 0C 28	                                            db  2,"bx", _BX, _STACK_BX
 0000BB8C  02 63 78 10 24	                                            db  2,"cx", _CX, _STACK_CX
 0000BB91  02 64 78 14 20	                                            db  2,"dx", _DX, _STACK_DX
 0000BB96  02 73 69 16 1C	                                            db  2,"si", _SI, _STACK_SI
 0000BB9B  02 64 69 18 18	                                            db  2,"di", _DI, _STACK_DI
 0000BBA0  02 62 70 1C 00	                                            db  2,"bp", _BP, _STACK_BP
 0000BBA5  02 73 70 1E FC	                                            db  2,"sp", _SP, _STACK_SP
 0000BBAA  02 69 70 1A 34	                                            db  2,"ip", _IP, _STACK_IP
 0000BBAF  FF			                                            db  -1

 0000BBB0 00			    seg_specified                           db  _NO
 0000BBB1 00000000		    seg_to_use                              dd  0
 0000BBB5 00000000		    offset_to_use                           dd  0
 0000BBB9 00			    last_operator                           db  _NONE

				  ; Used for displaying the selector information when the mouse hovers over it
 0000BBBA			  keyword_listing:      ; keyword_listing (the structure) is used by invDEBI_parse_expression().invDEBI_search_keywords()
 0000BBBA  05			                                            db  5
 0000BBBB 5F 73 49 44 54	    _sIDT_text                              db  "_sIDT",0
	   00
 0000BBC1  0008			                                            dw  _sIDT
 0000BBC3  05			                                            db  5
 0000BBC4 5F 73 47 44 54	    _sGDT_text                              db  "_sGDT",0
	   00
 0000BBCA  0010			                                            dw  _sGDT
 0000BBCC  07			                                            db  7
 0000BBCD 5F 73 53 54 41	    _sSTACK_text                            db  "_sSTACK",0
	   43 4B 00
 0000BBD5  0018			                                            dw  _sSTACK
 0000BBD7  06			                                            db  6
 0000BBD8 5F 73 43 4F 44	    _sCODE_text                             db  "_sCODE",0
	   45 00
 0000BBDF  0020			                                            dw  _sCODE
 0000BBE1  0A			                                            db  10
 0000BBE2 5F 73 47 52 41	    _sGRAPHICS_text                         db  "_sGRAPHICS",0
	   50 48 49 43 53
	   00
 0000BBED  0028			                                            dw  _sGRAPHICS
 0000BBEF  06			                                            db  6
 0000BBF0 5F 73 4D 4F 4E	    _sMONO_text                             db  "_sMONO",0
	   4F 00
 0000BBF7  0030			                                            dw  _sMONO
 0000BBF9  05			                                            db  5
 0000BBFA 5F 73 56 47 41	    _sVGA_text                              db  "_sVGA",0
	   00
 0000BC00  0038			                                            dw  _sVGA
 0000BC02  09			                                            db  9
 0000BC03 5F 73 41 4C 4C	    _sALL_MEM_text                          db  "_sALL_MEM",0
	   5F 4D 45 4D 00
 0000BC0D  0040			                                            dw  _sALL_MEM
 0000BC0F  06			                                            db  6
 0000BC10 5F 73 44 41 54	    _sDATA_text                             db  "_sDATA",0
	   41 00
 0000BC17  0048			                                            dw  _sDATA
 0000BC19  0C			                                            db  12
 0000BC1A 5F 73 45 58 4F	    _sEXODUS_MEM_text                       db  "_sEXODUS_MEM",0
	   44 55 53 5F 4D
	   45 4D 00
 0000BC27  0050			                                            dw  _sEXODUS_MEM
 0000BC29  0E			                                            db  14
 0000BC2A 5F 73 45 58 4F	    _sEXODUS_PORTS_text                     db  "_sEXODUS_PORTS",0
	   44 55 53 5F 50
	   4F 52 54 53 00
 0000BC39  0058			                                            dw  _sEXODUS_PORTS
 0000BC3B  0D			                                            db  13
 0000BC3C 5F 73 45 58 4F	    _sEXODUS_INTS_text                      db  "_sEXODUS_INTS",0
	   44 55 53 5F 49
	   4E 54 53 00
 0000BC4A  0060			                                            dw  _sEXODUS_INTS
 0000BC4C  0C			                                            db  12
 0000BC4D 5F 73 45 58 4F	    _sEXODUS_TSS_text                       db  "_sEXODUS_TSS",0
	   44 55 53 5F 54
	   53 53 00
 0000BC5A  0070			                                            dw  _sEXODUS_TSS
 0000BC5C  08			                                            db  8
 0000BC5D 5F 73 53 54 41	    _sSTACK0_text                           db  "_sSTACK0",0
	   43 4B 30 00
 0000BC66  0120			                                            dw  _sSTACK0
 0000BC68  08			                                            db  8
 0000BC69 5F 73 53 54 41	    _sSTACK1_text                           db  "_sSTACK1",0
	   43 4B 31 00
 0000BC72  0128			                                            dw  _sSTACK1
 0000BC74  08			                                            db  8
 0000BC75 5F 73 53 54 41	    _sSTACK2_text                           db  "_sSTACK2",0
	   43 4B 32 00
 0000BC7E  0130			                                            dw  _sSTACK2
 0000BC80  0C			                                            db  12
 0000BC81 5F 73 50 52 49	    _sPRIMATIVES_text                       db  "_sPRIMATIVES",0
	   4D 41 54 49 56
	   45 53 00
 0000BC8E  0098			                                            dw  _sPRIMATIVES
 0000BC90  08			                                            db  8
 0000BC91 5F 73 53 59 53	    _sSYSTEM_text                           db  "_sSYSTEM",0
	   54 45 4D 00
 0000BC9A  00A8			                                            dw  _sSYSTEM
 0000BC9C  12			                                            db  18
 0000BC9D 5F 73 45 58 4F	    _sEXODUS_REQUESTOR_text                 db  "_sEXODUS_REQUESTOR",0
	   44 55 53 5F 52
	   45 51 55 45 53
	   54 4F 52 00
 0000BCB0  00B0			                                            dw  _sEXODUS_REQUESTOR
 0000BCB2  0E			                                            db  14
 0000BCB3 5F 73 53 59 53	    _sSYSTEM_RING1_text                     db  "_sSYSTEM_RING1",0
	   54 45 4D 5F 52
	   49 4E 47 31 00
 0000BCC2  00B8			                                            dw  _sSYSTEM_RING1
 0000BCC4  0E			                                            db  14
 0000BCC5 5F 73 53 59 53	    _sSYSTEM_RING2_text                     db  "_sSYSTEM_RING2",0
	   54 45 4D 5F 52
	   49 4E 47 32 00
 0000BCD4  00C0			                                            dw  _sSYSTEM_RING2
 0000BCD6  0E			                                            db  14
 0000BCD7 5F 73 53 59 53	    _sSYSTEM_RING3_text                     db  "_sSYSTEM_RING3",0
	   54 45 4D 5F 52
	   49 4E 47 33 00
 0000BCE6  00C8			                                            dw  _sSYSTEM_RING3
 0000BCE8  0D			                                            db  13
 0000BCE9 5F 73 44 45 42	    _sDEBI_screen_text                      db  "_sDEBI_screen",0
	   49 5F 73 63 72
	   65 65 6E 00
 0000BCF7  00D0			                                            dw  _sDEBI_screen
 0000BCF9  0E			                                            db  14
 0000BCFA 5F 73 44 45 42	    _sDEBI_memory_text                      db  "_sDEBI_memory",0
	   49 5F 6D 65 6D
	   6F 72 79 00
 0000BD08  00D8			                                            dw  _sDEBI_memory
 0000BD0A  0E			                                            db  14
 0000BD0B 5F 73 46 4C 4F	    _sFLOPPY_TRACK_text                     db  "_sFLOPPY_TRACK",0
	   50 50 59 5F 54
	   52 41 43 4B 00
 0000BD1A  00E0			                                            dw  _sFLOPPY_TRACK
 0000BD1C  0C			                                            db  12
 0000BD1D 5F 73 56 47 41	    _sVGA_BACKUP_text                       db  "_sVGA_BACKUP",0
	   5F 42 41 43 4B
	   55 50 00
 0000BD2A  00E8			                                            dw  _sVGA_BACKUP
 0000BD2C  0C			                                            db  12
 0000BD2D 5F 73 45 58 4F	    _sEXODUS_INI_text                       db  "_sEXODUS_INI",0
	   44 55 53 5F 49
	   4E 49 00
 0000BD3A  0190			                                            dw  _sEXODUS_INI
 0000BD3C  13			                                            db  19
 0000BD3D 5F 73 45 58 4F	    _sEXODUS_INI_ERRORS_text                db  "_sEXODUS_INI_ERRORS",0
	   44 55 53 5F 49
	   4E 49 5F 45 52
	   52 4F 52 53 00
 0000BD51  0198			                                            dw  _sEXODUS_INI_ERRORS
 0000BD53  0D			                                            db  13
 0000BD54 5F 73 54 41 53	    _sTASK_SYSTEM_text                      db  "_sTASK_SYSTEM",0
	   4B 5F 53 59 53
	   54 45 4D 00
 0000BD62  01A0			                                            dw  _sTASK_SYSTEM
 0000BD64  FF			                                            db  -1
 0000BD65 5F 73 45 58 4F	    _sEXODUS_TSS_GATE_text                  db  "_sEXODUS_TSS_GATE",0
	   44 55 53 5F 54
	   53 53 5F 47 41
	   54 45 00
 0000BD77 5F 73 50 52 49	    _sPRIMATIVES_LOAD_INFO_text             db  "_sPRIMATIVES_LOAD_INFO",0
	   4D 41 54 49 56
	   45 53 5F 4C 4F
	   41 44 5F 49 4E
	   46 4F 00
 0000BD8E 73 65 6C 65 63	    _selector_text                          db  "selector: ",0
	   74 6F 72 3A 20
	   00

 0000BD99 68 65 78 3A 20	    hex_text                                db  "hex: ",0
	   00
 0000BD9F 64 65 63 3A 20	    dec_text                                db  "dec: ",0
	   00
 0000BDA5 62 69 6E 3A 20	    bin_text                                db  "bin: ",0
	   00
 0000BDAB			  real32_text:
 0000BDAB 72 33 32 3A 20	    real4_text                              db  "r32: ",0
	   00
 0000BDB1			  real64_text:
 0000BDB1 72 36 34 3A 20	    real8_text                              db  "r64: ",0
	   00
 0000BDB7			  real80_text:
 0000BDB7 72 38 30 3A 20	    real10_text                             db  "r80: ",0
	   00
 0000BDBD 64 69 73 61 73	    disasm_text                             db  "disasm: ",0
	   6D 3A 20 00
 0000BDC6 72 6F 75 6E 64	    rounding_text                           db  "rounding: ",0
	   69 6E 67 3A 20
	   00
 0000BDD1 70 72 65 63 69	    precision_prefix_text                   db  "precision: ",0
	   73 69 6F 6E 3A
	   20 00
 0000BDDD 65 78 63 65 70	    exception_prefix_text                   db  "exception: ",0
	   74 69 6F 6E 3A
	   20 00
 0000BDE9 6D 61 73 6B 3A	    mask_text                               db  "mask: ",0
	   20 00
 0000BDF0 43 33 32 31 30	    condition_codes_text                    db  "C3210: ",0
	   3A 20 00
 0000BDF8 54 4F 53 3A 20	    top_of_stack_text                       db  "TOS: ",0
	   00
 0000BDFE 73 74 78 3A 20	    stx_text                                db  "stx: ",0
	   00

 0000BE04 FA FA 00		    empty_byte_text                         db  "˙˙",0
 0000BE07 FA FA FA FA 00	    empty_word_text                         db  "˙˙˙˙",0
 0000BE0C FA FA FA FA FA	    empty_dword_text                        db  "˙˙˙˙˙˙˙˙",0
	   FA FA FA 00
 0000BE15 FA FA FA FA FA	    empty_16_byte_hex_string_text           db  "˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙",0
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA FA 00
 0000BE36 FA FA FA FA FA	    empty_16_byte_string_text               db  "˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙",0
	   FA FA FA FA FA
	   FA FA FA FA FA
	   FA 00

 0000BE47  00000C00 [		    menu_area                               db  3072 dup(0ffh)      ; Max of 3K for menu items
	    FF
	   ]
 0000CA47  00000690 [		    menu_mouse_objects                      db  60 * 28 dup(0ffh)   ; 60 = max # of mouse items active at one time
	    FF
	   ]
				                                                                    ; 28 = width of each mouse object

 0000D0D7 0000			    _EXODUS_requestor                       dw  0
 0000D0D9			  primative_call_gates:
 0000D0D9 0000			    _VID_draw_logo                          dw  0
 0000D0DB 00B0			    _VID_display_string_nr_vga              dw  _sEXODUS_REQUESTOR
 0000D0DD F000			    _VID_display_string_mono                dw  0f000h
 0000D0DF F000			    _VID_clear_screen_mono                  dw  0f000h
 0000D0E1 F000			    _VID_g_mono_display_text_mode           dw  0f000h
 0000D0E3 F000			    _VID_g_mono_display_text                dw  0f000h
 0000D0E5 F000			    _iKBD_activate_DEBI_intercept           dw  0f000h
 0000D0E7 F000			    _iKBD_deactivate_DEBI_intercept         dw  0f000h
 0000D0E9 F000			    _iMOUSE_activate_DEBI_intercept         dw  0f000h
 0000D0EB F000			    _iMOUSE_deactivate_DEBI_intercept       dw  0f000h
 0000D0ED F000			    _VID_g_mono_mouse_pointer               dw  0f000h
 0000D0EF F000			    _VID_g_set_font_8x6                     dw  0f000h
 0000D0F1 F000			    _VID_g_set_font_8x8                     dw  0f000h
 0000D0F3 F000			    _VID_g_set_font_8x14                    dw  0f000h
 0000D0F5 F000			    _VID_g_set_font_16x16                   dw  0f000h
 0000D0F7 F000			    _iTIMER_activate_DEBI_timer_feed        dw  0f000h
 0000D0F9 F000			    _iTIMER_deactivate_DEBI_timer_feed      dw  0f000h
 0000D0FB F000			    _TASK_release_timeslice                 dw  0f000h
 0000D0FD F000			    _VID_g_mono_window_function             dw  0f000h
 0000D0FF F000			    _VID_position_cursor_mono               dw  0f000h
 0000D101 F000			    _VID_g_display_radix_in_edx_mono        dw  0f000h
 0000D103 F000			    _VID_g_mono_cursor                      dw  0f000h
 0000D105 F000			    _VID_g_claim_ownership                  dw  0f000h
 0000D107 F000			    _VID_g_release_ownership                dw  0f000h
 0000D109 F000			    _VID_g_mono_enter_graphics_mode         dw  0f000h
 0000D10B F000			    _X86_disassemble                        dw  0f000h
 0000D10D F000			    _X86_simplify_disassembly               dw  0f000h
 0000D10F F000			    _X86_assemble                           dw  0f000h
 0000D111 F000			    _X86_fpu_opcode                         dw  0f000h
 0000D113 F000			    _VID_g_mono_cursor_no_insert            dw  0f000h
 0000D115 F000			    _iMOUSE_bochs_DEBI_intercept            dw  0f000h
 0000D117  F000			                                            dw  0f000h
 0000D119  F000			                                            dw  0f000h

 0000D11B 0D 56 49 44 5F	    required_primatives                     db  13, "VID_draw_logo"
	   64 72 61 77 5F
	   6C 6F 67 6F
 0000D129  19 56 49 44 5F	                                            db  25, "VID_display_string_nr_vga"
	   64 69 73 70 6C
	   61 79 5F 73 74
	   72 69 6E 67 5F
	   6E 72 5F 76 67
	   61
 0000D143  17 56 49 44 5F	                                            db  23, "VID_display_string_mono"
	   64 69 73 70 6C
	   61 79 5F 73 74
	   72 69 6E 67 5F
	   6D 6F 6E 6F
 0000D15B  15 56 49 44 5F	                                            db  21, "VID_clear_screen_mono"
	   63 6C 65 61 72
	   5F 73 63 72 65
	   65 6E 5F 6D 6F
	   6E 6F
 0000D171  1C 56 49 44 5F	                                            db  28, "VID_g_mono_display_text_mode"
	   67 5F 6D 6F 6E
	   6F 5F 64 69 73
	   70 6C 61 79 5F
	   74 65 78 74 5F
	   6D 6F 64 65
 0000D18E  17 56 49 44 5F	                                            db  23, "VID_g_mono_display_text"
	   67 5F 6D 6F 6E
	   6F 5F 64 69 73
	   70 6C 61 79 5F
	   74 65 78 74
 0000D1A6  1C 69 4B 42 44	                                            db  28, "iKBD_activate_DEBI_intercept"
	   5F 61 63 74 69
	   76 61 74 65 5F
	   44 45 42 49 5F
	   69 6E 74 65 72
	   63 65 70 74
 0000D1C3  1E 69 4B 42 44	                                            db  30, "iKBD_deactivate_DEBI_intercept"
	   5F 64 65 61 63
	   74 69 76 61 74
	   65 5F 44 45 42
	   49 5F 69 6E 74
	   65 72 63 65 70
	   74
 0000D1E2  1E 69 4D 4F 55	                                            db  30, "iMOUSE_activate_DEBI_intercept"
	   53 45 5F 61 63
	   74 69 76 61 74
	   65 5F 44 45 42
	   49 5F 69 6E 74
	   65 72 63 65 70
	   74
 0000D201  20 69 4D 4F 55	                                            db  32, "iMOUSE_deactivate_DEBI_intercept"
	   53 45 5F 64 65
	   61 63 74 69 76
	   61 74 65 5F 44
	   45 42 49 5F 69
	   6E 74 65 72 63
	   65 70 74
 0000D222  18 56 49 44 5F	                                            db  24, "VID_g_mono_mouse_pointer"
	   67 5F 6D 6F 6E
	   6F 5F 6D 6F 75
	   73 65 5F 70 6F
	   69 6E 74 65 72
 0000D23B  12 56 49 44 5F	                                            db  18, "VID_g_set_font_8x6"
	   67 5F 73 65 74
	   5F 66 6F 6E 74
	   5F 38 78 36
 0000D24E  12 56 49 44 5F	                                            db  18, "VID_g_set_font_8x8"
	   67 5F 73 65 74
	   5F 66 6F 6E 74
	   5F 38 78 38
 0000D261  13 56 49 44 5F	                                            db  19, "VID_g_set_font_8x14"
	   67 5F 73 65 74
	   5F 66 6F 6E 74
	   5F 38 78 31 34
 0000D275  14 56 49 44 5F	                                            db  20, "VID_g_set_font_16x16"
	   67 5F 73 65 74
	   5F 66 6F 6E 74
	   5F 31 36 78 31
	   36
 0000D28A  1F 69 54 49 4D	                                            db  31, "iTIMER_activate_DEBI_timer_feed"
	   45 52 5F 61 63
	   74 69 76 61 74
	   65 5F 44 45 42
	   49 5F 74 69 6D
	   65 72 5F 66 65
	   65 64
 0000D2AA  21 69 54 49 4D	                                            db  33, "iTIMER_deactivate_DEBI_timer_feed"
	   45 52 5F 64 65
	   61 63 74 69 76
	   61 74 65 5F 44
	   45 42 49 5F 74
	   69 6D 65 72 5F
	   66 65 65 64
 0000D2CC  16 54 41 53 4B	                                            db  22, "TASK_release_timeslice"
	   5F 72 65 6C 65
	   61 73 65 5F 74
	   69 6D 65 73 6C
	   69 63 65
 0000D2E3  1A 56 49 44 5F	                                            db  26, "VID_g_mono_window_function"
	   67 5F 6D 6F 6E
	   6F 5F 77 69 6E
	   64 6F 77 5F 66
	   75 6E 63 74 69
	   6F 6E
 0000D2FE  18 56 49 44 5F	                                            db  24, "VID_position_cursor_mono"
	   70 6F 73 69 74
	   69 6F 6E 5F 63
	   75 72 73 6F 72
	   5F 6D 6F 6E 6F
 0000D317  1F 56 49 44 5F	                                            db  31, "VID_g_display_radix_in_edx_mono"
	   67 5F 64 69 73
	   70 6C 61 79 5F
	   72 61 64 69 78
	   5F 69 6E 5F 65
	   64 78 5F 6D 6F
	   6E 6F
 0000D337  11 56 49 44 5F	                                            db  17, "VID_g_mono_cursor"
	   67 5F 6D 6F 6E
	   6F 5F 63 75 72
	   73 6F 72
 0000D349  15 56 49 44 5F	                                            db  21, "VID_g_claim_ownership"
	   67 5F 63 6C 61
	   69 6D 5F 6F 77
	   6E 65 72 73 68
	   69 70
 0000D35F  17 56 49 44 5F	                                            db  23, "VID_g_release_ownership"
	   67 5F 72 65 6C
	   65 61 73 65 5F
	   6F 77 6E 65 72
	   73 68 69 70
 0000D377  1E 56 49 44 5F	                                            db  30, "VID_g_mono_enter_graphics_mode"
	   67 5F 6D 6F 6E
	   6F 5F 65 6E 74
	   65 72 5F 67 72
	   61 70 68 69 63
	   73 5F 6D 6F 64
	   65
 0000D396  0F 58 38 36 5F	                                            db  15, "X86_disassemble"
	   64 69 73 61 73
	   73 65 6D 62 6C
	   65
 0000D3A6  18 58 38 36 5F	                                            db  24, "X86_simplify_disassembly"
	   73 69 6D 70 6C
	   69 66 79 5F 64
	   69 73 61 73 73
	   65 6D 62 6C 79
 0000D3BF  0C 58 38 36 5F	                                            db  12, "X86_assemble"
	   61 73 73 65 6D
	   62 6C 65
 0000D3CC  0E 58 38 36 5F	                                            db  14, "X86_fpu_opcode"
	   66 70 75 5F 6F
	   70 63 6F 64 65
 0000D3DB  1B 56 49 44 5F	                                            db  27, "VID_g_mono_cursor_no_insert"
	   67 5F 6D 6F 6E
	   6F 5F 63 75 72
	   73 6F 72 5F 6E
	   6F 5F 69 6E 73
	   65 72 74
 0000D3F7  1B 69 4D 4F 55	                                            db  27, "iMOUSE_bochs_DEBI_intercept"
	   53 45 5F 62 6F
	   63 68 73 5F 44
	   45 42 49 5F 69
	   6E 74 65 72 63
	   65 70 74
 0000D413  FF			                                            db  0ffh

				    ; This logo consists of a three-wide image (the +2 portion (the 2 stands for "an extra 2 18x16 images wide"))
				    ; It wants a box drawn around it (the +80h portion)
				    ; And the color we want to use is 8 (dark grey, the "+(8 SHL 3) portion)
				    ; * Refer to
 0000D414 8A			    debi_boot_logo                          db  08ah        ; * Refer to VGA\INF\VGA.INF for information on this byte's format
 0000D415  10 10 10 09 09	                                            db  10h,10h,10h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,10h,10h,10h
	   09 09 09 09 09
	   09 09 09 09 09
	   09 09 10 10 10
 0000D429  10 10 10 10 10	                                            db  10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h
	   10 10 10 10 10
	   10 10 10 10 10
	   10 10 10 10 10
 0000D43D  10 10 10 10 10	                                            db  10h,10h,10h,10h,10h,10h,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,10h,10h,10h
	   10 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   10 10 10
 0000D44F  10 10 10 09 01	                                            db  10h,10h,10h,09h,01h,01h,01h,01h,01h,01h,01h,01h,01h,01h,01h,01h,09h,09h,10h,10h
	   01 01 01 01 01
	   01 01 01 01 01
	   01 09 09 10 10
 0000D463  10 10 10 10 10	                                            db  10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h
	   10 10 10 10 10
	   10 10 10 10 10
	   10 10 10 10 10
 0000D477  10 10 10 10 10	                                            db  10h,10h,10h,10h,10h,10h,0fh,02h,02h,02h,02h,02h,02h,02h,0fh,10h,10h,10h
	   10 0F 02 02 02
	   02 02 02 02 0F
	   10 10 10
 0000D489  10 10 10 09 09	                                            db  10h,10h,10h,09h,09h,09h,01h,01h,01h,01h,09h,09h,09h,09h,01h,01h,01h,01h,09h,10h
	   09 01 01 01 01
	   09 09 09 09 01
	   01 01 01 09 10
 0000D49D  10 10 10 10 10	                                            db  10h,10h,10h,10h,10h,10h,10h,10h,10h,09h,09h,09h,09h,10h,10h,10h,10h,10h,10h,10h
	   10 10 10 10 09
	   09 09 09 10 10
	   10 10 10 10 10
 0000D4B1  09 09 09 09 10	                                            db  09h,09h,09h,09h,10h,10h,0fh,02h,02h,02h,02h,02h,02h,02h,0fh,10h,10h,10h
	   10 0F 02 02 02
	   02 02 02 02 0F
	   10 10 10
 0000D4C3  10 10 10 10 10	                                            db  10h,10h,10h,10h,10h,09h,01h,01h,01h,01h,09h,10h,10h,10h,09h,09h,01h,01h,01h,09h
	   09 01 01 01 01
	   09 10 10 10 09
	   09 01 01 01 09
 0000D4D7  10 10 10 10 10	                                            db  10h,10h,10h,10h,10h,10h,10h,10h,09h,01h,01h,01h,01h,09h,10h,10h,10h,10h,10h,09h
	   10 10 10 09 01
	   01 01 01 09 10
	   10 10 10 10 09
 0000D4EB  01 01 01 01 09	                                            db  01h,01h,01h,01h,09h,10h,0fh,02h,02h,02h,02h,02h,02h,02h,0fh,10h,10h,10h
	   10 0F 02 02 02
	   02 02 02 02 0F
	   10 10 10
 0000D4FD  10 10 10 10 10	                                            db  10h,10h,10h,10h,10h,09h,01h,01h,01h,0eh,09h,0eh,10h,10h,10h,09h,01h,01h,01h,01h
	   09 01 01 01 0E
	   09 0E 10 10 10
	   09 01 01 01 01
 0000D511  09 10 10 10 10	                                            db  09h,10h,10h,10h,10h,10h,10h,10h,10h,09h,01h,01h,01h,09h,10h,10h,10h,10h,10h,09h
	   10 10 10 10 09
	   01 01 01 09 10
	   10 10 10 10 09
 0000D525  01 01 01 01 09	                                            db  01h,01h,01h,01h,09h,10h,0fh,02h,02h,02h,02h,02h,02h,02h,0fh,10h,10h,10h
	   10 0F 02 02 02
	   02 02 02 02 0F
	   10 10 10
 0000D537  10 10 10 10 10	                                            db  10h,10h,10h,10h,10h,09h,0fh,0fh,01h,04h,0ch,0ch,04h,10h,0fh,0fh,0fh,01h,01h,01h
	   09 0F 0F 01 04
	   0C 0C 04 10 0F
	   0F 0F 01 01 01
 0000D54B  09 10 10 10 10	                                            db  09h,10h,10h,10h,10h,10h,10h,10h,10h,09h,01h,01h,01h,09h,10h,10h,10h,10h,10h,10h
	   10 10 10 10 09
	   01 01 01 09 10
	   10 10 10 10 10
 0000D55F  09 09 09 09 10	                                            db  09h,09h,09h,09h,10h,10h,0fh,02h,02h,02h,02h,02h,02h,02h,0fh,10h,10h,10h
	   10 0F 02 02 02
	   02 02 02 02 0F
	   10 10 10
 0000D571  10 10 10 10 10	                                            db  10h,10h,10h,10h,10h,0fh,01h,01h,0fh,04h,0ch,0ch,04h,0fh,10h,10h,09h,0fh,01h,01h
	   0F 01 01 0F 04
	   0C 0C 04 0F 10
	   10 09 0F 01 01
 0000D585  09 10 10 09 09	                                            db  09h,10h,10h,09h,09h,09h,09h,09h,09h,09h,01h,01h,01h,09h,10h,10h,10h,10h,10h,10h
	   09 09 09 09 09
	   01 01 01 09 10
	   10 10 10 10 10
 0000D599  10 10 10 10 10	                                            db  10h,10h,10h,10h,10h,10h,0fh,0fh,0fh,0fh,0fh,0fh,0dh,0fh,0fh,10h,10h,10h
	   10 0F 0F 0F 0F
	   0F 0F 0D 0F 0F
	   10 10 10
 0000D5AB  10 10 10 10 10	                                            db  10h,10h,10h,10h,10h,09h,01h,01h,01h,0ch,0ch,0ch,0ch,10h,10h,10h,09h,01h,01h,01h
	   09 01 01 01 0C
	   0C 0C 0C 10 10
	   10 09 01 01 01
 0000D5BF  09 10 09 01 01	                                            db  09h,10h,09h,01h,01h,01h,01h,01h,01h,09h,01h,01h,01h,09h,10h,09h,09h,09h,10h,09h
	   01 01 01 01 09
	   01 01 01 09 10
	   09 09 09 10 09
 0000D5D3  09 09 10 10 10	                                            db  09h,09h,10h,10h,10h,10h,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,10h,10h,10h
	   10 0F 0F 0F 0F
	   0F 0F 0F 0F 0F
	   10 10 10
 0000D5E5  10 10 10 10 10	                                            db  10h,10h,10h,10h,10h,09h,01h,0fh,0fh,0ch,0ch,0ch,0ch,0fh,0fh,10h,09h,01h,01h,01h
	   09 01 0F 0F 0C
	   0C 0C 0C 0F 0F
	   10 09 01 01 01
 0000D5F9  09 09 01 01 09	                                            db  09h,09h,01h,01h,09h,09h,09h,01h,01h,09h,01h,01h,01h,09h,09h,01h,01h,01h,09h,09h
	   09 09 01 01 09
	   01 01 01 09 09
	   01 01 01 09 09
 0000D60D  01 01 09 10 10	                                            db  01h,01h,09h,10h,10h,10h,10h,10h,10h,10h,0eh,10h,10h,10h,10h,10h,10h,10h
	   10 10 10 10 10
	   0E 10 10 10 10
	   10 10 10
 0000D61F  10 10 10 10 10	                                            db  10h,10h,10h,10h,10h,09h,0fh,01h,01h,04h,0ch,0ch,04h,10h,10h,0fh,0fh,01h,01h,01h
	   09 0F 01 01 04
	   0C 0C 04 10 10
	   0F 0F 01 01 01
 0000D633  09 01 01 09 01	                                            db  09h,01h,01h,09h,01h,01h,01h,01h,09h,09h,01h,01h,01h,01h,01h,01h,01h,01h,01h,09h
	   01 01 01 09 09
	   01 01 01 01 01
	   01 01 01 01 09
 0000D647  01 01 01 09 10	                                            db  01h,01h,01h,09h,10h,10h,10h,10h,10h,10h,0eh,10h,10h,10h,10h,10h,10h,10h
	   10 10 10 10 10
	   0E 10 10 10 10
	   10 10 10
 0000D659  10 10 10 10 10	                                            db  10h,10h,10h,10h,10h,0fh,01h,01h,01h,0fh,0ch,0ch,0fh,10h,10h,09h,01h,0fh,01h,01h
	   0F 01 01 01 0F
	   0C 0C 0F 10 10
	   09 01 0F 01 01
 0000D66D  09 01 01 01 01	                                            db  09h,01h,01h,01h,01h,01h,09h,09h,10h,09h,01h,01h,01h,01h,01h,09h,01h,01h,01h,09h
	   01 09 09 10 09
	   01 01 01 01 01
	   09 01 01 01 09
 0000D681  01 01 01 01 09	                                            db  01h,01h,01h,01h,09h,10h,10h,10h,10h,10h,0eh,10h,10h,10h,10h,10h,10h,10h
	   10 10 10 10 10
	   0E 10 10 10 10
	   10 10 10
 0000D693  10 10 10 10 10	                                            db  10h,10h,10h,10h,10h,09h,01h,01h,0fh,01h,09h,10h,10h,0fh,10h,09h,01h,01h,01h,01h
	   09 01 01 0F 01
	   09 10 10 0F 10
	   09 01 01 01 01
 0000D6A7  09 01 01 01 09	                                            db  09h,01h,01h,01h,09h,09h,10h,10h,10h,09h,01h,01h,01h,01h,01h,01h,09h,01h,01h,09h
	   09 10 10 10 09
	   01 01 01 01 01
	   01 09 01 01 09
 0000D6BB  01 01 01 01 09	                                            db  01h,01h,01h,01h,09h,10h,10h,10h,10h,10h,0eh,10h,10h,10h,10h,10h,10h,10h
	   10 10 10 10 10
	   0E 10 10 10 10
	   10 10 10
 0000D6CD  10 10 10 10 10	                                            db  10h,10h,10h,10h,10h,09h,01h,01h,0fh,01h,09h,10h,10h,10h,0fh,09h,01h,01h,01h,09h
	   09 01 01 0F 01
	   09 10 10 10 0F
	   09 01 01 01 09
 0000D6E1  09 01 01 01 09	                                            db  09h,01h,01h,01h,09h,09h,09h,09h,09h,09h,01h,01h,01h,01h,01h,01h,09h,01h,01h,09h
	   09 09 09 09 09
	   01 01 01 01 01
	   01 09 01 01 09
 0000D6F5  01 01 01 01 09	                                            db  01h,01h,01h,01h,09h,10h,0eh,0eh,0eh,0eh,0eh,10h,10h,10h,10h,10h,10h,10h
	   10 0E 0E 0E 0E
	   0E 10 10 10 10
	   10 10 10
 0000D707  10 10 10 09 09	                                            db  10h,10h,10h,09h,09h,09h,01h,0fh,01h,01h,09h,09h,09h,09h,0fh,01h,01h,01h,09h,10h
	   09 01 0F 01 01
	   09 09 09 09 0F
	   01 01 01 09 10
 0000D71B  09 01 01 01 01	                                            db  09h,01h,01h,01h,01h,01h,01h,01h,01h,09h,01h,01h,01h,01h,01h,01h,01h,01h,01h,09h
	   01 01 01 01 09
	   01 01 01 01 01
	   01 01 01 01 09
 0000D72F  01 01 01 01 09	                                            db  01h,01h,01h,01h,09h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h
	   10 10 10 10 10
	   10 10 10 10 10
	   10 10 10
 0000D741  10 10 10 09 01	                                            db  10h,10h,10h,09h,01h,01h,01h,0fh,01h,01h,01h,01h,01h,01h,01h,0fh,09h,09h,10h,10h
	   01 01 0F 01 01
	   01 01 01 01 01
	   0F 09 09 10 10
 0000D755  09 09 09 01 01	                                            db  09h,09h,09h,01h,01h,01h,01h,01h,01h,09h,01h,01h,01h,09h,01h,01h,01h,01h,09h,09h
	   01 01 01 01 09
	   01 01 01 09 01
	   01 01 01 09 09
 0000D769  01 01 01 09 10	                                            db  01h,01h,01h,09h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h
	   10 10 10 10 10
	   10 10 10 10 10
	   10 10 10
 0000D77B  10 10 10 09 09	                                            db  10h,10h,10h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,10h,10h,10h,10h
	   09 09 09 09 09
	   09 09 09 09 09
	   09 10 10 10 10
 0000D78F  10 10 09 09 09	                                            db  10h,10h,09h,09h,09h,09h,09h,09h,09h,10h,09h,09h,09h,10h,09h,09h,09h,09h,10h,10h
	   09 09 09 09 10
	   09 09 09 10 09
	   09 09 09 10 10
 0000D7A3  09 09 09 10 10	                                            db  09h,09h,09h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h
	   10 10 10 10 10
	   10 10 10 10 10
	   10 10 10
 0000D7B5  00 00 15		                                            db  0,0,15h     ; A dark shade of blue for the background

				    INCLUDE debilogo.asp
			      C ; debilogo.asp
			      C ;
			      C ; Low-Level Debi Debugger logo for the debugger screen
			      C ;
			      C ;
			      C 
			      C ; Total pixels:  x=30*8, y=4*6
 0000D7B8		      C debi_debugger_logo:
			      C ;   db  11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b,11111111b
			      C ;   db  11111111b,11101010b,10111010b,10101101b,01010000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00010101b,01010010b,10101010b,10101111b,11111111b
			      C ;   db  11111111b,11111111b,11010101b,01000010b,00000010b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000101b,01011101b,01111010b,11111111b
			      C ;   db  11111111b,11011010b,10101101b,01010100b,10101000b,00000000b,00111111b,11000000b,00000000b,00001000b,00000001b,10000000b,01111111b,10000000b,00000000b,00010000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00100101b,01011010b,10110011b,11101111b,11111111b
			      C ;   db  11111111b,01110111b,11110010b,10101001b,00000000b,00000000b,00110000b,00110000b,00000000b,00001000b,00000000b,00000000b,01100000b,01100000b,00000000b,00010000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,10000000b,10100101b,01001101b,01011111b,11111111b
			      C ;   db  11111111b,11111101b,01011101b,01010100b,10100100b,00000000b,00110000b,00011000b,11111111b,00001111b,11110001b,10000000b,01100000b,00110001b,11111110b,00011111b,11100011b,00000110b,00111111b,10100011b,11111010b,00111111b,11000101b,11110000b,00000000b,00010100b,00010010b,10110110b,11110101b,11111111b
			      C ;   db  11111111b,11110111b,10101010b,10100010b,00010001b,00000000b,00110000b,00011001b,10000001b,10001100b,00011001b,10000000b,01100000b,00110011b,00000011b,00011000b,00110011b,00000110b,01100000b,01100110b,00000110b,01100000b,01100110b,00011000b,00000000b,00000001b,01001010b,10101011b,01011111b,01111111b
			      C ;   db  11111111b,11011101b,01110101b,01010101b,01000000b,00000000b,00110000b,00011001b,11111111b,10001100b,00011001b,10000000b,01100000b,00110011b,11111111b,00011000b,00110011b,00000110b,01100000b,01100110b,00000110b,01111111b,11100110b,00000000b,00000000b,01000100b,10010101b,01010110b,11110111b,11111111b
			      C ;   db  11111111b,01111011b,10101010b,10101000b,00010000b,00000000b,00110000b,00011001b,10000000b,00001100b,00011001b,10000000b,01100000b,00110011b,00000000b,00011000b,00110011b,00000110b,01100000b,01100110b,00000110b,01100000b,00000110b,00000000b,00000000b,00010001b,00100010b,10101101b,10111101b,11111111b
			      C ;   db  11111111b,11101110b,11011010b,10010101b,01000100b,00000000b,00110000b,00110001b,10000001b,10001100b,00011001b,10000000b,01100000b,01100011b,00000011b,00011000b,00110011b,00000110b,01100000b,01100110b,00000110b,01100000b,01100110b,00000000b,00000000b,00000100b,10011010b,10110110b,11011111b,11111111b
			      C ;   db  11111111b,11111011b,10110101b,01100010b,00100001b,00000000b,00111111b,11100000b,11111111b,00001011b,11110001b,10000000b,01111111b,11000001b,11111110b,00010111b,11100001b,11111010b,00111111b,11100011b,11111110b,00111111b,11000110b,00000000b,00000000b,01000010b,00100101b,01001011b,01110110b,11111111b
			      C ;   db  11111111b,11011111b,01101010b,10001100b,10001000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,01100000b,00000110b,00000000b,00000000b,00000000b,00000000b,00001000b,01001010b,10110110b,11101111b,11111111b
			      C ;   db  11111111b,01110101b,10110101b,01100001b,00100000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,01100000b,00000110b,00000000b,00000000b,00000000b,00000000b,00010010b,10010010b,10101011b,10111101b,11111111b
			      C ;   db  11111111b,11111110b,11011010b,10011010b,00000100b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00111111b,11000011b,11111100b,00000000b,00000000b,00000000b,00000000b,10000000b,01001001b,01011101b,01101111b,11111111b
			      C ;   db  11111111b,11011011b,10110101b,01100001b,01010001b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000101b,00010110b,10100101b,10110111b,01111111b
			      C ;   db  11111111b,11110111b,01101010b,10001010b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00010000b,10101001b,01011011b,01111101b,11111111b
			      C ;   db  11111111b,01111101b,10101101b,01101000b,10100100b,00000000b,00000000b,00000000b,01000001b,00000000b,00000000b,00001000b,00000000b,00000000b,00000011b,10001110b,00000011b,10001110b,00000011b,10000111b,00001110b,00011100b,00000000b,00000000b,00000000b,01000101b,00010101b,01101101b,11011111b,11111111b
			      C ;   db  11111111b,11011110b,11010101b,00100101b,00010000b,00000000b,00000000b,00000000b,00100010b,00111000b,10110001b,11000000b,11110001b,01100000b,00000100b,01000001b,00000100b,01000001b,00000000b,01001000b,10010001b,00000010b,00000000b,00000000b,00000000b,00000000b,10100101b,00101010b,11101111b,11111111b
			      C ;   db  11111111b,11111011b,01111010b,10101010b,01000001b,00000000b,00000000b,00000000b,00100010b,01000100b,11000010b,00001001b,00001001b,10010000b,00000100b,01000001b,00000100b,01000001b,00000000b,01001000b,10010001b,00000010b,00000000b,00000000b,00000000b,00001010b,00001010b,11010111b,10110101b,01111111b
			      C ;   db  11111111b,11110111b,10100101b,01010000b,10000100b,00000000b,00000000b,00000000b,00010100b,01111100b,10000001b,10001001b,00001001b,00010000b,00000100b,01001110b,00000100b,01001110b,00000011b,10001000b,10010001b,00011100b,00000000b,00000000b,00000000b,00100000b,01010100b,10101101b,01111111b,11111111b
			      C ;   db  11111111b,01101101b,01111010b,10101010b,00100000b,00000000b,00000000b,00000000b,00010100b,01000000b,10000000b,01001001b,00001001b,00010000b,00000100b,01010000b,00000100b,01010000b,00000100b,00001000b,10010001b,00100000b,00000000b,00000000b,00000000b,10001010b,10100011b,01010110b,11011111b,11111111b
			      C ;   db  11111111b,11111111b,10101101b,01000101b,00010000b,00000000b,00000000b,00000000b,00001000b,00111000b,10000011b,11001000b,11110001b,00010000b,00000011b,10011111b,00100011b,10011111b,00100111b,11000111b,00001110b,00111110b,00000000b,00000000b,00000000b,00000000b,00011001b,01011011b,01101011b,11111111b
			      C ;   db  11111111b,10111010b,11010101b,01011000b,01001001b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00010010b,10100101b,01010101b,10111111b,01111111b
			      C ;   db  11111111b,01101101b,01111010b,10101010b,00100000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,00000000b,10001010b,10100011b,01010110b,11011111b,11111111b
			      C ;
			      C ;     ; €€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€€b
			      C ;     ; €€€€€€€€€€€˙€˙€˙€˙€€€˙€˙€˙€˙€€˙€˙€˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙€˙€˙€˙€˙˙€˙€˙€˙€˙€˙€˙€˙€€€€€€€€€€€€b
			      C ;     ; €€€€€€€€€€€€€€€€€€˙€˙€˙€˙€˙˙˙˙€˙˙˙˙˙˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙€˙€˙€€€˙€˙€€€€˙€˙€€€€€€€€b
			      C ;     ; €€€€€€€€€€˙€€˙€˙€˙€˙€€˙€˙€˙€˙€˙˙€˙€˙€˙˙˙˙˙˙˙˙˙˙˙˙˙€€€€€€€€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙˙˙˙˙˙˙˙˙€€˙˙˙˙˙˙˙˙€€€€€€€€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙€˙€˙€˙€€˙€˙€˙€€˙˙€€€€€˙€€€€€€€€€€€€b
			      C ;     ; €€€€€€€€˙€€€˙€€€€€€€˙˙€˙€˙€˙€˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€€˙˙˙˙˙˙€€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€€˙˙˙˙˙˙€€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙˙˙˙˙˙€˙€˙˙€˙€˙€˙˙€€˙€˙€˙€€€€€€€€€€€€€b
			      C ;     ; €€€€€€€€€€€€€€˙€˙€˙€€€˙€˙€˙€˙€˙˙€˙€˙˙€˙˙˙˙˙˙˙˙˙˙˙˙€€˙˙˙˙˙˙˙€€˙˙˙€€€€€€€€˙˙˙˙€€€€€€€€˙˙˙€€˙˙˙˙˙˙˙˙€€˙˙˙˙˙˙˙€€˙˙˙€€€€€€€€˙˙˙˙€€€€€€€€˙˙˙€€˙˙˙˙˙€€˙˙˙€€€€€€€˙€˙˙˙€€€€€€€˙€˙˙˙€€€€€€€€˙˙˙€˙€€€€€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙€˙˙˙˙˙€˙˙€˙€˙€€˙€€˙€€€€˙€˙€€€€€€€€€b
			      C ;     ; €€€€€€€€€€€€˙€€€€˙€˙€˙€˙€˙€˙˙˙€˙˙˙˙€˙˙˙€˙˙˙˙˙˙˙˙˙˙€€˙˙˙˙˙˙˙€€˙˙€€˙˙˙˙˙˙€€˙˙˙€€˙˙˙˙˙€€˙˙€€˙˙˙˙˙˙˙˙€€˙˙˙˙˙˙˙€€˙˙€€˙˙˙˙˙˙€€˙˙˙€€˙˙˙˙˙€€˙˙€€˙˙˙˙˙€€˙˙€€˙˙˙˙˙˙€€˙˙€€˙˙˙˙˙˙€€˙˙€€˙˙˙˙˙˙€€˙˙€€˙˙˙˙€€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙€˙˙€˙€˙€˙€˙€˙€€˙€˙€€€€€˙€€€€€€€b
			      C ;     ; €€€€€€€€€€˙€€€˙€˙€€€˙€˙€˙€˙€˙€˙€˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€€˙˙˙˙˙˙˙€€˙˙€€€€€€€€€€˙˙˙€€˙˙˙˙˙€€˙˙€€˙˙˙˙˙˙˙˙€€˙˙˙˙˙˙˙€€˙˙€€€€€€€€€€˙˙˙€€˙˙˙˙˙€€˙˙€€˙˙˙˙˙€€˙˙€€˙˙˙˙˙˙€€˙˙€€˙˙˙˙˙˙€€˙˙€€€€€€€€€€˙˙€€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙˙€˙˙€˙˙€˙€˙€˙€˙€˙€€˙€€€€˙€€€€€€€€€€€b
			      C ;     ; €€€€€€€€˙€€€€˙€€€˙€˙€˙€˙€˙€˙€˙˙˙˙˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙€€˙˙˙˙˙˙˙€€˙˙€€˙˙˙˙˙˙˙˙˙˙˙€€˙˙˙˙˙€€˙˙€€˙˙˙˙˙˙˙˙€€˙˙˙˙˙˙˙€€˙˙€€˙˙˙˙˙˙˙˙˙˙˙€€˙˙˙˙˙€€˙˙€€˙˙˙˙˙€€˙˙€€˙˙˙˙˙˙€€˙˙€€˙˙˙˙˙˙€€˙˙€€˙˙˙˙˙˙˙˙˙˙€€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙˙€˙˙€˙˙˙€˙€˙€˙€€˙€€˙€€€€˙€€€€€€€€€b
			      C ;     ; €€€€€€€€€€€˙€€€˙€€˙€€˙€˙€˙˙€˙€˙€˙€˙˙˙€˙˙˙˙˙˙˙˙˙˙˙˙€€˙˙˙˙˙˙€€˙˙˙€€˙˙˙˙˙˙€€˙˙˙€€˙˙˙˙˙€€˙˙€€˙˙˙˙˙˙˙˙€€˙˙˙˙˙˙€€˙˙˙€€˙˙˙˙˙˙€€˙˙˙€€˙˙˙˙˙€€˙˙€€˙˙˙˙˙€€˙˙€€˙˙˙˙˙˙€€˙˙€€˙˙˙˙˙˙€€˙˙€€˙˙˙˙˙˙€€˙˙€€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙€˙˙€€˙€˙€˙€€˙€€˙€€˙€€€€€€€€€€€€€b
			      C ;     ; €€€€€€€€€€€€€˙€€€˙€€˙€˙€˙€€˙˙˙€˙˙˙€˙˙˙˙€˙˙˙˙˙˙˙˙˙˙€€€€€€€€€˙˙˙˙˙€€€€€€€€˙˙˙˙€˙€€€€€€˙˙˙€€˙˙˙˙˙˙˙˙€€€€€€€€€˙˙˙˙˙€€€€€€€€˙˙˙˙€˙€€€€€€˙˙˙˙€€€€€€˙€˙˙˙€€€€€€€€€˙˙˙€€€€€€€€€˙˙˙€€€€€€€€˙˙˙€€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙˙˙€˙˙˙€˙˙€˙€˙€˙˙€˙€€˙€€€˙€€˙€€€€€€€€b
			      C ;     ; €€€€€€€€€€˙€€€€€˙€€˙€˙€˙€˙˙˙€€˙˙€˙˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€€˙˙˙˙˙˙˙˙˙˙€€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙˙˙€˙˙€˙€˙€˙€€˙€€˙€€€˙€€€€€€€€€€€€b
			      C ;     ; €€€€€€€€˙€€€˙€˙€€˙€€˙€˙€˙€€˙˙˙˙€˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€€˙˙˙˙˙˙˙˙˙˙€€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙€˙€˙˙€˙˙€˙€˙€˙€˙€€€˙€€€€˙€€€€€€€€€b
			      C ;     ; €€€€€€€€€€€€€€€˙€€˙€€˙€˙€˙˙€€˙€˙˙˙˙˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€€€€€€€€˙˙˙˙€€€€€€€€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙˙˙˙˙˙˙€˙˙€˙˙€˙€˙€€€˙€˙€€˙€€€€€€€€€€€€b
			      C ;     ; €€€€€€€€€€˙€€˙€€€˙€€˙€˙€˙€€˙˙˙˙€˙€˙€˙˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙€˙˙˙€˙€€˙€˙€˙˙€˙€€˙€€˙€€€˙€€€€€€€b
			      C ;     ; €€€€€€€€€€€€˙€€€˙€€˙€˙€˙€˙˙˙€˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙˙˙€˙€˙€˙˙€˙€˙€€˙€€˙€€€€€˙€€€€€€€€€b
			      C ;     ; €€€€€€€€˙€€€€€˙€€˙€˙€€˙€˙€€˙€˙˙˙€˙€˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙˙˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€€€˙˙˙€€€˙˙˙˙˙˙˙€€€˙˙˙€€€˙˙˙˙˙˙˙€€€˙˙˙˙€€€˙˙˙˙€€€˙˙˙˙€€€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙˙€˙€˙˙˙€˙€˙€˙€€˙€€˙€€€˙€€€€€€€€€€€€€b
			      C ;     ; €€€€€€€€€€˙€€€€˙€€˙€˙€˙€˙˙€˙˙€˙€˙˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙˙€˙˙˙€€€˙˙˙€˙€€˙˙˙€€€˙˙˙˙˙˙€€€€˙˙˙€˙€€˙˙˙˙˙˙˙˙˙˙€˙˙˙€˙˙˙˙˙€˙˙˙˙˙€˙˙˙€˙˙˙˙˙€˙˙˙˙˙˙˙˙˙€˙˙€˙˙˙€˙˙€˙˙˙€˙˙˙˙˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙€˙˙€˙€˙˙€˙€˙€˙€€€˙€€€€€€€€€€€€b
			      C ;     ; €€€€€€€€€€€€€˙€€˙€€€€˙€˙€˙€˙€˙€˙˙€˙˙˙˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙˙€˙˙€˙˙˙€˙˙€€˙˙˙˙€˙˙˙˙˙€˙˙€˙˙˙˙€˙˙€€˙˙€˙˙˙˙˙˙˙˙˙€˙˙˙€˙˙˙˙˙€˙˙˙˙˙€˙˙˙€˙˙˙˙˙€˙˙˙˙˙˙˙˙˙€˙˙€˙˙˙€˙˙€˙˙˙€˙˙˙˙˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙€˙˙˙˙˙€˙€˙€€˙€˙€€€€˙€€˙€˙€˙€€€€€€€b
			      C ;     ; €€€€€€€€€€€€˙€€€€˙€˙˙€˙€˙€˙€˙˙˙˙€˙˙˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙€˙˙˙€€€€€˙˙€˙˙˙˙˙˙€€˙˙˙€˙˙€˙˙˙˙€˙˙€˙˙˙€˙˙˙˙˙˙˙˙˙€˙˙˙€˙˙€€€˙˙˙˙˙˙€˙˙˙€˙˙€€€˙˙˙˙˙˙˙€€€˙˙˙€˙˙˙€˙˙€˙˙˙€˙˙˙€€€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙˙˙˙˙€˙€˙€˙˙€˙€˙€€˙€˙€€€€€€€€€€€€€€€b
			      C ;     ; €€€€€€€€˙€€˙€€˙€˙€€€€˙€˙€˙€˙€˙€˙˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙€˙˙˙€˙˙˙˙˙˙€˙˙˙˙˙˙˙˙€˙˙€˙˙€˙˙˙˙€˙˙€˙˙˙€˙˙˙˙˙˙˙˙˙€˙˙˙€˙€˙˙˙˙˙˙˙˙˙€˙˙˙€˙€˙˙˙˙˙˙˙˙˙€˙˙˙˙˙˙€˙˙˙€˙˙€˙˙˙€˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙˙€˙€˙€˙€˙˙˙€€˙€˙€˙€€˙€€˙€€€€€€€€€€€€€b
			      C ;     ; €€€€€€€€€€€€€€€€€˙€˙€€˙€˙€˙˙˙€˙€˙˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙˙˙˙€€€˙˙˙€˙˙˙˙˙€€€€˙˙€˙˙˙€€€€˙˙˙€˙˙˙€˙˙˙˙˙˙˙˙˙˙€€€˙˙€€€€€˙˙€˙˙˙€€€˙˙€€€€€˙˙€˙˙€€€€€˙˙˙€€€˙˙˙˙€€€˙˙˙€€€€€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€€˙˙€˙€˙€€˙€€˙€€˙€˙€€€€€€€€€€b
			      C ;     ; €€€€€€€€€˙€€€˙€˙€€˙€˙€˙€˙€˙€€˙˙˙˙€˙˙€˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙€˙€˙€˙˙€˙€˙€˙€˙€˙€€˙€€€€€€˙€€€€€€€b
			      C ;     ; €€€€€€€€˙€€˙€€˙€˙€€€€˙€˙€˙€˙€˙€˙˙˙€˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙€˙˙˙€˙€˙€˙€˙˙˙€€˙€˙€˙€€˙€€˙€€€€€€€€€€€€€b
			      C 

 0000D7B8			 end_of_required_data:

 0000D7B8 0A 44 45 42 49	    driver_primatives                       db  10, "DEBI_debug"
	   5F 64 65 62 75
	   67
 0000D7C3  000002AE R		                                            dd  offset DEBI_debug
 0000D7C7  0000			                                            dw  0

 0000D7C9  13 69 44 45 42	                                            db  19,"iDEBI_kbd_interface"
	   49 5F 6B 62 64
	   5F 69 6E 74 65
	   72 66 61 63 65
 0000D7DD  00001165 R		                                            dd  offset iDEBI_kbd_interface
 0000D7E1  0000			                                            dw  0

 0000D7E3  15 69 44 45 42	                                            db  21,"iDEBI_mouse_interface"
	   49 5F 6D 6F 75
	   73 65 5F 69 6E
	   74 65 72 66 61
	   63 65
 0000D7F9  000011AF R		                                            dd  offset iDEBI_mouse_interface
 0000D7FD  0000			                                            dw  0

 0000D7FF  15 69 44 45 42	                                            db  21,"iDEBI_timer_interface"
	   49 5F 74 69 6D
	   65 72 5F 69 6E
	   74 65 72 66 61
	   63 65
 0000D815  000015B5 R		                                            dd  offset iDEBI_timer_interface
 0000D819  0000			                                            dw  0

 0000D81B  0F 69 44 45 42	                                            db  15,"iDEBI_open_file"
	   49 5F 6F 70 65
	   6E 5F 66 69 6C
	   65
 0000D82B  00005391 R		                                            dd  offset iDEBI_open_file
 0000D82F  0000			                                            dw  0

 0000D831  10 69 44 45 42	                                            db  16,"iDEBI_close_file"
	   49 5F 63 6C 6F
	   73 65 5F 66 69
	   6C 65
 0000D842  00005392 R                                            dd  offset iDEBI_close_file
 0000D846  0000			                                            dw  0

 0000D848  0F 69 44 45 42	                                            db  15,"iDEBI_read_file"
	   49 5F 72 65 61
	   64 5F 66 69 6C
	   65
 0000D858  00005392 R		                                            dd  offset iDEBI_read_file
 0000D85C  0000			                                            dw  0

 0000D85E  10 69 44 45 42	                                            db  16,"iDEBI_write_file"
	   49 5F 77 72 69
	   74 65 5F 66 69
	   6C 65
 0000D86F  00005392 R		                                            dd  offset iDEBI_write_file
 0000D873  0000			                                            dw  0

 0000D875  1B 69 44 45 42	                                            db  27,"iDEBI_bochs_mouse_interface"
	   49 5F 62 6F 63
	   68 73 5F 6D 6F
	   75 73 65 5F 69
	   6E 74 65 72 66
	   61 63 65
 0000D891  0000140B R		                                            dd  offset iDEBI_bochs_mouse_interface
 0000D895  0000			                                            dw  0

 0000D897  FFFF			                                            dw  0ffffh              ; Teriminator

 0000D899 00			already_here                                db  _NO

 D89A				_TEXT32 ENDS

				END
