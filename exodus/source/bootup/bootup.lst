JWasm v2.06e, Nov 25 2011
bootup.asm
                                ; bootup.asm
                                ;
                                ; Exodus BOOTUP.COM
                                ;

                                TITLE Bootup

                                    .MODEL tiny

                                    .386P
                                ;_DEBI   EQU 0

                                INCLUDE ../source/common/macros.asp							; Macros used throughout Exodus
                              C ; macros.asp
                              C ;
                              C ; Exodus macros, used various places
                              C ;
                              C 
                              C 
                              C 
                              C callfp     MACRO   _seg:REQ, _offset:REQ
 >                            C ; This macro:   callfp  _code_seg, _offset
 >                            C ;
 >                            C     db  9ah
 >                            C     dd  _offset
 >                            C     dw  _seg
 >                            C ENDM
                              C 
                              C 
                              C 
                              C 
                              C callg      MACRO   _seg:REQ
 >                            C ; This macro:   callg   _call_gate
 >                            C     db  9ah
 >                            C     dd  0
 >                            C     dw  _seg
 >                            C ENDM
                              C 
                              C 
                              C 
                              C 
                              C jmpg       MACRO   _seg:REQ
 >                            C ; This macro:   jmpg    _call_gate
 >                            C     db  0eah
 >                            C     dd  0
 >                            C     dw  _seg
 >                            C ENDM
                              C 
                              C 
                              C 
                              C 
                              C callf      MACRO   _func:REQ
 >                            C ; This macro:   callf   function_name
 >                            C     push    cs
 >                            C     call    _func
 >                            C ENDM
                              C 
                              C 
                              C 
                              C 
                              C @IO_pause   MACRO
 >                            C     jmp     $+2
 >                            C ENDM
                                INCLUDE ../source/common/equates.asp						; Constants used to access memory variables, etc
                              C ; equates.asp
                              C ;
                              C ; Exodus constants.  These are used at various places.
                              C ; This file provides a common area to modify constant values, rather than sifting through programs, etc.
                              C ;
                              C 
                              C 
                              C 
                              C INCLUDE x86_eq.asp
                              C ; x86_eq.asp
                              C ;
                              C ; Constants specific to the Intel architecture
                              C ;
                              C 
                              C 
                              C 
 = 0                          C _TSS_BACK_LINK              EQU 0
 = 4                          C _TSS_ESP0                   EQU 4
 = 8                          C _TSS_SS0                    EQU 8
 = C                          C _TSS_ESP1                   EQU 12
 = 10                         C _TSS_SS1                    EQU 16
 = 14                         C _TSS_ESP2                   EQU 20
 = 18                         C _TSS_SS2                    EQU 24
 = 1C                         C _TSS_CR3                    EQU 28
 = 20                         C _TSS_EIP                    EQU 32
 = 24                         C _TSS_EFLAGS                 EQU 36
 = 28                         C _TSS_EAX                    EQU 40
 = 2C                         C _TSS_ECX                    EQU 44
 = 30                         C _TSS_EDX                    EQU 48
 = 34                         C _TSS_EBX                    EQU 52
 = 38                         C _TSS_ESP                    EQU 56
 = 3C                         C _TSS_EBP                    EQU 60
 = 40                         C _TSS_ESI                    EQU 64
 = 44                         C _TSS_EDI                    EQU 68
 = 48                         C _TSS_ES                     EQU 72
 = 4C                         C _TSS_CS                     EQU 76
 = 50                         C _TSS_SS                     EQU 80
 = 54                         C _TSS_DS                     EQU 84
 = 58                         C _TSS_FS                     EQU 88
 = 5C                         C _TSS_GS                     EQU 92
 = 60                         C _TSS_LDT                    EQU 96
 = 64                         C _TSS_TRAP_BIT               EQU 100
 = 1                          C _TSS_TRAP_BIT_MASK          EQU 1b
 = 66                         C _TSS_IO_MAP                 EQU 102
                              C ; The following area is used by Exodus.  It appears immediate after the TSS in memory
 = 68                         C _TSS_FPU_SAVE_AREA          EQU 104
                              C 
                              C 
                              C ; EFLAGS register constants to access individual flags
 = 0                          C _EFLAGS_CF                  EQU 0
 = 2                          C _EFLAGS_PF                  EQU 2
 = 4                          C _EFLAGS_ACF                 EQU 4
 = 6                          C _EFLAGS_ZF                  EQU 6
 = 7                          C _EFLAGS_SF                  EQU 7
 = 8                          C _EFLAGS_TF                  EQU 8
 = 9                          C _EFLAGS_IF                  EQU 9
 = A                          C _EFLAGS_DF                  EQU 10
 = B                          C _EFLAGS_OF                  EQU 11
 = C                          C _EFLAGS_IOPL                EQU 12
 = E                          C _EFLAGS_NT                  EQU 14
 = 10                         C _EFLAGS_RF                  EQU 16
 = 11                         C _EFLAGS_VM                  EQU 17
                              C ; Masks to access specific bits
 = 1                          C _EFLAGS_CF_MASK             EQU  1b SHL _EFLAGS_CF
 = 4                          C _EFLAGS_PF_MASK             EQU  1b SHL _EFLAGS_PF
 = 10                         C _EFLAGS_ACF_MASK            EQU  1b SHL _EFLAGS_ACF
 = 40                         C _EFLAGS_ZF_MASK             EQU  1b SHL _EFLAGS_ZF
 = 80                         C _EFLAGS_SF_MASK             EQU  1b SHL _EFLAGS_SF
 = 100                        C _EFLAGS_TF_MASK             EQU  1b SHL _EFLAGS_TF
 = 200                        C _EFLAGS_IF_MASK             EQU  1b SHL _EFLAGS_IF
 = 400                        C _EFLAGS_DF_MASK             EQU  1b SHL _EFLAGS_DF
 = 800                        C _EFLAGS_OF_MASK             EQU  1b SHL _EFLAGS_OF
 = 3000                       C _EFLAGS_IOPL_MASK           EQU 11b SHL _EFLAGS_IOPL
 = 4000                       C _EFLAGS_NT_MASK             EQU  1b SHL _EFLAGS_NT
 = 10000                      C _EFLAGS_RF_MASK             EQU  1b SHL _EFLAGS_RF
 = 20000                      C _EFLAGS_VM_MASK             EQU  1b SHL _EFLAGS_VM
                              C 
 = 1000                       C _CW_INFINITY                EQU 1000000000000b
 = C00                        C _CW_ROUNDING                EQU  110000000000b
 = 0                          C _CW_ROUNDING_00             EQU  000000000000b
 = 400                        C _CW_ROUNDING_01             EQU  010000000000b
 = 800                        C _CW_ROUNDING_10             EQU  100000000000b
 = C00                        C _CW_ROUNDING_11             EQU  110000000000b
 = 300                        C _CW_PRECISION               EQU    1100000000b
 = 0                          C _CW_PRECISION_00            EQU    0000000000b
 = 100                        C _CW_PRECISION_01            EQU    0100000000b
 = 200                        C _CW_PRECISION_10            EQU    1000000000b
 = 300                        C _CW_PRECISION_11            EQU    1100000000b
 = 20                         C _CW_PM                      EQU        100000b
 = 10                         C _CW_UM                      EQU         10000b
 = 8                          C _CW_OM                      EQU          1000b
 = 4                          C _CW_ZM                      EQU           100b
 = 2                          C _CW_DM                      EQU            10b
 = 1                          C _CW_IM                      EQU             1b
                              C 
 = 8000                       C _SW_BUSY                    EQU 1000000000000000b
 = 4000                       C _SW_C3                      EQU  100000000000000b
 = 3800                       C _SW_TOS                     EQU   11100000000000b
 = 400                        C _SW_C2                      EQU      10000000000b
 = 200                        C _SW_C1                      EQU       1000000000b
 = 100                        C _SW_C0                      EQU        100000000b
 = 80                         C _SW_ERROR_SUMMARY           EQU         10000000b
 = 40                         C _SW_STACK_FAULT             EQU          1000000b
 = 20                         C _SW_PE                      EQU           100000b
 = 10                         C _SW_UE                      EQU            10000b
 = 8                          C _SW_OE                      EQU             1000b
 = 4                          C _SW_ZE                      EQU              100b
 = 2                          C _SW_DE                      EQU               10b
 = 1                          C _SW_IE                      EQU                1b
                              C 
                              C 
                              C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                              C ; ³ GDT ENTRIES ³
                              C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 = 8                          C     _sIDT                       EQU 1 * 8       ; IDT
 = 10                         C     _sGDT                       EQU 2 * 8       ; GDT
 = 18                         C     _sSTACK                     EQU 3 * 8       ; STACK
 = 20                         C     _sCODE                      EQU 4 * 8       ; kernel CODE for kernel code
 = 48                         C     _sDATA                      EQU 9 * 8       ; kernel DATA selector for kernel data
 = 28                         C     _sGRAPHICS                  EQU 5 * 8       ; Graphics video (0a0000h)
 = 30                         C     _sMONO                      EQU 6 * 8       ; Mono video (0b0000h)
 = 38                         C     _sVGA                       EQU 7 * 8       ; VGA video (0b8000h)
 = 40                         C     _sALL_MEM                   EQU 8 * 8       ; All memory (for debugging)
                              C     ; 9 is above, _sDATA
 = 50                         C     _sEXODUS_MEM                EQU 10 * 8      ; Exodus assigned memory
 = 58                         C     _sEXODUS_PORTS              EQU 11 * 8      ; Exodus assigned ports
 = 60                         C     _sEXODUS_INTS               EQU 12 * 8      ; Exodus assigned ints
                              C     ;_sNOT_USED                                 ; available
 = 70                         C     _sEXODUS_TSS                EQU 14 * 8      ; Exodus TSS
 = 78                         C     _sEXODUS_TASK_GATE          EQU 15 * 8      ; Exodus kernel task gate (points to _sEXODUS_TSS)
 = 80                         C     _sEXODUS_SLAVE_TSS          EQU 16 * 8      ; Exodus Slave TSS
 = 88                         C     _sEXODUS_SLAVE_TASK_GATE    EQU 17 * 8      ; Exodus kernel slave task gate (points to _sEXODUS_SLAVE_TSS)
                              C     ;_sNOT USED
 = 98                         C     _sPRIMATIVES                EQU 19 * 8      ; Primative structure for natives
 = A0                         C     _sPRIMATIVE_LOAD_INFO       EQU 20 * 8      ; Primative load information (for reporting on each driver)
 = A8                         C     _sSYSTEM                    EQU 21 * 8      ; Exodus system memory
 = B0                         C     _sEXODUS_REQUESTOR          EQU 22 * 8      ; Call gate to Exodus's requestor() function
 = B8                         C     _sSYSTEM_RING1              EQU 23 * 8      ; Exodus system memory for ring-1 apps
 = C0                         C     _sSYSTEM_RING2              EQU 24 * 8      ; Exodus system memory for ring-2 apps
 = C8                         C     _sSYSTEM_RING3              EQU 25 * 8      ; Exodus system memory for ring-3 apps
 = D0                         C     _sDEBI_screen               EQU 26 * 8      ; low-level DEBI debugger's save screen buffer
 = D8                         C     _sDEBI_memory               EQU 27 * 8      ; low-level DEBI debugger's memory
 = E0                         C     _sFLOPPY_TRACK              EQU 28 * 8      ; Floppy disk data I/O for one full track
 = E8                         C     _sVGA_BACKUP                EQU 29 * 8      ; VGA video (060000h, used when in a graphics mode so writes
                              C                                                 ;  to the text screen are still valid)
 = F0                         C     _sDEBI_screen2              EQU 30 * 8      ; low-level DEBI debugger's save screen buffer2 (for popups and menus)
 = F8                         C     _sDEBI_temp                 EQU 31 * 8      ; low-level DEBI debugger's temporary selector (used for various things)
 = 100                        C     _sEXODUS_OBJECTS            EQU 32 * 8      ; Exodus objects
 = 108                        C     _sTASK_SWITCH_TSS           EQU 33 * 8      ; Task Manager's switch_task() function
 = 110                        C     _sTASK_SWITCH_TASK_GATE     EQU 34 * 8      ; Task Manager's task gate (points to _sTASK_SWITCH_TSS)
 = 118                        C     _sTASK_STACK                EQU 35 * 8      ; Task Manger task's stack
 = 120                        C     _sSTACK0                    EQU 36 * 8      ; Exodus Stack 0
 = 128                        C     _sSTACK1                    EQU 37 * 8      ; Exodus Stack 1
 = 130                        C     _sSTACK2                    EQU 38 * 8      ; Exodus Stack 2
 = 138                        C     _sDEBI_dt                   EQU 39 * 8      ; low-level DEBI debugger's DT storage
 = 140                        C     _sDEBI_np                   EQU 40 * 8      ; low-level DEBI debugger's NP storage
 = 148                        C     _sDEBI_rp                   EQU 41 * 8      ; low-level DEBI debugger's RP storage
                              C 
                              C   ; Variable base/limit GDT slots setup in INIT32.ASP
 = 190                        C     _sEXODUS_INI                EQU 50 * 8      ; Holds the parsed EXODUS.INI sructure
 = 198                        C     _sEXODUS_INI_ERRORS         EQU 51 * 8      ; Holds any errors found while parsing EXODUS.INI
 = 1A0                        C     _sTASK_SYSTEM               EQU 52 * 8      ; Holds all tasks
                              C 
 = 5DA0                       C     _cgTEMP_PRIMATIVE_MAIN      EQU 2996 * 8
 = 5DA8                       C     _cgTEMP_PRIMATIVE_REQUESTOR EQU 2997 * 8
 = 5DB0                       C     _csTEMP_PRIMATIVE           EQU 2998 * 8
 = 5DB8                       C     _dsTEMP_PRIMATIVE           EQU 2999 * 8
                              C 
                              C 
                              C 
                              C ; ÚÄÄÄÄÄÄÄÄÄÄÄ¿
                              C ; ³ CONSTANTS ³
                              C ; ÀÄÄÄÄÄÄÄÄÄÄÄÙ
 = C8                         C     _MIN_PRIMATIVE              EQU 200                             ; Start of the primatives
 = BB3                        C     _MAX_PRIMATIVE              EQU 2995                            ; End of the primatives
 = FFF                        C     _lastGDT                    EQU 4095                            ; Last valid GDT in the GDT
 = 32                         C     _firstASSIGNMENT            EQU 50                              ; The first Exodus assigned GDT entry for various items
 = C7                         C     _lastASSIGNMENT             EQU 199                             ; The last Exodus assigned GDT entry for various items
 = BB8                        C     _firstUSER_ASSIGNMENT       EQU 3000
 = FFF                        C     _lastUSER_ASSIGNMENT        EQU 4095
 = C7                         C     _sGDT_init                  EQU 199                             ; Only initialize the first 199 GDT entries
                              C 
                              C 
                              C   ; Required memory structures for Exodus
                              C   ; Refer to Bootup(internal) document for definitive memory locations
 = 8A000                      C     _sIDT_base                  EQU 8a000h
 = 800                        C     _sIDT_limit                 EQU 800h
 = 800                        C     _sGDT_base                  EQU 0800h
 = 8000                       C     _sGDT_limit                 EQU 8000h
 = 98000                      C     _sSTACK_base                EQU 98000h
 = 8000                       C     _sSTACK_limit               EQU 8000h
 = 10000                      C     _sCODE_base                 EQU 10000h
 = 40000                      C     _sCODE_limit                EQU 40000h
 = 10000                      C     _sDATA_base                 EQU 10000h
 = 30000                      C     _sDATA_limit                EQU 30000h
 = A0000                      C     _sGRAPHICS_base             EQU 0a0000h
 = 10000                      C     _sGRAPHICS_limit            EQU 10000h
 = B0000                      C     _sMONO_base                 EQU 0b0000h
 = 8000                       C     _sMONO_limit                EQU 8000h
 = B8000                      C     _sVGA_base                  EQU 0b8000h     ; Also, see _sVGA_BACKUP_ below
 = 8000                       C     _sVGA_limit                 EQU 8000h
 = 0                          C     _sALL_MEM_base              EQU 0
 = FFFFFFFF                   C     _sALL_MEM_limit             EQU 0ffffffffh
 = 70C00                      C     _sEXODUS_MEM_base           EQU 70c00h
 = 4000                       C     _sEXODUS_MEM_limit          EQU 4000h
 = 6CC00                      C     _sEXODUS_PORTS_base         EQU 6cc00h
 = 4000                       C     _sEXODUS_PORTS_limit        EQU 4000h
 = 97E00                      C     _sEXODUS_INTS_base          EQU 97e00h
 = 200                        C     _sEXODUS_INTS_limit         EQU 200h
 = 68100                      C     _sEXODUS_TSS_base           EQU 68100h
 = 100                        C     _sEXODUS_TSS_limit          EQU 100h        ; 256 bytes
                              C    ;_sEXODUS_TASK_GATE          EQU task gate pointing to _sEXODUS_TSS
 = 68200                      C     _sEXODUS_SLAVE_TSS_base     EQU 68200h
 = 100                        C     _sEXODUS_SLAVE_TSS_limit    EQU 100h        ; 256 bytes
 = 8D380                      C     _sPRIMATIVES_base           EQU 8d380h
 = 4000                       C     _sPRIMATIVES_limit          EQU 4000h       ; 16k
 = 8C380                      C     _sPRIMATIVE_LOAD_INFO_base  EQU 8c380h
 = 1000                       C     _sPRIMATIVE_LOAD_INFO_limit EQU 1000h       ; 4k
 = 89400                      C     _sSYSTEM_base               EQU 89400h
 = C00                        C     _sSYSTEM_limit              EQU 0c00h       ; 3k
 = 800                        C     _sSYSTEM_USER_limit         EQU 0800h       ; 2k
 = 281400                     C     _sDEBI_screen_base          EQU 281400h                         ; ; ; ; ; Added 2 MB, 02/26/2009 - RCH
 = 8000                       C     _sDEBI_screen_limit         EQU 8000h       ; 32k
 = 279400                     C     _sDEBI_memory_base          EQU 279400h                         ; ; ; ; ; Added 2 MB, 02/26/2009 - RCH
 = 8000                       C     _sDEBI_memory_limit         EQU 8000h       ; 32k
 = 74C00                      C     _sFLOPPY_TRACK_base         EQU 74c00h
 = 4800                       C     _sFLOPPY_TRACK_limit        EQU 4800h       ; 512 bytes per sector * 18 sectors * 2 sides = 18k
 = 60000                      C     _sVGA_BACKUP_base           EQU 60000h      ; Note, the backup area is used when in graphics modes that use a0000h
 = 8000                       C     _sVGA_BACKUP_limit          EQU 8000h       ; so all video writes to the text window are still saved
 = 258000                     C     _sDEBI_screen2_base         EQU 258000h
 = 28000                      C     _sDEBI_screen2_limit        EQU 28000h       ; 32k
 = 68000                      C     _sTASK_SWITCH_TSS_base      EQU 68000h
 = 100                        C     _sTASK_SWITCH_TSS_limit     EQU 100h        ; 256 bytes
 = 220000                     C     _sTASK_STACK_base           EQU 220000h                         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 8000                       C     _sTASK_STACK_limit          EQU 8000h       ; 32k
 = 95380                      C     _sSTACK0_base               EQU 95380h
 = 2000                       C     _sSTACK0_limit              EQU 2000h       ; 8k
 = 93380                      C     _sSTACK1_base               EQU 93380h
 = 2000                       C     _sSTACK1_limit              EQU 2000h       ; 8k
 = 91380                      C     _sSTACK2_base               EQU 91380h
 = 2000                       C     _sSTACK2_limit              EQU 2000h       ; 8k
 = 240000                     C     _sDEBI_dt_base              EQU 240000h                         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 8000                       C     _sDEBI_dt_limit             EQU 8000h       ; 32k
 = 248000                     C     _sDEBI_np_base              EQU 248000h                         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 8000                       C     _sDEBI_np_limit             EQU 8000h       ; 32k
 = 250000                     C     _sDEBI_rp_base              EQU 250000h                         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 8000                       C     _sDEBI_rp_limit             EQU 8000h       ; 32k
                              C 
 = 50000                      C     _sEXODUS_OBJECTS_base       EQU 50000h
 = 8000                       C     _sEXODUS_OBJECTS_limit      EQU 8000h       ; 32k
 = 200000                     C     _sEXODUS_INI_base           EQU 200000h     ; 1MB               ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 10000                      C     _sEXODUS_INI_limit          EQU 10000h      ; 64k
 = 210000                     C     _sEXODUS_INI_ERRORS_base    EQU 210000h     ; 1MB + 64k         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 4000                       C     _sEXODUS_INI_ERRORS_limit   EQU 4000h       ; 16k
 = 210000                     C     _sTASK_SYSTEM_base          EQU 210000h     ; 1MB + 64k         ; ; ; ; ; Added 1 MB, 03/01/2009 - RCH
 = 10000                      C     _sTASK_SYSTEM_limit         EQU 010000h     ; 64k
                              C 
                              C 
                              C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                              C ; ³ BOOT DT STRUCTURE ³
                              C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 = 0                          C     _BOOT_DT_object_type        EQU 0
 = 1                          C     _BOOT_DT_days               EQU 1
 = 5                          C     _BOOT_DT_seconds            EQU 5
 = 8                          C     _BOOT_DT_rp_offset          EQU 8
 = A                          C     _BOOT_DT_entry_type         EQU 10
 = B                          C     _BOOT_DT_np_offset          EQU 11
                              C 
                              C 
                              C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                              C ; ³ BOOT RP STRUCTURE ³
                              C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 = 0                          C     _BOOT_RP_length				EQU 0
 = 4                          C     _BOOT_RP_requestor			EQU 4
 = 8                          C     _BOOT_RP_main				EQU 8
                              C ;; For original version using head/track/sector
 = C                          C 	_BOOT_RP_start_head			EQU	12
 = D                          C 	_BOOT_RP_start_track		EQU	13
 = E                          C 	_BOOT_RP_start_sector		EQU	14
 = 10                         C 	_BOOT_RP_end_head			EQU	16
 = 11                         C 	_BOOT_RP_end_track			EQU	17
 = 12                         C 	_BOOT_RP_end_sector			EQU	18
                              C ;; For new version using linear disk offsets
 = C                          C     _BOOT_RP_disk_offset		EQU 12
 = 10                         C 	_BOOT_RP_nuserved			EQU 16 
                              C 
                              C 
                              C 
                              C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                              C ; ³ BOOT PARAMETER BLOCK STRUCTURE ³
                              C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 = 0                          C     _BOOT_PB_size               EQU 0
 = 4                          C     _BOOT_PB_main               EQU 4
 = 8                          C     _BOOT_PB_requestor          EQU 8
 = C                          C     _BOOT_PB_start_head         EQU 12
 = D                          C     _BOOT_PB_start_track        EQU 13
 = E                          C     _BOOT_PB_start_sector       EQU 14
 = 10                         C     _BOOT_PB_end_head           EQU 16
 = 11                         C     _BOOT_PB_end_track          EQU 17
 = 12                         C     _BOOT_PB_end_sector         EQU 18
 = 14                         C     _BOOT_PB_entry_type         EQU 20
 = 16                         C     _BOOT_PB_linear_offset      EQU 22
 = 1A                         C     _BOOT_PB_dt_offset          EQU 26
 = 1C                         C     _BOOT_PB_crc16              EQU 28
 = 20                         C     _BOOT_PB_structure_size     EQU 32
                              C 
                              C 
                              C 
                              C 
                              C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                              C ; ³ EXODUS.INI STRUCTURES ³
                              C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 = 0                          C     _EXODUS_INI_FIRST_BRACKET       EQU 0
 = 4                          C     _EXODUS_INI_TOTAL_BYTES         EQU 4
 = 8                          C     _EXODUS_INI_TOTAL_BRACKET_GROUPS EQU 8
 = C                          C     _EXODUS_INI_TOTAL_PAREN_CASKS   EQU 12
 = 10                         C     _EXODUS_INI_HEADER_LENGTH       EQU 16
                              C 
 = 0                          C     _EXODUS_BRACKET_NEXT            EQU 0
 = 4                          C     _EXODUS_BRACKET_PAREN_CASKS     EQU 4
 = 8                          C     _EXODUS_BRACKET_TOTAL_PARENS    EQU 8
 = C                          C     _EXODUS_BRACKET_NAME            EQU 12
 = 10                         C     _EXODUS_BRACKET_HANDLE          EQU 16
 = 14                         C     _EXODUS_BRACKET_REQUESTOR       EQU 20
 = 16                         C     _EXODUS_BRACKET_REQUESTOR_FUNC  EQU 22
 = 1A                         C     _EXODUS_BRACKET_SCRATCH_AREA    EQU 26
 = 1E                         C     _EXODUS_BRACKET_LENGTH          EQU 30
                              C 
 = 0                          C     _EXODUS_PAREN_NEXT              EQU 0
 = 4                          C     _EXODUS_PAREN_NEXT_SAME_LINE    EQU 4
 = 8                          C     _EXODUS_PAREN_DATA_ITEMS        EQU 8
 = C                          C     _EXODUS_PAREN_TOTAL_DATA_ITEMS  EQU 12
 = 10                         C     _EXODUS_PAREN_SOURCE_LINE       EQU 16
 = 14                         C     _EXODUS_PAREN_SOURCE_LINE_LENGTH EQU 20
 = 18                         C     _EXODUS_PAREN_HANDLE            EQU 24
 = 1A                         C     _EXODUS_PAREN_REQUESTOR         EQU 26
 = 1E                         C     _EXODUS_PAREN_REQUESTOR_FUNC    EQU 30
 = 22                         C     _EXODUS_PAREN_SCRATCH_AREA      EQU 34
 = 26                         C     _EXODUS_PAREN_LENGTH            EQU 38
                              C 
 = 0                          C     _EXODUS_DATA_NEXT               EQU 0
 = 4                          C     _EXODUS_DATA_DATA_ITEM_SOURCE   EQU 4
 = 8                          C     _EXODUS_DATA_DATA_ITEM_LENGTH   EQU 8
 = C                          C     _EXODUS_DATA_LENGTH             EQU 12
                              C 
                              C 
                              C 
                              C 
                              C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                              C ; ³ EXODUS xxx STRUCTURES ³
                              C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
 = 0                          C     _EXODUS_MEM_type                EQU 0
 = 4                          C     _EXODUS_MEM_base                EQU 4
 = 8                          C     _EXODUS_MEM_limit               EQU 8
 = C                          C     _EXODUS_MEM_gdt                 EQU 12
 = E                          C     _EXODUS_MEM_ldt                 EQU 14
 = 10                         C     _EXODUS_MEM_size                EQU 16
                              C 
 = 10                         C     _EXODUS_PORTS_size              EQU 16
                              C 
 = 2                          C     _EXODUS_INTS_size               EQU 2
                              C 
                              C 
                              C 
                              C 
                              C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                              C ; ³ EXODUS SYSTEM MEMORY ³
                              C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                              C ; Note, when updates are made here they need to be reflected in INF\SYSTEM.INF
                              C ; Note, when updates are made here and INF\SYSTEM.INF, the "Exodus Quick Reference" manual needs to be updated
 = 0                          C     _SYSTEM_SECONDS_SINCE_BOOTUP    EQU 0                           ; dword
 = 4                          C     _SYSTEM_SECONDS_SINCE_MIDNIGHT  EQU 4                           ; dword
 = 8                          C     _SYSTEM_HOURS                   EQU 8                           ; byte
 = 9                          C     _SYSTEM_MINUTES                 EQU 9                           ; byte
 = A                          C     _SYSTEM_SECONDS                 EQU 10                          ; byte
 = B                          C     _SYSTEM_182S_OF_A_SECOND        EQU 11                          ; byte
 = C                          C     _SYSTEM_DAY                     EQU 12                          ; byte
 = D                          C     _SYSTEM_MONTH                   EQU 13                          ; byte
 = E                          C     _SYSTEM_YEAR                    EQU 14                          ; word
 = 10                         C     _SYSTEM_DAY_OF_YEAR             EQU 16                          ; word
 = 12                         C     _SYSTEM_BUILD                   EQU 18                          ; 10-byte string in the format: "mm.dd.yyyy"
 = 1C                         C     _SYSTEM_TOTAL_MEMORY            EQU 28                          ; dword, total ram in bytes
 = 20                         C     _SYSTEM_VGA_HORIZONTAL          EQU 32                          ; word (pixels-graphics, or columns-text)
 = 22                         C     _SYSTEM_VGA_VERTICAL            EQU 34                          ; word (pixels-graphics, or rows-text)
 = 24                         C     _SYSTEM_VGA_VIDEO_MODE          EQU 36                          ; byte (0-graphics, 1-text)
 = 25                         C     _SYSTEM_MONO_VIDEO_MODE         EQU 37                          ; byte (0-graphics, 1-text, 0ffh-Unknown)
                              C 
                              C   ; Non-user accessible system memory areas (Exodus internal, hence the use of the _i_)
 = 800                        C     _SYSTEM_i_FATAL                 EQU 2048                        ; dword
 = 804                        C     _SYSTEM_i_TASKS_CREATED         EQU 2052                        ; dword
 = 808                        C     _SYSTEM_i_TASKS_BY_USER         EQU 2056                        ; dword
 = 80C                        C     _SYSTEM_i_TASKS_BY_ERROR        EQU 2060                        ; dword
 = 810                        C     _SYSTEM_i_IRQ6_INDICATOR        EQU 2064                        ; byte, IRQ6 indicator (changes each time an IRQ6 is signaled)
 = 811                        C     _SYSTEM_i_IRQ6_INDICATOR_LAST   EQU 2065                        ; byte, IRQ6 indicator previous, used to see when an IRQ6 is signaled
 = 812                        C     _SYSTEM_i_BASE                  EQU 2066                        ; dword
 = 816                        C     _SYSTEM_i_LIMIT                 EQU 2070                        ; dword
 = 81A                        C     _SYSTEM_i_DWORD_TO_COPY         EQU 2074                        ; word
 = 81C                        C     _SYSTEM_i_LAST_GDT_REFERENCED   EQU 2076                        ; qword
 = 824                        C     _SYSTEM_i_CODE_GDT_OFFSET       EQU 2084                        ; dword (used temporarily during native primative install)
 = 828                        C     _SYSTEM_i_DATA_GDT_OFFSET       EQU 2088                        ; dword (used temporarily during native primative install)
 = 82C                        C     _SYSTEM_i_MAIN_GDT_OFFSET       EQU 2092                        ; dword (used temporarily during native primative install)
 = 830                        C     _SYSTEM_i_REQUESTOR_GDT_OFFSET  EQU 2096                        ; dword (used temporarily during native primative install)
 = 834                        C     _SYSTEM_i_GDT_TO_ASSIGN         EQU 2100                        ; word (used various places to assign GDT entries)
 = 836                        C     _SYSTEM_i_USER_GDT_TO_ASSIGN    EQU 2102                        ; word (used various places to assign USER Program GDTs)
                              C   ; Next offset is 2104
                              C 
                              C 
                              C   ; These scratch items exist from end of memory down
 = BF8                        C     _SYSTEM_i_SCRATCH_DWORD2        EQU 3064                        ; dword (used various places as a scratch buffer)
 = BFC                        C     _SYSTEM_i_SCRATCH_DWORD1        EQU 3068                        ; dword (used various places as a scratch buffer)
                              C 
                              C 
                              C 
                              C 
                              C ; ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
                              C ; ³ BOCHS SUPPORT ³
                              C ; ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
                              C ; These equates are used to communicate via INT 0FFh
                              C ; Values here are in ecx, with edx being used for data information.
                              C ; Values in eax must be
 = 12345678                   C     _BOCHS1                         EQU 12345678h
 = 87654321                   C     _BOCHS2                         EQU 87654321h
 = 0                          C     _BOCHS_GET_MONO_MOUSE_XY        EQU 0
 = 1                          C     _BOCHS_GET_MONO_CURSOR          EQU 1
                                INCLUDE ../source/common/errors.asp							; Error codes used throughout
                              C ; errors.asp
                              C 
                              C ; FDC error codes
 = 1                          C _FDC_INVALID_PARAMETERS         EQU 1
 = 2                          C _FDC_SEEK_FAILED                EQU 2
 = 3                          C _FDC_TIMEOUT                    EQU 3
 = 4                          C _FDC_INVALID_DRIVE              EQU 4
 = 5                          C _FDC_UNKNOWN_DRIVE_TYPE         EQU 5
 = 6                          C _FDC_INVALID_MEDIA              EQU 6
 = 7                          C _FDC_SECTOR_NOT_FOUND           EQU 7
                              C 
                              C 
                              C ; DISK error codes
 = 1                          C _DISK_INVALID_DRIVE             EQU 1
 = 2                          C _DISK_INVALID_REQUEST           EQU 2
 = 3                          C _DISK_INVALID_PARAMETERS        EQU 3
                              C 
                              C 
                              C ; Requestor error codes, general
 = 1                          C _RQ_UNKNOWN_REQUEST             EQU 1
                              C 
                              C 
                              C ; Requestor error codes, specific
 = 3E8                        C _RQ_iDISK_DRIVE_NOT_FOUND       EQU 1000
                              C 
                              C 
                              C ; OBJECT system error codes
 = 0                          C _TASK_NOT_FOUND                 EQU 0
 = 1                          C _OBJECT_NOT_FOUND               EQU 1
 = 2                          C _UNKNOWN_OBJECT_TYPE            EQU 2
 = 3                          C _UNKNOWN_OBJECT_PROPERTY        EQU 3
 = 4                          C _UNKNOWN_OBJECT_EVENT           EQU 4
                                INCLUDE equates.asp
                              C ; equates.asp
                              C ;
                              C ; Exodus equates used by BOOTUP
                              C ;
                              C 
 = 0                          C _NO                     EQU 0
 = 1                          C _YES                    EQU 1

                                ;;
                                ;;  úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
                                ;;  úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
                                ;;  úúúÛÛúúúúúÛÛÛúúúúúúúúúúúÛÛÛúúúúúúúúÛÛúúúúúúÛúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúÛÛÛúúúúúúúúúú
                                ;;  úúÛÛÛúúúúÛÛúúúúúúúúúúúúúúÛÛúúúúúúúúÛÛúúúúúÛÛúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúÛÛúúúúúúúúúú
                                ;;  úÛÛÛÛúúúÛÛúúúúúúúúúúúúúúúÛÛúúúúúúúúúúúúúúúÛÛúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúÛÛúúúúúúúúúú
                                ;;  úúúÛÛúúúÛÛúúúúúúúúúúúúúúúÛÛÛÛúúúúúÛÛÛúúúÛÛÛÛÛÛúúúúúúúúúúúÛÛÛÛÛúúúÛÛÛÛÛúúúúÛÛÛÛúúúÛÛÛÛÛúú
                                ;;  úúúÛÛúúúÛÛÛÛÛÛúúúúúúúúúúúÛÛúÛÛúúúúúÛÛúúúúúÛÛúúúúúúúúúúúúÛÛúúúÛÛúÛÛúúúÛÛúúÛÛúÛÛúúÛÛúúúÛÛú
                                ;;  úúúÛÛúúúÛÛúúúÛÛúúúúúúúúúúÛÛúúÛÛúúúúÛÛúúúúúÛÛúúúúúúúúúúúúÛÛúúúúúúÛÛúúúÛÛúÛÛúúÛÛúúÛÛÛÛÛÛÛú
                                ;;  úúúÛÛúúúÛÛúúúÛÛúúúúúúúúúúÛÛúúÛÛúúúúÛÛúúúúúÛÛúúúúúúúúúúúúÛÛúúúúúúÛÛúúúÛÛúÛÛúúÛÛúúÛÛúúúúúú
                                ;;  úúúÛÛúúúÛÛúúúÛÛúúúúúúúúúúÛÛúúÛÛúúúúÛÛúúúúúÛÛúÛÛúúúúúúúúúÛÛúúúÛÛúÛÛúúúÛÛúÛÛúúÛÛúúÛÛúúúÛÛú
                                ;;  úÛÛÛÛÛÛúúÛÛÛÛÛúúúúúúúúúúúÛÛÛÛÛúúúúÛÛÛÛúúúúúÛÛÛúúúúúúúúúúúÛÛÛÛÛúúúÛÛÛÛÛúúúÛÛÛúÛÛúúÛÛÛÛÛúú
                                ;;  úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
                                ;;  úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
                                ;;  úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
                                ;;
00000000                        _TEXT   SEGMENT PUBLIC  'CODE'  USE16
                                    ORG 0h
                                ;;
                                ;; START OF EXODUS
                                ;;
                                ;; ---------------
                                ;;
                                ;; During this segment we're in real mode.
                                ;; All BIOS services are available
                                ;;
                                ;; Upon entry:  cx - total # of bytes in boot_parameter_block
                                ;;             edx - next linear address of free memory (between 010000h and 03ffffh)
                                ;;         cs:[si] - far ptr to start of parameter_block
                                ;;      cs:[si-12] - linear address of boot device's DT entry
                                ;;      cs:[si-08] - linear address of boot device's NP entry
                                ;;      cs:[si-04] - linear address of boot device's RP entry
                                ;;

00000000                          start:
                                ;; Save the parameter block information given by BOOT.COM
00000000  2E890E7F0A                mov     cs:boot_parameter_count,cx                              ; Number of drivers loaded
00000005  662E8916810A              mov     cs:next_linear_address,edx                              ; Next address of free memory in Exodus bootup area
0000000B  668B44F4                  mov     eax,dword ptr ds:[si-12]
0000000F  662EA3850A                mov     cs:boot_dt_linear,eax                                   ; 1st sector of DT
00000014  668B44F8                  mov     eax,dword ptr ds:[si-8]
00000018  662EA3890A                mov     cs:boot_np_linear,eax                                   ; 1st sector of NP
0000001D  668B44FC                  mov     eax,dword ptr ds:[si-4]
00000021  662EA38D0A                mov     cs:boot_rp_linear,eax                                   ; 1st sector of RP
00000026  6633C0                    xor     eax,eax
00000029  6681E6FFFF0000            and     esi,0ffffh
00000030  8CD8                      mov     ax,ds
00000032  66C1E004                  shl     eax,4
00000036  6603C6                    add     eax,esi
00000039  662EA37B0A                mov     cs:boot_parameter_block,eax                             ; Linear offset into memory where boot_parameter_block starts
                                                                                                    ; * Refer to source\boot.asm for boot_parameter_block info

                                ;; Setup the data segments for this program
0000003E  8CC8                      mov     ax,cs
00000040  8ED8                      mov     ds,ax
00000042  8EC0                      mov     es,ax

                                ;; Set video mode using BIOS
00000044  B80300                    mov     ax,00003h                                               ; Mode 3 = 80x25 color
00000047  CD10                      int     10h

                                ;; Turn on high intensity using BIOS
00000049  B80310                    mov     ax,1003h                                                ; video high intensity on (instead of blinking)
0000004C  32DB                      xor     bl,bl
0000004E  CD10                      int     10h

                                ;; Show the bootup identification using BIOS
00000050  BBB900                    mov     bx,57+128                                               ; bright blue on bright cyan
00000053  33D2                      xor     dx,dx
00000055  BD7508                    mov     bp,offset bootup_id1
00000058  B95000                    mov     cx,sizeof bootup_id1
0000005B  32FF                      xor     bh,bh
0000005D  B80113                    mov     ax,01301h
00000060  CD10                      int     10h

00000062  BBB900                    mov     bx,57+128                                               ; bright blue on bright cyan
00000065  BA0001                    mov     dx,00100h
00000068  BDC508                    mov     bp,offset bootup_id2
0000006B  B95000                    mov     cx,sizeof bootup_id2
0000006E  32FF                      xor     bh,bh
00000070  B80113                    mov     ax,01301h
00000073  CD10                      int     10h

                                ;; Verify the CRC-16 of the boot files
                                ;    mov     bx,07
                                ;    mov     dx,00300h
                                ;    mov     bp,offset verifying_crc
                                ;    mov     cx,sizeof verifying_crc
                                ;    xor     bh,bh
                                ;    mov     ax,01301h
                                ;    int     10h
                                ;    call    verify_crc16

                                ;; Enable gate A20 via Exodus
00000075  BD2409                    mov     bp,offset enabling_gate_a20
00000078  B90E00                    mov     cx,sizeof enabling_gate_a20
0000007B  BB0700                    mov     bx,07
0000007E  BA0004                    mov     dx,0400h
00000081  B80113                    mov     ax,01301h
00000084  CD10                      int     10h
00000086  E88D01                    call    enable_gate_a20

                                ;; Setup environment for protected mode via Exodus
00000089  BD3209                    mov     bp,offset setup_pmode_vars
0000008C  B91000                    mov     cx,sizeof setup_pmode_vars
0000008F  BB0700                    mov     bx,07
00000092  BA0005                    mov     dx,0500h
00000095  B80113                    mov     ax,01301h
00000098  CD10                      int     10h
0000009A  E89C01                    call    setup_pmode_variables

                                ;; Enter protected mode via Exodus
0000009D  BD4209                    mov     bp,offset entering_pmode
000000A0  B91900                    mov     cx,sizeof entering_pmode
000000A3  BB0700                    mov     bx,07
000000A6  BA0006                    mov     dx,0600h
000000A9  B80113                    mov     ax,01301h
000000AC  CD10                      int     10h

000000AE  FA                        cli                                                             ; Clear interrupts
000000AF  0F20C0                    mov     eax,cr0
000000B2  0C01                      or      al,1
000000B4  0F22C0                    mov     cr0,eax
                                ;; Ok, we're in protected mode, still 16-bit code segment though
000000B7  EB00                      jmp     $+2                                                     ; Clear the cache
000000B9  0F011E910A                lidt    fword ptr IDT_ptr                                       ; Load IDT
000000BE  0F0116970A                lgdt    fword ptr GDT_ptr                                       ; Load GDT
000000C3  33C0                      xor     ax,ax
000000C5  0F00D0                    lldt    ax                                                      ; Load LDT with NULL
000000C8  B87000                    mov     ax,_sEXODUS_TSS                                         ; Load TR
000000CB  0F00D8                    ltr     ax
                                  ; Data segment registers
000000CE  B84800                    mov     ax,_sDATA
000000D1  8ED8                      mov     ds,ax
000000D3  8EC0                      mov     es,ax
                                  ; Extra segment registers
000000D5  B83800                    mov     ax,_sVGA
000000D8  8EE0                      mov     fs,ax
000000DA  B83000                    mov     ax,_sMONO
000000DD  8EE8                      mov     gs,ax
                                  ; Stack
000000DF  B81800                    mov     ax,_sSTACK
000000E2  8ED0                      mov     ss,ax
000000E4  66BCFC7F0000              mov     esp,_sSTACK_limit - 4
000000EA  FB                        sti

                                ;; Load the 32-bit _sCODE selector for CS and enter 32-bit code
000000EB  682000                    push    word ptr _sCODE                                         ; Exodus CODE segment
000000EE  689D0A                    push    word ptr offset end_of_16_bit_segment                   ; EIP
000000F1  CB                        retf                                                            ; Execution continues below after "first_pmode_instruction"

                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ;;
                                ;; Note:  Each of these include files contains only 16-bit code and/or data.  However, some of them can create 32-bit items.
                                ;;
                                    INCLUDE init16.asp
                              C ; init16.asp
                              C ;
                              C ; Exodus initialization routines
                              C ;
                              C ;  Functions:
                              C ;     verify_crc16                            ; Verify the CRC16 value stored in the bootup entries
                              C ;      enable_gate_a20                         ; Enables gate A20 so we can access all memory
                              C ;      setup_pmode_variables                   ; Sets up GDT and IDT
                              C ;        create_null_data_descriptor
                              C ;         create_data_descriptor
                              C ;         create_code_descriptor
                              C ;         create_interrupt_descriptor_32_bit   ; Creates a 32-bit descriptor entry
                              C ;         create_interrupt_descriptors
                              C ;         create_exodus_tss_descriptor
                              C ;         create_call_gate_descriptor
                              C ;         create_task_gate_descriptor
                              C ;
                              C 
                              C 
                              C 
                              C 
000000F2                      C verify_crc16    PROC    NEAR
                              C ; This routine scans all of the loaded data to ensure that the calculated CRC matches the CRC stored in the DT
                              C ;
                              C ; Upon entry:   boot_parameter_block - holds the linear address of all the files loaded in memory
                              C ;
                              C ; Upon exit:    This routine is self-terminating.  If there is a CRC error the program is terminated here.
                              C ;
000000F2  C8020000            C     enter   2,0
                              C   ; [bp-2] - item
000000F6  6660                C     pushad
000000F8  1E                  C     push    ds
000000F9  06                  C     push    es
                              C 
                              C 
000000FA  668B367B0A          C     mov     esi,ds:boot_parameter_block
000000FF  6646                C     inc     esi
00000101  668BD6              C     mov     edx,esi
00000104  66C1EA04            C     shr     edx,4
00000108  8EDA                C     mov     ds,dx
0000010A  6683E60F            C     and     esi,0fh
                              C   ; Right now, ds:[si] - far ptr to the boot parameter block
0000010E  C746FE0000          C     mov     word ptr [bp-2],0
00000113                      C     .WHILE (byte ptr ds:[si+_BOOT_PB_entry_type] != 0ffh)
00000115  8A4414              C         mov     al,byte ptr ds:[si+_BOOT_PB_entry_type]
00000118  D0E8                C         shr     al,1
0000011A  2407                C         and     al,111b
0000011C                      C         .IF (al != 011b)
                              C           ; It's not bootup.bin (this program is bootup.bin, and whenever memory variables change the CRC will change,
                              C           ;                      so we don't do any crc calculations on bootup.bin)
00000120  668B0C              C             mov     ecx,dword ptr ds:[si+_BOOT_PB_size]
00000123  668B7C16            C             mov     edi,dword ptr ds:[si+_BOOT_PB_linear_offset]
00000127  668BD7              C             mov     edx,edi
0000012A  66C1EA04            C             shr     edx,4
0000012E  8EC2                C             mov     es,dx
00000130  6683E70F            C             and     edi,0fh
                              C 
                              C           ; Right now, es:[di] - far ptr to start of this entry
                              C           ;                 bx - used for crc16 value
00000134  33DB                C             xor     bx,bx
00000136                      C           @@:
00000136  6801A0              C             push    word ptr 0a001h         ; mask
00000139  32E4                C             xor     ah,ah
0000013B  268A05              C             mov     al,byte ptr es:[di]
0000013E  50                  C             push    ax                      ; c
0000013F  53                  C             push    bx                      ; crc
                              C 
00000140  E89C00              C             call    update_crc16_value
00000143  8BD8                C             mov     bx,ax
00000145  83C406              C             add     sp,6
                              C 
00000148  47                  C             inc     di
00000149  E2EB                C             loop    @B
                              C           ; Right now, bx is the crc16 value for this entry
0000014B  395C1C              C             cmp     word ptr ds:[si+_BOOT_PB_crc16],bx
0000014E  7424                C             jz      next_one
                              C 
                              C           ; This CRC value does not match the one on disk
                              C           ; Display a message and then lockup the system
00000150  8CCB                C             mov     bx,cs
00000152  8EDB                C             mov     ds,bx
00000154  8EC3                C             mov     es,bx
                              C 
00000156  8B46FE              C             mov     ax,word ptr [bp-2]
00000159  0441                C             add     al,'A'
0000015B  A28A09              C             mov     crc_error_code[3],al                        ; Store the error code for display
0000015E  BB0700              C             mov     bx,07
00000161  BA0004              C             mov     dx,00400h
00000164  BD6709              C             mov     bp,offset crc_error_start
00000167  B91401              C             mov     cx,offset crc_error_end - offset crc_error_start
0000016A  32FF                C             xor     bh,bh
0000016C  B80113              C             mov     ax,01301h
0000016F  CD10                C             int     10h
                              C           ; Now that the message is displayed, lock up the system
                              C           ; They have to press reset to fix this error
00000171                      C           @@:
00000171  F4                  C             hlt
00000172  EBFD                C             jmp     @B
                              C 
00000174                      C         .ENDIF
                              C 
00000174                      C       next_one:
00000174  FF46FE              C         inc     word ptr [bp-2]
00000177  83C620              C         add     si,_BOOT_PB_structure_size
0000017A                      C     .ENDW
                              C 
00000180  07                  C     pop     es
00000181  1F                  C     pop     ds
00000182  6661                C     popad
00000184  C9                  C     leave
00000185                      C     ret
00000186                      C verify_crc16    ENDP
                              C 
                              C 
                              C 
                              C 
00000186                      C display_crc_comparitive     PROC    NEAR
00000186  32FF                C     xor     bh,bh
00000188  BB0700              C     mov     bx,07
0000018B  8A76FE              C     mov     dh,byte ptr [bp-2]
0000018E  80C605              C     add     dh,5
00000191  32D2                C     xor     dl,dl
00000193  55                  C     push    bp
00000194  BD5B09              C     mov     bp,offset crc_comparitive
00000197  B90C00              C     mov     cx,sizeof crc_comparitive
0000019A  B80113              C     mov     ax,01301h
0000019D  CD10                C     int     10h
0000019F  5D                  C     pop     bp
000001A0                      C     ret
000001A1                      C display_crc_comparitive     ENDP
                              C 
                              C 
                              C 
                              C 
000001A1                      C extract_word_to_ds_di       PROC    NEAR
                              C ; This routine is used to extract the dword
                              C ;
                              C ; Upon entry:   dx - word to extract
                              C ;          ds:[si] - where to store
                              C ;
                              C ; Upon exit:    4 hex characters are stored at ds:[si]
                              C ;
000001A1  57                  C     push    di
000001A2  50                  C     push    ax
                              C 
000001A3  8AC6                C     mov     al,dh
000001A5  C0E804              C     shr     al,4
000001A8  E82500              C     call    adjust_al
000001AB  8805                C     mov     byte ptr ds:[di],al
000001AD  47                  C     inc     di
                              C 
000001AE  8AC6                C     mov     al,dh
000001B0  240F                C     and     al,0fh
000001B2  E81B00              C     call    adjust_al
000001B5  8805                C     mov     byte ptr ds:[di],al
000001B7  47                  C     inc     di
                              C 
000001B8  8AC2                C     mov     al,dl
000001BA  C0E804              C     shr     al,4
000001BD  E81000              C     call    adjust_al
000001C0  8805                C     mov     byte ptr ds:[di],al
000001C2  47                  C     inc     di
                              C 
000001C3  8AC2                C     mov     al,dl
000001C5  240F                C     and     al,0fh
000001C7  E80600              C     call    adjust_al
000001CA  8805                C     mov     byte ptr ds:[di],al
000001CC  47                  C     inc     di
                              C 
000001CD  58                  C     pop     ax
000001CE  5F                  C     pop     di
000001CF                      C     ret
000001D0                      C extract_word_to_ds_di       ENDP
                              C 
                              C 
                              C 
                              C 
000001D0                      C adjust_al   proc    near
000001D0                      C     .IF (al >= 0 && al <= 9)
000001D8  0430                C         add     al,'0'
000001DA                      C     .ELSE
000001DC  0457                C         add     al,'a'-10
000001DE                      C     .ENDIF
000001DE                      C     ret
000001DF                      C adjust_al   endp
                              C 
                              C 
                              C 
                              C 
000001DF                      C update_crc16_value      PROC    NEAR
                              C ; This is the assembly generated by this CRC16 algorithm
                              C ;
                              C ; Upon entry:   On the stack:   mask, c, crc (each a word, in that order)
                              C ;
                              C ; [bp+8] - word, mask
                              C ; [bp+6] - word, c
                              C ; [bp+4] - word, crc
                              C ; [bp+2] - word, ip
                              C ; [bp+0] - word, bp
000001DF  C8020000            C     enter   2,0
                              C ; [bp-2] - word, i
000001E3  57                  C     push    di
000001E4  56                  C     push    si
000001E5  51                  C     push    cx
                              C 
000001E6  C746FE0800          C     mov     word ptr [bp-2],8   ; i
000001EB  8B7604              C     mov     si,word ptr [bp+4]  ; crc
000001EE  8B7E06              C     mov     di,word ptr [bp+6]  ; c
000001F1                      C   F515:
000001F1  8BC6                C     mov     ax,si
000001F3  8BCF                C     mov     cx,di
000001F5  32C1                C     xor     al,cl
000001F7  A801                C     test    al,1
000001F9  740B                C     je      I518
000001FB  8BC6                C     mov     ax,si
000001FD  D1E8                C     shr     ax,1
000001FF  334608              C     xor     ax,word ptr [bp+8]  ; mask
00000202  8BF0                C     mov     si,ax
00000204  EB02                C     jmp     I519
                              C 
00000206                      C   I518:
00000206  D1EE                C     shr     si,1
                              C 
00000208                      C   I519:
00000208  D1EF                C     shr     di,1
0000020A  FF4EFE              C     dec     word ptr [bp-2]     ; i
0000020D  75E2                C     jne     F515
0000020F  8BC6                C     mov     ax,si
                              C 
00000211  59                  C     pop     cx
00000212  5E                  C     pop     si
00000213  5F                  C     pop     di
00000214  C9                  C     leave
00000215                      C     ret
00000216                      C update_crc16_value      ENDP
                              C 
                              C 
                              C 
                              C 
00000216                      C enable_gate_a20     PROC    NEAR
                              C   ;; Clear interrupts
00000216  FA                  C     cli
                              C 
                              C   ;; Take control of gate A20
00000217  33C9                C     xor     cx,cx                                                   ; Only loop 64k times
00000219                      C   eg_loop1:
00000219  E464                C     in      al,64h                                                  ; Are we able to send our data yet?
0000021B  A802                C     test    al,2
0000021D  E0FA                C     loopnz  eg_loop1                                                ; No if loop
                              C 
0000021F  B0D1                C     mov     al,0d1h                                                 ; Send command "get ready to receive Output Port byte"
00000221  E664                C     out     64h,al
                              C 
00000223  33C9                C     xor     cx,cx
00000225                      C   eg_loop2:
00000225  E464                C     in      al,64h                                                  ; Are we able to send our data yet?
00000227  A802                C     test    al,2
00000229  E0FA                C     loopnz  eg_loop2
                              C 
0000022B  B033                C     mov     al,00110011b                                            ; Send "Output Port" byte
0000022D  E660                C     out     60h,al                                                  ; 76543210
                              C                                                                     ; xx11xx11
0000022F  33C9                C     xor     cx,cx                                                   ; 
00000231                      C   eg_loop3:                                                         ;          system reset (0-reset)
00000231  E464                C     in      al,64h                                                  ;         gate A20 (1-access above 1MB)
00000233  A802                C     test    al,2                                                    ;        mouse data clock
00000235  E0FA                C     loopnz  eg_loop3                                                ;       data to mouse
                              C                                                                     ;      IRQ1 int 71h
                              C   ;; Enable interrupts                                              ;     IRQ12 int 74h
00000237  FB                  C     sti                                                             ;    keyboard clock
00000238                      C     ret                                                             ;   data to keyboard
00000239                      C enable_gate_a20     ENDP
                              C 
                              C 
                              C 
                              C 
00000239                      C setup_pmode_variables   PROC    NEAR
00000239  1E                  C     push    ds
                              C 
                              C ;; Setup all the IDT entries to point to an "iret"
0000023A  B8008A              C     mov     ax,_sIDT_base SHR 4
0000023D  8ED8                C     mov     ds,ax
0000023F  6633F6              C     xor     esi,esi
00000242  E8A704              C     call    create_interrupt_descriptors
                              C 
                              C ;; Setup all the GDT entries to point to a NULL data descriptor
00000245  33C0                C     xor     ax,ax
00000247  8ED8                C     mov     ds,ax
00000249  66BE00080000        C     mov     esi,_sGDT_base                                          ; GDT is defined in common\equates.asp
0000024F  B9C700              C     mov     cx,_sGDT_init                                           ; But, only the first 200 entries are initialized at bootup
00000252  6656                C     push    esi
00000254                      C     .REPEAT
00000254  E82B03              C         call    create_null_data_descriptor
00000257  6683C608            C         add     esi,8
0000025B                      C     .UNTILCXZ
0000025D  665E                C     pop     esi
                              C 
                              C ;; Now, setup only the ones we'll need for the Exodus bootup.com requirements
                              C ;; Additional entries will be created during initialization and exodus.ini processing
                              C   ;; Slot 1, IDT ptr
0000025F  66B801000000        C     mov     eax,_sIDT / 8                                           ; slot in GDT
00000265  66BB00A00800        C     mov     ebx,_sIDT_base                                          ; base
0000026B  66BA00080000        C     mov     edx,_sIDT_limit                                         ; limit
00000271  E82003              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 2, GDT ptr
00000274  66B802000000        C     mov     eax,_sGDT / 8
0000027A  66BB00080000        C     mov     ebx,_sGDT_base
00000280  66BA00800000        C     mov     edx,_sGDT_limit
00000286  E80B03              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 3, STACK ptr
00000289  66B803000000        C     mov     eax,_sSTACK / 8
0000028F  66BB00800900        C     mov     ebx,_sSTACK_base
00000295  66BA00800000        C     mov     edx,_sSTACK_limit
0000029B  E8F602              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 4, kernel code (this program)
0000029E  66B804000000        C     mov     eax,_sCODE / 8
000002A4  66BB00000100        C     mov     ebx,_sCODE_base
000002AA  66BA00000400        C     mov     edx,_sCODE_limit
000002B0  E8D603              C     call    create_code_descriptor
                              C 
                              C   ;; Slot 9, kernel data (same area as code, just mapped as read/write)
000002B3  66B809000000        C     mov     eax,_sDATA / 8
000002B9  66BB00000100        C     mov     ebx,_sDATA_base
000002BF  66BA00000300        C     mov     edx,_sDATA_limit
000002C5  E8CC02              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 5, data (graphics video memory)
000002C8  66B805000000        C     mov     eax,_sGRAPHICS / 8
000002CE  66BB00000A00        C     mov     ebx,_sGRAPHICS_base
000002D4  66BA00000100        C     mov     edx,_sGRAPHICS_limit
000002DA  E8B702              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 6, data (mono video memory)
000002DD  66B806000000        C     mov     eax,_sMONO / 8
000002E3  66BB00000B00        C     mov     ebx,_sMONO_base
000002E9  66BA00800000        C     mov     edx,_sMONO_limit
000002EF  E8A202              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 7, data (vga video memory)
000002F2  66B807000000        C     mov     eax,_sVGA / 8
000002F8  66BB00800B00        C     mov     ebx,_sVGA_base
000002FE  66BA00800000        C     mov     edx,_sVGA_limit
00000304  E88D02              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 8, data (access to all memory)
00000307  66B808000000        C     mov     eax,_sALL_MEM / 8
0000030D  66BB00000000        C     mov     ebx,_sALL_MEM_base
00000313  66BAFFFFFFFF        C     mov     edx,_sALL_MEM_limit
00000319  E87802              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 10, Exodus assigned memory
0000031C  66B80A000000        C     mov     eax,_sEXODUS_MEM / 8
00000322  66BB000C0700        C     mov     ebx,_sEXODUS_MEM_base
00000328  66BA00400000        C     mov     edx,_sEXODUS_MEM_limit
0000032E  E86302              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 11, Exodus assigned ports
00000331  66B80B000000        C     mov     eax,_sEXODUS_PORTS / 8
00000337  66BB00CC0600        C     mov     ebx,_sEXODUS_PORTS_base
0000033D  66BA00400000        C     mov     edx,_sEXODUS_PORTS_limit
00000343  E84E02              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 12, Exodus assigned ints
00000346  66B80C000000        C     mov     eax,_sEXODUS_INTS / 8
0000034C  66BB007E0900        C     mov     ebx,_sEXODUS_INTS_base
00000352  66BA00020000        C     mov     edx,_sEXODUS_INTS_limit
00000358  E83902              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 13, --Nuserved
                              C   ;; Slot 14, Exodus TSS
0000035B  66B80E000000        C     mov     eax,_sEXODUS_TSS / 8
00000361  66BB00810600        C     mov     ebx,_sEXODUS_TSS_base
00000367  66B900000000        C     mov     ecx,offset first_pmode_instruction
0000036D  66BA00010000        C     mov     edx,_sEXODUS_TSS_limit
00000373  E89A03              C     call    create_exodus_tss_descriptor
                              C 
                              C   ;; Slot 15, Task gate to Exodus TSS
00000376  66B80F000000        C     mov     eax,_sEXODUS_TASK_GATE / 8                              ; GDT slot
0000037C  66BB70000000        C     mov     ebx,_sEXODUS_TSS                                        ; GDT slot of TSS this task gate points to
00000382  E8D704              C     call    create_task_gate_descriptor
                              C 
                              C   ;; Slot 16, Exodus TSS
00000385  66B810000000        C     mov     eax,_sEXODUS_SLAVE_TSS / 8
0000038B  66BB00820600        C     mov     ebx,_sEXODUS_SLAVE_TSS_base
00000391  66B900000000        C     mov     ecx,offset first_pmode_instruction
00000397  66BA00010000        C     mov     edx,_sEXODUS_SLAVE_TSS_limit
0000039D  E87003              C     call    create_exodus_tss_descriptor
                              C 
                              C   ;; Slot 17, Task gate to Exodus TSS
000003A0  66B811000000        C     mov     eax,_sEXODUS_SLAVE_TASK_GATE / 8                        ; GDT slot
000003A6  66BB80000000        C     mov     ebx,_sEXODUS_SLAVE_TSS                                  ; GDT slot of TSS this task gate points to
000003AC  E8AD04              C     call    create_task_gate_descriptor
                              C 
                              C   ;; Slot 18, --Nuserved
                              C   ;; Slot 19, PRIMATIVES
000003AF  66B813000000        C     mov     eax,_sPRIMATIVES / 8
000003B5  66BB80D30800        C     mov     ebx,_sPRIMATIVES_base
000003BB  66BA00400000        C     mov     edx,_sPRIMATIVES_limit
000003C1  E8D001              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 20, PRIMATIVES
000003C4  66B814000000        C     mov     eax,_sPRIMATIVE_LOAD_INFO / 8
000003CA  66BB80C30800        C     mov     ebx,_sPRIMATIVE_LOAD_INFO_base
000003D0  66BA00100000        C     mov     edx,_sPRIMATIVE_LOAD_INFO_limit
000003D6  E8BB01              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 21, Exodus system memory
000003D9  66B815000000        C     mov     eax,_sSYSTEM / 8
000003DF  66BB00940800        C     mov     ebx,_sSYSTEM_base
000003E5  66BA000C0000        C     mov     edx,_sSYSTEM_limit
000003EB  E8A601              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 22, Exodus's requestor() call gate
000003EE  66B816000000        C     mov     eax,_sEXODUS_REQUESTOR / 8
000003F4  66BB6B2C0000        C     mov     ebx,offset requestor
000003FA  6633C9              C     xor     ecx,ecx
000003FD  BA2000              C     mov     dx,_sCODE
00000400  E83604              C     call    create_call_gate_descriptor
                              C 
                              C   ;; Slot 23, Exodus system memory (ring-1)
00000403  66B817000000        C     mov     eax,_sSYSTEM_RING1 / 8
00000409  66BB00940800        C     mov     ebx,_sSYSTEM_base
0000040F  66BA00080000        C     mov     edx,_sSYSTEM_USER_limit
00000415  B101                C     mov     cl,1
00000417  E8C901              C     call    create_data_descriptor_pl
                              C 
                              C   ;; Slot 24, Exodus system memory (ring-2)
0000041A  66B818000000        C     mov     eax,_sSYSTEM_RING2 / 8
00000420  66BB00940800        C     mov     ebx,_sSYSTEM_base
00000426  66BA00080000        C     mov     edx,_sSYSTEM_USER_limit
0000042C  B102                C     mov     cl,2
0000042E  E8B201              C     call    create_data_descriptor_pl
                              C 
                              C   ;; Slot 25, Exodus system memory (ring-3)
00000431  66B819000000        C     mov     eax,_sSYSTEM_RING3 / 8
00000437  66BB00940800        C     mov     ebx,_sSYSTEM_base
0000043D  66BA00080000        C     mov     edx,_sSYSTEM_USER_limit
00000443  B103                C     mov     cl,3
00000445  E89B01              C     call    create_data_descriptor_pl
                              C 
                              C   ;; Slot 26, low-level DEBI screen memory
00000448  66B81A000000        C     mov     eax,_sDEBI_screen / 8
0000044E  66BB00142800        C     mov     ebx,_sDEBI_screen_base
00000454  66BA00800000        C     mov     edx,_sDEBI_screen_limit
0000045A  E83701              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 27, low-level DEBI objects memory
0000045D  66B81B000000        C     mov     eax,_sDEBI_memory / 8
00000463  66BB00942700        C     mov     ebx,_sDEBI_memory_base
00000469  66BA00800000        C     mov     edx,_sDEBI_memory_limit
0000046F  E82201              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 28, low-level DEBI objects memory
00000472  66B81C000000        C     mov     eax,_sFLOPPY_TRACK / 8
00000478  66BB004C0700        C     mov     ebx,_sFLOPPY_TRACK_base
0000047E  66BA00480000        C     mov     edx,_sFLOPPY_TRACK_limit
00000484  E80D01              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 29, data (vga backup video memory)
00000487  66B81D000000        C     mov     eax,_sVGA_BACKUP / 8
0000048D  66BB00000600        C     mov     ebx,_sVGA_BACKUP_base
00000493  66BA00800000        C     mov     edx,_sVGA_BACKUP_limit
00000499  E8F800              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 30, low-level DEBI screen memory2
0000049C  66B81E000000        C     mov     eax,_sDEBI_screen2 / 8
000004A2  66BB00802500        C     mov     ebx,_sDEBI_screen2_base
000004A8  66BA00800200        C     mov     edx,_sDEBI_screen2_limit
000004AE  E8E300              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 32, Exodus objects
000004B1  66B820000000        C     mov     eax,_sEXODUS_OBJECTS / 8
000004B7  66BB00000500        C     mov     ebx,_sEXODUS_OBJECTS_base
000004BD  66BA00800000        C     mov     edx,_sEXODUS_OBJECTS_limit
000004C3  E8CE00              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 33, task_switch() TSS
                              C   ;; Note, the value of ecx is filled in later by the TASK primative itself, for now we just use NULL to get it created
000004C6  66B821000000        C     mov     eax,_sTASK_SWITCH_TSS / 8
000004CC  66BB00800600        C     mov     ebx,_sTASK_SWITCH_TSS_base
000004D2  6633C9              C     xor     ecx,ecx                                                 ; starting instruction
000004D5  66BA00010000        C     mov     edx,_sTASK_SWITCH_TSS_limit
000004DB  E83202              C     call    create_exodus_tss_descriptor
                              C 
                              C   ;; Slot 34, Task gate to task_switch()
000004DE  66B822000000        C     mov     eax,_sTASK_SWITCH_TASK_GATE / 8                         ; GDT slot
000004E4  66BB08010000        C     mov     ebx,_sTASK_SWITCH_TSS                                   ; GDT slot of TSS this task gate points to
000004EA  E86F03              C     call    create_task_gate_descriptor
                              C 
                              C   ;; Slot 35, Task manager's stack for its TSS
000004ED  66B823000000        C     mov     eax,_sTASK_STACK / 8
000004F3  66BB00002200        C     mov     ebx,_sTASK_STACK_base
000004F9  66BA00800000        C     mov     edx,_sTASK_STACK_limit
000004FF  E89200              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 50, Exodus.ini parsing area
00000502  66B832000000        C     mov     eax,_sEXODUS_INI / 8
00000508  66BB00002000        C     mov     ebx,_sEXODUS_INI_base
0000050E  66BA00000100        C     mov     edx,_sEXODUS_INI_limit
00000514  E87D00              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 36, STACK 0
00000517  66B824000000        C     mov     eax,_sSTACK0 / 8
0000051D  66BB80530900        C     mov     ebx,_sSTACK0_base
00000523  66BA00200000        C     mov     edx,_sSTACK0_limit
00000529  E86800              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 37, STACK 1
0000052C  66B825000000        C     mov     eax,_sSTACK1 / 8
00000532  66BB80330900        C     mov     ebx,_sSTACK1_base
00000538  66BA00200000        C     mov     edx,_sSTACK1_limit
0000053E  E85300              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 38, STACK 2
00000541  66B826000000        C     mov     eax,_sSTACK2 / 8
00000547  66BB80130900        C     mov     ebx,_sSTACK2_base
0000054D  66BA00200000        C     mov     edx,_sSTACK2_limit
00000553  E83E00              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 51, Exodus.ini parsing area
00000556  66B833000000        C     mov     eax,_sEXODUS_INI_ERRORS / 8
0000055C  66BB00002100        C     mov     ebx,_sEXODUS_INI_ERRORS_base
00000562  66BA00400000        C     mov     edx,_sEXODUS_INI_ERRORS_limit
00000568  E82900              C     call    create_data_descriptor
                              C 
                              C   ;; Slot 52, TASK system
0000056B  66B834000000        C     mov     eax,_sTASK_SYSTEM / 8
00000571  66BB00002100        C     mov     ebx,_sTASK_SYSTEM_base
00000577  66BA00000100        C     mov     edx,_sTASK_SYSTEM_limit
0000057D  E81400              C     call    create_data_descriptor
                              C 
00000580  1F                  C     pop     ds
00000581                      C     ret
00000582                      C setup_pmode_variables   ENDP
                              C 
                              C 
                              C 
                              C 
00000582                      C create_null_data_descriptor     PROC    NEAR
                              C ; Upon entry, ds:[esi] - far ptr to memory location for null data descriptor
00000582  6766C70600000000    C     mov     dword ptr [esi+0],00000000000000000000000000000000b
0000058A  6766C7460400900000  C     mov     dword ptr [esi+4],00000000000000001001000000000000b
00000593                      C     ret
00000594                      C create_null_data_descriptor     ENDP
                              C 
                              C 
                              C 
                              C 
00000594                      C create_data_descriptor      PROC    NEAR
                              C ; Upon entry, ds:[esi] - far ptr to GDT
                              C ;                  eax - slot # to insert
                              C ;                  ebx - base
                              C ;                  edx - limit
                              C ;
00000594  6660                C     pushad
                              C 
00000596  67895CC602          C     mov     word ptr [esi+eax*8+2],bx                           ; base 0:15
0000059B  66C1EB10            C     shr     ebx,16
0000059F  67885CC604          C     mov     byte ptr [esi+eax*8+4],bl                           ; base 16:23
000005A4  66C1EB08            C     shr     ebx,8
000005A8  67C644C60592        C     mov     byte ptr [esi+eax*8+5],10010010b                    ; Not accessed, writeable, expand=0, DPL=00
000005AE                      C     .IF (edx > 0fffffh)
                              C       ; This is a BIG data descriptor (so, we have to change the granularity to 1)
                              C       ; Also, setting the granularity bit makes the limit value be the number of 4k segments
000005B7  66C1EA0C            C         shr     edx,12                                          ; Divide by 4096
000005BB  678914C6            C         mov     word ptr [esi+eax*8+0],dx                       ; Store the new limit 0:15
000005BF  66C1EA10            C         shr     edx,16                                          ; Move over to store the next part of the limit
000005C3  80E20F              C         and     dl,0fh                                          ; Mask off the top nibble (the limit is only 20 bits)
000005C6  80CAC0              C         or      dl,11000000b                                    ; make granularity=1, big=1 (high bits in dl)
000005C9                      C     .ELSE
                              C       ; It's a small data descriptor (leave the granularity at 0)
000005CB  678914C6            C         mov     word ptr [esi+eax*8+0],dx                       ; limit 0:15
000005CF  66C1EA10            C         shr     edx,16
000005D3  80E20F              C         and     dl,0fh
000005D6                      C     .ENDIF
000005D6  678854C606          C     mov     byte ptr [esi+eax*8+6],dl                           ; limit 16:19, Granularity=0/1, big=0/1 (depends on size)
000005DB  67885CC607          C     mov     byte ptr [esi+eax*8+7],bl                           ; base 24:31
                              C 
000005E0  6661                C     popad
000005E2                      C     ret
000005E3                      C create_data_descriptor      ENDP
                              C 
                              C 
                              C 
                              C 
000005E3                      C create_data_descriptor_pl       PROC    NEAR
                              C ; Upon entry, ds:[esi] - far ptr to GDT
                              C ;                  eax - slot # to insert
                              C ;                  ebx - base
                              C ;                  edx - limit
                              C ;                   cl - privledge level
                              C ;
000005E3  6660                C     pushad
                              C 
000005E5  67895CC602          C     mov     word ptr [esi+eax*8+2],bx                           ; base 0:15
000005EA  66C1EB10            C     shr     ebx,16
000005EE  67885CC604          C     mov     byte ptr [esi+eax*8+4],bl                           ; base 16:23
000005F3  66C1EB08            C     shr     ebx,8
000005F7  C0E105              C     shl     cl,5
000005FA  67C644C60592        C     mov     byte ptr [esi+eax*8+5],10010010b                    ; Not accessed, writeable, expand=0, (PL=00 for now)
00000600  67084CC605          C     or      byte ptr [esi+eax*8+5],cl                           ; Apply the privledge level
00000605                      C     .IF (edx > 0fffffh)
                              C       ; This is a BIG data descriptor (so, we have to change the granularity to 1)
                              C       ; Also, setting the granularity bit makes the limit value be the number of 4k segments
0000060E  66C1EA0C            C         shr     edx,12                                          ; Divide by 4096
00000612  678914C6            C         mov     word ptr [esi+eax*8+0],dx                       ; Store the new limit 0:15
00000616  66C1EA10            C         shr     edx,16                                          ; Move over to store the next part of the limit
0000061A  80E20F              C         and     dl,0fh                                          ; Mask off the top nibble (the limit is only 20 bits)
0000061D  80CAC0              C         or      dl,11000000b                                    ; make granularity=1, big=1 (high bits in dl)
00000620                      C     .ELSE
                              C       ; It's a small data descriptor (leave the granularity at 0)
00000622  678914C6            C         mov     word ptr [esi+eax*8+0],dx                       ; limit 0:15
00000626  66C1EA10            C         shr     edx,16
0000062A  80E20F              C         and     dl,0fh
0000062D                      C     .ENDIF
0000062D  678854C606          C     mov     byte ptr [esi+eax*8+6],dl                           ; limit 16:19, Granularity=0/1, big=0/1 (depends on size)
00000632  67885CC607          C     mov     byte ptr [esi+eax*8+7],bl                           ; base 24:31
                              C 
00000637  6661                C     popad
00000639                      C     ret
0000063A                      C create_data_descriptor_pl       ENDP
                              C 
                              C 
                              C 
                              C 
0000063A                      C create_ldt_descriptor   PROC
                              C ; Upon entry, ds:[esi] - far ptr to GDT
                              C ;                  eax - slot # to insert
                              C ;                  ebx - base
                              C ;                  edx - limit
                              C ;
0000063A  6660                C     pushad
                              C 
0000063C  67895CC602          C     mov     word ptr [esi+eax*8+2],bx                           ; base 0:15
00000641  66C1EB10            C     shr     ebx,16
00000645  67885CC604          C     mov     byte ptr [esi+eax*8+4],bl                           ; base 16:23
0000064A  66C1EB08            C     shr     ebx,8
0000064E  67C644C60582        C     mov     byte ptr [esi+eax*8+5],10000010b                    ; Not accessed, writeable, expand=0, DPL=00
00000654                      C     .IF (edx > 0fffffh)
                              C       ; This is a BIG data descriptor (so, we have to change the granularity to 1)
                              C       ; Also, setting the granularity bit makes the limit value be the number of 4k segments
0000065D  66C1EA0C            C         shr     edx,12                                          ; Divide by 4096
00000661  678914C6            C         mov     word ptr [esi+eax*8+0],dx                       ; Store the new limit 0:15
00000665  66C1EA10            C         shr     edx,16                                          ; Move over to store the next part of the limit
00000669  80E20F              C         and     dl,0fh                                          ; Mask off the top nibble (the limit is only 20 bits)
0000066C  80CAC0              C         or      dl,11000000b                                    ; make granularity=1, big=1 (high bits in dl)
0000066F                      C     .ELSE
                              C       ; It's a small data descriptor (leave the granularity at 0)
00000671  678914C6            C         mov     word ptr [esi+eax*8+0],dx                       ; limit 0:15
00000675  66C1EA10            C         shr     edx,16
00000679  80E20F              C         and     dl,0fh
0000067C                      C     .ENDIF
0000067C  678854C606          C     mov     byte ptr [esi+eax*8+6],dl                           ; limit 16:19, Granularity=0/1, big=0/1 (depends on size)
00000681  67885CC607          C     mov     byte ptr [esi+eax*8+7],bl                           ; base 24:31
                              C 
00000686  6661                C     popad
00000688                      C     ret
00000689                      C create_ldt_descriptor   ENDP
                              C 
                              C 
                              C 
                              C 
00000689                      C create_code_descriptor   PROC    NEAR
                              C ; Upon entry, ds:[esi] - far ptr to GDT
                              C ;                  eax - slot # to insert
                              C ;                  ebx - base
                              C ;                  edx - limit
00000689  6660                C     pushad
                              C 
0000068B  678914C6            C     mov     word ptr [esi+eax*8+0],dx                           ; limit 0:15
0000068F  66C1EA10            C     shr     edx,16
00000693  67895CC602          C     mov     word ptr [esi+eax*8+2],bx                           ; base 0:15
00000698  66C1EB10            C     shr     ebx,16
0000069C  67885CC604          C     mov     byte ptr [esi+eax*8+4],bl                           ; base 16:23
000006A1  66C1EB08            C     shr     ebx,8
000006A5  67C644C6059A        C     mov     byte ptr [esi+eax*8+5],10011010b                    ; Not accessed, readable, conforming=0, DPL=00
000006AB  80E20F              C     and     dl,0fh
000006AE  80CA40              C     or      dl,01000000b
000006B1  678854C606          C     mov     byte ptr [esi+eax*8+6],dl                           ; limit 16:19, Granularity=0, big=0
000006B6  67885CC607          C     mov     byte ptr [esi+eax*8+7],bl                           ; base 24:31
                              C 
000006BB  6661                C     popad
000006BD                      C     ret
000006BE                      C create_code_descriptor   ENDP
                              C 
                              C 
                              C 
                              C 
000006BE                      C create_interrupt_descriptor_32_bit      PROC    NEAR
                              C ; Upon entry: eax - interrupt # to update (0-based)
                              C ;        ds:[esi] - far pointer to start of IDT
                              C ;             edx - offset in bx to routine
                              C ;             ebx - segment selector of routine
000006BE  6660                C     pushad
                              C 
000006C0  668BCA              C     mov     ecx,edx                                             ; Copy 32-bit offset to ecx
000006C3  6681E2FFFF0000      C     and     edx,00000ffffh                                      ; Keep lower 16-bits in edx
000006CA  6681E10000FFFF      C     and     ecx,0ffff0000h                                      ; Keep upper 16-bits in ecx
000006D1  B9008E              C     mov     cx,1000111000000000b                                ; Add lower 16-bits in ecx, 32-bit, DPL=0, Present
000006D4  66C1CA10            C     ror     edx,16                                              ; Move edx around so we can access the high word
000006D8  8BD3                C     mov     dx,bx                                               ; Segment selector
000006DA  66C1CA10            C     ror     edx,16                                              ; Ok, put it back the way it was
                              C 
000006DE  67668914C6          C     mov     dword ptr [esi+eax*8+0],edx                         ; Store the IDT descriptor
000006E3  6766894CC604        C     mov     dword ptr [esi+eax*8+4],ecx
                              C 
000006E9  6661                C     popad
000006EB                      C     ret
000006EC                      C create_interrupt_descriptor_32_bit      ENDP
                              C 
                              C 
                              C 
                              C 
000006EC                      C create_interrupt_descriptors    PROC    NEAR
                              C ; Create all of the interrupt descriptors.  All 256 of them.
                              C ; Upon entry:   ds:[esi] - far ptr to start of IDT
                              C ;
000006EC  6660                C     pushad
                              C 
000006EE  66BB20000000        C     mov     ebx,_sCODE                                              ; Code segment
000006F4  66BA05260000        C     mov     edx,offset default_interrupt_handler32                  ; Default interrupt handler for 32-bit code
000006FA  66B9FF000000        C     mov     ecx,255
00000700  66B800000000        C     mov     eax,0                                                   ; Start at int 0 in the IDT
00000706                      C   @@:
00000706  E8B5FF              C     call    create_interrupt_descriptor_32_bit
00000709  6640                C     inc     eax
0000070B  E2F9                C     loop    @b
                              C 
0000070D  6661                C     popad
0000070F                      C     ret
00000710                      C create_interrupt_descriptors    ENDP
                              C 
                              C 
                              C 
                              C 
00000710                      C create_exodus_tss_descriptor    PROC
                              C ; Upon entry, ds:[esi] - far ptr to memory location for the TSS descriptor
                              C ;                  eax - slot # to insert
                              C ;                  ebx - base
                              C ;                  ecx - offset of first instruction
                              C ;                  edx - limit
00000710  06                  C     push    es
00000711  6660                C     pushad
00000713  668BFB              C     mov     edi,ebx
                              C 
                              C   ; Create the TSS descriptor
00000716  678914C6            C     mov     word ptr [esi+eax*8+0],dx                           ; limit 0:15
0000071A  67895CC602          C     mov     word ptr [esi+eax*8+2],bx                           ; base 0:15
0000071F  66C1EB10            C     shr     ebx,16
00000723  67885CC604          C     mov     byte ptr [esi+eax*8+4],bl                           ; base 16:23
00000728  66C1EB08            C     shr     ebx,8
0000072C  67C644C60589        C     mov     byte ptr [esi+eax*8+5],10001001b                    ; present=1:dpl=00:010:busy=1:1
00000732  66C1EA10            C     shr     edx,16
00000736  80E20F              C     and     dl,0fh                                              ; make the top nibble be all 0s
00000739  678854C606          C     mov     byte ptr [esi+eax*8+6],dl                           ; Granularity=0:0:0:Available=0:limit 16:19
0000073E  67885CC607          C     mov     byte ptr [esi+eax*8+7],bl                           ; base 24:31
                              C 
                              C   ; Write the Exodus variables there
00000743  668BDF              C     mov     ebx,edi
00000746  66C1EB04            C     shr     ebx,4
0000074A  8EC3                C     mov     es,bx
0000074C  6683E70F            C     and     edi,0fh
                              C   ; Right now, es:[edi] - far ptr the memory location for Exodus
                              C   ; Code segment register
00000750  66B820000000        C     mov     eax,_sCODE
00000756  67662689474C        C     mov     dword ptr es:[edi+_TSS_CS],eax                          ; cs
                              C   ; Instruction Pointer
0000075C  676626894F20        C     mov     dword ptr es:[edi+_TSS_EIP],ecx                         ; eip
                              C   ; Data segment registers
00000762  66B848000000        C     mov     eax,_sDATA
00000768  676626894754        C     mov     dword ptr es:[edi+_TSS_DS],eax                          ; ds
0000076E  676626894748        C     mov     dword ptr es:[edi+_TSS_ES],eax                          ; es
                              C   ; Extra segment registers
00000774  66B838000000        C     mov     eax,_sVGA
0000077A  676626894758        C     mov     dword ptr es:[edi+_TSS_FS],eax                          ; fs
00000780  66B830000000        C     mov     eax,_sMONO
00000786  67662689475C        C     mov     dword ptr es:[edi+_TSS_GS],eax                          ; gs
                              C   ; Stack
0000078C  66B818000000        C     mov     eax,_sSTACK
00000792  676626894750        C     mov     dword ptr es:[edi+_TSS_SS],eax                          ; ss
00000798  676626C74738008000  C     mov     dword ptr es:[edi+_TSS_ESP],_sSTACK_limit               ; esp
                              C   ; Stack 2
000007A2  66B830010000        C     mov     eax,_sSTACK2
000007A8  676626894718        C     mov     dword ptr es:[edi+_TSS_SS2],eax                         ; ss2
000007AE  676626C74714002000  C     mov     dword ptr es:[edi+_TSS_ESP2],_sSTACK2_limit             ; esp2
                              C   ; Stack 1
000007B8  66B828010000        C     mov     eax,_sSTACK1
000007BE  676626894710        C     mov     dword ptr es:[edi+_TSS_SS1],eax                         ; ss1
000007C4  676626C7470C002000  C     mov     dword ptr es:[edi+_TSS_ESP1],_sSTACK1_limit             ; esp1
                              C   ; Stack 0
000007CE  66B820010000        C     mov     eax,_sSTACK0
000007D4  676626894708        C     mov     dword ptr es:[edi+_TSS_SS0],eax                         ; ss0
000007DA  676626C74704002000  C     mov     dword ptr es:[edi+_TSS_ESP0],_sSTACK0_limit             ; esp0
                              C   ; General purpose registers
000007E4  6633C0              C     xor     eax,eax
000007E7  676626894728        C     mov     dword ptr es:[edi+_TSS_EAX],eax                         ; eax
000007ED  67662689472C        C     mov     dword ptr es:[edi+_TSS_ECX],eax                         ; ecx
000007F3  676626894730        C     mov     dword ptr es:[edi+_TSS_EDX],eax                         ; edx
000007F9  676626894734        C     mov     dword ptr es:[edi+_TSS_EBX],eax                         ; ebx
000007FF  67662689473C        C     mov     dword ptr es:[edi+_TSS_EBP],eax                         ; ebp
00000805  676626894740        C     mov     dword ptr es:[edi+_TSS_ESI],eax                         ; esi
0000080B  676626894744        C     mov     dword ptr es:[edi+_TSS_EDI],eax                         ; edi
00000811  67662689471C        C     mov     dword ptr es:[edi+_TSS_CR3],eax                         ; CR3, paging (not used in Exodus)
00000817  676626894766        C     mov     dword ptr es:[edi+_TSS_IO_MAP],eax                      ; IO Map Base Address, Trap bit
0000081D  6766268907          C     mov     dword ptr es:[edi+_TSS_BACK_LINK],eax                   ; Previous task link
00000822  6633C0              C     xor     eax,eax
00000825  676626894760        C     mov     dword ptr es:[edi+_TSS_LDT],eax                         ; LDT segment selector
                              C   ; EFLAGS
0000082B  669C                C     pushfd
0000082D  6658                C     pop     eax
0000082F  676626894724        C     mov     dword ptr es:[edi+_TSS_EFLAGS],eax
                              C 
                              C   ; Finished
00000835  6661                C     popad
00000837  07                  C     pop     es
00000838                      C     ret
00000839                      C create_exodus_tss_descriptor    ENDP
                              C 
                              C 
                              C 
                              C 
                              C 
00000839                      C create_call_gate_descriptor     PROC
                              C ; This routine is used to create a call gate
                              C ; Upon entry: ds:[esi] - far ptr to GDT
                              C ;                  eax - GDT slot # to create/update
                              C ;                  ebx - Offset for start of function
                              C ;                  ecx - Number of dwords to copy
                              C ;                   dx - code segment selector
                              C ;
00000839  6660                C     pushad
                              C 
0000083B  678954C602          C     mov     word ptr [esi+eax*8+2],dx                               ; code segment selector
00000840  83E11F              C     and     cx,011111b                                              ; Keep the lower 5 bits
00000843  81C9008C            C     or      cx,1000110000000000b                                    ; Put parameters in the upper 11 bits
00000847  67894CC604          C     mov     word ptr [esi+eax*8+4],cx                               ; dword count + constants
0000084C  67891CC6            C     mov     word ptr [esi+eax*8+0],bx                               ; Lower 16-bits of 32-bit offset
00000850  66C1CB10            C     ror     ebx,16
00000854  67895CC606          C     mov     word ptr [esi+eax*8+6],bx                               ; Upper 16-bits of 32-bit offset
                              C 
00000859  6661                C     popad
0000085B                      C     ret
0000085C                      C create_call_gate_descriptor     ENDP
                              C 
                              C 
                              C 
                              C 
                              C 
0000085C                      C create_task_gate_descriptor     PROC
                              C ; Upon entry, ds:[esi] - far ptr to memory location for the TSS descriptor
                              C ;                  eax - slot # to insert
                              C ;                  bx - GDT slot for TSS
0000085C  6660                C     pushad
                              C 
0000085E  66C1E310            C     shl     ebx,16                                              ; Move bx(TSS selector) to high-order word in ebx
00000862  6766891CC6          C     mov     dword ptr [esi+eax*8+0],ebx
00000867  6633DB              C     xor     ebx,ebx
0000086A  B785                C     mov     bh,10000101b                                        ; present=1:dpl=00:00101
0000086C  6766895CC604        C     mov     dword ptr [esi+eax*8+4],ebx
                              C 
00000872  6661                C     popad
00000874                      C     ret
00000875                      C create_task_gate_descriptor     ENDP
                                    INCLUDE data16.asp
                              C ; data16.asp
                              C ;
                              C ; Exodus data used in the 16-bit segment
                              C ;
                              C 
                              C ; DATA
00000875  2045786F6475732874  C     bootup_id1              db  " Exodus(tm) Operating System                                    10.10.2010.beta "
000008C5  2028632920436F7079  C     bootup_id2              db  " (c) Copyright Beatleworks, Inc.                                                "
                              C 
00000915  FE2056657269667969  C     verifying_crc           db  " Verifying CRC"
00000924  FE20456E61626C696E  C     enabling_gate_a20       db  " Enabling A20"
00000932  FE2053657475702049  C     setup_pmode_vars        db  " Setup IDT, GDT"
00000942  FE20456E746572696E  C     entering_pmode          db  " Entering protected mode"
                              C 
0000095B  0D0A78787878202078  C     crc_comparitive         db  13,10,"xxxx  xxxx"
00000967  FE2043524320657272  C     crc_error_start         db  " CRC error has been detected.",13,10
00000987  FE2028782920697320  C     crc_error_code          db  " (x) is the error code",13,10
000009A0  0D0A                C                             db  13,10
000009A2  FE2045786F64757320  C                             db  " Exodus cannot boot up when CRC errors are found.",13,10
000009D6  FE20506C6561736520  C                             db  " Please correct this error and try again.  You may need",13,10
00000A10  2020746F20636F7079  C                             db  "  to copy system files from the master Exodus Boot Disk.",13,10
00000A4A  0D0A                C                             db  13,10
00000A4C  FE2053797374656D20  C                             db  " System halted.  Please press RESET to reboot."
00000A7B                      C     crc_error_end:
                              C 
00000A7B  00000000            C     boot_parameter_block    dd  0
00000A7F  0000                C     boot_parameter_count    dw  0
00000A81  00000000            C     next_linear_address     dd  0
00000A85  00000000            C     boot_dt_linear          dd  0
00000A89  00000000            C     boot_np_linear          dd  0
00000A8D  00000000            C     boot_rp_linear          dd  0
                              C 
00000A91  0008                C     IDT_ptr                 dw  _sIDT_limit     ; 256 slots, 8 bytes each = 7ffh bytes
00000A93  00A00800            C                             dd  _sIDT_base      ; Linear offset in memory
                              C 
00000A97  0080                C     GDT_ptr                 dw  _sGDT_limit     ; 4096 GDT entries
00000A99  00080000            C                             dd  _sGDT_base      ; Linear offset

00000A9D                        end_of_16_bit_segment:
00000A9D                        _TEXT   ENDS





                                ;;
                                ;;  úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
                                ;;  úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
                                ;;  úÛÛÛÛÛúúúÛÛÛÛÛúúúúúúúúúúÛÛÛúúúúúúúúÛÛúúúúúúÛúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúÛÛÛúúúúúúúúúú
                                ;;  ÛÛúúúÛÛúÛÛúúúÛÛúúúúúúúúúúÛÛúúúúúúúúÛÛúúúúúÛÛúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúÛÛúúúúúúúúúú
                                ;;  úúúúúÛÛúúúúúúÛÛúúúúúúúúúúÛÛúúúúúúúúúúúúúúúÛÛúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúÛÛúúúúúúúúúú
                                ;;  úúúúúÛÛúúúúúÛÛúúúúúúúúúúúÛÛÛÛúúúúúÛÛÛúúúÛÛÛÛÛÛúúúúúúúúúúúÛÛÛÛÛúúúÛÛÛÛÛúúúúÛÛÛÛúúúÛÛÛÛÛúú
                                ;;  úúÛÛÛÛúúúúúÛÛúúúúúúúúúúúúÛÛúÛÛúúúúúÛÛúúúúúÛÛúúúúúúúúúúúúÛÛúúúÛÛúÛÛúúúÛÛúúÛÛúÛÛúúÛÛúúúÛÛú
                                ;;  úúúúúÛÛúúúÛÛúúúúúúúúúúúúúÛÛúúÛÛúúúúÛÛúúúúúÛÛúúúúúúúúúúúúÛÛúúúúúúÛÛúúúÛÛúÛÛúúÛÛúúÛÛÛÛÛÛÛú
                                ;;  úúúúúÛÛúúÛÛúúúúúúúúúúúúúúÛÛúúÛÛúúúúÛÛúúúúúÛÛúúúúúúúúúúúúÛÛúúúúúúÛÛúúúÛÛúÛÛúúÛÛúúÛÛúúúúúú
                                ;;  ÛÛúúúÛÛúÛÛúúúÛÛúúúúúúúúúúÛÛúúÛÛúúúúÛÛúúúúúÛÛúÛÛúúúúúúúúúÛÛúúúÛÛúÛÛúúúÛÛúÛÛúúÛÛúúÛÛúúúÛÛú
                                ;;  úÛÛÛÛÛúúÛÛÛÛÛÛÛúúúúúúúúúúÛÛÛÛÛúúúúÛÛÛÛúúúúúÛÛÛúúúúúúúúúúúÛÛÛÛÛúúúÛÛÛÛÛúúúÛÛÛúÛÛúúÛÛÛÛÛúú
                                ;;  úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
                                ;;  úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
                                ;;  úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú
                                ;;
00000000                        _TEXT32 SEGMENT PUBLIC BYTE 'CODE' USE32
                                    ASSUME NOTHING
                                ;;
                                ;; Exodus Bootup Program 32-bit kernel begins here
                                ;;
                                ;; -----
                                ;;
                                ;; PROTECTED MODE
                                ;; All services from here on out are internal
                                ;;

00000000                        first_pmode_instruction:                                            ; Setup segment selectors so they are loaded correctly
                                ;  ;; Indicate that we entered protected mode OK
                                ;    mov     dword ptr fs:[6*80*2 + (sizeof entering_pmode * 2)],'KO'      ; Line 6, plus the offset of whatever text was shown


                                  ;; Turn off the nested-task flag
00000000  9C                        pushfd
00000001  812424FFBFFFFF            and     dword ptr ss:[esp],NOT _EFLAGS_NT_MASK
00000008  9D                        popfd


                                  ;; Setup some of the required memory blocks
00000009  E84C040000                call    invSetup_memory_blocks                                  ; init32.asp


                                  ;; Setup the Exodus native primatives
0000000E  E8AA1E0000                call    invSetup_native_primatives                              ; native.asp

                                  ; Note, this is temporarily done manually until the iFDC drivers are installed
00000013  B00C                      mov     al,001100b
00000015  BAF2030000                mov     edx,03f2h
0000001A  EE                        out     dx,al
                                  ;; Parse the exodus.ini file
0000001B  E874270000                call    invFind_Exodus_ini                                      ; ini.asp
00000020  E8452C0000                call    invDetermine_Exodus_ini_ownership                       ;


                                  ;; Reset the video mode
00000025  83EC14                    sub     esp,20                                                  ; return values (+16=bpp, +12=hp, +8=vp, +4=refresh, +0=status)
00000028  6A00                      push    0                                                       ; param: graphics mode
0000002A  6A08                      push    8                                                       ; param: bits per pixel
0000002C  6840010000                push    320                                                     ; param: horizontal pixels
00000031  68C8000000                push    200                                                     ; param: vertical pixels
00000036  6A3C                      push    60                                                      ; param: refresh rate
00000038  B801000000                mov     eax,1
0000003D  2EFF1DE01A0000            call    fword ptr cs:_VID_requestor
00000044  83C414                    add     esp,20                                                  ; get the return values off the stack (we know this works)


                                  ;; Turn off the floppy drive motor
                                ;    mov     al,'A'
                                ;    call    fword ptr cs:_iFDC_motor_off

                                  ;; Transfer control to EXODUS.COM
00000047  2EFF2DEA1A0000            jmp     fword ptr cs:_EXODUS_dot_com
                                ;;
                                ;; END OF PROGRAM
                                ;;
                                ;; --------------
                                ;;
                                ;; Control will never return here
                                ;;
                                ;; -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                                ;;



                                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                ;;
                                ;; Note:  Each of these include files contains only 32-bit code and/or data
                                ;;

                                    INCLUDE init32.asp                                              ; Baseline initialization routines
                              C ; init32.asp
                              C ;
                              C ; Exodus initialization routines (32-bit code)
                              C ;
                              C ;  Functions:
                              C ;      invCreate_call_gate_descriptor32            ; Creates a new call gate in the GDT
                              C ;      invCreate_task_gate_descriptor32            ; Creates a new task gate in the GDT
                              C ;      invCreate_interrupt_task_gate_descriptor32  ; Creates a new task gate in the IDT
                              C ;      invCreate_code_descriptor32                 ; Creates a new code segment descriptor
                              C ;      invCreate_data_descriptor32                 ; Creates a new data segment descriptor
                              C ;      invCreate_tss_descriptor32                  ; Creates a new 32-bit TSS descriptor entry
                              C ;      invCreate_tss32                             ; Initializes a 32-bit TSS
                              C ;      invUpdate_interrupt_descriptor16            ; Used after initialization to update an IDT entry
                              C ;      invUpdate_interrupt_descriptor32            ; Used after initialization to update an IDT entry
                              C ;      invExtract_code_descriptor32                ; Extracts the information in a code descriptor segment
                              C ;      invExtract_call_gate_descriptor32           ; Extracts the information in a call gate descriptor segment
                              C ;      invExtract_data_descriptor32                ; Extracts the information in a data descriptor segment
                              C ;      invAlter_descriptor32_base_limit            ; Used after initialization to alter a GDT entry's base and/or limit
                              C ;      invSetup_memory_blocks                      ; Sets up the initial values in Exodus memory blocks
                              C ;      invExtract_linear_offset_into_edx_from_ds   ; Extracts a linear offset from the current value of DS
                              C ;      invSet_80x25_text_mode                      ; Calls the VID_requestor() function to enter 80x25 text mode (for errors)
                              C ;      init_failed                                 ; Used when there is a problem initializing primatives
                              C ;
                              C 
                              C 
                              C 
0000004E                      C invCreate_call_gate_descriptor32   PROC
                              C ; This routine is used to create a call gate
                              C ; Upon entry:   cpu is in pmode
                              C ;               eax - GDT slot # to create/update
                              C ;               ebx - Offset for start of function
                              C ;               ecx - Number of dwords to copy
                              C ;                dx - code segment selector
                              C ;
0000004E  9C                  C     pushfd
0000004F                      C     .IF (eax <= _lastGDT)
00000056  1E                  C         push    ds
00000057  56                  C         push    esi
00000058  51                  C         push    ecx
00000059  53                  C         push    ebx
                              C 
0000005A  66BE1000            C         mov     si,_sGDT
0000005E  668EDE              C         mov     ds,si
00000061  668914C502000000    C         mov     word ptr ds:[eax*8+2],dx                            ; code segment selector
00000069  6683E11F            C         and     cx,011111b                                          ; Keep the lower 5 bits
0000006D  6681C9008C          C         or      cx,1000110000000000b                                ; Put parameters in the upper 11 bits
00000072  66890CC504000000    C         mov     word ptr ds:[eax*8+4],cx                            ; dword count + constants
0000007A  66891CC500000000    C         mov     word ptr ds:[eax*8+0],bx                            ; Lower 16-bits of 32-bit offset
00000082  C1CB10              C         ror     ebx,16
00000085  66891CC506000000    C         mov     word ptr ds:[eax*8+6],bx                            ; Upper 16-bits of 32-bit offset
                              C 
0000008D  5B                  C         pop     ebx
0000008E  59                  C         pop     ecx
0000008F  5E                  C         pop     esi
00000090  1F                  C         pop     ds
00000091                      C     .ENDIF
00000091  9D                  C     popfd
00000092                      C     ret
00000093                      C invCreate_call_gate_descriptor32   ENDP
                              C 
                              C 
                              C 
                              C 
00000093                      C invCreate_task_gate_descriptor32   PROC
                              C ; This routine is used to create a task gate in the GDT
                              C ; Upon entry:   cpu is in pmode
                              C ;               eax - GDT slot # to create/update
                              C ;                bx - Task's TSS
                              C ;
00000093  9C                  C     pushfd
00000094                      C     .IF (eax <= _lastGDT)
0000009B  1E                  C         push    ds
0000009C  56                  C         push    esi
0000009D  53                  C         push    ebx
                              C 
0000009E  66BE1000            C         mov     si,_sGDT
000000A2  668EDE              C         mov     ds,si
                              C 
000000A5  C1E310              C         shl     ebx,16
000000A8  891CC500000000      C         mov     dword ptr ds:[eax*8+0],ebx                          ; TSS Segment Selector
000000AF  33DB                C         xor     ebx,ebx
000000B1  B785                C         mov     bh,10000101b                                        ; P=1:DPL=00:00101:00000000
000000B3  891CC504000000      C         mov     dword ptr ds:[eax*8+4],ebx
                              C 
000000BA  5B                  C         pop     ebx
000000BB  5E                  C         pop     esi
000000BC  1F                  C         pop     ds
000000BD                      C     .ENDIF
000000BD  9D                  C     popfd
000000BE                      C     ret
000000BF                      C invCreate_task_gate_descriptor32   ENDP
                              C 
                              C 
                              C 
                              C 
000000BF                      C invCreate_interrupt_task_gate_descriptor32   PROC
                              C ; This routine is used to create a task gate in the IDT
                              C ; Upon entry:   cpu is in pmode
                              C ;               eax - IDT slot # to create/update
                              C ;                bx - Task's TSS
                              C ;
000000BF  9C                  C     pushfd
000000C0                      C     .IF (eax <= 256)
000000C7  1E                  C         push    ds
000000C8  56                  C         push    esi
000000C9  53                  C         push    ebx
                              C 
000000CA  66BE0800            C         mov     si,_sIDT
000000CE  668EDE              C         mov     ds,si
                              C 
000000D1  C1E310              C         shl     ebx,16
000000D4  891CC500000000      C         mov     dword ptr ds:[eax*8+0],ebx                          ; TSS Segment Selector
000000DB  33DB                C         xor     ebx,ebx
000000DD  B785                C         mov     bh,10000101b                                        ; P=1:DPL=00:00101:00000000
000000DF  891CC504000000      C         mov     dword ptr ds:[eax*8+4],ebx
                              C 
000000E6  5B                  C         pop     ebx
000000E7  5E                  C         pop     esi
000000E8  1F                  C         pop     ds
000000E9                      C     .ENDIF
000000E9  9D                  C     popfd
000000EA                      C     ret
000000EB                      C invCreate_interrupt_task_gate_descriptor32   ENDP
                              C 
                              C 
                              C 
                              C 
000000EB                      C invCreate_code_descriptor32    PROC    NEAR
                              C ; Upon entry, eax - slot # to insert
                              C ;             ebx - base
                              C ;             edx - limit
                              C ;
000000EB  9C                  C     pushfd
000000EC                      C     .IF (eax <= _lastGDT)
000000F3  1E                  C         push    ds
000000F4  56                  C         push    esi
000000F5  53                  C         push    ebx
000000F6  52                  C         push    edx
                              C 
000000F7  66BF1000            C         mov     di,_sGDT
000000FB  668EDF              C         mov     ds,di
                              C 
                              C       ; Fixed information, not accessed, readable, conforming=0, DPL=00
000000FE  C604C5050000009A    C         mov     byte ptr ds:[eax*8+5],10011010b
                              C 
                              C       ; Base
00000106  66891CC502000000    C         mov     word ptr ds:[eax*8+2],bx                            ; base 0:15
0000010E  C1EB10              C         shr     ebx,16
00000111  881CC504000000      C         mov     byte ptr ds:[eax*8+4],bl                            ; base 16:23
00000118  C1EB08              C         shr     ebx,8
0000011B  881CC507000000      C         mov     byte ptr ds:[eax*8+7],bl                            ; base 24:31
                              C 
                              C       ; Limit
00000122                      C         .IF (edx > 0fffffh)
                              C           ; It's bigger than 20 bits (so, we have to change the granularity to 1)
                              C           ; This is a BIG data descriptor
                              C           ; Also, setting the granularity bit makes the limit value be the number of 4k segments
0000012A  C1EA0C              C             shr     edx,12                                          ; Divide by 4096
0000012D  668914C500000000    C             mov     word ptr ds:[eax*8+0],dx                        ; Store the new limit 0:15
00000135  C1EA10              C             shr     edx,16                                          ; Move over to store the next part of the limit
00000138  80E20F              C             and     dl,0fh                                          ; Mask off the top nibble (the limit is only 20 bits)
0000013B  80CA80              C             or      dl,10000000b                                    ; make granularity=1
0000013E                      C         .ELSE
                              C           ; It's a small data descriptor (leave the granularity at 0)
00000140  668914C500000000    C             mov     word ptr ds:[eax*8+0],dx                        ; limit 0:15
00000148  C1EA10              C             shr     edx,16
0000014B  80E20F              C             and     dl,0fh
0000014E                      C         .ENDIF
0000014E  80CA40              C         or      dl,01000000b                                        ; 32-bit code
00000151  8814C506000000      C         mov     byte ptr ds:[eax*8+6],dl                            ; limit 16:19, Granularity=0
                              C 
00000158  5A                  C         pop     edx
00000159  5B                  C         pop     ebx
0000015A  5E                  C         pop     esi
0000015B  1F                  C         pop     ds
0000015C                      C     .ENDIF
0000015C  9D                  C     popfd
0000015D                      C     ret
0000015E                      C invCreate_code_descriptor32    ENDP
                              C 
                              C 
                              C 
                              C 
0000015E                      C invCreate_data_descriptor32    PROC    NEAR
                              C ; Upon entry, eax - slot # to insert
                              C ;             ebx - base
                              C ;             edx - limit
                              C ;
0000015E  9C                  C     pushfd
0000015F                      C     .IF (eax <= _lastGDT)
00000166  1E                  C         push    ds
00000167  51                  C         push    ecx
00000168  53                  C         push    ebx
00000169  52                  C         push    edx
                              C 
0000016A  66B91000            C         mov     cx,_sGDT
0000016E  668ED9              C         mov     ds,cx
                              C 
00000171  66891CC502000000    C         mov     word ptr ds:[eax*8+2],bx                            ; base 0:15
00000179  C1EB10              C         shr     ebx,16
0000017C  881CC504000000      C         mov     byte ptr ds:[eax*8+4],bl                            ; base 16:23
00000183  883CC507000000      C         mov     byte ptr ds:[eax*8+7],bh                            ; base 24:31
0000018A  C604C50500000092    C         mov     byte ptr ds:[eax*8+5],10010010b                     ; Not accessed, writeable, expand=0, DPL=00
00000192                      C         .IF (edx > 0fffffh)
                              C           ; It's bigger than 20 bits (so, we have to change the granularity to 1)
                              C           ; This is a BIG data descriptor
                              C           ; Also, setting the granularity bit makes the limit value be the number of 4k segments
0000019A  C1EA0C              C             shr     edx,12                                          ; Divide by 4096
0000019D  668914C500000000    C             mov     word ptr ds:[eax*8+0],dx                        ; Store the new limit 0:15
000001A5  C1EA10              C             shr     edx,16                                          ; Move over to store the next part of the limit
000001A8  80E20F              C             and     dl,0fh                                          ; Mask off the top nibble (the limit is only 20 bits)
000001AB  80CAC0              C             or      dl,11000000b                                    ; make granularity=1, big=1 (high bits in dl)
000001AE                      C         .ELSE
                              C           ; It's a small data descriptor (leave the granularity at 0)
000001B0  668914C500000000    C             mov     word ptr ds:[eax*8+0],dx                        ; limit 0:15
000001B8  C1EA10              C             shr     edx,16
000001BB  80E20F              C             and     dl,0fh
000001BE                      C         .ENDIF
000001BE  8814C506000000      C         mov     byte ptr ds:[eax*8+6],dl                            ; limit 16:19, Granularity=0/1, big=0/1 (depends on size)
                              C 
000001C5  5A                  C         pop     edx
000001C6  5B                  C         pop     ebx
000001C7  59                  C         pop     ecx
000001C8  1F                  C         pop     ds
000001C9                      C     .ENDIF
000001C9  9D                  C     popfd
000001CA                      C     ret
000001CB                      C invCreate_data_descriptor32    ENDP
                              C 
                              C 
                              C 
                              C 
000001CB                      C invExtract_code_descriptor32        PROC    NEAR
                              C ; This routine takes an already existent code segment and extracts the base and limit
                              C ;
                              C ; Upon entry, eax - GDT offset
                              C ;
                              C ; Upon exit:  ebx - base
                              C ;             edx - limit
                              C ;
000001CB  9C                  C     pushfd
000001CC                      C     .IF (eax <= _lastGDT * 8)
000001D3  1E                  C         push    ds
000001D4  51                  C         push    ecx
                              C 
000001D5  66B91000            C         mov     cx,_sGDT
000001D9  668ED9              C         mov     ds,cx
                              C 
                              C       ; Get the limit
000001DC  33D2                C         xor     edx,edx
000001DE  668B10              C         mov     dx,word ptr [eax]
000001E1  C1CA10              C         ror     edx,16
000001E4  8A5006              C         mov     dl,byte ptr [eax+6]
000001E7  80E20F              C         and     dl,0fh
000001EA  C1C210              C         rol     edx,16
000001ED  F6400680            C         test    byte ptr [eax+6],10000000b                          ; See if the "G" bit is set
000001F1                      C         .IF (!zero?)
                              C           ; It is set for granularity
000001F3  C1E20C              C             shl     edx,12
000001F6                      C         .ENDIF
                              C 
                              C       ; Get the base
000001F6  8B5802              C         mov     ebx,dword ptr [eax+2]
000001F9  81E3FFFFFF00        C         and     ebx,0ffffffh
000001FF  C1C308              C         rol     ebx,8
00000202  8A5807              C         mov     bl,byte ptr [eax+7]
00000205  C1CB08              C         ror     ebx,8
                              C 
00000208  59                  C         pop     ecx
00000209  1F                  C         pop     ds
0000020A                      C     .ENDIF
0000020A  9D                  C     popfd
0000020B                      C     ret
0000020C                      C invExtract_code_descriptor32        ENDP
                              C 
                              C 
                              C 
                              C 
0000020C                      C invExtract_call_gate_descriptor32       PROC    NEAR
                              C ; This routine takes an already existent code segment and extracts the base and limit
                              C ;
                              C ; Upon entry, eax - GDT offset
                              C ;
                              C ; Upon exit:  ebx - offset
                              C ;             ecx - param count
                              C ;             edx - code segment
                              C ;
0000020C  9C                  C     pushfd
0000020D                      C     .IF (eax <= _lastGDT * 8)
00000214  1E                  C         push    ds
                              C 
00000215  BA10000000          C         mov     edx,_sGDT
0000021A  8EDA                C         mov     ds,edx
                              C 
                              C       ; Get the offset
0000021C  33DB                C         xor     ebx,ebx
0000021E  668B18              C         mov     bx,word ptr ds:[eax]
00000221  C1CB10              C         ror     ebx,16
00000224  668B5806            C         mov     bx,word ptr ds:[eax+6]
00000228  C1CB10              C         ror     ebx,16
                              C 
                              C       ; Get the param count
0000022B  0FB64804            C         movzx   ecx,byte ptr ds:[eax+4]
                              C 
                              C       ; Get the code selector
0000022F  0FB75002            C         movzx   edx,word ptr ds:[eax+2]
                              C 
00000233  1F                  C         pop     ds
00000234                      C     .ENDIF
00000234  9D                  C     popfd
00000235                      C     ret
00000236                      C invExtract_call_gate_descriptor32       ENDP
                              C 
                              C 
                              C 
                              C 
00000236                      C invExtract_data_descriptor32        PROC    NEAR
                              C ; This routine takes an already existent data segment and extracts the base and offset
                              C ;
                              C ; Upon entry:   eax - GDT offset
                              C ;
                              C ; Upon exit:    ebx - base
                              C ;               edx - limit
                              C ;
00000236  9C                  C     pushfd
00000237                      C     .IF (eax <= _lastGDT * 8)
0000023E  1E                  C         push    ds
0000023F  51                  C         push    ecx
                              C 
00000240  B910000000          C         mov     ecx,_sGDT
00000245  8ED9                C         mov     ds,ecx
                              C 
                              C       ; Get the limit
00000247  33D2                C         xor     edx,edx
00000249  668B10              C         mov     dx,word ptr [eax]
0000024C  C1CA10              C         ror     edx,16
0000024F  8A5006              C         mov     dl,byte ptr [eax+6]
00000252  80E20F              C         and     dl,0fh
00000255  C1C210              C         rol     edx,16
00000258  F6400680            C         test    byte ptr [eax+6],10000000b                          ; See if the "G" bit is set
0000025C                      C         .IF (!zero?)
                              C           ; It is set for granularity
0000025E  C1E20C              C             shl     edx,12
00000261                      C         .ENDIF
                              C 
                              C       ; Get the base
00000261  8B5802              C         mov     ebx,dword ptr [eax+2]
00000264  81E3FFFFFF00        C         and     ebx,0ffffffh
0000026A  C1C308              C         rol     ebx,8
0000026D  8A5807              C         mov     bl,byte ptr [eax+7]
00000270  C1CB08              C         ror     ebx,8
                              C 
00000273  59                  C         pop     ecx
00000274  1F                  C         pop     ds
00000275                      C     .ENDIF
00000275  9D                  C     popfd
00000276                      C     ret
00000277                      C invExtract_data_descriptor32        ENDP
                              C 
                              C 
                              C 
                              C 
00000277                      C invAlter_descriptor32_base_limit    PROC
                              C ; This routine is used to alter the base and/or limit of an existing GDT entry
                              C ;
                              C ; Upon entry:   edx - slot
                              C ;               esi - new base
                              C ;               edi - new limit
                              C ;
                              C ; Upon exit:    Value is updated if edx is valid
                              C ;
                              C 
00000277  9C                  C     pushfd
00000278                      C     .IF (edx <= _lastGDT)
00000280  1E                  C         push    ds
00000281  51                  C         push    ecx
00000282  53                  C         push    ebx
00000283  50                  C         push    eax
                              C 
00000284  B910000000          C         mov     ecx,_sGDT
00000289  8ED9                C         mov     ds,ecx
                              C       ; Right now,  ds:[edx*8] - far ptr to GDT entry
                              C       ;             esi - new base
                              C       ;             edi - new limit
0000028B  8BDE                C         mov     ebx,esi
0000028D  8BC7                C         mov     eax,edi
0000028F                      C         .IF (eax > 0fffffh)
                              C           ; Turn on the granularity bit
00000296  C1E80C              C             shr     eax,12
00000299  800CD50600000080    C             or      byte ptr ds:[edx*8+6],10000000b
000002A1                      C         .ELSE
                              C           ; Turn off the granularity bit
000002A3  8024D5060000007F    C             and     byte ptr ds:[edx*8+6],not 10000000b
000002AB                      C         .ENDIF
                              C 
000002AB  668904D500000000    C         mov     word ptr ds:[edx*8+0],ax                            ; limit 0-15
000002B3  66891CD502000000    C         mov     word ptr ds:[edx*8+2],bx                            ; base 0-15
000002BB  C1E810              C         shr     eax,16
000002BE  C1EB10              C         shr     ebx,16
000002C1  881CD504000000      C         mov     byte ptr ds:[edx*8+4],bl                            ; base 16-23
000002C8  883CD507000000      C         mov     byte ptr ds:[edx*8+7],bh                            ; base 24-31
                              C 
000002CF  240F                C         and     al,0fh
000002D1  8024D506000000F0    C         and     byte ptr ds:[edx*8+6],0f0h
000002D9  0804D506000000      C         or      byte ptr ds:[edx*8+6],al
                              C       ; Right now, it's updated
                              C 
000002E0  58                  C         pop     eax
000002E1  5B                  C         pop     ebx
000002E2  59                  C         pop     ecx
000002E3  1F                  C         pop     ds
000002E4                      C     .ENDIF
000002E4  9D                  C     popfd
000002E5                      C     ret
000002E6                      C invAlter_descriptor32_base_limit    ENDP
                              C 
                              C 
                              C 
                              C 
000002E6                      C invExtract_linear_offset_into_edx_from_ds   PROC
                              C ; This routine is used to extract the linear offset from the GDT value in ds
                              C ;
                              C ; Upon entry:   ds - GDT slot being searched for
                              C ;
                              C ; Upon exit:    edx - linear offset
                              C ;
000002E6  9C                  C     pushfd
000002E7  50                  C     push    eax
                              C 
000002E8  8CD8                C     mov     eax,ds
000002EA                      C     .IF (eax <= _lastGDT * 8)
000002F1  1E                  C         push    ds
000002F2  51                  C         push    ecx
                              C 
000002F3  66B91000            C         mov     cx,_sGDT
000002F7  668ED9              C         mov     ds,cx
                              C 
                              C       ; Get the base (linear offset)
000002FA  8B5002              C         mov     edx,dword ptr [eax+2]
000002FD  81E2FFFFFF00        C         and     edx,0ffffffh
00000303  C1C208              C         rol     edx,8
00000306  8A5007              C         mov     dl,byte ptr [eax+7]
00000309  C1CA08              C         ror     edx,8
                              C 
0000030C  59                  C         pop     ecx
0000030D  1F                  C         pop     ds
0000030E                      C     .ENDIF
                              C 
0000030E  58                  C     pop     eax
0000030F  9D                  C     popfd
00000310                      C     ret
00000311                      C invExtract_linear_offset_into_edx_from_ds   ENDP
                              C 
                              C 
                              C 
                              C 
00000311                      C invCreate_tss_descriptor32     PROC
                              C ; Upon entry, eax - slot # to insert
                              C ;             ebx - base
                              C ;             edx - limit
                              C ;
00000311  9C                  C     pushfd
00000312                      C     .IF (eax <= _lastGDT)
00000319  1E                  C         push    ds
0000031A  56                  C         push    esi
0000031B  53                  C         push    ebx
0000031C  52                  C         push    edx
                              C 
0000031D  66BE1000            C         mov     si,_sGDT
00000321  668EDE              C         mov     ds,si
                              C 
00000324  66891CC502000000    C         mov     word ptr [eax*8+2],bx                               ; base 0:15
0000032C  C1EB10              C         shr     ebx,16
0000032F  881CC504000000      C         mov     byte ptr [eax*8+4],bl                               ; base 16:23
00000336  883CC507000000      C         mov     byte ptr [eax*8+7],bh                               ; base 24:31
0000033D  668914C500000000    C         mov     word ptr [eax*8+0],dx                               ; limit 0:15
00000345  C1EA10              C         shr     edx,16
00000348  80E20F              C         and     dl,0fh                                              ; make the top nibble be all 0s
0000034B  8814C506000000      C         mov     byte ptr [eax*8+6],dl                               ; Granularity=0:0:0:Available=0:limit 16:19
00000352  C604C50500000089    C         mov     byte ptr [eax*8+5],10001001b                        ; present=1:dpl=00:010:busy=0:1
                              C 
0000035A  5A                  C         pop     edx
0000035B  5B                  C         pop     ebx
0000035C  5E                  C         pop     esi
0000035D  1F                  C         pop     ds
0000035E                      C     .ENDIF
0000035E  9D                  C     popfd
0000035F                      C     ret
00000360                      C invCreate_tss_descriptor32     ENDP
                              C 
                              C 
                              C 
                              C 
00000360                      C invCreate_tss32    PROC
                              C ; Upon entry, ds:[esi] - far ptr to offset in memory to create the TSS
                              C ;                  ebx - code segment selector
                              C ;                  ecx - first instruction offset
                              C ;                  edx - stack segment selector
                              C ;                  edi - esp value
00000360  50                  C     push eax
                              C 
                              C   ; Code segment register
00000361  895E4C              C     mov     dword ptr ds:[esi+76],ebx                           ; cs
                              C   ; Instruction Pointer
00000364  894E20              C     mov     dword ptr ds:[esi+32],ecx                           ; eip
                              C   ; Stack
00000367  895650              C     mov     dword ptr ds:[esi+80],edx                           ; ss
0000036A  897E38              C     mov     dword ptr ds:[esi+56],edi                           ; esp
                              C   ; Data segment registers
0000036D  B848000000          C     mov     eax,_sDATA
00000372  894654              C     mov     dword ptr ds:[esi+84],eax                           ; ds
00000375  894648              C     mov     dword ptr ds:[esi+72],eax                           ; es
                              C   ; Extra segment registers
00000378  B838000000          C     mov     eax,_sVGA
0000037D  894658              C     mov     dword ptr ds:[esi+88],eax                           ; fs
00000380  B830000000          C     mov     eax,_sMONO
00000385  89465C              C     mov     dword ptr ds:[esi+92],eax                           ; gs
                              C   ; Stack 2
00000388  B830010000          C     mov     eax,_sSTACK2
0000038D  894618              C     mov     dword ptr ds:[esi+24],eax                           ; ss2
00000390  C74614FC070000      C     mov     dword ptr ds:[esi+20],07fch                         ; esp2
                              C   ; Stack 1
00000397  B828010000          C     mov     eax,_sSTACK1
0000039C  894610              C     mov     dword ptr ds:[esi+16],eax                           ; ss1
0000039F  C7460CFC070000      C     mov     dword ptr ds:[esi+12],07fch                         ; esp1
                              C   ; Stack 0
000003A6  B820010000          C     mov     eax,_sSTACK0
000003AB  894608              C     mov     dword ptr ds:[esi+8],eax                            ; ss0
000003AE  C74604FC070000      C     mov     dword ptr ds:[esi+4],07fch                          ; esp0
                              C   ; General purpose registers
000003B5  33C0                C     xor     eax,eax
000003B7  894628              C     mov     dword ptr ds:[esi+40],eax                           ; eax
000003BA  89462C              C     mov     dword ptr ds:[esi+44],eax                           ; ecx
000003BD  894630              C     mov     dword ptr ds:[esi+48],eax                           ; edx
000003C0  894634              C     mov     dword ptr ds:[esi+52],eax                           ; ebx
000003C3  89463C              C     mov     dword ptr ds:[esi+60],eax                           ; ebp
000003C6  894640              C     mov     dword ptr ds:[esi+64],eax                           ; esi
000003C9  894644              C     mov     dword ptr ds:[esi+68],eax                           ; edi
000003CC  89461C              C     mov     dword ptr ds:[esi+28],eax                           ; CR3, paging (not used in Exodus)
000003CF  894664              C     mov     dword ptr ds:[esi+100],eax                          ; IO Map Base Address, Trap bit
000003D2  8906                C     mov     dword ptr ds:[esi+0],eax                            ; Previous task link
000003D4  33C0                C     xor     eax,eax
000003D6  894660              C     mov     dword ptr ds:[esi+96],eax                           ; LDT segment selector
                              C   ; EFLAGS
000003D9  9C                  C     pushfd
000003DA  58                  C     pop     eax
000003DB  894624              C     mov     dword ptr ds:[esi+36],eax
                              C 
000003DE  58                  C     pop     eax
000003DF                      C     ret
000003E0                      C invCreate_tss32    ENDP
                              C 
                              C 
                              C 
                              C 
000003E0                      C invUpdate_interrupt_descriptor16   PROC
                              C ; Upon entry, eax - interrupt # to update (0-based)
                              C ;             edx - offset in bx to routine
                              C ;              bx - segment selector of routine
000003E0  51                  C     push    ecx
000003E1  52                  C     push    edx
000003E2  0FA0                C     push    fs
                              C 
000003E4  66B90800            C     mov     cx,_sIDT                                                ; IDT slot in GDT
000003E8  668EE1              C     mov     fs,cx
000003EB  8BCA                C     mov     ecx,edx                                                 ; Copy 32-bit offset to ecx
000003ED  81E2FFFF0000        C     and     edx,00000ffffh                                          ; Keep lower 16-bits in edx
000003F3  81E10000FFFF        C     and     ecx,0ffff0000h                                          ; Keep upper 16-bits in ecx
000003F9  66B90086            C     mov     cx,1000011000000000b                                    ; Add lower 16-bits in ecx, 16-bit, DPL=0, Present
000003FD  C1CA10              C     ror     edx,16                                                  ; Move edx around so we can access the high word
00000400  668BD3              C     mov     dx,bx                                                   ; Segment selector
00000403  C1CA10              C     ror     edx,16                                                  ; Ok, put it back the way it was
                              C 
00000406  FA                  C     cli
00000407  648914C500000000    C     mov     dword ptr fs:[eax*8+0],edx                              ; Store the IDT descriptor
0000040F  64890CC504000000    C     mov     dword ptr fs:[eax*8+4],ecx
00000417  FB                  C     sti
                              C 
00000418  0FA1                C     pop     fs
0000041A  5A                  C     pop     edx
0000041B  59                  C     pop     ecx
0000041C                      C     ret
0000041D                      C invUpdate_interrupt_descriptor16   ENDP
                              C 
                              C 
                              C 
                              C 
0000041D                      C invUpdate_interrupt_descriptor32   PROC
                              C ; Upon entry, eax - interrupt # to update (0-based)
                              C ;             edx - offset in bx to routine
                              C ;              bx - segment selector of routine
0000041D  51                  C     push    ecx
0000041E  52                  C     push    edx
0000041F  0FA0                C     push    fs
                              C 
00000421  66B90800            C     mov     cx,_sIDT                                                ; IDT slot in GDT
00000425  668EE1              C     mov     fs,cx
00000428  8BCA                C     mov     ecx,edx                                                 ; Copy 32-bit offset to ecx
0000042A  81E2FFFF0000        C     and     edx,00000ffffh                                          ; Keep lower 16-bits in edx
00000430  81E10000FFFF        C     and     ecx,0ffff0000h                                          ; Keep upper 16-bits in ecx
00000436  66B9008E            C     mov     cx,1000111000000000b                                    ; Add control bits to ecx, 32-bit, DPL=0, Present
0000043A  C1CA10              C     ror     edx,16                                                  ; Move edx around so we can access the high word
0000043D  668BD3              C     mov     dx,bx                                                   ; Segment selector
00000440  C1CA10              C     ror     edx,16                                                  ; Ok, put it back the way it was
                              C 
00000443  FA                  C     cli
00000444  648914C500000000    C     mov     dword ptr fs:[eax*8+0],edx                              ; Store the IDT descriptor
0000044C  64890CC504000000    C     mov     dword ptr fs:[eax*8+4],ecx
00000454  FB                  C     sti
                              C 
00000455  0FA1                C     pop     fs
00000457  5A                  C     pop     edx
00000458  59                  C     pop     ecx
00000459                      C     ret
0000045A                      C invUpdate_interrupt_descriptor32   ENDP
                              C 
                              C 
                              C 
                              C 
                              C 
0000045A                      C invSetup_memory_blocks      PROC
                              C ; This routine is used to setup required memory blocks for Exodus
                              C ;
                              C ; Upon entry:   This function is called as the first function in protected mode
                              C ;               It is known that all of the standard GDT entries are setup (those before _sEXODUS_REQUESTOR)
                              C ;
                              C ; Upon exit:    These memory blocks are setup with their default structures/info:
                              C ;                   _sEXODUS_MEM            ; Refer to inf\exodus.inf for more information
                              C ;                   _sEXODUS_PORTS          ; Refer to inf\exodus.inf for more information
                              C ;                   _sEXODUS_INTS           ; Refer to inf\exodus.inf for more information
                              C ;                   _sSYSTEM                ; Various memory regions
                              C ;
0000045A  50                  C     push    eax
0000045B  56                  C     push    esi
0000045C  1E                  C     push    ds
                              C 
                              C 
                              C ;; Do the Exodus memory block regions
0000045D  66B85000            C     mov     ax,_sEXODUS_MEM
00000461  668ED8              C     mov     ds,ax
00000464  67C706000014000000  C     mov     dword ptr ds:[0],4 + _EXODUS_MEM_size                   ; The length of this structure plus the initial dword
0000046D  BE04000000          C     mov     esi,4
00000472  C60600              C     mov     byte ptr ds:[esi+_EXODUS_MEM_type],0                    ; Free block
00000475  C7460400001000      C     mov     dword ptr ds:[esi+_EXODUS_MEM_base],100000h             ; Start at 1MB
0000047C  C7460800001000      C     mov     dword ptr ds:[esi+_EXODUS_MEM_limit],100000h            ; Limit (1MB, Exodus requires 2MB of RAM to boot)
00000483  C7460C00000000      C     mov     dword ptr ds:[esi+_EXODUS_MEM_gdt],0
                              C 
                              C 
                              C ;; Do the Exodus port assignments
0000048A  66B85800            C     mov     ax,_sEXODUS_PORTS
0000048E  668ED8              C     mov     ds,ax
00000491  67C706000004000000  C     mov     dword ptr ds:[0],4                                      ; 4 = The initial dword only (no ports are auto reserved)
                              C 
                              C 
                              C ;; Do the Exodus interrupt assignments
0000049A  66B86000            C     mov     ax,_sEXODUS_INTS
0000049E  668ED8              C     mov     ds,ax
000004A1  67C706000004000000  C     mov     dword ptr ds:[0],4                                      ; 4 = The initial dword only (no ports are auto reserved)
                              C 
                              C 
                              C ;; Do the Exodus system memory area
000004AA  66B8A800            C     mov     ax,_sSYSTEM
000004AE  668ED8              C     mov     ds,ax
                              C   ; These values are Exodus internal
000004B1  6766C70634083200    C     mov     word ptr ds:[_SYSTEM_i_GDT_TO_ASSIGN],_firstASSIGNMENT
000004B9  6766C7063608B80B    C     mov     word ptr ds:[_SYSTEM_i_USER_GDT_TO_ASSIGN],_firstUSER_ASSIGNMENT
                              C   ; These values are user application accessible
000004C1  67C7061C0000002000  C     mov     dword ptr ds:[_SYSTEM_TOTAL_MEMORY],200000h             ; Default to 2MB until we know otherwise
                              C 
                              C 
000004CA  1F                  C     pop     ds
000004CB  5E                  C     pop     esi
000004CC  58                  C     pop     eax
000004CD                      C     ret
000004CE                      C invSetup_memory_blocks      ENDP
                              C 
                              C 
                              C 
                              C 
000004CE                      C invSet_80x25_text_mode      PROC
                              C ; This routine is called from various places in Exodus's core.  It calls the VID_requestor() function to enter an 80x25 text mode
                              C ; This is usually used for displaying errors, etc.
                              C ;
                              C ; Upon entry:   Nothing
                              C ;
                              C ; Upon exit:    Nothing
                              C ;
000004CE  6800000000          C     push    dword ptr 0                                         ; return: bits per pixel
000004D3  6800000000          C     push    dword ptr 0                                         ; return: horizontal pixels
000004D8  6800000000          C     push    dword ptr 0                                         ; return: vertical pixels
000004DD  6800000000          C     push    dword ptr 0                                         ; return: refresh rate
000004E2  6800000000          C     push    dword ptr 0                                         ; return: status
000004E7  6801000000          C     push    dword ptr 1                                         ; input: text mode
000004EC  6808000000          C     push    dword ptr 8                                         ; input: bits per pixel
000004F1  6850000000          C     push    dword ptr 80                                        ; input: horizontal pixels
000004F6  6819000000          C     push    dword ptr 25                                        ; input: vertical pixels
000004FB  683C000000          C     push    dword ptr 60                                        ; input: refresh rate
00000500  B801000000          C     mov     eax,1
00000505  2EFF1DE01A0000      C     call    fword ptr cs:_VID_requestor
0000050C  83C414              C     add     esp,20                                              ; get the values off the stack (we know this works)
0000050F                      C     ret
00000510                      C invSet_80x25_text_mode      ENDP
                                    INCLUDE data32.asp
                              C ; data32.asp
                              C ;
                              C ; Exodus data used in the 32-bit segment
                              C ;
                              C 
                              C 
                              C ;
                              C ; Ŀ
                              C ;  invSetup_native_primative() 
                              C ; 
                              C ;
                              C ; These variables are used in the invSetup_native_primative() function
                              C ;
00000510  6E6F20737570706F72  C no_support_for_primative                db  "no support for primative"
00000528  00000000            C code_gdt_offset                         dd  0                       ; used temporarily to hold permanent value of _csTEMP_PRIMATIVE
0000052C  00000000            C data_gdt_offset                         dd  0                       ; same, but for _dsTEMP_PRIMATIVE
00000530  00000000            C main_gdt_offset                         dd  0                       ; same, but for _cgTEMP_PRIMATIVE_MAIN
00000534  00000000            C requestor_gdt_offset                    dd  0                       ; same, but for _cgTEMP_PRIMATIVE_REQUESTOR
00000538  00                  C vga_kbd_support                         db  0                       ; Indicates whether or not basic VGA/keyboard support
                              C                                                                     ; has been installed.  Will be set to 1 after both are
                              C                                                                     ; available.
                              C 
00000539  202845786F64757320  C exodus_internal_text                    db  " (Exodus Internal)",0
0000054C  2028756E6B6E6F776E  C unknown_function_text                   db  " (unknown)",0
00000557  2028756E6B6E6F776E  C unknown_user_function_text              db  " (unknown user function)",0
00000570  2028756E6B6E6F776E  C unknown_primative_text                  db  " (unknown primative)",0
00000585  07204552524F52202D  C error_loading_exodus_ini_1              db  " ERROR - An error occurred while parsing EXODUS.INI.",0
000005BB  07204552524F52202D  C error_loading_exodus_ini_2              db  " ERROR - Exodus cannot find a required boot file: EXODUS.INI",0
000005F9  07204552524F52202D  C error_loading_exodus_ini_3              db  " ERROR - Exodus found multiple EXODUS.INI files on the boot drive.",0
0000063D  202020202020202020  C error_loading_exodus_ini_4              db  "          Please correct this problem and try booting again.",0
0000067A  072053797374656D20  C system_halted                           db  " System is stopped.  Please press RESET or power down to restart.",0
000006BD  2028666F756E642069  C found_it_text                           db  " (found it!)",0
                              C 
000006CA  4C696E652078787878  C line_text                               db  "Line xxxxxx"
000006D5  457870656374656420  C parse_expected_bracket_paren            db  "Expected [ or (",0
000006E5  457870656374656420  C parse_expected_paren                    db  "Expected (",0
000006F0  556E65787065637465  C parse_unexpected_end_of_file            db  "Unexpected end of file",0
00000707  5B5D206E616D652069  C parse_bracket_group_name_too_long       db  "[] name is too long, can only be 4 characters",0
                              C 
00000735  00                  C loading_primatives_displayed            db  _NO
00000736  FE204C6F6164696E67  C loading_primatives                      db  " Loading primatives",0
0000074B  FE204C6F6164696E67  C loading_drivers                         db  " Loading drivers",0
0000075D  2020C32000          C next_item                               db  "   ",0
00000762  2020C02000          C last_item                               db  "   ",0
00000767  2C2000              C comma_space                             db  ", ",0
                              C 
                              C ; Boot screen
0000076A                      C bootscreen_start:
                              C   ;INCLUDE bootscrn.inc
                              C   INCLUDE boot_scr.inc
0000076A  0D0000003030303037  C db 00dh,000h,000h,000h,030h,030h,030h,030h,037h,030h,000h,000h,010h,018h,018h,020h,020h,020h,020h,03fh
0000077E  3E3C2828293F000000  C db 03eh,03ch,028h,028h,029h,03fh,000h,000h,000h,03fh,000h,03fh,03fh,000h,000h,000h,03fh,03fh,03fh,03fh
00000792  FF03FF03FF03FF03FF  C db 0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h
000007A6  FF03FF03FF03FF03FF  C db 0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h
000007BA  FF03FF03FF03FF03C1  C db 0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0c1h,003h,007h,00ch,0ffh,003h,03ah,003h,007h,00ch,0dah,003h
000007CE  140C4B03070C860329  C db 014h,00ch,04bh,003h,007h,00ch,086h,003h,029h,00bh,02bh,003h,014h,00ch,04bh,003h,007h,00ch,086h,003h
000007E2  290B2B03140C4B0307  C db 029h,00bh,02bh,003h,014h,00ch,04bh,003h,007h,00ch,086h,003h,002h,00bh,025h,000h,002h,00bh,02bh,003h
000007F6  140C4B03070C860302  C db 014h,00ch,04bh,003h,007h,00ch,086h,003h,002h,00bh,025h,000h,002h,00bh,02bh,003h,014h,00ch,04bh,003h
0000080A  070C8603020B250002  C db 007h,00ch,086h,003h,002h,00bh,025h,000h,002h,00bh,02bh,003h,014h,00ch,04bh,003h,007h,00ch,086h,003h
0000081E  020B2500020B2B0308  C db 002h,00bh,025h,000h,002h,00bh,02bh,003h,008h,00ch,032h,003h,001h,004h,001h,001h,002h,006h,003h,00ch
00000832  020601010105100301  C db 002h,006h,001h,001h,001h,005h,010h,003h,001h,005h,001h,002h,001h,006h,003h,00ch,001h,006h,001h,001h
00000846  01040103070C260301  C db 001h,004h,001h,003h,007h,00ch,026h,003h,001h,004h,001h,001h,001h,002h,001h,006h,005h,00ch,001h,006h
0000085A  010201010105530302  C db 001h,002h,001h,001h,001h,005h,053h,003h,002h,00bh,025h,000h,002h,00bh,02bh,003h,008h,00ch,010h,003h
0000086E  0102060C0106090307  C db 001h,002h,006h,00ch,001h,006h,009h,003h,007h,00ch,001h,002h,007h,003h,001h,005h,001h,006h,00bh,00ch
00000882  010601050C03010501  C db 001h,006h,001h,005h,00ch,003h,001h,005h,001h,006h,009h,00ch,001h,006h,007h,00ch,005h,003h,007h,00ch
00000896  0903070C0803010501  C db 009h,003h,007h,00ch,008h,003h,001h,005h,001h,002h,00eh,00ch,001h,002h,051h,003h,002h,00bh,025h,000h
000008AA  020B2B03080C110301  C db 002h,00bh,02bh,003h,008h,00ch,011h,003h,001h,006h,006h,00ch,001h,002h,007h,003h,001h,002h,006h,00ch
000008BE  0106070301070F0C01  C db 001h,006h,007h,003h,001h,007h,00fh,00ch,001h,007h,00ah,003h,001h,007h,013h,00ch,005h,003h,007h,00ch
000008D2  0903070C0703010111  C db 009h,003h,007h,00ch,007h,003h,001h,001h,011h,00ch,045h,003h,00eh,00bh,025h,000h,00bh,00bh,022h,003h
000008E6  080C11030104070C01  C db 008h,00ch,011h,003h,001h,004h,007h,00ch,001h,007h,005h,003h,001h,007h,007h,00ch,001h,004h,006h,003h
000008FA  0107110C0107080301  C db 001h,007h,011h,00ch,001h,007h,008h,003h,001h,007h,014h,00ch,005h,003h,007h,00ch,009h,003h,007h,00ch
0000090E  06030101120C450301  C db 006h,003h,001h,001h,012h,00ch,045h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,008h,008h
00000922  010B2203080C120301  C db 001h,00bh,022h,003h,008h,00ch,012h,003h,001h,007h,007h,00ch,001h,004h,003h,003h,001h,004h,007h,00ch
00000936  010506030104130C01  C db 001h,005h,006h,003h,001h,004h,013h,00ch,001h,005h,006h,003h,001h,004h,015h,00ch,005h,003h,007h,00ch
0000094A  0903070C0503010513  C db 009h,003h,007h,00ch,005h,003h,001h,005h,013h,00ch,045h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h
0000095E  020B0808010B220313  C db 002h,00bh,008h,008h,001h,00bh,022h,003h,013h,00ch,008h,003h,001h,001h,006h,00ch,001h,006h,003h,003h
00000972  0106060C0101070301  C db 001h,006h,006h,00ch,001h,001h,007h,003h,001h,006h,007h,00ch,001h,007h,003h,003h,001h,007h,007h,00ch
00000986  010606030102070C01  C db 001h,006h,006h,003h,001h,002h,007h,00ch,001h,006h,001h,007h,003h,003h,001h,005h,001h,001h,007h,00ch
0000099A  0503070C0903070C05  C db 005h,003h,007h,00ch,009h,003h,007h,00ch,005h,003h,001h,002h,006h,00ch,001h,002h,001h,007h,001h,004h
000009AE  030301050107010101  C db 003h,003h,001h,005h,001h,007h,001h,001h,001h,006h,003h,00ch,045h,003h,001h,00bh,00bh,008h,002h,00bh
000009C2  2500020B0808010B22  C db 025h,000h,002h,00bh,008h,008h,001h,00bh,022h,003h,013h,00ch,009h,003h,001h,006h,006h,00ch,001h,001h
000009D6  01030101060C010207  C db 001h,003h,001h,001h,006h,00ch,001h,002h,007h,003h,001h,004h,007h,00ch,001h,005h,005h,003h,001h,005h
000009EA  070C01040403010407  C db 007h,00ch,001h,004h,004h,003h,001h,004h,007h,00ch,001h,002h,007h,003h,007h,00ch,005h,003h,007h,00ch
000009FE  0903070C0503070C0A  C db 009h,003h,007h,00ch,005h,003h,007h,00ch,00ah,003h,001h,004h,001h,002h,001h,00ch,045h,003h,001h,00bh
00000A12  0B08020B2500020B08  C db 00bh,008h,002h,00bh,025h,000h,002h,00bh,008h,008h,001h,00bh,022h,003h,013h,00ch,00ah,003h,001h,006h
00000A26  060C0101060C010608  C db 006h,00ch,001h,001h,006h,00ch,001h,006h,008h,003h,001h,001h,006h,00ch,001h,002h,007h,003h,001h,002h
00000A3A  060C01010403010107  C db 006h,00ch,001h,001h,004h,003h,001h,001h,007h,00ch,008h,003h,007h,00ch,005h,003h,007h,00ch,009h,003h
00000A4E  070C0503070C010151  C db 007h,00ch,005h,003h,007h,00ch,001h,001h,051h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh
00000A62  0808010B2203130C0A  C db 008h,008h,001h,00bh,022h,003h,013h,00ch,00ah,003h,001h,005h,00dh,00ch,001h,005h,008h,003h,001h,006h
00000A76  060C01070703010706  C db 006h,00ch,001h,007h,007h,003h,001h,007h,006h,00ch,001h,006h,004h,003h,001h,002h,006h,00ch,001h,001h
00000A8A  0803070C0503070C09  C db 008h,003h,007h,00ch,005h,003h,007h,00ch,009h,003h,007h,00ch,005h,003h,009h,00ch,001h,006h,001h,001h
00000A9E  010701054C03010B0B  C db 001h,007h,001h,005h,04ch,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,008h,008h,001h,00bh
00000AB2  2203130C0B0301070B  C db 022h,003h,013h,00ch,00bh,003h,001h,007h,00bh,00ch,001h,007h,009h,003h,001h,006h,006h,00ch,001h,004h
00000AC6  07030104060C010604  C db 007h,003h,001h,004h,006h,00ch,001h,006h,004h,003h,001h,006h,006h,00ch,001h,005h,008h,003h,007h,00ch
00000ADA  0503070C0903070C05  C db 005h,003h,007h,00ch,009h,003h,007h,00ch,005h,003h,001h,002h,00dh,00ch,001h,006h,001h,001h,001h,005h
00000AEE  4803010B0B08020B25  C db 048h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,008h,008h,001h,00bh,022h,003h,013h,00ch
00000B02  0C030102090C01020A  C db 00ch,003h,001h,002h,009h,00ch,001h,002h,00ah,003h,007h,00ch,009h,003h,007h,00ch,004h,003h,007h,00ch
00000B16  0903070C0503070C09  C db 009h,003h,007h,00ch,005h,003h,007h,00ch,009h,003h,007h,00ch,005h,003h,001h,004h,010h,00ch,001h,006h
00000B2A  01074603010B0B0802  C db 001h,007h,046h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,008h,008h,001h,00bh,022h,003h
00000B3E  080C18030106070C01  C db 008h,00ch,018h,003h,001h,006h,007h,00ch,001h,006h,00bh,003h,007h,00ch,009h,003h,007h,00ch,004h,003h
00000B52  070C0903070C050307  C db 007h,00ch,009h,003h,007h,00ch,005h,003h,007h,00ch,009h,003h,007h,00ch,006h,003h,001h,007h,011h,00ch
00000B66  01074503010B0B0802  C db 001h,007h,045h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,008h,008h,001h,00bh,022h,003h
00000B7A  080C18030106070C01  C db 008h,00ch,018h,003h,001h,006h,007h,00ch,001h,006h,00bh,003h,007h,00ch,009h,003h,007h,00ch,004h,003h
00000B8E  070C0903070C050307  C db 007h,00ch,009h,003h,007h,00ch,005h,003h,007h,00ch,009h,003h,007h,00ch,007h,003h,001h,005h,001h,006h
00000BA2  100C01054403010B0B  C db 010h,00ch,001h,005h,044h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,008h,008h,001h,00bh
00000BB6  2203080C1703010209  C db 022h,003h,008h,00ch,017h,003h,001h,002h,009h,00ch,001h,002h,00ah,003h,001h,006h,006h,00ch,001h,004h
00000BCA  0803060C0106040307  C db 008h,003h,006h,00ch,001h,006h,004h,003h,007h,00ch,009h,003h,007h,00ch,005h,003h,007h,00ch,009h,003h
00000BDE  070C09030107010201  C db 007h,00ch,009h,003h,001h,007h,001h,002h,001h,006h,00dh,00ch,001h,002h,044h,003h,001h,00bh,00bh,008h
00000BF2  020B25001A0B130308  C db 002h,00bh,025h,000h,01ah,00bh,013h,003h,008h,00ch,016h,003h,001h,007h,00bh,00ch,001h,007h,009h,003h
00000C06  0106060C0107070301  C db 001h,006h,006h,00ch,001h,007h,007h,003h,001h,007h,006h,00ch,001h,006h,004h,003h,001h,006h,006h,00ch
00000C1A  01050803070C050307  C db 001h,005h,008h,003h,007h,00ch,005h,003h,007h,00ch,001h,005h,008h,003h,007h,00ch,00dh,003h,001h,005h
00000C2E  02010106090C440301  C db 002h,001h,001h,006h,009h,00ch,044h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,01ah,00bh,013h,003h
00000C42  080C150301050D0C01  C db 008h,00ch,015h,003h,001h,005h,00dh,00ch,001h,005h,008h,003h,001h,001h,006h,00ch,001h,002h,007h,003h
00000C56  0102060C0101040301  C db 001h,002h,006h,00ch,001h,001h,004h,003h,001h,002h,006h,00ch,001h,002h,008h,003h,007h,00ch,005h,003h
00000C6A  070C01020803070C05  C db 007h,00ch,001h,002h,008h,003h,007h,00ch,005h,003h,001h,00ch,001h,001h,00bh,003h,001h,001h,007h,00ch
00000C7E  4403010B0B08020B25  C db 044h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,01ah,00bh,013h,003h,008h,00ch,015h,003h,001h,006h
00000C92  060C0101060C010608  C db 006h,00ch,001h,001h,006h,00ch,001h,006h,008h,003h,001h,004h,007h,00ch,001h,005h,005h,003h,001h,005h
00000CA6  070C01040403010707  C db 007h,00ch,001h,004h,004h,003h,001h,007h,007h,00ch,001h,005h,007h,003h,007h,00ch,005h,003h,008h,00ch
00000CBA  010101050303010701  C db 001h,001h,001h,005h,003h,003h,001h,007h,001h,002h,008h,00ch,005h,003h,002h,00ch,001h,006h,001h,007h
00000CCE  0A03070C4403010B0B  C db 00ah,003h,007h,00ch,044h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,01ah,00bh,013h,003h,014h,00ch
00000CE2  08030102060C010101  C db 008h,003h,001h,002h,006h,00ch,001h,001h,001h,003h,001h,001h,006h,00ch,001h,006h,008h,003h,001h,006h
00000CF6  070C01070303010707  C db 007h,00ch,001h,007h,003h,003h,001h,007h,007h,00ch,001h,006h,006h,003h,008h,00ch,001h,001h,001h,004h
00000D0A  020301050101080C05  C db 002h,003h,001h,005h,001h,001h,008h,00ch,005h,003h,001h,006h,016h,00ch,005h,003h,005h,00ch,001h,002h
00000D1E  010701050403010501  C db 001h,007h,001h,005h,004h,003h,001h,005h,001h,002h,006h,00ch,001h,002h,044h,003h,001h,00bh,00bh,008h
00000D32  020B25001A0B130314  C db 002h,00bh,025h,000h,01ah,00bh,013h,003h,014h,00ch,007h,003h,001h,001h,006h,00ch,001h,006h,003h,003h
00000D46  0106060C0101070301  C db 001h,006h,006h,00ch,001h,001h,007h,003h,001h,004h,013h,00ch,001h,004h,006h,003h,001h,001h,015h,00ch
00000D5A  05030101160C050314  C db 005h,003h,001h,001h,016h,00ch,005h,003h,014h,00ch,001h,005h,044h,003h,001h,00bh,00bh,008h,002h,00bh
00000D6E  2500020B1309050B13  C db 025h,000h,002h,00bh,013h,009h,005h,00bh,013h,003h,014h,00ch,006h,003h,001h,005h,007h,00ch,001h,005h
00000D82  03030104070C010707  C db 003h,003h,001h,004h,007h,00ch,001h,007h,007h,003h,001h,007h,011h,00ch,001h,007h,008h,003h,001h,006h
00000D96  140C0603160C050313  C db 014h,00ch,006h,003h,016h,00ch,005h,003h,013h,00ch,001h,001h,045h,003h,001h,00bh,00bh,008h,002h,00bh
00000DAA  2500020B1309050B13  C db 025h,000h,002h,00bh,013h,009h,005h,00bh,013h,003h,014h,00ch,005h,003h,001h,004h,007h,00ch,001h,001h
00000DBE  05030107070C010407  C db 005h,003h,001h,007h,007h,00ch,001h,004h,007h,003h,001h,007h,00fh,00ch,001h,007h,009h,003h,001h,005h
00000DD2  140C060301070D0C01  C db 014h,00ch,006h,003h,001h,007h,00dh,00ch,001h,001h,007h,00ch,005h,003h,012h,00ch,001h,001h,046h,003h
00000DE6  010B0B08020B250002  C db 001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,013h,003h,014h,00ch,005h,003h
00000DFA  0106060C0102070301  C db 001h,006h,006h,00ch,001h,002h,007h,003h,001h,002h,006h,00ch,001h,006h,008h,003h,001h,005h,001h,006h
00000E0E  0B0C010601050B0301  C db 00bh,00ch,001h,006h,001h,005h,00bh,003h,001h,005h,001h,006h,009h,00ch,001h,006h,001h,005h,007h,00ch
00000E22  070301070A0C010202  C db 007h,003h,001h,007h,00ah,00ch,001h,002h,002h,003h,007h,00ch,005h,003h,001h,007h,001h,002h,00eh,00ch
00000E36  010201054703010B0B  C db 001h,002h,001h,005h,047h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh
00000E4A  1303140C0403010206  C db 013h,003h,014h,00ch,004h,003h,001h,002h,006h,00ch,001h,006h,009h,003h,001h,006h,006h,00ch,001h,002h
00000E5E  090301050101020603  C db 009h,003h,001h,005h,001h,001h,002h,006h,003h,00ch,002h,006h,001h,001h,001h,005h,00fh,003h,001h,007h
00000E72  0102040C0106010201  C db 001h,002h,004h,00ch,001h,006h,001h,002h,001h,005h,002h,003h,007h,00ch,009h,003h,001h,001h,001h,006h
00000E86  040C01060101010403  C db 004h,00ch,001h,006h,001h,001h,001h,004h,003h,003h,007h,00ch,008h,003h,001h,007h,001h,001h,002h,006h
00000E9A  050C01060102010701  C db 005h,00ch,001h,006h,001h,002h,001h,007h,001h,004h,049h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h
00000EAE  020B1309050BF30301  C db 002h,00bh,013h,009h,005h,00bh,0f3h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,013h,009h
00000EC2  050BF303010B0B0802  C db 005h,00bh,0f3h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,0f3h,003h
00000ED6  010B0B08020B250002  C db 001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,0f3h,003h,001h,00bh,00bh,008h
00000EEA  020B2500020B130905  C db 002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,0f3h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h
00000EFE  020B1309050BF30301  C db 002h,00bh,013h,009h,005h,00bh,0f3h,003h,001h,00bh,00bh,008h,002h,00bh,025h,000h,002h,00bh,013h,009h
00000F12  050BEC03150B250002  C db 005h,00bh,0ech,003h,015h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,0ech,003h,015h,00bh,025h,000h
00000F26  020B1309050BEC0315  C db 002h,00bh,013h,009h,005h,00bh,0ech,003h,015h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,0ech,003h
00000F3A  030B100A020B250002  C db 003h,00bh,010h,00ah,002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,030h,003h,001h,007h,001h,001h
00000F4E  0206040C0206010101  C db 002h,006h,004h,00ch,002h,006h,001h,001h,001h,005h,011h,003h,001h,007h,001h,002h,001h,006h,004h,00ch
00000F62  010601020101120301  C db 001h,006h,001h,002h,001h,001h,012h,003h,001h,007h,001h,002h,001h,006h,004h,00ch,001h,006h,001h,002h
00000F76  01010E030107010102  C db 001h,001h,00eh,003h,001h,007h,001h,001h,002h,006h,004h,00ch,002h,006h,001h,001h,001h,005h,05fh,003h
00000F8A  030B100A020B250002  C db 003h,00bh,010h,00ah,002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,02dh,003h,001h,001h,001h,006h
00000F9E  0D0C010601050D0301  C db 00dh,00ch,001h,006h,001h,005h,00dh,003h,001h,001h,00ch,00ch,001h,001h,00eh,003h,001h,001h,00ch,00ch
00000FB2  01010903010101060D  C db 001h,001h,009h,003h,001h,001h,001h,006h,00dh,00ch,001h,006h,001h,005h,05dh,003h,003h,00bh,010h,00ah
00000FC6  020B2500020B130905  C db 002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,02dh,003h,011h,00ch,001h,007h,00ah,003h,001h,005h
00000FDA  01060E0C010601050A  C db 001h,006h,00eh,00ch,001h,006h,001h,005h,00ah,003h,001h,005h,001h,006h,00eh,00ch,001h,006h,001h,005h
00000FEE  0703110C01075C0303  C db 007h,003h,011h,00ch,001h,007h,05ch,003h,003h,00bh,010h,00ah,002h,00bh,025h,000h,002h,00bh,013h,009h
00001002  050B2D03120C010709  C db 005h,00bh,02dh,003h,012h,00ch,001h,007h,009h,003h,012h,00ch,00ah,003h,012h,00ch,007h,003h,012h,00ch
00001016  01075B03030B100A02  C db 001h,007h,05bh,003h,003h,00bh,010h,00ah,002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,02dh,003h
0000102A  130C08030106120C01  C db 013h,00ch,008h,003h,001h,006h,012h,00ch,001h,006h,008h,003h,001h,006h,012h,00ch,001h,006h,006h,003h
0000103E  130C5B03030B100A02  C db 013h,00ch,05bh,003h,003h,00bh,010h,00ah,002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,02dh,003h
00001052  130C01010603010508  C db 013h,00ch,001h,001h,006h,003h,001h,005h,008h,00ch,001h,007h,002h,003h,001h,007h,008h,00ch,001h,005h
00001066  06030105080C010702  C db 006h,003h,001h,005h,008h,00ch,001h,007h,002h,003h,001h,007h,008h,00ch,001h,005h,005h,003h,013h,00ch
0000107A  01015A03030B100A02  C db 001h,001h,05ah,003h,003h,00bh,010h,00ah,002h,00bh,025h,000h,002h,00bh,013h,009h,005h,00bh,02dh,003h
0000108E  030C01020107010503  C db 003h,00ch,001h,002h,001h,007h,001h,005h,003h,003h,001h,007h,001h,006h,008h,00ch,001h,006h,006h,003h
000010A2  0102070C0107040301  C db 001h,002h,007h,00ch,001h,007h,004h,003h,001h,007h,007h,00ch,001h,002h,006h,003h,001h,002h,007h,00ch
000010B6  010704030107070C01  C db 001h,007h,004h,003h,001h,007h,007h,00ch,001h,002h,005h,003h,003h,00ch,001h,002h,001h,007h,001h,005h
000010CA  030301070106080C01  C db 003h,003h,001h,007h,001h,006h,008h,00ch,001h,006h,05ah,003h,003h,00bh,010h,00ah,002h,00bh,025h,000h
000010DE  020B1309050B2D0301  C db 002h,00bh,013h,009h,005h,00bh,02dh,003h,001h,00ch,001h,001h,001h,004h,008h,003h,001h,006h,008h,00ch
000010F2  0603070C0106060301  C db 006h,003h,007h,00ch,001h,006h,006h,003h,001h,006h,007h,00ch,006h,003h,007h,00ch,001h,006h,006h,003h
00001106  0106070C0503010C01  C db 001h,006h,007h,00ch,005h,003h,001h,00ch,001h,001h,001h,004h,008h,003h,001h,006h,008h,00ch,05ah,003h
0000111A  030B100A290B130905  C db 003h,00bh,010h,00ah,029h,00bh,013h,009h,005h,00bh,038h,003h,001h,007h,008h,00ch,005h,003h,001h,007h
0000112E  070C01010603010107  C db 007h,00ch,001h,001h,006h,003h,001h,001h,007h,00ch,001h,007h,004h,003h,001h,007h,007h,00ch,001h,001h
00001142  06030101070C01070F  C db 006h,003h,001h,001h,007h,00ch,001h,007h,00fh,003h,001h,007h,008h,00ch,05ah,003h,003h,00bh,010h,00ah
00001156  290B1309050B390308  C db 029h,00bh,013h,009h,005h,00bh,039h,003h,008h,00ch,005h,003h,001h,001h,007h,00ch,001h,007h,006h,003h
0000116A  0107070C0101040301  C db 001h,007h,007h,00ch,001h,001h,004h,003h,001h,001h,007h,00ch,001h,007h,006h,003h,001h,007h,007h,00ch
0000117E  01011003080C5A0303  C db 001h,001h,010h,003h,008h,00ch,05ah,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,039h,003h
00001192  070C01060503010607  C db 007h,00ch,001h,006h,005h,003h,001h,006h,007h,00ch,001h,005h,006h,003h,001h,005h,007h,00ch,001h,006h
000011A6  04030106070C010506  C db 004h,003h,001h,006h,007h,00ch,001h,005h,006h,003h,001h,005h,007h,00ch,001h,006h,010h,003h,007h,00ch
000011BA  01065A03030B1F0A03  C db 001h,006h,05ah,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,038h,003h,001h,005h,007h,00ch
000011CE  010205030106070C01  C db 001h,002h,005h,003h,001h,006h,007h,00ch,001h,004h,006h,003h,001h,004h,007h,00ch,001h,006h,004h,003h
000011E2  0106070C0104060301  C db 001h,006h,007h,00ch,001h,004h,006h,003h,001h,004h,007h,00ch,001h,006h,00fh,003h,001h,005h,007h,00ch
000011F6  01025A03030B1F0A03  C db 001h,002h,05ah,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,038h,003h,001h,001h,007h,00ch
0000120A  01070503080C080308  C db 001h,007h,005h,003h,008h,00ch,008h,003h,008h,00ch,004h,003h,008h,00ch,008h,003h,008h,00ch,00fh,003h
0000121E  0101070C01075A0303  C db 001h,001h,007h,00ch,001h,007h,05ah,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,038h,003h
00001232  070C01060603080C08  C db 007h,00ch,001h,006h,006h,003h,008h,00ch,008h,003h,008h,00ch,004h,003h,008h,00ch,008h,003h,008h,00ch
00001246  0F03070C01065B0303  C db 00fh,003h,007h,00ch,001h,006h,05bh,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,037h,003h
0000125A  0102070C0107060308  C db 001h,002h,007h,00ch,001h,007h,006h,003h,008h,00ch,008h,003h,008h,00ch,004h,003h,008h,00ch,008h,003h
0000126E  080C0E030102070C01  C db 008h,00ch,00eh,003h,001h,002h,007h,00ch,001h,007h,05bh,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h
00001282  050B36030101070C01  C db 005h,00bh,036h,003h,001h,001h,007h,00ch,001h,002h,007h,003h,008h,00ch,008h,003h,008h,00ch,004h,003h
00001296  080C0803080C0D0301  C db 008h,00ch,008h,003h,008h,00ch,00dh,003h,001h,001h,007h,00ch,001h,002h,05ch,003h,003h,00bh,01fh,00ah
000012AA  030B2A09050B350301  C db 003h,00bh,02ah,009h,005h,00bh,035h,003h,001h,007h,007h,00ch,001h,006h,008h,003h,008h,00ch,008h,003h
000012BE  080C0403080C080308  C db 008h,00ch,004h,003h,008h,00ch,008h,003h,008h,00ch,00ch,003h,001h,007h,007h,00ch,001h,006h,05dh,003h
000012D2  030B1F0A030B2A0905  C db 003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,034h,003h,001h,007h,008h,00ch,001h,005h,008h,003h
000012E6  080C0803080C040308  C db 008h,00ch,008h,003h,008h,00ch,004h,003h,008h,00ch,008h,003h,008h,00ch,00bh,003h,001h,007h,008h,00ch
000012FA  01055D03030B1F0A03  C db 001h,005h,05dh,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,033h,003h,001h,007h,008h,00ch
0000130E  010509030106070C01  C db 001h,005h,009h,003h,001h,006h,007h,00ch,001h,004h,006h,003h,001h,004h,007h,00ch,001h,006h,004h,003h
00001322  0106070C0104060301  C db 001h,006h,007h,00ch,001h,004h,006h,003h,001h,004h,007h,00ch,001h,006h,00ah,003h,001h,007h,008h,00ch
00001336  01055E03030B1F0A03  C db 001h,005h,05eh,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,032h,003h,001h,001h,008h,00ch
0000134A  01050A030106070C01  C db 001h,005h,00ah,003h,001h,006h,007h,00ch,001h,005h,006h,003h,001h,005h,007h,00ch,001h,006h,004h,003h
0000135E  0106070C0105060301  C db 001h,006h,007h,00ch,001h,005h,006h,003h,001h,005h,007h,00ch,001h,006h,009h,003h,001h,001h,008h,00ch
00001372  01055F03030B1F0A03  C db 001h,005h,05fh,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,031h,003h,001h,002h,007h,00ch
00001386  010601040B03010107  C db 001h,006h,001h,004h,00bh,003h,001h,001h,007h,00ch,001h,007h,006h,003h,001h,007h,007h,00ch,001h,001h
0000139A  04030101070C010706  C db 004h,003h,001h,001h,007h,00ch,001h,007h,006h,003h,001h,007h,007h,00ch,001h,001h,008h,003h,001h,002h
000013AE  070C01060104600303  C db 007h,00ch,001h,006h,001h,004h,060h,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,030h,003h
000013C2  0106070C01020D0301  C db 001h,006h,007h,00ch,001h,002h,00dh,003h,001h,007h,007h,00ch,001h,001h,006h,003h,001h,001h,007h,00ch
000013D6  010704030107070C01  C db 001h,007h,004h,003h,001h,007h,007h,00ch,001h,001h,006h,003h,001h,001h,007h,00ch,001h,007h,007h,003h
000013EA  0106070C0102620303  C db 001h,006h,007h,00ch,001h,002h,062h,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,02eh,003h
000013FE  0105080C01010F0307  C db 001h,005h,008h,00ch,001h,001h,00fh,003h,007h,00ch,001h,006h,006h,003h,001h,006h,007h,00ch,006h,003h
00001412  070C01060603010607  C db 007h,00ch,001h,006h,006h,003h,001h,006h,007h,00ch,006h,003h,001h,005h,008h,00ch,001h,001h,063h,003h
00001426  030B1F0A030B2A0905  C db 003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,02dh,003h,001h,007h,008h,00ch,001h,007h,010h,003h
0000143A  0106070C0101040301  C db 001h,006h,007h,00ch,001h,001h,004h,003h,001h,001h,007h,00ch,001h,002h,006h,003h,001h,006h,007h,00ch
0000144E  010104030101070C01  C db 001h,001h,004h,003h,001h,001h,007h,00ch,001h,002h,005h,003h,001h,007h,008h,00ch,001h,007h,064h,003h
00001462  030B1F0A030B2A0905  C db 003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,02ch,003h,001h,002h,015h,00ch,005h,003h,001h,005h
00001476  080C01010203010108  C db 008h,00ch,001h,001h,002h,003h,001h,001h,008h,00ch,001h,005h,006h,003h,001h,005h,008h,00ch,001h,001h
0000148A  02030101080C010504  C db 002h,003h,001h,001h,008h,00ch,001h,005h,004h,003h,001h,002h,015h,00ch,059h,003h,003h,00bh,01fh,00ah
0000149E  030B2A09050B2C0316  C db 003h,00bh,02ah,009h,005h,00bh,02ch,003h,016h,00ch,006h,003h,001h,006h,012h,00ch,001h,006h,008h,003h
000014B2  0106120C0106050316  C db 001h,006h,012h,00ch,001h,006h,005h,003h,016h,00ch,059h,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h
000014C6  050B2C03160C070312  C db 005h,00bh,02ch,003h,016h,00ch,007h,003h,012h,00ch,001h,004h,009h,003h,012h,00ch,001h,004h,005h,003h
000014DA  160C5903030B1F0A03  C db 016h,00ch,059h,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,02ch,003h,016h,00ch,007h,003h
000014EE  010501060E0C010601  C db 001h,005h,001h,006h,00eh,00ch,001h,006h,001h,005h,00ah,003h,001h,005h,001h,006h,00eh,00ch,001h,006h
00001502  01050603160C590303  C db 001h,005h,006h,003h,016h,00ch,059h,003h,003h,00bh,01fh,00ah,003h,00bh,02ah,009h,005h,00bh,02ch,003h
00001516  160C090301010C0C01  C db 016h,00ch,009h,003h,001h,001h,00ch,00ch,001h,001h,00eh,003h,001h,001h,00ch,00ch,001h,001h,008h,003h
0000152A  160C5903250B2A0905  C db 016h,00ch,059h,003h,025h,00bh,02ah,009h,005h,00bh,02ch,003h,016h,00ch,00bh,003h,001h,007h,001h,002h
0000153E  0106040C0106010201  C db 001h,006h,004h,00ch,001h,006h,001h,002h,001h,001h,012h,003h,001h,007h,001h,002h,001h,006h,004h,00ch
00001552  0106010201010A0316  C db 001h,006h,001h,002h,001h,001h,00ah,003h,016h,00ch,059h,003h,025h,00bh,02ah,009h,005h,00bh,0ech,003h
00001566  250B2A09050BF30301  C db 025h,00bh,02ah,009h,005h,00bh,0f3h,003h,001h,00bh,009h,008h,005h,00bh,039h,009h,005h,00bh,0f3h,003h
0000157A  010B0908050B390905  C db 001h,00bh,009h,008h,005h,00bh,039h,009h,005h,00bh,0f3h,003h,001h,00bh,009h,008h,005h,00bh,039h,009h
0000158E  050BF303010B090805  C db 005h,00bh,0f3h,003h,001h,00bh,009h,008h,005h,00bh,039h,009h,005h,00bh,0f3h,003h,001h,00bh,009h,008h
000015A2  050B3909050BF30301  C db 005h,00bh,039h,009h,005h,00bh,0f3h,003h,001h,00bh,009h,008h,005h,00bh,039h,009h,005h,00bh,0f3h,003h
000015B6  010B0908050B390905  C db 001h,00bh,009h,008h,005h,00bh,039h,009h,005h,00bh,0f3h,003h,001h,00bh,009h,008h,005h,00bh,039h,009h
000015CA  050BF303010B090805  C db 005h,00bh,0f3h,003h,001h,00bh,009h,008h,005h,00bh,039h,009h,005h,00bh,0f3h,003h,001h,00bh,009h,008h
000015DE  050B3909050BF30301  C db 005h,00bh,039h,009h,005h,00bh,0f3h,003h,001h,00bh,009h,008h,005h,00bh,039h,009h,005h,00bh,0f3h,003h
000015F2  0F0B3909050BFD0305  C db 00fh,00bh,039h,009h,005h,00bh,0fdh,003h,005h,00bh,039h,009h,005h,00bh,045h,003h,002h,00bh,026h,003h
00001606  020B8E03050B070902  C db 002h,00bh,08eh,003h,005h,00bh,007h,009h,002h,000h,002h,009h,003h,000h,007h,009h,002h,000h,002h,009h
0000161A  030006090300030902  C db 003h,000h,006h,009h,003h,000h,003h,009h,002h,000h,003h,009h,002h,000h,002h,009h,003h,000h,005h,009h
0000162E  050B2303060B160302  C db 005h,00bh,023h,003h,006h,00bh,016h,003h,002h,00bh,004h,003h,002h,00bh,026h,003h,002h,00bh,017h,003h
00001642  040B7303050B060901  C db 004h,00bh,073h,003h,005h,00bh,006h,009h,001h,000h,002h,009h,001h,000h,004h,009h,001h,000h,005h,009h
00001656  010002090100040901  C db 001h,000h,002h,009h,001h,000h,004h,009h,001h,000h,008h,009h,001h,000h,001h,009h,001h,000h,002h,009h
0000166A  010001090100020901  C db 001h,000h,001h,009h,001h,000h,002h,009h,001h,000h,004h,009h,001h,000h,004h,009h,005h,00bh,023h,003h
0000167E  020B0303020B150302  C db 002h,00bh,003h,003h,002h,00bh,015h,003h,002h,00bh,004h,003h,002h,00bh,026h,003h,002h,00bh,018h,003h
00001692  020B7403050B060901  C db 002h,00bh,074h,003h,005h,00bh,006h,009h,001h,000h,002h,009h,001h,000h,004h,009h,001h,000h,002h,009h
000016A6  010002090100020901  C db 001h,000h,002h,009h,001h,000h,002h,009h,001h,000h,004h,009h,001h,000h,002h,009h,001h,000h,005h,009h
000016BA  010001090100020901  C db 001h,000h,001h,009h,001h,000h,002h,009h,001h,000h,001h,009h,001h,000h,002h,009h,001h,000h,004h,009h
000016CE  01000409050B230302  C db 001h,000h,004h,009h,005h,00bh,023h,003h,002h,00bh,003h,003h,002h,00bh,004h,003h,005h,00bh,004h,003h
000016E2  050B0203050B020302  C db 005h,00bh,002h,003h,005h,00bh,002h,003h,002h,00bh,003h,003h,005h,00bh,003h,003h,002h,00bh,002h,003h
000016F6  020B0203020B030305  C db 002h,00bh,002h,003h,002h,00bh,003h,003h,005h,00bh,003h,003h,002h,00bh,001h,003h,002h,00bh,001h,003h
0000170A  020B0203020B030305  C db 002h,00bh,002h,003h,002h,00bh,003h,003h,005h,00bh,00ch,003h,002h,00bh,003h,003h,002h,00bh,001h,003h
0000171E  030B0403050B620305  C db 003h,00bh,004h,003h,005h,00bh,062h,003h,005h,00bh,006h,009h,001h,000h,002h,009h,001h,000h,002h,009h
00001732  020003090100020901  C db 002h,000h,003h,009h,001h,000h,002h,009h,001h,000h,002h,009h,001h,000h,002h,009h,002h,000h,003h,009h
00001746  010003090200020901  C db 001h,000h,003h,009h,002h,000h,002h,009h,001h,000h,002h,009h,001h,000h,001h,009h,001h,000h,002h,009h
0000175A  010002090200050905  C db 001h,000h,002h,009h,002h,000h,005h,009h,005h,00bh,023h,003h,002h,00bh,003h,003h,002h,00bh,003h,003h
0000176E  020B0303020B070302  C db 002h,00bh,003h,003h,002h,00bh,007h,003h,002h,00bh,002h,003h,002h,00bh,004h,003h,002h,00bh,002h,003h
00001782  020B0303020B020302  C db 002h,00bh,003h,003h,002h,00bh,002h,003h,002h,00bh,002h,003h,002h,00bh,002h,003h,002h,00bh,002h,003h
00001796  020B0303020B020305  C db 002h,00bh,003h,003h,002h,00bh,002h,003h,005h,00bh,001h,003h,002h,00bh,001h,003h,002h,00bh,003h,003h
000017AA  020B1003020B030303  C db 002h,00bh,010h,003h,002h,00bh,003h,003h,003h,00bh,002h,003h,002h,00bh,002h,003h,002h,00bh,003h,003h
000017BE  020B6103050B060901  C db 002h,00bh,061h,003h,005h,00bh,006h,009h,001h,000h,002h,009h,001h,000h,001h,009h,001h,000h,008h,009h
000017D2  010002090100010901  C db 001h,000h,002h,009h,001h,000h,001h,009h,001h,000h,008h,009h,001h,000h,004h,009h,001h,000h,002h,009h
000017E6  010001090100020901  C db 001h,000h,001h,009h,001h,000h,002h,009h,001h,000h,001h,009h,001h,000h,007h,009h,005h,00bh,023h,003h
000017FA  070B0303020B030302  C db 007h,00bh,003h,003h,002h,00bh,003h,003h,002h,00bh,003h,003h,006h,00bh,002h,003h,002h,00bh,004h,003h
0000180E  020B0203020B030302  C db 002h,00bh,002h,003h,002h,00bh,003h,003h,002h,00bh,002h,003h,002h,00bh,002h,003h,002h,00bh,002h,003h
00001822  020B0203020B030302  C db 002h,00bh,002h,003h,002h,00bh,003h,003h,002h,00bh,002h,003h,002h,00bh,004h,003h,004h,00bh,004h,003h
00001836  030B0F03020B030302  C db 003h,00bh,00fh,003h,002h,00bh,003h,003h,002h,00bh,003h,003h,002h,00bh,002h,003h,002h,00bh,066h,003h
0000184A  050B07090200020904  C db 005h,00bh,007h,009h,002h,000h,002h,009h,004h,000h,006h,009h,002h,000h,002h,009h,004h,000h,005h,009h
0000185E  040002090200030902  C db 004h,000h,002h,009h,002h,000h,003h,009h,002h,000h,002h,009h,004h,000h,004h,009h,005h,00bh,023h,003h
00001872  020B0403020B020307  C db 002h,00bh,004h,003h,002h,00bh,002h,003h,007h,00bh,002h,003h,002h,00bh,003h,003h,002h,00bh,002h,003h
00001886  020B0403020B020307  C db 002h,00bh,004h,003h,002h,00bh,002h,003h,007h,00bh,002h,003h,002h,00bh,001h,003h,001h,00bh,002h,003h
0000189A  010B0103020B020302  C db 001h,00bh,001h,003h,002h,00bh,002h,003h,002h,00bh,003h,003h,002h,00bh,002h,003h,002h,00bh,004h,003h
000018AE  040B0503040B0D0302  C db 004h,00bh,005h,003h,004h,00bh,00dh,003h,002h,00bh,003h,003h,002h,00bh,003h,003h,002h,00bh,002h,003h
000018C2  020B6603050B390905  C db 002h,00bh,066h,003h,005h,00bh,039h,009h,005h,00bh,023h,003h,002h,00bh,004h,003h,002h,00bh,002h,003h
000018D6  020B0703020B030302  C db 002h,00bh,007h,003h,002h,00bh,003h,003h,002h,00bh,002h,003h,002h,00bh,004h,003h,002h,00bh,002h,003h
000018EA  020B0803030B020303  C db 002h,00bh,008h,003h,003h,00bh,002h,003h,003h,00bh,003h,003h,002h,00bh,003h,003h,002h,00bh,002h,003h
000018FE  020B0403020B010302  C db 002h,00bh,004h,003h,002h,00bh,001h,003h,002h,00bh,006h,003h,003h,00bh,00ch,003h,002h,00bh,003h,003h
00001912  020B0303020B020302  C db 002h,00bh,003h,003h,002h,00bh,002h,003h,002h,00bh,066h,003h,005h,00bh,039h,009h,005h,00bh,023h,003h
00001926  020B0403020B020302  C db 002h,00bh,004h,003h,002h,00bh,002h,003h,002h,00bh,003h,003h,002h,00bh,002h,003h,002h,00bh,003h,003h
0000193A  020B0203020B040302  C db 002h,00bh,002h,003h,002h,00bh,004h,003h,002h,00bh,002h,003h,002h,00bh,003h,003h,002h,00bh,003h,003h
0000194E  020B0403020B040301  C db 002h,00bh,004h,003h,002h,00bh,004h,003h,001h,00bh,003h,003h,002h,00bh,002h,003h,002h,00bh,004h,003h
00001962  020B0203020B060302  C db 002h,00bh,002h,003h,002h,00bh,006h,003h,002h,00bh,002h,003h,003h,00bh,007h,003h,002h,00bh,003h,003h
00001976  020B0303020B020302  C db 002h,00bh,003h,003h,002h,00bh,002h,003h,002h,00bh,003h,003h,002h,00bh,061h,003h,043h,00bh,023h,003h
0000198A  070B0403050B040306  C db 007h,00bh,004h,003h,005h,00bh,004h,003h,006h,00bh,003h,003h,003h,00bh,002h,003h,002h,00bh,003h,003h
0000199E  050B0403020B040302  C db 005h,00bh,004h,003h,002h,00bh,004h,003h,002h,00bh,004h,003h,005h,00bh,003h,003h,002h,00bh,004h,003h
000019B2  020B0303020B010305  C db 002h,00bh,003h,003h,002h,00bh,001h,003h,005h,00bh,003h,003h,002h,00bh,007h,003h,004h,00bh,002h,003h
000019C6  020B0303020B030305  C db 002h,00bh,003h,003h,002h,00bh,003h,003h,005h,00bh,062h,003h,043h,00bh,07dh,003h,002h,00bh,07eh,003h
000019DA  430B7C03020B7F0343  C db 043h,00bh,07ch,003h,002h,00bh,07fh,003h,043h,00bh,07ch,003h,002h,00bh,07fh,003h,043h,00bh,0ffh,003h
000019EE  FF03FF03FF03FF03FF  C db 0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h
00001A02  FF03FF03FF03FF03FF  C db 0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h
00001A16  FF03FF03FF03FF03E2  C db 0ffh,003h,0ffh,003h,0ffh,003h,0ffh,003h,0e2h,003h,0ffh,00ch,041h,00ch,0ffh,000h,0ffh,000h,0ffh,000h
00001A2A  FF00FF00FF00FF00FF  C db 0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h
00001A3E  FF00FF00FF00FF00FF  C db 0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h
00001A52  FF00FF00FF00FF00FF  C db 0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h
00001A66  FF00FF00FF00FF00FF  C db 0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h
00001A7A  FF00FF00FF00FF00FF  C db 0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h
00001A8E  FF00FF00FF00FF00FF  C db 0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h
00001AA2  FF00FF00FF00FF00FF  C db 0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h,0ffh,000h
00001AB6  FF00FF00FF008C00    C db 0ffh,000h,0ffh,000h,0ffh,000h,08ch,000h
00001ABE                      C bootscreen_end:
                              C 
                              C 
                              C ; These functions are required during bootup
                              C ;
00001ABE  0000                C _EXODUS_requestor                       dw  0
00001AC0  0000                C _VID_clear_screen_vga                   dw  0
00001AC2  B000                C _VID_display_decimal_in_edx_nr_vga      dw  _sEXODUS_REQUESTOR
00001AC4  00F0                C _VID_display_string_ecx_nr_vga          dw  0f000h
00001AC6  00F0                C _VID_display_string_ecx_vga             dw  0f000h
00001AC8  00F0                C _VID_display_string_nr_vga              dw  0f000h
00001ACA  00F0                C _VID_display_string_vga                 dw  0f000h
00001ACC  00F0                C _VID_freeze_frame_vga                   dw  0f000h
00001ACE  00F0                C _VID_position_cursor_vga                dw  0f000h
00001AD0  00F0                C _VID_mono_enter_graphics_mode           dw  0f000h
00001AD2  00F0                C _VID_g_mono_display_text                dw  0f000h
00001AD4  00F0                C _VID_g_mono_display_text_mode           dw  0f000h
00001AD6  00F0                C _VID_g_mono_clear_screen                dw  0f000h
00001AD8  00F0                C _VID_g_set_font_8x8                     dw  0f000h
00001ADA  00F0                C _VID_g_set_font_8x14                    dw  0f000h
00001ADC  00F0                C _VID_g_set_font_16x16                   dw  0f000h
00001ADE  00F0                C _VID_draw_logo                          dw  0f000h
00001AE0  00F0                C _VID_requestor                          dw  0f000h
00001AE2  00F0                C _VID_g_display_radix_in_edx_mono        dw  0f000h
00001AE4  00F0                C _VID_freeze_frame_mono                  dw  0f000h
00001AE6  00F0                C _VID_move_to_next_line_vga              dw  0f000h
00001AE8  00F0                C _VID_set_attribute_vga                  dw  0f000h
00001AEA  00F0                C _EXODUS_dot_com                         dw  0f000h
00001AEC  00F0                C _VID_draw_exodus_boot_screen            dw  0f000h
00001AEE  00F0                C                                         dw  0f000h
00001AF0  00F0                C                                         dw  0f000h
                              C 
                              C 
                              C 
00001AF2  145649445F636C6561  C required_native_primatives              db  20, "VID_clear_screen_vga"
00001B07  215649445F64697370  C                                         db  33, "VID_display_decimal_in_edx_nr_vga"
00001B29  1D5649445F64697370  C                                         db  29, "VID_display_string_ecx_nr_vga"
00001B47  1A5649445F64697370  C                                         db  26, "VID_display_string_ecx_vga"
00001B62  195649445F64697370  C                                         db  25, "VID_display_string_nr_vga"
00001B7C  165649445F64697370  C                                         db  22, "VID_display_string_vga"
00001B93  145649445F66726565  C                                         db  20, "VID_freeze_frame_vga"
00001BA8  175649445F706F7369  C                                         db  23, "VID_position_cursor_vga"
00001BC0  1C5649445F6D6F6E6F  C                                         db  28, "VID_mono_enter_graphics_mode"
00001BDD  175649445F675F6D6F  C                                         db  23, "VID_g_mono_display_text"
00001BF5  1C5649445F675F6D6F  C                                         db  28, "VID_g_mono_display_text_mode"
00001C12  175649445F675F6D6F  C                                         db  23, "VID_g_mono_clear_screen"
00001C2A  125649445F675F7365  C                                         db  18, "VID_g_set_font_8x8"
00001C3D  135649445F675F7365  C                                         db  19, "VID_g_set_font_8x14"
00001C51  145649445F675F7365  C                                         db  20, "VID_g_set_font_16x16"
00001C66  0D5649445F64726177  C                                         db  13, "VID_draw_logo"
00001C74  0D5649445F72657175  C                                         db  13, "VID_requestor"
00001C82  1F5649445F675F6469  C                                         db  31, "VID_g_display_radix_in_edx_mono"
00001CA2  155649445F66726565  C                                         db  21, "VID_freeze_frame_mono"
00001CB8  195649445F6D6F7665  C                                         db  25, "VID_move_to_next_line_vga"
00001CD2  155649445F7365745F  C                                         db  21, "VID_set_attribute_vga"
00001CE8  0E45584F4455535F64  C                                         db  14, "EXODUS_dot_com"
00001CF7  1B5649445F64726177  C                                         db  27, "VID_draw_exodus_boot_screen"
00001D13  FF                  C                                         db  0ffh
                              C 
                              C 
                              C 
                              C ;_KBD_get_a_key                          dw  0f000h     ;    db  13, "KBD_get_a_key"
                              C ;_VID_display_decimal_in_edx_vga         dw  0f000h     ;    db  30, "VID_display_decimal_in_edx_vga"
                              C ;_VID_display_hex_string_ecx_nr_vga      dw  0f000h     ;    db  33, "VID_display_hex_string_ecx_nr_vga"
                              C ;_VID_display_hex_string_ecx_ro_vga      dw  0f000h     ;    db  33, "VID_display_hex_string_ecx_ro_vga"
                              C ;_VID_display_hex_string_ecx_vga         dw  0f000h     ;    db  30, "VID_display_hex_string_ecx_vga"
                              C ;_VID_display_hexidecimal_in_edx_nr_vga  dw  0f000h     ;    db  37, "VID_display_hexidecimal_in_edx_nr_vga"
                              C ;_VID_display_hexidecimal_in_edx_vga     dw  0f000h     ;    db  34, "VID_display_hexidecimal_in_edx_vga"
                              C ;_VID_display_radix_in_edx_nr_vga        dw  0f000h     ;    db  31, "VID_display_radix_in_edx_nr_vga"
                              C ;_VID_display_radix_in_edx_vga           dw  0f000h     ;    db  28, "VID_display_radix_in_edx_vga"
                              C ;_VID_get_cursor_vga                     dw  0f000h     ;    db  18, "VID_get_cursor_vga"
                              C ;_VID_move_to_next_line_vga              dw  0f000h     ;    db  25, "VID_move_to_next_line_vga"
                              C ;_VID_set_attribute_vga                  dw  0f000h     ;    db  21, "VID_set_attribute_vga"
                              C ;_VID_set_registers_for_vga              dw  0f000h     ;    db  25, "VID_set_registers_for_vga"
                              C ;_VID_clear_screen_mono                  dw  0f000h     ;    db  21, "VID_clear_screen_mono"
                              C ;_VID_display_decimal_in_edx_mono        dw  0f000h     ;    db  31, "VID_display_decimal_in_edx_mono"
                              C ;_VID_display_decimal_in_edx_nr_mono     dw  0f000h     ;    db  34, "VID_display_decimal_in_edx_nr_mono"
                              C ;_VID_display_hex_string_ecx_mono        dw  0f000h     ;    db  31, "VID_display_hex_string_ecx_mono"
                              C ;_VID_display_hex_string_ecx_nr_mono     dw  0f000h     ;    db  34, "VID_display_hex_string_ecx_nr_mono"
                              C ;_VID_display_hex_string_ecx_ro_mono     dw  0f000h     ;    db  34, "VID_display_hex_string_ecx_ro_mono"
                              C ;_VID_display_hexidecimal_in_edx_mono    dw  0f000h     ;    db  35, "VID_display_hexidecimal_in_edx_mono"
                              C ;_VID_display_hexidecimal_in_edx_nr_mono dw  0f000h     ;    db  38, "VID_display_hexidecimal_in_edx_nr_mono"
                              C ;_VID_display_radix_in_edx_mono          dw  0f000h     ;    db  29, "VID_display_radix_in_edx_mono"
                              C ;_VID_display_radix_in_edx_nr_mono       dw  0f000h     ;    db  32, "VID_display_radix_in_edx_nr_mono"
                              C ;_VID_display_string_ecx_mono            dw  0f000h     ;    db  27, "VID_display_string_ecx_mono"
                              C ;_VID_display_string_ecx_nr_mono         dw  0f000h     ;    db  30, "VID_display_string_ecx_nr_mono"
                              C ;_VID_display_string_mono                dw  0f000h     ;    db  23, "VID_display_string_mono"
                              C ;_VID_display_string_nr_mono             dw  0f000h     ;    db  26, "VID_display_string_nr_mono"
                              C ;_VID_get_cursor_mono                    dw  0f000h     ;    db  19, "VID_get_cursor_mono"
                              C ;_VID_move_to_next_line_mono             dw  0f000h     ;    db  26, "VID_move_to_next_line_mono"
                              C ;_VID_position_cursor_mono               dw  0f000h     ;    db  24, "VID_position_cursor_mono"
                              C ;_VID_set_attribute_mono                 dw  0f000h     ;    db  22, "VID_set_attribute_mono"
                              C ;_VID_set_registers_for_mono             dw  0f000h     ;    db  26, "VID_set_registers_for_mono"
                              C ;_VID_clear_screen_both                  dw  0f000h     ;    db  21, "VID_clear_screen_both"
                              C ;_VID_display_decimal_in_edx_both        dw  0f000h     ;    db  31, "VID_display_decimal_in_edx_both"
                              C ;_VID_display_decimal_in_edx_nr_both     dw  0f000h     ;    db  34, "VID_display_decimal_in_edx_nr_both"
                              C ;_VID_display_hex_string_ecx_both        dw  0f000h     ;    db  31, "VID_display_hex_string_ecx_both"
                              C ;_VID_display_hex_string_ecx_nr_both     dw  0f000h     ;    db  34, "VID_display_hex_string_ecx_nr_both"
                              C ;_VID_display_hex_string_ecx_ro_both     dw  0f000h     ;    db  34, "VID_display_hex_string_ecx_ro_both"
                              C ;_VID_display_hexidecimal_in_edx_both    dw  0f000h     ;    db  35, "VID_display_hexidecimal_in_edx_both"
                              C ;_VID_display_hexidecimal_in_edx_nr_both dw  0f000h     ;    db  38, "VID_display_hexidecimal_in_edx_nr_both"
                              C ;_VID_display_string_both                dw  0f000h     ;    db  23, "VID_display_string_both"
                              C ;_VID_display_radix_in_edx_nr_both       dw  0f000h     ;    db  32, "VID_display_radix_in_edx_nr_both"
                              C ;_VID_display_string_ecx_both            dw  0f000h     ;    db  27, "VID_display_string_ecx_both"
                              C ;_VID_display_string_ecx_nr_both         dw  0f000h     ;    db  30, "VID_display_string_ecx_nr_both"
                              C ;_VID_display_string_nr_both             dw  0f000h     ;    db  26, "VID_display_string_nr_both"
                              C ;_VID_freeze_frame_both                  dw  0f000h     ;    db  21, "VID_freeze_frame_both"
                              C ;_VID_move_to_next_line_both             dw  0f000h     ;    db  26, "VID_move_to_next_line_both"
                              C ;_VID_position_cursor_both               dw  0f000h     ;    db  24, "VID_position_cursor_both"
                              C ;_VID_set_attribute_both                 dw  0f000h     ;    db  22, "VID_set_attribute_both"
                              C ;_VID_mono_enter_text_mode               dw  0f000h     ;    db  24, "VID_mono_enter_text_mode"
                              C 
                              C 
                              C 
                              C ;
                              C ; Displays a message when an Exodus bootup device doesn't properly identify itself
                              C ; But, this is only displayed before VGA and KBD support is available.
                              C ; After that the invSetup_native_primates() function takes control and allows selective non-install, etc.
                              C ;
00001D14  4641494C45440D0A    C failed                                  db  "FAILED",13,10
00001D1C  0D0A                C                                         db  13,10
00001D1E  0720416E2045786F64  C                                         db  " An Exodus Driver failed to initialize properly",13,10
00001D50  072054686973207761  C                                         db  " This was before VGA and keyboard support was available (to allow user action)",13,10
00001DA1  0720466F7220746869  C                                         db  " For this reason Exodus cannot continue to boot",13,10
00001DD3  0D0A                C                                         db  13,10
00001DD5  0D0A                C                                         db  13,10
00001DD7  0D0A                C                                         db  13,10
00001DD9  0D0A                C                                         db  13,10
00001DDB  0D0A                C                                         db  13,10
00001DDD  0D0A                C                                         db  13,10
00001DDF  2D2D2D2D2D0D0A      C                                         db  "-----",13,10
00001DE6  0720506C6561736520  C                                         db  " Please attempt to correct this problem and try again",13,10
00001E1E  0D0A                C                                         db  13,10
00001E20  072049662074686520  C                                         db  " If the problem persists, you can reach us online (use a friend's computer)",13,10
00001E6E  2020C320687474703A  C                                         db  "   http://www.beatleworks.com/boot_trouble",13,10
00001E9B  2020C020626F6F745F  C                                         db  "   boot_trouble@beatleworks.com",13,10
00001EBD                      C failed_end:
                                    INCLUDE native.asp                                              ; Native primatives
                              C ; native.asp
                              C ;
                              C ; Exodus Native Primatives declaration
                              C ; December 24, 2000
                              C ;
                              C ; * Refer to inf\native.inf for more information
                              C ; * Note, the mechanical operations of this process are governed by inf\primload.inf
                              C ; * Native Primatives run in the call gate range of 200 - 2999
                              C ;
                              C ;  Functions:
                              C ;     invSetup_native_primatives               ; sets up the native primates specified as boot drivers
                              C ;     default_primative_response               ; provides a system for undefined primatives
                              C ;     invCopy_this_part                        ; copies a portion of data (called multiple times)
                              C ;     invMove_temp_gdts_to_permanent           ; copies the temporary primative GDT entries to their permanent locations
                              C ;     invAdd_primative                         ; adds a primative to between _MIN_PRIMATIVE and _MAX_PRIMATIVE call gates
                              C ;     invUpdate_required_primatives            ; updates an driver/program with the required call gates to run
                              C ;
                              C ;
                              C 
                              C 
                              C 
                              C 
                              C 
00001EBD                      C invSetup_native_primatives      PROC    NEAR
                              C ; This routine is responsible for setting up all Exodus native primatives
                              C ;
                              C ; Upon entry:   It is known that the GDT slots setup in the init16 algorithms are used
                              C ;
                              C ; Upon exit:    The native primative call gates are defined in the GDT and IDT
                              C ;
00001EBD  0FA8                C     push    gs
00001EBF  0FA0                C     push    fs
00001EC1  06                  C     push    es
00001EC2  1E                  C     push    ds
                              C   ; * Note:  Can't use EBP here because it is returned as a parameter from the primatives
                              C   ; * Note:  These references all use ESP.  No PUSH/POP's are to be used unless they are self-terminating
                              C   ;          and in-between references of ss:[esp+xx].
00001EC3  83EC44              C     sub     esp,68
                              C   ; [esp+64] - <Used for debugging>
                              C   ; [esp+60] - temporary
                              C   ; [esp+56] - temporary
                              C   ; [esp+52] - temporary
                              C   ; [esp+48] - temporary
                              C   ; [esp+44] - holds primative selector
                              C   ; [esp+40] - ptr to NP in linear memory
                              C   ; [esp+36] - ptr to DT in linear memory
                              C   ; [esp+32] - holds current value of esi (boot_parameter_block)
                              C   ; [esp+28] - temporary "Length of definition block" ptr into _sPRIMATIVE_LOAD_INFO
                              C   ; [esp+24] - requestor(-1) ebp - ptr to author text (null-terminated)
                              C   ; [esp+20] - requestor(-1) ebx - ptr to version text (null-terminated)
                              C   ; [esp+16] - requestor(-1) edi - ptr to driver self-identified name (null-terminated)
                              C   ; [esp+12] - requestor(-1) esi - ptr to native primative structure for this driver
                              C   ; [esp+08] - --Nuserved
                              C   ; [esp+04] - requestor(-1) ecx - actual number of bytes to keep after each driver is initialized
                              C   ; [esp+00] - driver name from NP (linear offset in memory)
                              C   ;
                              C 
00001EC6  FC                  C     cld
                              C   ;; Setup the parameters for the default primative response
00001EC7  33C0                C     xor     eax,eax
00001EC9  BBF4230000          C     mov     ebx,offset default_primative_response                   ; Offset to function
00001ECE  33C9                C     xor     ecx,ecx                                                 ; Number of dword to copy if privledge level change
00001ED0  66BA2000            C     mov     dx,_sCODE                                               ; Code segment selector
00001ED4  B8C8000000          C     mov     eax,_MIN_PRIMATIVE
00001ED9                      C     .WHILE (eax <= _MAX_PRIMATIVE)
00001EDB  E86EE1FFFF          C         call    invCreate_call_gate_descriptor32
00001EE0  40                  C         inc     eax
00001EE1                      C     .ENDW
                              C 
                              C   ;; Initialize our primative memory areas
00001EE8  B898000000          C     mov     eax,_sPRIMATIVES
00001EED  8EC0                C     mov     es,eax
00001EEF  33FF                C     xor     edi,edi
00001EF1  B900400000          C     mov     ecx,_sPRIMATIVES_limit
00001EF6  B0FF                C     mov     al,0ffh
00001EF8  F3AA                C     rep     stosb
00001EFA  6726C7060000080000  C     mov     dword ptr es:[0],8
00001F04  6726C7060400C80000  C     mov     dword ptr es:[4],_MIN_PRIMATIVE
                              C 
00001F0E  B8A0000000          C     mov     eax,_sPRIMATIVE_LOAD_INFO
00001F13  8EC0                C     mov     es,eax
00001F15  33FF                C     xor     edi,edi
00001F17  B900100000          C     mov     ecx,_sPRIMATIVE_LOAD_INFO_limit
00001F1C  32C0                C     xor     al,al
00001F1E  F3AA                C     rep     stosb
00001F20  6726C7060000040000  C     mov     dword ptr es:[0],4
                              C 
                              C   ;; Now, process all of the drivers that were loaded at bootup
00001F2A  B840000000          C     mov     eax,_sALL_MEM
00001F2F  8ED8                C     mov     ds,eax
00001F31  672E8B367B0A        C     mov     esi,cs:boot_parameter_block
00001F37  46                  C     inc     esi                                                     ; Move passed the boot drive letter
00001F38  672E8B1E850A        C     mov     ebx,cs:boot_dt_linear
00001F3E  672E8B0E890A        C     mov     ecx,cs:boot_np_linear
00001F44  895C2424            C     mov     dword ptr ss:[esp+36],ebx
00001F48  894C2428            C     mov     dword ptr ss:[esp+40],ecx
00001F4C  C744244000000000    C     mov     dword ptr ss:[esp+64],0                                 ; Used for debugging
00001F54                      C     .WHILE (byte ptr ds:[esi+_BOOT_PB_entry_type] != 0ffh)
                              C       ; Let's see what this bad boy is
00001F59  8A4614              C         mov     al,byte ptr ds:[esi+_BOOT_PB_entry_type]
00001F5C  240F                C         and     al,1111b
00001F5E                      C         .IF (al == 011b)
                              C           ; It's a driver
                              C           ; Store driver name (linear offset to it)
00001F66  89742420            C             mov     dword ptr ss:[esp+32],esi
00001F6A  8B5C2424            C             mov     ebx,dword ptr ss:[esp+36]
00001F6E  8B542428            C             mov     edx,dword ptr ss:[esp+40]
                              C 
00001F72  33C0                C             xor     eax,eax
00001F74  668B461A            C             mov     ax,word ptr ds:[esi+_BOOT_PB_dt_offset]
00001F78  03D8                C             add     ebx,eax
00001F7A                      C             .IF (word ptr ds:[ebx+_BOOT_DT_np_offset] != 0ffffh)
                              C               ; Name was specified
00001F81  672E8B16890A        C                 mov     edx,cs:boot_np_linear
00001F87  33C0                C                 xor     eax,eax
00001F89  668B460B            C                 mov     ax,word ptr ds:[esi+_BOOT_DT_np_offset]
00001F8D  03D0                C                 add     edx,eax
00001F8F                      C             .ELSE
00001F91  BAFFFFFFFF          C                 mov     edx,0ffffffffh
00001F96                      C             .ENDIF
00001F96  891424              C             mov     dword ptr ss:[esp+00],edx
                              C 
                              C           ;; Build the temporary GDT entries for our initialization
                              C 
                              C           ; Build the temporary code segment
00001F99  B8B60B0000          C             mov     eax,_csTEMP_PRIMATIVE / 8
00001F9E  8B5E16              C             mov     ebx,dword ptr ds:[esi+_BOOT_PB_linear_offset]
00001FA1  8B16                C             mov     edx,dword ptr ds:[esi+_BOOT_PB_size]
00001FA3  E843E1FFFF          C             call    invCreate_code_descriptor32
                              C 
                              C           ; Build the temporary data segment
00001FA8  B8B70B0000          C             mov     eax,_dsTEMP_PRIMATIVE / 8
00001FAD  8B5E16              C             mov     ebx,dword ptr ds:[esi+_BOOT_PB_linear_offset]
00001FB0  8B16                C             mov     edx,dword ptr ds:[esi+_BOOT_PB_size]
00001FB2  E8A7E1FFFF          C             call    invCreate_data_descriptor32
                              C 
                              C           ; Build the temporary call gates
00001FB7  B8B40B0000          C             mov     eax,_cgTEMP_PRIMATIVE_MAIN / 8
00001FBC  8B5E04              C             mov     ebx,dword ptr ds:[esi+_BOOT_PB_main]
00001FBF  33C9                C             xor     ecx,ecx
00001FC1  66BAB05D            C             mov     dx,_csTEMP_PRIMATIVE
00001FC5  E884E0FFFF          C             call    invCreate_call_gate_descriptor32
                              C 
00001FCA  B8B50B0000          C             mov     eax,_cgTEMP_PRIMATIVE_REQUESTOR / 8
00001FCF  8B5E08              C             mov     ebx,dword ptr ds:[esi+_BOOT_PB_requestor]
00001FD2  33C9                C             xor     ecx,ecx
00001FD4  66BAB05D            C             mov     dx,_csTEMP_PRIMATIVE
00001FD8  E871E0FFFF          C             call    invCreate_call_gate_descriptor32
                              C 
                              C ;; Call the requestor function to get "Program Information"
                              C ;; 'info'
                              C 
                              C           ; Ok, the temporary code segment, data segment and call gate are built
                              C           ; Now, we need to call the requestor function so it can work its magic
00001FDD  B8B85D0000          C             mov     eax,_dsTEMP_PRIMATIVE
00001FE2  8ED8                C             mov     ds,eax
00001FE4  B86F666E69          C             mov     eax,'info'                                      ; Requestor function for "Program Information"
                              C             callg   _cgTEMP_PRIMATIVE_REQUESTOR
                             1C 
00001FE9  9A                 1C db  9ah
00001FEA  00000000           1C dd  0
00001FEE  A85D               1C dw  _cgTEMP_PRIMATIVE_REQUESTOR
                              C           ; Right now, the information specified in INF\REQUESTR.INF is supposed to be available
00001FF0                      C             .IF (eax != 'nati')
                              C               ; This program was identified as a driver in DT, but it's not a native primative.  This is a fatal error.
00001FF7  E816070000          C                 call    init_failed                                 ; at the bottom of this source file
                              C                 ; * Note:  The init_failed() routine is terminal.  Control will never return here.
00001FFC                      C             .ENDIF
                              C           ; It is a driver.  We should treat it as such. :)
                              C           ; Store the information it provided to us
00001FFC  894C2404            C             mov     dword ptr ss:[esp+04],ecx
00002000  8974240C            C             mov     dword ptr ss:[esp+12],esi
00002004  897C2410            C             mov     dword ptr ss:[esp+16],edi
00002008  895C2414            C             mov     dword ptr ss:[esp+20],ebx
0000200C  896C2418            C             mov     dword ptr ss:[esp+24],ebp
                              C 
                              C           ; Now, let's copy the relevent information
00002010  B898000000          C             mov     eax,_sPRIMATIVES
00002015  8EC0                C             mov     es,eax
00002017  B8A0000000          C             mov     eax,_sPRIMATIVE_LOAD_INFO
0000201C  8EE0                C             mov     fs,eax
0000201E  B840000000          C             mov     eax,_sALL_MEM
00002023  8EE8                C             mov     gs,eax
                              C 
                              C           ; Copy the this driver's code and data segment GDT entries from their temporary area to a permanent area
00002025  6726A10400          C             mov     eax,dword ptr es:[4]
0000202A  C1E003              C             shl     eax,3                                           ; Multiply by 8
0000202D  8B742420            C             mov     esi,dword ptr ss:[esp+32]
00002031  E809040000          C             call    invMove_temp_gdts_to_permanent
00002036  C1E803              C             shr     eax,3                                           ; Divide by 8
00002039  6726A30400          C             mov     dword ptr es:[4],eax
                              C 
                              C           ; Get our starting offsets into the two memory areas
0000203E  67648B3E0000        C             mov     edi,dword ptr fs:[0]
00002044  67268B1E0000        C             mov     ebx,dword ptr es:[0]
                              C 
                              C 
                              C           ;; Do the load info structure
                              C           ;; * Refer to inf\primload.inf for information on this structure
0000204A  6664891F            C             mov     word ptr fs:[edi],bx                            ; store the offset in our load info structure
0000204E  8BC7                C             mov     eax,edi
00002050  83C002              C             add     eax,2
00002053  8944241C            C             mov     dword ptr ss:[esp+28],eax                       ; Now, store a ptr to the location where we'll eventually
                              C                                                                     ;   store the length of the primative structure this driver
                              C                                                                     ;   has requested (the ptr is stored in temp variable space)
                              C           ; Move past those two word entries
00002057  83C704              C             add     edi,4
                              C 
                              C           ; Store the driver's filename
                              C           ; A small degree of indirection here :)
0000205A  8B442420            C             mov     eax,dword ptr ss:[esp+32]                       ; Get a pointer to this driver's boot_parameter_block entry
0000205E  33DB                C             xor     ebx,ebx
00002060  66658B581A          C             mov     bx,word ptr gs:[eax+_BOOT_PB_dt_offset]         ; Which tells us where our DT entry is
00002065  83C302              C             add     ebx,2                                           ; Move past the sector indicator
00002068  035C2424            C             add     ebx,dword ptr ss:[esp+36]
0000206C  66658B5B0B          C             mov     bx,word ptr gs:[ebx+_BOOT_DT_np_offset]         ; Which tells us where our NP entry is
00002071  81E3FFFF0000        C             and     ebx,0ffffh
00002077  83C302              C             add     ebx,2
0000207A  035C2428            C             add     ebx,dword ptr ss:[esp+40]
0000207E  33C9                C             xor     ecx,ecx
00002080  658A0B              C             mov     cl,byte ptr gs:[ebx]                            ; Where we get our filename length
00002083  41                  C             inc     ecx
00002084                      C             .REPEAT                                                 ; And finally, where we copy the text from
00002084  658A03              C                 mov     al,byte ptr gs:[ebx]
00002087  648807              C                 mov     byte ptr fs:[edi],al
0000208A  43                  C                 inc     ebx
0000208B  47                  C                 inc     edi
0000208C                      C             .UNTILCXZ
                              C 
                              C           ; Store the driver's self-assigned name (what it calls itself)
0000208E  8B5C2410            C             mov     ebx,dword ptr ss:[esp+16]
00002092  E888030000          C             call    invCopy_this_part
                              C 
                              C           ; Store the driver's version text
00002097  8B5C2414            C             mov     ebx,dword ptr ss:[esp+20]
0000209B  E87F030000          C             call    invCopy_this_part
                              C 
                              C           ; Store the author's name text
000020A0  8B5C2418            C             mov     ebx,dword ptr ss:[esp+24]
000020A4  E876030000          C             call    invCopy_this_part
                              C 
                              C           ; Store the GDT offsets for the main portions of this function
000020A9  0FA8                C             push    gs
000020AB  B8A8000000          C             mov     eax,_sSYSTEM
000020B0  8EE8                C             mov     gs,eax
000020B2  6765A12408          C             mov     eax,dword ptr gs:[_SYSTEM_i_CODE_GDT_OFFSET]
000020B7  648907              C             mov     dword ptr fs:[edi],eax
000020BA  8BE8                C             mov     ebp,eax
000020BC  83C704              C             add     edi,4
000020BF  6765A12808          C             mov     eax,dword ptr gs:[_SYSTEM_i_DATA_GDT_OFFSET]
000020C4  648907              C             mov     dword ptr fs:[edi],eax
000020C7  83C704              C             add     edi,4
000020CA  6765A12C08          C             mov     eax,dword ptr gs:[_SYSTEM_i_MAIN_GDT_OFFSET]
000020CF  648907              C             mov     dword ptr fs:[edi],eax
000020D2  83C704              C             add     edi,4
000020D5  6765A13008          C             mov     eax,dword ptr gs:[_SYSTEM_i_REQUESTOR_GDT_OFFSET]
000020DA  648907              C             mov     dword ptr fs:[edi],eax
000020DD  83C704              C             add     edi,4
000020E0  0FA9                C             pop     gs
                              C 
                              C           ; And, finally, update the next location pointer in this _sPRIMATIVE_LOAD_INFO structure
000020E2  6764893E0000        C             mov     dword ptr fs:[0],edi
                              C 
                              C           ;; Parse their primatives structure
                              C           ;; * Refer to inf\primload.inf for information on the structure this information is converted to in Exodus
                              C           ;; * Refer to inf\requestr.inf for information on the structure the driver provides
000020E8  8B74240C            C             mov     esi,dword ptr ss:[esp+12]
000020EC  33C9                C             xor     ecx,ecx
000020EE                      C             .WHILE (byte ptr [esi] != 0ffh)
000020F0  8A0E                C                 mov     cl,byte ptr [esi]
000020F2  46                  C                 inc     esi
000020F3  8B140E              C                 mov     edx,dword ptr [esi+ecx]                     ; Offset to function
000020F6  668B5C0E04          C                 mov     bx,word ptr [esi+ecx+4]                     ; Dwords to copy
000020FB  6726A10400          C                 mov     eax,dword ptr es:[4]                        ; Call gate for this primative
00002100  C1E003              C                 shl     eax,3                                       ; Multiply by 8 to get the call gate offset (rather than slot)
                              C               ; Right now,      ds:[esi] - far ptr to primative function name
                              C               ;                      ebp - code segment for this driver
                              C               ;                      eax - GDT slot
                              C               ;                      ecx - length
                              C               ;                      edx - offset into driver for access to this function
                              C               ;                       bx - dwords to copy
                              C 
                              C               ; Let's add it
00002103  E8DE030000          C                 call    invAdd_primative
00002108  6726FF060400        C                 inc     dword ptr es:[4]                            ; Move to the next primative SLOT
                              C 
0000210E  03F1                C                 add     esi,ecx                                     ; Move past the function name
00002110  83C606              C                 add     esi,6                                       ; Move past the function offset (dword)
00002113                      C             .ENDW                                                   ;   and number of dwords to copy (word)
                              C 
                              C 
                              C           ; At this point, we've received all the information from this first REQUESTOR request
                              C           ; The additional request, 'prim' and 'ints' are not executed until after *ALL* the drivers are loaded (in case they're
                              C           ;                         loaded out of order.  Look below for the followup loads that take place once all the
                              C           ;                         primatives have been installed.
                              C 
                              C           ; Phew!
                              C           ; It's loaded and all processed and everything
00002118                      C             .IF (cs:vga_kbd_support == 0)
                              C               ; We don't have our VGA/keyboard drivers installed yet, let's see if this most recent driver installed any of them
00002122  B848000000          C                 mov     eax,_sDATA
00002127  8ED8                C                 mov     ds,eax
                              C 
00002129  BEF21A0000          C                 mov     esi,offset required_native_primatives
0000212E  BFC01A0000          C                 mov     edi,offset _VID_clear_screen_vga
00002133  E800040000          C                 call    invUpdate_required_primatives
00002138                      C                 .IF (!carry?)
                              C                   ; All required primatives were found
                              C                   ; We have the ability to display stuff on the screen and get a key
0000213A  C6053805000001      C                     mov     ds:vga_kbd_support,1
00002141                      C                 .ENDIF
00002141                      C             .ENDIF
                              C 
00002141                      C           @@:
                              C           ; Proceed along happily to the next driver :)
00002141  B840000000          C             mov     eax,_sALL_MEM
00002146  8ED8                C             mov     ds,eax
00002148  8B742420            C             mov     esi,dword ptr ss:[esp+32]
0000214C                      C         .ENDIF
                              C 
0000214C                      C       next_native_primative:
0000214C  83C620              C         add     esi,_BOOT_PB_structure_size
0000214F                      C     .ENDW
                              C 
                              C 
                              C   ; If we're here, then everything has loaded ok, or the ones that didn't load correctly were ignored
                              C   ; Now, since all of the drivers were loaded we need to go ahead and call the remaining requestor() functions, 'prim' and 'ints'
                              C   ; Once those are called we call main() in each one in the order loaded
                              C   ;
                              C   ; * Note:  When we get here, all of the [esp+xx] references above are no longer in use
                              C   ;
                              C 
                              C 
                              C 
                              C   ; Setup the video information for the following portion of code.  From here on out we're fully digital, baby! :)
                              C   ;
00002159  B848000000          C     mov     eax,_sDATA
0000215E  8EC0                C     mov     es,eax
00002160  BBA0000000          C     mov     ebx,_sPRIMATIVE_LOAD_INFO
00002165  8EE3                C     mov     fs,ebx
00002167  B804000000          C     mov     eax,4
0000216C                      C     .WHILE (eax < dword ptr fs:[0])
                              C 
00002171  33C9                C         xor     ecx,ecx
00002173  83C004              C         add     eax,4
00002176  648A08              C         mov     cl,byte ptr fs:[eax]                                ; Get the length of the driver file name
00002179  40                  C         inc     eax
0000217A  03C1                C         add     eax,ecx
0000217C  648A08              C         mov     cl,byte ptr fs:[eax]                                ; Get the length of the driver's self-assigned name
0000217F  40                  C         inc     eax
00002180  03C1                C         add     eax,ecx
00002182  648A08              C         mov     cl,byte ptr fs:[eax]                                ; Get the length of the version text
00002185  40                  C         inc     eax
00002186  03C1                C         add     eax,ecx
00002188  648A08              C         mov     cl,byte ptr fs:[eax]                                ; Get the length of the author text
0000218B  40                  C         inc     eax
0000218C  03C1                C         add     eax,ecx
0000218E  8BF8                C         mov     edi,eax
                              C 
                              C       ;
                              C       ; Right now, fs:[edi] - far ptr to GDT offsets for:
                              C       ;
                              C       ;                     Offset  Length  Description             How to access
                              C       ;                     ------  ------  --------------------    -------------------------------------
                              C       ;                        0      4     code segment            to access (word ptr fs:[eax+0])
                              C       ;                        4      4     data segment            to access (word ptr fs:[eax+4])
                              C       ;                        8      4     main call gate          to access (call fword ptr fs:[eax+4])
                              C       ;                        12     4     requestor, call gate    to access (call fword ptr fs:[eax+8])
                              C       ;
                              C 
                              C       ; Physically call the primative
00002190  50                  C         push    eax
                              C 
00002191  33DB                C         xor     ebx,ebx
00002193  66648B580C          C         mov     bx,word ptr fs:[eax+12]                             ; Modify the selector for this primative
00002198  BE82220000          C         mov     esi,offset id_offset
0000219D  6626891E            C         mov     word ptr es:[esi],bx
000021A1  BEDA210000          C         mov     esi,offset prim_offset
000021A6  6626891E            C         mov     word ptr es:[esi],bx
000021AA  BE19220000          C         mov     esi,offset note_offset
000021AF  6626891E            C         mov     word ptr es:[esi],bx
000021B3  EB00                C         jmp     $+2                                                 ; Clear the prefetch cache (just in case)
                              C 
000021B5  B86D697270          C         mov     eax,'prim'                                          ; requested primative function
000021BA  66648E5F04          C         mov     ds,word ptr fs:[edi+4]                              ; this primative's permanent data segment
000021BF  648B5F08            C         mov     ebx,dword ptr fs:[edi+8]                            ; main() call gate
000021C3  648B4F0C            C         mov     ecx,dword ptr fs:[edi+12]                           ; requestor() call gate
000021C7  33D2                C         xor     edx,edx
000021C9  33F6                C         xor     esi,esi
000021CB  33FF                C         xor     edi,edi
000021CD  33ED                C         xor     ebp,ebp
000021CF  8EC2                C         mov     es,edx
000021D1  8EE2                C         mov     fs,edx
000021D3  8EEA                C         mov     gs,edx
                              C ;        call    invExtract_linear_offset_into_edx_from_ds
                              C       ;
                              C       ; Right now, eax - 'prim', indicating what requestor() function we're calling
                              C       ;             bx - main() call gate
                              C       ;             cx - requestor() call gate
                              C       ;            edx - null
                              C       ;            esi - null
                              C       ;            edi - null
                              C       ;            ebp - null
                              C       ;             ds - permanent data segment for this primative
                              C       ;             es - null
                              C       ;             fs - null
                              C       ;             gs - null
000021D5  9A                  C         db  9ah                     ; Call immed16:32
000021D6  00000000            C         dd  0                       ; Offset (the value here doesn't matter because we're calling a call gate)
000021DA                      C       prim_offset:
000021DA  0000                C         dw  0                       ; Selector (this part changes for each primative, see the code above (before jmp $+2))
                              C 
                              C       ; Right now, esi - offset to list of names to find
                              C       ;            edi - offset to corresponding call gate area
000021DC                      C         .IF (esi != 0ffffffffh)
                              C           ; They have specified a list of primatives they need
000021E8  E84B030000          C             call    invUpdate_required_primatives
000021ED                      C             .IF (carry?)
                              C               ; Not all of them are available, we need to call the driver and tell them
000021EF  B8A8000000          C                 mov     eax,_sSYSTEM
000021F4  8EE0                C                 mov     fs,eax
000021F6  B865746F6E          C                 mov     eax,'note'
000021FB  BB6D697270          C                 mov     ebx,'prim'
00002200  67648B0EFC0B        C                 mov     ecx,dword ptr fs:[_SYSTEM_i_SCRATCH_DWORD1]     ; Total
00002206  67648B2EF80B        C                 mov     ebp,dword ptr fs:[_SYSTEM_i_SCRATCH_DWORD2]     ; Number that weren't found
0000220C  33D2                C                 xor     edx,edx
0000220E  33F6                C                 xor     esi,esi
00002210  33FF                C                 xor     edi,edi
00002212  8EE2                C                 mov     fs,edx
                              C               ; Now, call the 'note' requestor function
00002214  9A                  C                 db  9ah             ; Call immed16:32
00002215  00000000            C                 dd  0               ; Offset (the value here doesn't matter because we're calling a call gate)
00002219                      C               note_offset:
00002219  0000                C                 dw  0               ; Selector (this part changes for each primative, see the code above (before jmp $+2))
                              C 
0000221B                      C                 .IF (carry?)
                              C                   ; They've indicated this driver cannot continue without those primatives
0000221D  E8F0040000          C                     call    init_failed
00002222                      C                 .ENDIF
00002222                      C             .ENDIF
                              C 
                              C           ; Right now, everything's loaded OK.
00002222  BBA0000000          C             mov     ebx,_sPRIMATIVE_LOAD_INFO
00002227  8EE3                C             mov     fs,ebx
00002229  8B0424              C             mov     eax,dword ptr ss:[esp]                          ; Get our offset off the stack
0000222C  83C010              C             add     eax,16                                          ; And move to the next location to see WHERE IT'S AT! (Got 2 turn tables and a microphone...)
0000222F  1E                  C             push    ds
00002230  60                  C             pushad
00002231  BECE1A0000          C             mov     esi,offset _VID_display_string_vga + 4
00002236                      C             .IF (eax < dword ptr fs:[0])
0000223E  BE5D070000          C                 mov     esi,offset next_item
00002243                      C             .ELSE
00002245  BE62070000          C                 mov     esi,offset last_item
0000224A                      C             .ENDIF
0000224A  B848000000          C             mov     eax,_sDATA
0000224F  8ED8                C             mov     ds,eax
00002251                      C             .IF (ds:loading_primatives_displayed == _NO)
0000225A  C6053507000001      C                 mov     ds:loading_primatives_displayed,_YES
00002261  60                  C                 pushad
00002262  BE36070000          C                 mov     esi,offset loading_primatives
00002267  2EFF1DC81A0000      C                 call    fword ptr cs:_VID_display_string_nr_vga
0000226E  61                  C                 popad
0000226F                      C             .ENDIF
0000226F  2EFF1DCA1A0000      C             call    fword ptr cs:_VID_display_string_vga
00002276  61                  C             popad
00002277  1F                  C             pop     ds
                              C           ; Ask the driver to identify itself on the VGA display
00002278  B820206469          C             mov     eax,'id  '
0000227D  9A                  C             db  9ah                 ; Call immed16:32
0000227E  00000000            C             dd  0                   ; Offset (the value here doesn't matter because we're calling a call gate)
00002282                      C           id_offset:
00002282  0000                C             dw  0                   ; Selector (this part changes for each primative, see the code above (before jmp $+2))
                              C 
00002284                      C         .ENDIF
                              C 
00002284  58                  C         pop     eax
                              C       ; Reset the data segments for use in our procedure
00002285  BB48000000          C         mov     ebx,_sDATA
0000228A  8EC3                C         mov     es,ebx
0000228C  BBA0000000          C         mov     ebx,_sPRIMATIVE_LOAD_INFO
00002291  8EE3                C         mov     fs,ebx
                              C 
00002293  83C010              C         add     eax,16
00002296                      C     .ENDW
                              C 
                              C 
                              C   ; At this point, all of the requestor() functions have been setup for all drivers
                              C   ; Now, it's time to call main() on each one of them
                              C   ; Before we do that we need to setup Exodus's requestor() memory blocks
000022A2  B850000000          C     mov     eax,_sEXODUS_MEM
000022A7  8ED8                C     mov     ds,eax
000022A9  67C706000004000000  C     mov     dword ptr ds:[0],4                                      ; Starting location to write data for memory blocks
000022B2  B858000000          C     mov     eax,_sEXODUS_PORTS
000022B7  8ED8                C     mov     ds,eax
000022B9  67C706000004000000  C     mov     dword ptr ds:[0],4                                      ; Starting location to write data for port requests
000022C2  B860000000          C     mov     eax,_sEXODUS_INTS
000022C7  8ED8                C     mov     ds,eax
000022C9  67C706000004000000  C     mov     dword ptr ds:[0],4                                      ; Starting location to write data for interrupt requests
                              C 
                              C   ; Display the driver's name before we begin call main()
000022D2  B848000000          C     mov     eax,_sDATA
000022D7  8ED8                C     mov     ds,eax
000022D9  BE4B070000          C     mov     esi,offset loading_drivers
000022DE  2EFF1DC81A0000      C     call    fword ptr cs:_VID_display_string_nr_vga
                              C 
000022E5  BBA0000000          C     mov     ebx,_sPRIMATIVE_LOAD_INFO
000022EA  8EDB                C     mov     ds,ebx
000022EC  B804000000          C     mov     eax,4
000022F1  8BEC                C     mov     ebp,esp
000022F3                      C     .WHILE (eax < dword ptr ds:[0])
000022F8  33C9                C         xor     ecx,ecx
000022FA  83C004              C         add     eax,4
000022FD  8A08                C         mov     cl,byte ptr ds:[eax]                                ; Get the length of the driver file name
000022FF  40                  C         inc     eax
00002300  03C1                C         add     eax,ecx
00002302  8A08                C         mov     cl,byte ptr ds:[eax]                                ; Get the length of the driver's self-assigned name
00002304  40                  C         inc     eax
00002305  894530              C         mov     dword ptr ss:[ebp+48],eax                           ; Save for later use (below)
00002308  894D34              C         mov     dword ptr ss:[ebp+52],ecx                           ; Save for later use (below)
0000230B  03C1                C         add     eax,ecx
0000230D  8A08                C         mov     cl,byte ptr ds:[eax]                                ; Get the length of the version text
0000230F  40                  C         inc     eax
00002310  894538              C         mov     dword ptr ss:[ebp+56],eax                           ; Save for later use (below)
00002313  894D3C              C         mov     dword ptr ss:[ebp+60],ecx                           ; Save for later use (below)
00002316  03C1                C         add     eax,ecx
00002318  8A08                C         mov     cl,byte ptr ds:[eax]                                ; Get the length of the author text
0000231A  40                  C         inc     eax
0000231B  03C1                C         add     eax,ecx
0000231D  8BF8                C         mov     edi,eax
0000231F  50                  C         push    eax
                              C 
00002320  33DB                C         xor     ebx,ebx
00002322  66648B5804          C         mov     bx,word ptr fs:[eax+4]                              ; Get the data segment for this primative
00002327  895D2C              C         mov     dword ptr ss:[ebp+44],ebx
0000232A  66648B5808          C         mov     bx,word ptr fs:[eax+8]                              ; Get the main() selector for this primative
0000232F  BED2230000          C         mov     esi,offset main_offset
00002334  6626891E            C         mov     word ptr es:[esi],bx
                              C       ;
                              C       ; Right now,          ds - data segment for this primative's name in the _sPRIMATIVE_LOAD_INFO structure
                              C       ;            ss:[ebp+48] - ptr to offset of driver's self-assigned name
                              C       ;            ss:[ebp+52] - length of the name at that location
                              C       ;
00002338  83C710              C         add     edi,16
0000233B                      C         .IF (edi < dword ptr ds:[0])
00002342  BE5D070000          C             mov     esi,offset next_item
00002347                      C         .ELSE
00002349  BE62070000          C             mov     esi,offset last_item
0000234E                      C         .ENDIF
                              C 
0000234E  1E                  C         push    ds
0000234F  B848000000          C         mov     eax,_sDATA
00002354  8ED8                C         mov     ds,eax
00002356  2EFF1DCA1A0000      C         call    fword ptr cs:_VID_display_string_vga
0000235D  1F                  C         pop     ds
                              C 
                              C       ; Display what the driver calls itself
0000235E  8B7530              C         mov     esi,dword ptr ss:[ebp+48]
00002361  8B4D34              C         mov     ecx,dword ptr ss:[ebp+52]
                              C       ; This code removes anything that comes after the ASCII-255 (indicating not-displayed information)
00002364  8BC1                C         mov     eax,ecx
00002366                      C         .WHILE (eax > 0)
00002368                      C             .IF (byte ptr ds:[esi+eax-1] == 255)
0000236F  8BC8                C                 mov     ecx,eax
00002371  49                  C                 dec     ecx
00002372                      C             .ENDIF
00002372  48                  C             dec     eax
00002373                      C         .ENDW
00002378                      C         .IF (ecx != 0 && ecx < 7fffffffh)
                              C           ; Display the name
00002385  2EFF1DC61A0000      C             call    fword ptr cs:_VID_display_string_ecx_vga
                              C 
0000238C  1E                  C             push    ds
0000238D  B848000000          C             mov     eax,_sDATA
00002392  8ED8                C             mov     ds,eax
00002394  BE67070000          C             mov     esi,offset comma_space
00002399  2EFF1DCA1A0000      C             call    fword ptr cs:_VID_display_string_vga
000023A0  1F                  C             pop     ds
000023A1                      C         .ENDIF
                              C 
                              C       ; Display the version information
000023A1  8B7538              C         mov     esi,dword ptr ss:[ebp+56]
000023A4  8B4D3C              C         mov     ecx,dword ptr ss:[ebp+60]
000023A7  2EFF1DC41A0000      C         call    fword ptr cs:_VID_display_string_ecx_nr_vga
                              C 
000023AE  60                  C         pushad
000023AF  1E                  C         push    ds
000023B0  06                  C         push    es
000023B1  0FA0                C         push    fs
000023B3  0FA8                C         push    gs
000023B5  668E5D2C            C         mov     ds,word ptr ss:[ebp+44]
000023B9  33ED                C         xor     ebp,ebp
000023BB  33C0                C         xor     eax,eax
000023BD  33DB                C         xor     ebx,ebx
000023BF  33C9                C         xor     ecx,ecx
000023C1  33D2                C         xor     edx,edx
000023C3  33F6                C         xor     esi,esi
000023C5  33FF                C         xor     edi,edi
000023C7  8EC0                C         mov     es,eax
000023C9  8EE0                C         mov     fs,eax
000023CB  8EE8                C         mov     gs,eax
                              C       ; Ok, we've displayed its name on the screen....
                              C       ; Right now:  ds - The primative data segment
                              C       ;             everything else is NULL
                              C       ; Now, we let it initialize itself
000023CD  9A                  C         db  9ah                     ; Call immed16:32
000023CE  00000000            C         dd  0                       ; Offset (the value here doesn't matter because we're calling a call gate)
000023D2                      C       main_offset:
000023D2  0000                C         dw  0                       ; Selector (this part changes for each primative, see the code near "offset main_offset")
000023D4  0FA9                C         pop     gs
000023D6  0FA1                C         pop     fs
000023D8  07                  C         pop     es
000023D9  1F                  C         pop     ds
000023DA  61                  C         popad
                              C 
000023DB  58                  C         pop     eax
000023DC  83C010              C         add     eax,16
000023DF                      C     .ENDW
                              C 
000023EA  83C444              C     add     esp,68
000023ED  1F                  C     pop     ds
000023EE  07                  C     pop     es
000023EF  0FA1                C     pop     fs
000023F1  0FA9                C     pop     gs
000023F3                      C     ret
000023F4                      C invSetup_native_primatives      ENDP
                              C 
                              C 
                              C 
                              C 
000023F4                      C default_primative_response      PROC    NEAR
                              C ; This routine is called on any primative that has not been defined.
                              C ;
                              C ; * The primative call gates represent a range defined at the top of this program
                              C ;   Any primative call gate that has not been used by a defined function points to this routine
                              C ;   It returns the text "no support for primative" in the registers
                              C ;
000023F4  2EA110050000        C     mov     eax,dword ptr cs:no_support_for_primative[00]
000023FA  2E8B1D14050000      C     mov     ebx,dword ptr cs:no_support_for_primative[04]
00002401  2E8B0D18050000      C     mov     ecx,dword ptr cs:no_support_for_primative[08]
00002408  2E8B151C050000      C     mov     edx,dword ptr cs:no_support_for_primative[12]
0000240F  2E8B3520050000      C     mov     esi,dword ptr cs:no_support_for_primative[16]
00002416  2E8B3D24050000      C     mov     edi,dword ptr cs:no_support_for_primative[20]
0000241D  F9                  C     stc
0000241E  CB                  C     retf
0000241F                      C default_primative_response      ENDP
                              C 
                              C 
                              C 
                              C 
0000241F                      C invCopy_this_part   PROC    NEAR
                              C ; This routine is used to copy data from ds:[ebx] to fs:[edi]
                              C ;
                              C ; Upon entry:   ds:[ebx] - ptr to source string
                              C ;               fs:[edi] - ptr to destination string
                              C ;
                              C ; Upon exit:    ecx - number of bytes copied
                              C ;
0000241F  52                  C     push    edx
00002420  51                  C     push    ecx
00002421  53                  C     push    ebx
00002422  50                  C     push    eax
                              C 
00002423  8BD7                C     mov     edx,edi
00002425  47                  C     inc     edi
00002426  33C9                C     xor     ecx,ecx
00002428                      C     .WHILE (byte ptr ds:[ebx] != 0)
0000242A  8A03                C         mov     al,byte ptr ds:[ebx]
0000242C  648807              C         mov     byte ptr fs:[edi],al
0000242F  43                  C         inc     ebx
00002430  47                  C         inc     edi
00002431  41                  C         inc     ecx
00002432                      C     .ENDW
00002437  64880A              C     mov     byte ptr fs:[edx],cl
                              C 
0000243A  58                  C     pop     eax
0000243B  5B                  C     pop     ebx
0000243C  59                  C     pop     ecx
0000243D  5A                  C     pop     edx
0000243E                      C     ret
0000243F                      C invCopy_this_part   ENDP
                              C 
                              C 
                              C 
                              C 
0000243F                      C invMove_temp_gdts_to_permanent      PROC    NEAR
                              C ; This routine is used to copy the temporary primative GDT entries to their permanent location
                              C ;
                              C ; Upon entry:   eax - starting GDT offset to use
                              C ;               ecx - actual code segment/data segment length
                              C ;               _csTEMP_PRIMATIVE - defined as Code segment
                              C ;               _dsTEMP_PRIMATIVE - defined as Data segment
                              C ;          _cgTEMP_PRIMATIVE_MAIN - defined as call gate to main()
                              C ;     _cgTEMP_PRIMATIVE_REQUESTOR - defined as call gate to requestor()
                              C ;
                              C ; Upon exit:    _csTEMP_PRIMATIVE - copied to the next available location
                              C ;               _dsTEMP_PRIMATIVE - copied to the one after that
                              C ;                             eax - next GDT offset to use
                              C ;                                   * Note:  If the value in ebx != 0, then the limit of the
                              C ;
0000243F  57                  C     push    edi
00002440  53                  C     push    ebx
00002441  1E                  C     push    ds
00002442  06                  C     push    es
00002443  0FA0                C     push    fs
00002445  0FA8                C     push    gs
                              C 
00002447  BB10000000          C     mov     ebx,_sGDT
0000244C  8EDB                C     mov     ds,ebx
0000244E  BBA8000000          C     mov     ebx,_sSYSTEM
00002453  8EC3                C     mov     es,ebx
00002455  BB48000000          C     mov     ebx,_sDATA
0000245A  8EE3                C     mov     fs,ebx
0000245C  BBA8000000          C     mov     ebx,_sSYSTEM
00002461  8EEB                C     mov     gs,ebx
                              C 
                              C   ; Copy the code segment
00002463  BFB05D0000          C     mov     edi,_csTEMP_PRIMATIVE
00002468  8B1F                C     mov     ebx,dword ptr [edi]
0000246A  8918                C     mov     dword ptr [eax],ebx
0000246C  8B5F04              C     mov     ebx,dword ptr [edi+4]
0000246F  895804              C     mov     dword ptr [eax+4],ebx
                              C   ; Derive the GDT information (to see if we need to adjust it)
00002472  E854DDFFFF          C     call    invExtract_code_descriptor32
                              C ;    .IF (ecx < edx)
                              C ;      ; We need to make the limit field shorter because they don't need all of the memory in the file
                              C ;        push    eax
                              C ;        shr     eax,3                                               ; Divide by 8
                              C ;        mov     edx,ecx                                             ; Decrease the limit to the value specified by requestor()
                              C ;        call    invCreate_code_descriptor32
                              C ;        pop     eax
                              C ;    .ENDIF
00002477  6765A32408          C     mov     dword ptr gs:[_SYSTEM_i_CODE_GDT_OFFSET],eax
0000247C  83C008              C     add     eax,8
                              C 
                              C   ; Copy the data segment
0000247F  BFB85D0000          C     mov     edi,_dsTEMP_PRIMATIVE
00002484  8B1F                C     mov     ebx,dword ptr [edi]
00002486  8918                C     mov     dword ptr [eax],ebx
00002488  8B5F04              C     mov     ebx,dword ptr [edi+4]
0000248B  895804              C     mov     dword ptr [eax+4],ebx
0000248E  E8A3DDFFFF          C     call    invExtract_data_descriptor32
                              C ;    .IF (ecx < edx)
                              C ;      ; We need to make the limit field shorter because they don't need all of the memory in the file
                              C ;        push    eax
                              C ;        shr     eax,3                                               ; Divide by 8
                              C ;        mov     edx,ecx                                             ; Decrease the limit to the value specified by requestor()
                              C ;        call    invCreate_data_descriptor32
                              C ;        pop     eax
                              C ;    .ENDIF
00002493  6765A32808          C     mov     dword ptr gs:[_SYSTEM_i_DATA_GDT_OFFSET],eax
00002498  83C008              C     add     eax,8
                              C 
                              C   ; Copy the main call gate
0000249B  BFA05D0000          C     mov     edi,_cgTEMP_PRIMATIVE_MAIN
000024A0  8B1F                C     mov     ebx,dword ptr [edi]
000024A2  8918                C     mov     dword ptr [eax],ebx
000024A4  8B5F04              C     mov     ebx,dword ptr [edi+4]
000024A7  895804              C     mov     dword ptr [eax+4],ebx
000024AA  6765A32C08          C     mov     dword ptr gs:[_SYSTEM_i_MAIN_GDT_OFFSET],eax
                              C   ; Now, update the code segment selector for this newly located code segment (see above)
000024AF  67658B1E2408        C     mov     ebx,dword ptr gs:[_SYSTEM_i_CODE_GDT_OFFSET]
000024B5  66895802            C     mov     word ptr [eax+2],bx
000024B9  83C008              C     add     eax,8
                              C 
                              C   ; Copy the requestor call gate
000024BC  BFA85D0000          C     mov     edi,_cgTEMP_PRIMATIVE_REQUESTOR
000024C1  8B1F                C     mov     ebx,dword ptr [edi]
000024C3  8918                C     mov     dword ptr [eax],ebx
000024C5  8B5F04              C     mov     ebx,dword ptr [edi+4]
000024C8  895804              C     mov     dword ptr [eax+4],ebx
000024CB  6765A33008          C     mov     dword ptr gs:[_SYSTEM_i_REQUESTOR_GDT_OFFSET],eax
                              C   ; And, update this one's code selector also (see above)
000024D0  67658B1E2408        C     mov     ebx,dword ptr gs:[_SYSTEM_i_CODE_GDT_OFFSET]
000024D6  66895802            C     mov     word ptr [eax+2],bx
000024DA  83C008              C     add     eax,8
                              C 
000024DD  0FA9                C     pop     gs
000024DF  0FA1                C     pop     fs
000024E1  07                  C     pop     es
000024E2  1F                  C     pop     ds
000024E3  5B                  C     pop     ebx
000024E4  5F                  C     pop     edi
000024E5                      C     ret
000024E6                      C invMove_temp_gdts_to_permanent      ENDP
                              C 
                              C 
                              C 
                              C 
000024E6                      C invAdd_primative    PROC    NEAR
                              C ; This routine is used to add a primative to the following items:
                              C ;   #1 - The _sPRIMATIVE structure
                              C ;   #2 - The GDT as a call gate
                              C ;
                              C ; Upon entry:        eax - GDT offset for this primative's call gate
                              C ;               ds:[esi] - far ptr to primative function name
                              C ;                     bx - dword to copy
                              C ;                    ecx - length
                              C ;                    edx - offset into the driver for this function
                              C ;                    ebp - Code segment for the driver this primative comes from
                              C ;
                              C ; Upon exit:    This routine is self contained
                              C ;               If control is returned to the calling function then it can be assumed that it is ok to continue
                              C ;               The data is added (or not added)
                              C ;
000024E6  60                  C     pushad
000024E7  06                  C     push    es
                              C 
000024E8                      C     .IF (eax < _MAX_PRIMATIVE*8)
                              C       ; We're within the range for this primative
000024EF  BF98000000          C         mov     edi,_sPRIMATIVES
000024F4  8EC7                C         mov     es,edi
                              C 
000024F6  67268B3E0000        C         mov     edi,dword ptr es:[0]
000024FC  66268907            C         mov     word ptr es:[edi],ax                                ; store the call gate
00002500  83C702              C         add     edi,2
                              C 
00002503  26C60701            C         mov     byte ptr es:[edi],1                                 ; active? (0-No, 1-Yes)
00002507  47                  C         inc     edi
                              C 
00002508  26880F              C         mov     byte ptr es:[edi],cl                                ; length of the function name
0000250B  47                  C         inc     edi
                              C 
                              C       ; Store the primative function name
                              C       ; Right now, ds:[esi] - far ptr to their primative name
                              C       ;            es:[edi] - far ptr to store it
                              C       ;                 ecx - length of that name
0000250C  50                  C         push    eax
0000250D                      C         .REPEAT
0000250D  8A06                C             mov     al,byte ptr [esi]
0000250F                      C             .IF (al >= "A" && al <= "Z")
00002517  0C20                C                 or      al,20h                                      ; force the name to lower-case
00002519                      C             .ENDIF
00002519  46                  C             inc     esi
0000251A  268807              C             mov     byte ptr es:[edi],al
0000251D  47                  C             inc     edi
0000251E                      C         .UNTILCXZ
00002520  58                  C         pop     eax
                              C 
                              C       ; Update for the next location
00002521  6726893E0000        C         mov     dword ptr es:[0],edi
                              C 
                              C       ; Now, physically create the call gate to this primative
00002527  8BCB                C         mov     ecx,ebx                                             ; dwords to copy
00002529  8BDA                C         mov     ebx,edx                                             ; Offset to start of function
0000252B  8BD5                C         mov     edx,ebp                                             ; Code segment
0000252D  C1E803              C         shr     eax,3                                               ; Divide by 8 to get the GDT slot
00002530  E819DBFFFF          C         call    invCreate_call_gate_descriptor32
00002535                      C     .ENDIF
                              C 
00002535  07                  C     pop     es
00002536  61                  C     popad
00002537                      C     ret
00002538                      C invAdd_primative    ENDP
                              C 
                              C 
                              C 
                              C 
00002538                      C invUpdate_required_primatives   PROC    NEAR
                              C ; This routine is used to update the required primatives required by a particular function
                              C ; * Refer to inf\
                              C ;
                              C ; Upon entry:   ds:[esi] - Offset to name structure of the required primatives
                              C ;               ds:[edi] - Offset to the start of the structure used for the call gates to assign to them
                              C ;
                              C ; Upon exit:    carry? - CLEAR=all functions were found (meaning they've already been installed)
                              C ;                          SET=error
                              C ;                               ecx - number of functions not found
                              C ;
00002538  60                  C     pushad
00002539  06                  C     push    es
0000253A  0FA0                C     push    fs
0000253C  C8140000            C     enter   20,0
                              C   ; [ebp-04] - dword, --Nuserved
                              C   ; [ebp-08] - dword, current value of eax
                              C   ; [ebp-12] - dword, current value of ecx for inner loop
                              C   ; [ebp-16] - dword, current value of esi
                              C   ; [ebp-20] - dword, curent value of ecx for outter loop
00002540  B898000000          C     mov     eax,_sPRIMATIVES
00002545  8EC0                C     mov     es,eax
00002547  B8A8000000          C     mov     eax,_sSYSTEM
0000254C  8EE0                C     mov     fs,eax
                              C 
0000254E  6764C706FC0B000000  C     mov     dword ptr fs:[_SYSTEM_i_SCRATCH_DWORD1],0               ; Holds total number of primative names found
00002558  6764C706F80B000000  C     mov     dword ptr fs:[_SYSTEM_i_SCRATCH_DWORD2],0               ; Holds total number not matched with installed primatives
                              C 
00002562  33C9                C     xor     ecx,ecx
00002564                      C     .WHILE (byte ptr ds:[esi] != 0ffh)
00002569  8975F0              C         mov     dword ptr ss:[ebp-16],esi
0000256C  8A0E                C         mov     cl,byte ptr ds:[esi]
0000256E  894DEC              C         mov     dword ptr ss:[ebp-20],ecx
00002571  6764FF06FC0B        C         inc     dword ptr fs:[_SYSTEM_i_SCRATCH_DWORD1]
                              C 
                              C       ; Start at the beginning of the _sPRIMATIVE structure for each pass
00002577  B808000000          C         mov     eax,8
                              C       ; Right now, es:[eax] - far ptr to start of primative's structure, refer to inf\primload.inf for information
0000257C                      C         .WHILE (eax < dword ptr es:[0])
0000257E  268A4803            C             mov     cl,byte ptr es:[eax+3]
00002582  894DF4              C             mov     dword ptr ss:[ebp-12],ecx
00002585  8B75F0              C             mov     esi,dword ptr ss:[ebp-16]
00002588                      C             .IF (byte ptr es:[eax+2] == 1 && cl == byte ptr ds:[esi])
00002593  66268B18            C                 mov     bx,word ptr es:[eax]                        ; Get the call gate
00002597  8945F8              C                 mov     dword ptr ss:[ebp-08],eax
0000259A  83C004              C                 add     eax,4
0000259D  46                  C                 inc     esi
                              C               ; Right now, es:[eax] - far ptr to _sPRIMATIVE name
                              C               ;            ds:[esi] - far ptr to current native primative name the application is requiring
                              C               ;                 ecx - length
                              C               ;                  bx - call gate for this primative
0000259E                      C                 .REPEAT
0000259E  8A16                C                     mov     dl,byte ptr ds:[esi]
000025A0                      C                     .IF (dl >= 'A' && dl <= 'Z')
000025AA  80C220              C                         add     dl,020h                             ; force lowercase
000025AD                      C                     .ENDIF
000025AD                      C                     .IF (dl != byte ptr es:[eax])
                              C                       ; It wasn't a match
000025B2  EB0A                C                         jmp     @F
000025B4                      C                     .ENDIF
000025B4  40                  C                     inc     eax
000025B5  46                  C                     inc     esi
000025B6                      C                 .UNTILCXZ
                              C               ; If we're here, then this was a match
000025B8  66895F04            C                 mov     word ptr ds:[edi+4],bx
000025BC  EB1F                C                 jmp     next_primative
                              C 
000025BE                      C               @@:
000025BE  8B4DF4              C                 mov     ecx,dword ptr ss:[ebp-12]
000025C1  8B45F8              C                 mov     eax,dword ptr ss:[ebp-08]
000025C4                      C             .ENDIF
000025C4  03C1                C             add     eax,ecx
000025C6  83C004              C             add     eax,4
000025C9                      C         .ENDW
                              C       ; If we're here, then the item wasn't found
000025D1  66C74704FFFF        C         mov     word ptr ds:[edi+4],0ffffh                          ; Set it so it will indicate it "wasn't found"
000025D7  6764FF06F80B        C         inc     dword ptr fs:[_SYSTEM_i_SCRATCH_DWORD2]             ; Increase the number of items not found
                              C 
000025DD                      C       next_primative:
000025DD  8B4DEC              C         mov     ecx,dword ptr ss:[ebp-20]
000025E0  8B75F0              C         mov     esi,dword ptr ss:[ebp-16]
000025E3  03F1                C         add     esi,ecx
000025E5  46                  C         inc     esi
000025E6  83C702              C         add     edi,2
000025E9                      C     .ENDW
                              C 
                              C 
000025F2                      C     .IF (dword ptr fs:[_SYSTEM_i_SCRATCH_DWORD2] != 0)
000025FB  F9                  C         stc
000025FC                      C     .ELSE
000025FE  F8                  C         clc
000025FF                      C     .ENDIF
                              C 
000025FF  C9                  C     leave
00002600  0FA1                C     pop     fs
00002602  07                  C     pop     es
00002603  61                  C     popad
00002604                      C     ret
00002605                      C invUpdate_required_primatives   ENDP
                              C 
                              C 
                              C 
                              C 
00002605                      C default_interrupt_handler32     PROC
                              C ; This is the default interrupt handler
                              C ; All IDT entries are initially setup to this in init16.asp
                              C ; invSetup_native_primatives updates those that are relevant to
00002605  50                  C     push    eax
00002606  B020                C     mov     al,20h
00002608  E620                C     out     20h,al
0000260A  58                  C     pop     eax
0000260B                      C     iretd
0000260C                      C default_interrupt_handler32     ENDP
                              C 
                              C 
                              C 
                              C 
                              C ;VID_display_radix_in_edx_vga    PROC
                              C ;    pushad
                              C ;    push    ds
                              C ;    sub     esp,16                                                  ; Assume a maximum length of 12 chars (4 extra for boundary)
                              C ;    mov     ebp,esp
                              C ;
                              C ;    call    iString_generate_radix_string
                              C ;    call    VID_display_string_vga
                              C ;
                              C ;    add     esp,16
                              C ;    pop     ds
                              C ;    popad
                              C ;    ret
                              C ;VID_display_radix_in_edx_vga    ENDP
                              C 
                              C 
                              C 
                              C 
0000260C                      C VID_display_radix_in_edx_mono   PROC
0000260C  60                  C     pushad
0000260D  1E                  C     push    ds
0000260E  83EC10              C     sub     esp,16                                                  ; Assume a maximum length of 12 chars (4 extra for boundry)
00002611  8BEC                C     mov     ebp,esp
                              C 
00002613  E80B000000          C     call    iString_generate_radix_string
00002618  E839000000          C     call    VID_display_string_mono
                              C 
0000261D  83C410              C     add     esp,16
00002620  1F                  C     pop     ds
00002621  61                  C     popad
00002622                      C     ret
00002623                      C VID_display_radix_in_edx_mono   ENDP
                              C 
                              C 
                              C 
                              C 
00002623                      C iString_generate_radix_string   PROC
00002623  C6450C00            C     mov     byte ptr [ebp+12],0                                 ; NULL terminate the string we're building
00002627  8BF5                C     mov     esi,ebp
00002629  83C60B              C     add     esi,11
0000262C  8BC2                C     mov     eax,edx
0000262E  81E3FFFF0000        C     and     ebx,0ffffh
00002634                      C   @@:
00002634  33D2                C     xor     edx,edx
00002636  F7F3                C     div     ebx
00002638                      C     .IF (dl > 9)
0000263D  80C257              C         add     dl,'a'-10                                       ; Make it a letter if it's above 9 (10+ cannot be represented in 1 digit)
00002640                      C     .ELSE
00002642  80C230              C         add     dl,'0'                                          ; Make it a number
00002645                      C     .ENDIF
00002645  368816              C     mov     byte ptr ss:[esi],dl
00002648  4E                  C     dec     esi                                                 ; Decrement (move to next position to store data)
00002649  3BF5                C     cmp     esi,ebp
0000264B  7405                C     jz      @F
0000264D  83F800              C     cmp     eax,0
00002650  75E2                C     jnz     @B
00002652                      C   @@:
00002652  16                  C     push    ss
00002653  1F                  C     pop     ds
00002654  46                  C     inc     esi                                                 ; Add back for the one we decremented above
                              C   ; Right now, ds:[esi] - pointer to the value to display
00002655                      C     ret
00002656                      C iString_generate_radix_string   ENDP
                              C 
                              C 
                              C 
                              C 
                              C ;VID_display_string_vga    PROC
                              C ;; ds:[esi] - far pointer to null-terminated string
                              C ;;      edi - offset into video memory to write
                              C ;    pushad
                              C ;    push    es
                              C ;    push    fs
                              C ;
                              C ;    mov     eax,_sDATA
                              C ;    mov     es,eax
                              C ;    mov     eax,_sVGA
                              C ;    mov     fs,eax
                              C ;    mov     ah,7
                              C ;    .WHILE (byte ptr ds:[esi] != 0)                                 ; Loop until the NULL terminated string is found
                              C ;        lodsb
                              C ;        mov     byte ptr fs:[edi],al                                ; Write character
                              C ;        inc     di
                              C ;        mov     byte ptr fs:[edi],ah                                ; Write color
                              C ;        inc     di
                              C ;    .ENDW
                              C ;
                              C ;    pop     fs
                              C ;    pop     es
                              C ;    popad
                              C ;    ret
                              C ;VID_display_string_vga    ENDP
                              C 
                              C 
                              C 
                              C 
00002656                      C VID_display_string_mono   PROC
                              C ; ds:[esi] - far pointer to null-terminated string
                              C ;      edi - offset into video memory to write
00002656  60                  C     pushad
00002657  06                  C     push    es
00002658  0FA0                C     push    fs
                              C 
0000265A  B848000000          C     mov     eax,_sDATA
0000265F  8EC0                C     mov     es,eax
00002661  B830000000          C     mov     eax,_sMONO
00002666  8EE0                C     mov     fs,eax
00002668  B407                C     mov     ah,7
0000266A                      C     .WHILE (byte ptr ds:[esi] != 0)                                 ; Loop until the NULL terminated string is found
0000266C  AC                  C         lodsb
0000266D  648807              C         mov     byte ptr fs:[edi],al                                ; Write character
00002670  6647                C         inc     di
00002672  648827              C         mov     byte ptr fs:[edi],ah                                ; Write color
00002675  6647                C         inc     di
00002677                      C     .ENDW
                              C 
0000267C  0FA1                C     pop     fs
0000267E  07                  C     pop     es
0000267F  61                  C     popad
00002680                      C     ret
00002681                      C VID_display_string_mono   ENDP
                              C 
                              C 
                              C 
                              C 
                              C ;VID_display_string_ecx_vga      PROC
                              C ;; ds:[esi] - far pointer to null-terminated string
                              C ;;      edi - offset into video memory to write
                              C ;;      ecx - count
                              C ;    pushad
                              C ;    push    es
                              C ;    push    fs
                              C ;
                              C ;    mov     eax,_sDATA
                              C ;    mov     es,eax
                              C ;    mov     eax,_sVGA
                              C ;    mov     fs,eax
                              C ;    mov     ah,7
                              C ;    .REPEAT
                              C ;        lodsb
                              C ;        mov     byte ptr fs:[edi],al                                ; Write character
                              C ;        inc     di
                              C ;        mov     byte ptr fs:[edi],ah                                ; Write color
                              C ;        inc     di
                              C ;    .UNTILCXZ
                              C ;
                              C ;    pop     fs
                              C ;    pop     es
                              C ;    popad
                              C ;    ret
                              C ;VID_display_string_ecx_vga      ENDP
                              C ;
                              C ;
                              C ;
                              C ;
00002681                      C VID_display_string_ecx_mono     PROC
                              C ; ds:[esi] - far pointer to null-terminated string
                              C ;      edi - offset into video memory to write
                              C ;      ecx - count
00002681  60                  C     pushad
00002682  06                  C     push    es
00002683  0FA0                C     push    fs
                              C 
00002685                      C     .IF (ecx != 0)
0000268A  B848000000          C         mov     eax,_sDATA
0000268F  8EC0                C         mov     es,eax
00002691  B830000000          C         mov     eax,_sMONO
00002696  8EE0                C         mov     fs,eax
00002698  B407                C         mov     ah,7
0000269A                      C         .REPEAT
0000269A  AC                  C             lodsb
0000269B  648807              C             mov     byte ptr fs:[edi],al                                ; Write character
0000269E  6647                C             inc     di
000026A0  648827              C             mov     byte ptr fs:[edi],ah                                ; Write color
000026A3  6647                C             inc     di
000026A5                      C         .UNTILCXZ
000026A7                      C     .ENDIF
                              C 
000026A7  0FA1                C     pop     fs
000026A9  07                  C     pop     es
000026AA  61                  C     popad
000026AB                      C     ret
000026AC                      C VID_display_string_ecx_mono     ENDP
                              C ;
                              C ;
                              C ;
                              C ;
                              C ;
000026AC                      C VID_display_hex_string_ecx_mono     PROC
                              C ; ds:[esi] - far pointer to null-terminated string
                              C ;     ecx - number of hexidecimal digits to display
                              C ; offset_mono- pointer into the screen where to start writing
000026AC  60                  C     pushad
000026AD  0FA8                C     push    gs
                              C 
000026AF                      C     .IF (ecx != 0)
000026B4  B830000000          C         mov     eax,_sMONO
000026B9  8EE8                C         mov     gs,eax
000026BB  B407                C         mov     ah,7
000026BD                      C         .REPEAT
000026BD  AC                  C             lodsb
000026BE  8AD0                C             mov     dl,al
000026C0  E830000000          C             call    hex_adjust_al_dl
000026C5  65C60720            C             mov     byte ptr gs:[edi],32                                ; Write a space before hexidecimal values
000026C9  6647                C             inc     di
000026CB  658827              C             mov     byte ptr gs:[edi],ah                                ; Write color
000026CE  6647                C             inc     di
000026D0  658817              C             mov     byte ptr gs:[edi],dl                                ; Write left 1/2 of hexidecimal values character
000026D3  6647                C             inc     di
000026D5  658827              C             mov     byte ptr gs:[edi],ah                                ; Write color
000026D8  6647                C             inc     di
000026DA  658807              C             mov     byte ptr gs:[edi],al                                ; Write right 1/2 of hexidecimal values character
000026DD  6647                C             inc     di
000026DF  658827              C             mov     byte ptr gs:[edi],ah                                ; Write color
000026E2  6647                C             inc     di
000026E4  65C60720            C             mov     byte ptr gs:[edi],32                                ; Write a space after hexidecimal value
000026E8  6647                C             inc     di
000026EA  658827              C             mov     byte ptr gs:[edi],ah                                ; Write color
000026ED  6647                C             inc     di
000026EF                      C         .UNTILCXZ
000026F1                      C     .ENDIF
                              C 
000026F1  0FA9                C     pop     gs
000026F3  61                  C     popad
000026F4                      C     ret
000026F5                      C VID_display_hex_string_ecx_mono     ENDP
                              C 
                              C 
                              C 
                              C 
000026F5                      C hex_adjust_al_dl    PROC
000026F5  C0EA04              C     shr     dl,4
000026F8                      C     .IF (dl <= 9)
000026FD  80C230              C         add     dl,'0'
00002700                      C     .ELSE
00002702  80C257              C         add     dl,'a'-10
00002705                      C     .ENDIF
00002705  240F                C     and     al,0fh
00002707                      C     .IF (al <= 9)
0000270B  0430                C         add     al,'0'
0000270D                      C     .ELSE
0000270F  0457                C         add     al,'a'-10
00002711                      C     .ENDIF
00002711                      C     ret
00002712                      C hex_adjust_al_dl    ENDP
                              C 
                              C 
                              C 
                              C 
00002712                      C init_failed     PROC    NEAR
                              C ; This routine returns to real mode and goes to a section of code that indicates a failed to boot message.
                              C ; It is called when Exodus is trying to boot up but received unexpected information from a device driver before VGA/keyboard
                              C ; support had been installed.
                              C ;
00002712  B838000000          C     mov     eax,_sVGA
00002717  8EE0                C     mov     fs,eax
00002719  B830000000          C     mov     eax,_sMONO
0000271E  8EE8                C     mov     gs,eax
00002720  BFC0030000          C     mov     edi,6*80*2
                              C 
00002725  BE141D0000          C     mov     esi,offset failed
0000272A  B407                C     mov     ah,7
0000272C                      C     .WHILE (esi < offset failed_end)
0000272E  2E8A06              C         mov     al,byte ptr cs:[esi]
00002731  46                  C         inc     esi
00002732                      C         .IF (al == 13)
                              C           ; It's a carriage return
00002736  81C7A0000000        C             add     edi,80*2
0000273C                      C         .ELSEIF (al == 10)
                              C           ; It's a line feed
00002742  50                  C             push    eax
00002743  33D2                C             xor     edx,edx
00002745  8BC7                C             mov     eax,edi
00002747  BBA0000000          C             mov     ebx,80*2
0000274C  F7F3                C             div     ebx
0000274E  F7E3                C             mul     ebx
00002750  8BF8                C             mov     edi,eax
00002752  58                  C             pop     eax
00002753                      C         .ELSEIF (al == '')
00002759  B470                C             mov     ah,112
0000275B                      C         .ELSEIF (al == '')
00002761  B407                C             mov     ah,7
00002763                      C         .ELSEIF (al == '')
00002769  B40F                C             mov     ah,15
0000276B                      C         .ELSEIF (al == '')
00002771  B407                C             mov     ah,7
00002773                      C         .ELSEIF (al == '')
00002779  80C480              C             add     ah,128
0000277C                      C         .ELSE
0000277E  66648907            C             mov     word ptr fs:[edi],ax
00002782  66658907            C             mov     word ptr gs:[edi],ax
00002786  83C702              C             add     edi,2
00002789                      C         .ENDIF
00002789                      C     .ENDW
                              C 
00002791                      C   @@:
00002791  F4                  C     hlt
00002792  EBFD                C     jmp     @B
00002794                      C init_failed     ENDP
                                    INCLUDE ini.asp
                              C ; ini.asp
                              C ;
                              C ; Exodus parse EXODUS.INI routines
                              C ;
                              C ;  Functions:
                              C ;      invParse_Exodus_ini                             ; Locate the Exodus.INI table
                              C ;      invParse_Exodus_ini_build_structure             ; Physically build the bootup structure
                              C ;      invDetermine_Exodus_ini_ownership               ; Calls the requestor('ini ') functions of all native primatives to
                              C ;                                                       ;  find out who the owner of each item is
                              C ;
                              C 
                              C 
                              C 
00002794                      C invFind_Exodus_ini      PROC    NEAR
                              C ; This routine is used to parse the EXODUS.INI
                              C ;
                              C ; Upon entry:   Nothing
                              C ;
                              C ; Upon exit:    The EXODUS.INI text file has been converted
                              C ;
00002794  C8540000            C     enter   84,0
                              C   ;------------
                              C   ; These two variables are defined in this procedure
                              C   ; [ebp-04] - dword, length of exodus.ini
                              C   ; [ebp-08] - dword, linear offset in memory to start of exodus.ini
                              C   ; [ebp-12] - dword, count (number of exodus.ini's found)
                              C   ;------------
                              C   ; The rest of this local variable space is defined and used in invParse_Exodus_ini()
                              C   ; Please look there for their definitions
                              C   ;
00002798  60                  C     pushad
00002799  1E                  C     push    ds
0000279A  06                  C     push    es
0000279B  0FA0                C     push    fs
0000279D  0FA8                C     push    gs
                              C 
0000279F  C745FCFFFFFFFF      C     mov     dword ptr ss:[ebp-04],0ffffffffh                        ; length
000027A6  C745F8FFFFFFFF      C     mov     dword ptr ss:[ebp-08],0ffffffffh                        ; linear offset
000027AD  C745F400000000      C     mov     dword ptr ss:[ebp-12],0                                 ; count
                              C 
000027B4  66B84000            C     mov     ax,_sALL_MEM
000027B8  8ED8                C     mov     ds,eax
000027BA  672E8B3E7B0A        C     mov     edi,cs:boot_parameter_block
000027C0  47                  C     inc     edi                                                     ; Skip past the "drive booted from" byte
                              C   ; Right now, ds:[edi] - far ptr to the boot parameter block
000027C1                      C     .WHILE (byte ptr ds:[edi] != 0ffh)
000027C3  8A4714              C         mov     al,byte ptr ds:[edi+_BOOT_PB_entry_type]
000027C6  240F                C         and     al,1111b
000027C8                      C         .IF (al == 0001b)
                              C           ; It's EXODUS.INI (refer to INF\FILE_SYS.INF for information on these bits)
000027CC  8B17                C             mov     edx,dword ptr ds:[edi+_BOOT_PB_size]
000027CE  8955FC              C             mov     dword ptr ss:[ebp-04],edx
000027D1  8B5716              C             mov     edx,dword ptr ds:[edi+_BOOT_PB_linear_offset]
000027D4  8955F8              C             mov     dword ptr ss:[ebp-08],edx
000027D7  FF45F4              C             inc     dword ptr ss:[ebp-12]
000027DA                      C         .ENDIF
                              C 
000027DA  83C720              C         add     edi,_BOOT_PB_structure_size
000027DD                      C     .ENDW
000027E2                      C     .IF (dword ptr ss:[ebp-12] == 1)
                              C       ; Only one EXODUS.INI was found, so we're in business
000027E8  E875000000          C         call    invParse_Exodus_ini
000027ED                      C         .IF (carry?)
                              C           ; Some error occurred during the parse
000027EF  C745F4FFFFFFFF      C             mov     dword ptr ss:[ebp-12],0ffffffffh
000027F6  EB02                C             jmp     @F
000027F8                      C         .ENDIF
000027F8                      C     .ELSE
                              C       ; More than one EXODUS.INI was found, or there were errors from processing invParse_Exodus_ini() above
000027FA                      C       @@:
                              C       ;; Set the VGA video mode to 80x25 text and the color to red
000027FA  66B84800            C         mov     ax,_sDATA
000027FE  8ED8                C         mov     ds,eax
00002800  E8C9DCFFFF          C         call    invSet_80x25_text_mode
00002805  B00C                C         mov     al,12
00002807  2EFF1DE81A0000      C         call    fword ptr cs:_VID_set_attribute_vga
0000280E  2EFF1DE61A0000      C         call    fword ptr cs:_VID_move_to_next_line_vga
00002815                      C         .IF (dword ptr ss:[ebp-12] == 0ffffffffh)
                              C           ; Error occurred during processing
0000281E  BE85050000          C             mov     esi,offset error_loading_exodus_ini_1
00002823                      C         .ELSEIF (dword ptr ss:[ebp-12] == 0)
                              C           ; No EXODUS.INI was found
0000282B  BEBB050000          C             mov     esi,offset error_loading_exodus_ini_2
00002830                      C         .ELSE
                              C           ; Multiple EXODUS.INI's were found
00002832  BEF9050000          C             mov     esi,offset error_loading_exodus_ini_3
00002837                      C         .ENDIF
00002837  2EFF1DC81A0000      C         call    fword ptr cs:_VID_display_string_nr_vga
                              C 
                              C       ; These messages are in BOOTUP\DATA32.ASP
0000283E  BE3D060000          C         mov     esi,offset error_loading_exodus_ini_4
00002843  2EFF1DC81A0000      C         call    fword ptr cs:_VID_display_string_nr_vga
                              C 
0000284A  BE7A060000          C         mov     esi,offset system_halted
0000284F  2EFF1DC81A0000      C         call    fword ptr cs:_VID_display_string_nr_vga
00002856                      C       @@:
00002856  F4                  C         hlt
00002857  EBFD                C         jmp @B
00002859                      C     .ENDIF
                              C 
                              C 
00002859                      C   finished:
00002859  0FA9                C     pop     gs
0000285B  0FA1                C     pop     fs
0000285D  07                  C     pop     es
0000285E  1F                  C     pop     ds
0000285F  61                  C     popad
00002860  C9                  C     leave
00002861                      C     ret
00002862                      C invFind_Exodus_ini      ENDP
                              C 
                              C 
                              C 
                              C 
                              C 
00002862                      C invParse_Exodus_ini     PROC
                              C ; This routine is used to parse the Exodus.INI file and build an internal structure that's suitable for parsing.
                              C ;
                              C ; Upon entry:   [ebp-04] - length of file
                              C ;               [ebp-08] - offset to start of EXODUS.INI
                              C ;                     ds - _sALL_MEM (used for Exodus.ini and the output structure)
                              C ;               * Note also that this algorithm uses the stack frame/local variables created in invFind_Exodus_ini
                              C ;               * Refer to that algorithm for local variables
                              C ;
                              C ; Upon exit:    The structure is updated
                              C ;               edx - !zero if any errors encountered
                              C ;
                              C ;
                              C   ; The variables above are defined in the invFind_Exodus_ini() algorithm above.
                              C   ; They already exist when this procedure gets control.
                              C   ; [ebp-04] - dword, length of exodus.ini
                              C   ; [ebp-08] - dword, linear offset in memory to start of exodus.ini
                              C   ; [ebp-12] - Note, this value is reused as its significance is no longer significant. :)
                              C   ;----------
                              C   ; These slots are all defined here and are used here and in invParse_Exodus_ini_store_error()
                              C   ; [ebp-12] - dword, line number of exodus.ini
                              C   ; [ebp-16] - dword, are we in a bracket grouping?  0-no, 1-yes
                              C   ; [ebp-20] - dword, are we in a paren grouping?  0-no, 1-yes
                              C   ; [ebp-24] - dword, source line offset (start of)
                              C   ; [ebp-28] - dword, store line to error area?  0-no, 1-yes
                              C   ; [ebp-32] - dword, header offset
                              C   ; [ebp-36] - dword, current bracket group structure item
                              C   ; [ebp-40] - dword, currently processing a bracket group? 0-no, 1-yes
                              C   ; [ebp-44] - dword, currently processing a paren cask? 0-no, 1-yes
                              C   ; [ebp-48] - dword, total # of paren casks
                              C   ; [ebp-52] - dword, count of bytes left in exodus.ini
                              C   ; [ebp-56] - dword, souce line offset (first non-whitespace)
                              C   ; [ebp-60] - dword, current paren cask structure
                              C   ; [ebp-64] - dword, number of chars to backup (due to 's being found)
                              C   ; [ebp-68] - dword, current paren cask structure (if more than one per line)
                              C   ; [ebp-70] - word,  --Nuserved
                              C   ; [ebp-80] - tbyte, miscellaneous BCD values used to report error line numbers, etc
                              C   ; [ebp-84] - dword, last data item
00002862  CC                  C int 3
00002863                      C     ret
00002864  C745F401000000      C     mov     dword ptr ss:[ebp-12],1                                 ; starting line number (base-1)
0000286B  C745F000000000      C     mov     dword ptr ss:[ebp-16],0                                 ; bracket grouping?  0-no
00002872  C745EC00000000      C     mov     dword ptr ss:[ebp-20],0                                 ; paren grouping?  0-no
                              C 
                              C   ; Load the EXODUS.INI variables
00002879  8B4DFC              C     mov     ecx,dword ptr ss:[ebp-04]
0000287C  8B75F8              C     mov     esi,dword ptr ss:[ebp-08]
0000287F  894DCC              C     mov     dword ptr ss:[ebp-52],ecx
                              C 
00002882  BA90010000          C     mov     edx,_sEXODUS_INI
00002887  8EC2                C     mov     es,edx
00002889  BA98010000          C     mov     edx,_sEXODUS_INI_ERRORS
0000288E  8EE2                C     mov     fs,edx
00002890  33FF                C     xor     edi,edi
00002892  33D2                C     xor     edx,edx
                              C   ; Right now,   ecx - count
                              C   ;         ds:[esi] - far ptr to start of exodus.ini
                              C   ;         es:[edi] - where we'll store our converted structure
                              C   ;         fs:[edx] - where we'll store error text
                              C 
                              C   ; Initialize our EXODUS.INI structure
00002894  26C707FFFFFFFF      C     mov     dword ptr es:[edi+_EXODUS_INI_FIRST_BRACKET],0ffffffffh
0000289B  26C7470400000000    C     mov     dword ptr es:[edi+_EXODUS_INI_TOTAL_BYTES],0
000028A3  26C7470800000000    C     mov     dword ptr es:[edi+_EXODUS_INI_TOTAL_BRACKET_GROUPS],0
000028AB  26C7470C00000000    C     mov     dword ptr es:[edi+_EXODUS_INI_TOTAL_PAREN_CASKS],0
                              C 
                              C   ; Initalize our starting variables
000028B3  897DE0              C     mov     dword ptr ss:[ebp-32],edi                               ; Start of header
000028B6  83C710              C     add     edi,_EXODUS_INI_HEADER_LENGTH
000028B9  897DDC              C     mov     dword ptr ss:[ebp-36],edi                               ; Start of data
                              C 
000028BC  C745D800000000      C     mov     dword ptr ss:[ebp-40],0                                 ; No bracket group
000028C3  C745D400000000      C     mov     dword ptr ss:[ebp-44],0                                 ; No paren cask
                              C 
                              C   ; Right now, es:[edi] - ready for starting structure
000028CA                      C     .WHILE (dword ptr ss:[ebp-52] > 0)
                              C       ; Skip passed any leading spaces or tabs
000028CF  C745E400000000      C         mov     dword ptr ss:[ebp-28],0                             ; store line to error area?  0-no
000028D6  8975E8              C         mov     dword ptr ss:[ebp-24],esi                           ; start of line
000028D9                      C         .WHILE (byte ptr ds:[esi] == 32 || byte ptr ds:[esi] == 9 && dword ptr ss:[ebp-52] > 0)
000028DB  46                  C             inc     esi
000028DC  FF4DCC              C             dec     dword ptr ss:[ebp-52]
000028DF                      C         .ENDW
000028EF  837DCC00            C         cmp     dword ptr ss:[ebp-52],0
000028F3  0F84EF020000        C         jz      finished
                              C 
                              C       ; Right now we're passed the white spaces
000028F9  8B06                C         mov     eax,dword ptr ds:[esi]
000028FB                      C         .IF (al == ';' || ax == 0d0ah || ax == 0a0dh)
                              C           ; This is a comment line, we skip it
0000290B  E972020000          C             jmp     next_line
00002910                      C         .ENDIF
                              C 
                              C       ; Store first non-whitespace offset
00002910  8975C8              C         mov     dword ptr ss:[ebp-56],esi
                              C 
                              C       ; Right now we're at the start of something
00002913                      C         .IF (al == '[')
                              C           ; It's the start of a bracket grouping
0000291B                      C             .IF (dword ptr ss:[ebp-40] != 0)
                              C               ; We're already processing a bracket group, we have to close this one out
00002921  8B5DDC              C                 mov     ebx,dword ptr ss:[ebp-36]
                              C               ; Right now, es:[ebx] - far ptr to previous bracket group structure
00002924  26893B              C                 mov     dword ptr es:[ebx+_EXODUS_BRACKET_NEXT],edi
00002927                      C             .ELSE
                              C               ; We're starting anew
                              C               ; Update header (if necessary)
00002929  8B5DE0              C                  mov     ebx,dword ptr ss:[ebp-32]
0000292C                      C                 .IF (dword ptr es:[ebx+_EXODUS_INI_FIRST_BRACKET] == 0ffffffffh)
00002935  8B45DC              C                     mov     eax,dword ptr ss:[ebp-36]
00002938  268903              C                     mov     dword ptr es:[ebx+_EXODUS_INI_FIRST_BRACKET],eax
0000293B                      C                 .ENDIF
0000293B                      C             .ENDIF
                              C           ; Get the name into eax
0000293B  33C0                C             xor     eax,eax
0000293D  33C9                C             xor     ecx,ecx
0000293F  46                  C             inc     esi
00002940  FF4DCC              C             dec     dword ptr ss:[ebp-52]
00002943                      C             .WHILE (dword ptr ss:[ebp-52] > 0 && ecx < 4 && byte ptr ds:[esi] != ']')
00002945  C1E008              C                 shl     eax,8
00002948  8A06                C                 mov     al,byte ptr ds:[esi]
0000294A  46                  C                 inc     esi
0000294B  FF4DCC              C                 dec     dword ptr ss:[ebp-52]
0000294E  41                  C                 inc     ecx
0000294F                      C             .ENDW
0000295F                      C             .IF (ecx == 4)
                              C               ; The bracket group's name is too long
00002964  BB07070000          C                 mov     ebx,offset parse_bracket_group_name_too_long
00002969  E87B020000          C                 call    invParse_Exodus_ini_store_error
0000296E  C745E401000000      C                 mov     dword ptr ss:[ebp-28],1
00002975  E908020000          C                 jmp     next_line
0000297A                      C             .ENDIF
0000297A                      C             .IF (byte ptr ds:[esi] != ']')
                              C               ; We hit the end of file before we loaded everything
0000297F  BBF0060000          C                 mov     ebx,offset parse_unexpected_end_of_file
00002984  E860020000          C                 call    invParse_Exodus_ini_store_error
00002989  C745E401000000      C                 mov     dword ptr ss:[ebp-28],1
00002990  E9ED010000          C                 jmp     next_line
00002995                      C             .ENDIF
                              C 
                              C           ; Everything is good
                              C           ; Pad any names less than 4 characters with spaces
00002995                      C             .WHILE (ecx < 4)
00002997  C1E008              C                 shl     eax,8
0000299A  B020                C                 mov     al,32
0000299C  41                  C                 inc     ecx
0000299D                      C             .ENDW
                              C 
                              C           ; Right now, eax contains the name to use
                              C           ; Initialize this item's structure
000029A2  26C707FFFFFFFF      C             mov     dword ptr es:[edi+_EXODUS_BRACKET_NEXT],0ffffffffh
000029A9  26C74704FFFFFFFF    C             mov     dword ptr es:[edi+_EXODUS_BRACKET_PAREN_CASKS],0ffffffffh
000029B1  26C7470800000000    C             mov     dword ptr es:[edi+_EXODUS_BRACKET_TOTAL_PARENS],0
000029B9  2689470C            C             mov     dword ptr es:[edi+_EXODUS_BRACKET_NAME],eax
000029BD  26C74710FFFFFFFF    C             mov     dword ptr es:[edi+_EXODUS_BRACKET_HANDLE],0ffffffffh
000029C5  6626C74714FFFF      C             mov     word ptr es:[edi+_EXODUS_BRACKET_REQUESTOR],0ffffh
000029CC  26C74716FFFFFFFF    C             mov     dword ptr es:[edi+_EXODUS_BRACKET_REQUESTOR_FUNC],0ffffffffh
000029D4  26C7471AFFFFFFFF    C             mov     dword ptr es:[edi+_EXODUS_BRACKET_SCRATCH_AREA],0ffffffffh
                              C 
                              C           ; Raise/lower the flags
000029DC  C745D801000000      C             mov     dword ptr ss:[ebp-40],1                     ; Bracket group flag
000029E3  C745D400000000      C             mov     dword ptr ss:[ebp-44],0                     ; Paren cask flag
                              C 
                              C           ; Store the current bracket group pointer
000029EA  897DDC              C             mov     dword ptr ss:[ebp-36],edi
                              C 
                              C           ; Move past this structure (for future data)
000029ED  83C71E              C             add     edi,_EXODUS_BRACKET_LENGTH
                              C 
000029F0                      C         .ELSEIF (al == '(')
                              C           ; It's the start of a paren cask
000029FD  CC                  C int 3
000029FE                      C             .IF (dword ptr ss:[ebp-44] != 0)
                              C               ; We're already processing a cask, we have to close this one out
00002A04  8B5DC4              C                 mov     ebx,dword ptr ss:[ebp-60]
                              C               ; Right now, es:[ebx] - far ptr to previous bracket group structure
00002A07  26893B              C                 mov     dword ptr es:[ebx+_EXODUS_PAREN_NEXT],edi
00002A0A                      C             .ELSE
                              C               ; We're starting anew
                              C               ; Update bracket group item (if necessary)
00002A0C  8B5DDC              C                 mov     ebx,dword ptr ss:[ebp-36]
00002A0F  26894304            C                 mov     dword ptr es:[ebx+_EXODUS_BRACKET_PAREN_CASKS],eax
00002A13                      C             .ENDIF
                              C 
                              C           ; Lower flag for more than one cask per line
00002A13  C745BCFFFFFFFF      C             mov     dword ptr ss:[ebp-68],0ffffffffh
                              C 
                              C           ; Initialize this item's structure
00002A1A                      C           do_next_cask:
00002A1A  26C707FFFFFFFF      C             mov     dword ptr es:[edi+_EXODUS_PAREN_NEXT],0ffffffffh
00002A21  26C74704FFFFFFFF    C             mov     dword ptr es:[edi+_EXODUS_PAREN_NEXT_SAME_LINE],0ffffffffh
00002A29  26C74708FFFFFFFF    C             mov     dword ptr es:[edi+_EXODUS_PAREN_DATA_ITEMS],0ffffffffh
00002A31  26C7470C00000000    C             mov     dword ptr es:[edi+_EXODUS_PAREN_TOTAL_DATA_ITEMS],0
00002A39  26897710            C             mov     dword ptr es:[edi+_EXODUS_PAREN_SOURCE_LINE],esi
00002A3D  26C7471400000000    C             mov     dword ptr es:[edi+_EXODUS_PAREN_SOURCE_LINE_LENGTH],0
00002A45  26C74718FFFFFFFF    C             mov     dword ptr es:[edi+_EXODUS_PAREN_HANDLE],0ffffffffh
00002A4D  6626C7471AFFFF      C             mov     word ptr es:[edi+_EXODUS_PAREN_REQUESTOR],0ffffh
00002A54  26C7471EFFFFFFFF    C             mov     dword ptr es:[edi+_EXODUS_PAREN_REQUESTOR_FUNC],0ffffffffh
00002A5C  26C74722FFFFFFFF    C             mov     dword ptr es:[edi+_EXODUS_PAREN_SCRATCH_AREA],0ffffffffh
                              C 
                              C           ; Raise/lower the flags
00002A64  C745D401000000      C             mov     dword ptr ss:[ebp-44],1                         ; Raise the "processing paren cask" flag
00002A6B  C745C000000000      C             mov     dword ptr ss:[ebp-64],0                         ; Back off for  chars
                              C 
                              C           ; Copy current structure pointer to ebx
00002A72  8BDF                C             mov     ebx,edi
                              C           ; And move to next structure pointer in edi
00002A74  83C726              C             add     edi,_EXODUS_PAREN_LENGTH
                              C 
                              C           ; Now, process the cask to load all of its data items
                              C           ; Right now, ebx - used as the pointer to the current structure
00002A77  46                  C             inc     esi
00002A78  FF4DCC              C             dec     dword ptr ss:[ebp-52]
00002A7B  26FF4314            C             inc     dword ptr es:[ebx+_EXODUS_PAREN_SOURCE_LINE_LENGTH]
                              C 
                              C           ; Create the data item structure
00002A7F  C745ACFFFFFFFF      C             mov     dword ptr ss:[ebp-84],0ffffffffh                ; Lower the "last data item" flag
00002A86                      C           do_next_data_item:
00002A86  26C707FFFFFFFF      C             mov     dword ptr es:[edi+_EXODUS_DATA_NEXT],0ffffffffh
00002A8D  26897704            C             mov     dword ptr es:[edi+_EXODUS_DATA_DATA_ITEM_SOURCE],esi
00002A91  26C7470800000000    C             mov     dword ptr es:[edi+_EXODUS_DATA_DATA_ITEM_LENGTH],0
00002A99                      C             .WHILE (byte ptr ds:[esi] != ')' && dword ptr ss:[ebp-52] > 0 && word ptr ds:[esi] != 0d0ah && word ptr ds:[esi] != 0a0dh)
00002A9B                      C                 .IF (byte ptr ds:[esi] == '')
                              C                   ; We skip past this character and assume that the next one is the real one
                              C                   ; This character means "whatever is next is to be used literally", thereby giving a way for () and | chars to
                              C                   ; be used as data within a cask (also, if the  character needs to appear it has to be represented by )
00002AA0  FF45C0              C                     inc     dword ptr ss:[ebp-64]
00002AA3                      C                 .ELSE
00002AA5                      C                     .IF (byte ptr ds:[esi] == '|' || byte ptr ds:[esi] == ')')
                              C                       ; This is a data item separator or a cask closer
00002AAF  8BD6                C                         mov     edx,esi
00002AB1  262B5704            C                         sub     edx,dword ptr es:[edi+_EXODUS_DATA_DATA_ITEM_SOURCE]
00002AB5  26895708            C                         mov     dword ptr es:[edi+_EXODUS_DATA_DATA_ITEM_LENGTH],edx
00002AB9                      C                         .IF (dword ptr ss:[ebp-84] == 0ffffffffh)
                              C                           ; This is the first data item
00002AC2  897DAC              C                             mov     dword ptr ss:[ebp-84],edi
00002AC5  26897B08            C                             mov     dword ptr es:[ebx+_EXODUS_PAREN_DATA_ITEMS],edi
00002AC9                      C                         .ELSE
00002ACB  8B55AC              C                             mov     edx,dword ptr ss:[ebp-84]
00002ACE  26893A              C                             mov     dword ptr es:[edx+_EXODUS_DATA_NEXT],edi
00002AD1                      C                         .ENDIF
00002AD1  26FF430C            C                         inc     dword ptr es:[ebx+_EXODUS_PAREN_TOTAL_DATA_ITEMS]
00002AD5  83C70C              C                         add     edi,_EXODUS_DATA_LENGTH
00002AD8  EBAC                C                         jmp     do_next_data_item
00002ADA                      C                     .ENDIF
00002ADA                      C                 .ENDIF
00002ADA                      C                 .IF (dword ptr ss:[ebp-52] > 0)
00002AE0  46                  C                     inc     esi
00002AE1  FF4DCC              C                     dec     dword ptr ss:[ebp-52]
00002AE4  26FF4314            C                     inc     dword ptr es:[ebx+_EXODUS_PAREN_SOURCE_LINE_LENGTH]
00002AE8                      C                 .ENDIF
00002AE8                      C             .ENDW
00002B01                      C             .IF (dword ptr ss:[ebp-52] == 0 || word ptr ds:[esi] != 0d0ah || word ptr ds:[esi] != 0a0dh)
                              C               ; We have unexpectedly hit the end of file
00002B15  BBF0060000          C                 mov     ebx,offset parse_unexpected_end_of_file
00002B1A  E8CA000000          C                 call    invParse_Exodus_ini_store_error
00002B1F  C745E401000000      C                 mov     dword ptr ss:[ebp-28],1
00002B26  EB5A                C                 jmp     next_line
00002B28                      C             .ENDIF
                              C 
00002B28                      C           cask_finished:
                              C           ; We're past this cask, see if there are any more on the same line
00002B28                      C             .WHILE (byte ptr ds:[esi] == 32 || byte ptr ds:[esi] == 9 && dword ptr ss:[ebp-52] > 0)
00002B2A  46                  C                 inc     esi
00002B2B  FF4DCC              C                 dec     dword ptr ss:[ebp-52]
00002B2E                      C             .ENDW
00002B3E                      C             .IF (dword ptr ss:[ebp-52] == 0 || byte ptr ds:[esi] != '(')
00002B49  EB37                C                 jmp     next_line
00002B4B                      C             .ENDIF
                              C 
00002B4B                      C             .IF (byte ptr ds:[esi] == '(')
                              C               ; There is another cask, we need to process this one
00002B50  26897B04            C                 mov     dword ptr es:[ebx+_EXODUS_PAREN_NEXT_SAME_LINE],edi
00002B54  897DBC              C                 mov     dword ptr ss:[ebp-68],edi
00002B57  E9BEFEFFFF          C                 jmp     do_next_cask
00002B5C                      C             .ELSE
00002B5E  BBE5060000          C                 mov     ebx,offset parse_expected_paren
00002B63  E881000000          C                 call    invParse_Exodus_ini_store_error
00002B68  C745E401000000      C                 mov     dword ptr ss:[ebp-28],1
00002B6F                      C             .ENDIF
                              C 
00002B6F                      C         .ELSE
                              C           ; This is an error.  Lines cannot stand by themselves with data on it
00002B71  BBD5060000          C             mov     ebx,offset parse_expected_bracket_paren
00002B76  E86E000000          C             call    invParse_Exodus_ini_store_error
00002B7B  C745E401000000      C             mov     dword ptr ss:[ebp-28],1
00002B82                      C         .ENDIF
                              C 
00002B82                      C       next_line:
                              C       ; Skip until we reach the end of the line
00002B82                      C         .IF (dword ptr ss:[ebp-28] != 0)
                              C           ; We have to copy this line to the error output
00002B88  8B75E8              C             mov     esi,dword ptr ss:[ebp-24]
00002B8B                      C         .ENDIF
00002B8B                      C         .WHILE (word ptr ds:[esi] != 0d0ah && word ptr ds:[esi] != 0a0dh && dword ptr ss:[ebp-52] > 0)
00002B8D                      C             .IF (dword ptr ss:[ebp-28] != 0)
                              C               ; We need to copy this line to the error area
00002B93  8A06                C                 mov     al,byte ptr ds:[esi]
00002B95  648802              C                 mov     byte ptr fs:[edx],al
00002B98  42                  C                 inc     edx
00002B99                      C             .ENDIF
00002B99  46                  C             inc     esi
00002B9A  FF4DCC              C             dec     dword ptr ss:[ebp-52]
00002B9D                      C         .ENDW
00002BB1                      C         .IF (dword ptr ss:[ebp-28] != 0)
                              C           ; Store CR/LF to the error line
00002BB7  6664C7020D0A        C             mov     word ptr fs:[edx],0a0dh
00002BBD  83C202              C             add     edx,2
00002BC0                      C         .ENDIF
00002BC0                      C         .IF ((word ptr ds:[esi] == 0d0ah || word ptr ds:[esi] == 0a0dh) && dword ptr ss:[ebp-52] >= 2)
00002BD4  83C602              C             add     esi,2
00002BD7  836DCC02            C             sub     dword ptr ss:[ebp-52],2
00002BDB                      C         .ENDIF
00002BDB  FF45F4              C         inc     dword ptr ss:[ebp-12]                               ; increase line number
00002BDE                      C     .ENDW
                              C 
00002BE8                      C   finished:
00002BE8                      C     ret
00002BE9                      C invParse_Exodus_ini     ENDP
                              C 
                              C 
                              C 
                              C 
00002BE9                      C invParse_Exodus_ini_store_error     PROC
                              C ; This routine is used to copy the line number and an error message from cs:[ebx] to fs:[edx]
                              C ;
                              C ; Upon entry:   cs:[ebx] - far ptr to null-terminated message to store
                              C ;               fs:[edx] - far ptr to where to store
                              C ;
                              C ; Upon exit:    It's stored
                              C ;               edx - where the next message will be stored
                              C ;
00002BE9  53                  C     push    ebx
                              C 
                              C ;-------
00002BEA  56                  C     push    esi
00002BEB  51                  C     push    ecx
00002BEC  53                  C     push    ebx
00002BED  06                  C     push    es
                              C 
                              C   ; Store the line number
00002BEE  B848000000          C     mov     eax,_sDATA
00002BF3  8EC0                C     mov     es,eax
00002BF5  9BDBE3              C     finit
00002BF8  DB45F4              C     fild    dword ptr ss:[ebp-12]
00002BFB  DF75B0              C     fbstp   tbyte ptr ss:[ebp-80]
00002BFE  8B45B0              C     mov     eax,dword ptr ss:[ebp-80]
00002C01  BECF060000          C     mov     esi,offset line_text + 5
                              C   ; Right now, eax contains the BCD nibbles of the current line number
00002C06  B908000000          C     mov     ecx,8                                                   ; This lowers the flag in ch and stores 8 to cl
00002C0B                      C   @@:
00002C0B  C1C004              C     rol     eax,4
00002C0E  8AD8                C     mov     bl,al
00002C10  80E30F              C     and     bl,0fh
00002C13                      C     .IF (bl != 0 || (bl == 0 && ch != 0))
                              C       ; We're storing this value
00002C22  80C330              C         add     bl,'0'
00002C25  26881E              C         mov     byte ptr es:[esi],bl
00002C28  46                  C         inc     esi
00002C29  B501                C         mov     ch,1                                                ; raise the flag to copy bytes
00002C2B                      C     .ENDIF
00002C2B  FEC9                C     dec     cl
00002C2D  75DC                C     jnz     @B
00002C2F  26C706202D2000      C     mov     dword ptr es:[esi+0],00202d20h                          ; this is "<null>_-_"
                              C 
                              C   ; Store the line number
00002C36  BECA060000          C     mov     esi,offset line_text
00002C3B                      C     .WHILE (byte ptr es:[esi] != 0)
00002C3D  268A06              C         mov     al,byte ptr es:[esi]
00002C40  46                  C         inc     esi
00002C41  648802              C         mov     byte ptr fs:[edx],al
00002C44  42                  C         inc     edx
00002C45                      C     .ENDW
                              C 
00002C4B  07                  C     pop     es
00002C4C  5B                  C     pop     ebx
00002C4D  59                  C     pop     ecx
00002C4E  5E                  C     pop     esi
                              C ;-------
                              C 
                              C   ; Store the error message
00002C4F                      C     .WHILE (byte ptr cs:[ebx] != 0)
00002C51  2E8A03              C         mov     al,byte ptr cs:[ebx]
00002C54  43                  C         inc     ebx
00002C55  648802              C         mov     byte ptr fs:[edx],al
00002C58  42                  C         inc     edx
00002C59                      C     .ENDW
                              C 
                              C   ; Store the trailing CR/LF
00002C5F  6664C7020D0A        C     mov     word ptr fs:[edx],0a0dh
00002C65  83C202              C     add     edx,2
                              C 
00002C68  5B                  C     pop     ebx
00002C69                      C     ret
00002C6A                      C invParse_Exodus_ini_store_error     ENDP
                              C 
                              C 
                              C 
00002C6A                      C invDetermine_Exodus_ini_ownership       PROC    NEAR
                              C ; This routine is used to call all of the Requestor('ini ') routines for all the native primatives.  It allows them to decide
                              C ; what items in the exodus.ini file they have ownership of
                              C ;
                              C ; Upon entry:   Nothing
                              C ;
                              C ; Upon exit:    Nothing
                              C ;
                              C 
00002C6A                      C     ret
                              C 
00002C6B                      C invDetermine_Exodus_ini_ownership       ENDP
                                    INCLUDE req.asp                                                 ; requestor()
                              C ; req.asp
                              C ;
                              C ; Exodus requestor()
                              C ; January 02, 2001
                              C ;
                              C ; * Refer to inf\requestr.inf for more information
                              C ; * The Exodus requestor call gate points here.  It is _sEXODUS_REQUESTOR
                              C ;
                              C ;  Functions:
                              C ;     requestor                        ; Exodus's requestor function
                              C ;
                              C ;
                              C 
                              C 
                              C 
                              C 
                              C 
00002C6B                      C requestor       PROC    NEAR
                              C ; This routine is responsible for all Exodus requestor functions
                              C ; Only FAR CALLS will be made to this routine
                              C ; * Refer to inf\requestr.inf for info on this function
                              C ; * Refer to inf\exodus.inf for info on the data structures used in memory regions _sEXODUS_MEM, _sEXODUS_PORTS and _sEXODUS_INTS
                              C ;
                              C ; Upon entry:   eax - requestor request
                              C ;             other - varies
                              C ;
                              C ; Upon exit:  varies based on input
                              C ;
                              C   ; [ebp+08] - dword, cs
                              C   ; [ebp+04] - dword, eip
                              C   ; [ebp+00] - dword, ebp
00002C6B  C8140000            C     enter   20,0
                              C   ; [ebp-04] - dword, --Nuserved                                    ; This space was reserved for future expansion
                              C   ; [ebp-08] - dword, --Nuserved
                              C   ; [ebp-12] - dword, --Nuserved
                              C   ; [ebp-16] - dword, --Nuserved
                              C   ; [ebp-20] - dword, --Nuserved
00002C6F  0FA0                C     push    fs
                              C   ; [ebp-24] - dword, fs
00002C71  60                  C     pushad
                              C   ; [ebp-28] - dword, eax                                           ; These locations are noted in case some variables need
                              C   ; [ebp-32] - dword, ecx                                           ; to be updated for the return
                              C   ; [ebp-36] - dword, edx
                              C   ; [ebp-40] - dword, ebx
                              C   ; [ebp-44] - dword, esp
                              C   ; [ebp-48] - dword, ebp
                              C   ; [ebp-52] - dword, esi
                              C   ; [ebp-56] - dword, edi
                              C 
00002C72                      C     .IF (eax == 'bmem')
                              C       ; They're requesting a quantity of memory
                              C       ; Upon entry: dl - action  0-free memory
                              C       ;                               ebx - number of bytes requested
                              C       ;                            1-allocate memory
                              C       ;                               dx - previous selector
                              C       ;                            2-make smaller
                              C       ;                                ebx - new number of bytes
                              C       ;                                dx - previous selector
                              C       ; Upon exit:  carry? - SET if ERROR, CLEAR if OK
                              C       ;                 dx - block selector if successful
                              C       ;
00002C7D  66B85000            C         mov     ax,_sEXODUS_MEM
00002C81  668EE0              C         mov     fs,ax
00002C84  BE04000000          C         mov     esi,4
00002C89                      C         .IF (dl == 0)
                              C           ; They want to free up a little memory, you know ... for old time's sake.
00002C8E                      C         .ELSEIF (dl == 1)
                              C           ; They want a hunk of our precious memory ... so, what the hell ... we'll oblige
00002C9C                      C             .WHILE (esi < dword ptr fs:[0])
00002CA1  648A06              C                 mov     al,byte ptr fs:[esi]
00002CA4                      C                 .IF (al == 0 && dword ptr fs:[esi+_EXODUS_MEM_limit] >= ebx)
                              C                   ; This block is free and it's big enough
                              C                   ; Update it with the new information
00002CB2  8B5508              C                     mov     edx,dword ptr ss:[ebp+08]               ; Get the calling code segment off the stack
00002CB5  8BCA                C                     mov     ecx,edx                                 ; Find out what PL it is
00002CB7  83E103              C                     and     ecx,011b
00002CBA                      C                     .IF (dword ptr fs:[esi+_EXODUS_MEM_limit] == ebx)
                              C                       ; They're exactly the same size
00002CC0                      C                         .IF (dx == _sCODE)
                              C                           ; It's Exodus itself
00002CC6  64C60601            C                             mov     byte ptr fs:[esi+_EXODUS_MEM_type],1
00002CCA  666489560C          C                             mov     word ptr fs:[esi+_EXODUS_MEM_gdt],dx
00002CCF  F8                  C                             clc
00002CD0                      C                         .ELSEIF (dx >= (_MIN_PRIMATIVE * 8) && dx <= (_MAX_PRIMATIVE * 8) && ecx == 0)
                              C                           ; It's a native primative
00002CE5  666489560C          C                             mov     word ptr fs:[esi+_EXODUS_MEM_gdt],dx
00002CEA  1E                  C                             push    ds
00002CEB  66B99800            C                             mov     cx,_sPRIMATIVES
00002CEF  668ED9              C                             mov     ds,cx
00002CF2                      C                             .IF (dword ptr ds:[4] < _MAX_PRIMATIVE)
                              C                               ; We have room to add this into their memory space
00002CFD  67A10400            C                                 mov     eax,dword ptr ds:[4]
00002D01  67FF060400          C                                 inc     dword ptr ds:[4]                            ; Move to next call gate
00002D06  64C60602            C                                 mov     byte ptr fs:[esi+_EXODUS_MEM_type],2        ; This is a user application (primative)
00002D0A  666489560C          C                                 mov     word ptr fs:[esi+_EXODUS_MEM_gdt],dx        ; Store their code segment
00002D0F  666489460E          C                                 mov     word ptr fs:[esi+_EXODUS_MEM_ldt],ax        ; Store the GDT where this block will go
                              C                               ; Right now, ebx - number of bytes requested
                              C                               ;             ax - GDT slot where it will go
00002D14  F8                  C                                 clc
00002D15                      C                             .ELSE
00002D17  F9                  C                                 stc
00002D18                      C                             .ENDIF
00002D18  1F                  C                             pop     ds
00002D19  E91F050000          C                             jmp     requestor_quit
00002D1E                      C                         .ELSE
                              C                           ; It's a user application
00002D20  666489560C          C                             mov     word ptr fs:[esi+_EXODUS_MEM_gdt],dx
                              C                           ; We have to add in the LDT of the calling program
                              C ;; REMEMBER
00002D25                      C                         .ENDIF
00002D25                      C                     .ELSE
                              C                       ; It's bigger, so we have to update this one and add a new entry
                              C 
00002D27                      C                     .ENDIF
                              C                   ; Create an entry in the user's LDT
00002D27  F8                  C                     clc
00002D28  E910050000          C                     jmp     requestor_quit
00002D2D                      C                 .ENDIF
00002D2D  83C610              C                 add     esi,_EXODUS_MEM_size
00002D30                      C             .ENDW
                              C           ; If we're here then there were no free memory blocks, or none of sufficient size (out of memory)
                              C 
00002D3C                      C         .ELSEIF (dl == 2)
                              C           ; They want to decrease a previously allocated block of memory
                              C 
00002D43                      C         .ELSE
                              C           ; And now ... here they are on our doorstep asking for more.  The greedy little programs!
00002D45  F9                  C             stc
00002D46                      C         .ENDIF
                              C       ; If we're here, then there were some error
00002D46  F9                  C         stc
00002D47                      C     .ELSEIF (eax == 'bprt')
                              C       ; They're requesting exclusive access to a particular port (or range of ports)
                              C       ; Upon entry: ebx - number of ports
                              C       ;             edx - starting port
                              C       ;
                              C       ; Upon exit:  carry? - CLEAR=ok, SET=nope, can't have it
                              C       ;
00002D53  66B85800            C         mov     ax,_sEXODUS_PORTS
00002D57  668EE0              C         mov     fs,ax
00002D5A  BE04000000          C         mov     esi,4
00002D5F                      C         .WHILE (esi < dword ptr fs:[0])
00002D61  83C610              C             add     esi,_EXODUS_PORTS_size
00002D64                      C         .ENDW
00002D6C                      C     .ELSEIF (eax == 'bint')
                              C       ; They're requesting exclusive access to a particular interrupt (or range of interrupts)
                              C       ; Upon entry:  bl - interrupt
                              C       ;              cl - count
                              C       ;             edx - offset to interrupt service routine
                              C       ;
                              C       ; Upon exit:  carry? - CLEAR=ok, SET=nope, can't have it
                              C       ;
00002D78  66B86000            C         mov     ax,_sEXODUS_INTS
00002D7C  668EE0              C         mov     fs,ax
00002D7F  BE04000000          C         mov     esi,4
                              C 
00002D84  8AFB                C         mov     bh,bl
00002D86  02F9                C         add     bh,cl
00002D88  FECF                C         dec     bh
                              C       ; Right now, bl - starting interrupt
                              C       ;            bh - ending interrupt
00002D8A                      C         .WHILE (esi < dword ptr fs:[0])
00002D8C  66648B06            C             mov     ax,word ptr fs:[esi]
00002D90  8AEC                C             mov     ch,ah
00002D92  FEC8                C             dec     al
00002D94  02E8                C             add     ch,al
                              C           ; Right now, ah - starting interrupt
                              C           ;            ch - ending interrupt
00002D96                      C             .IF ((bl >= ah && bl <= ch) || (bh >= ah && bh <= ch))
                              C               ; This one is already used
00002DA6  F9                  C                 stc
00002DA7  E991040000          C                 jmp     requestor_quit
00002DAC                      C             .ENDIF
00002DAC  83C602              C             add     esi,_EXODUS_INTS_size
00002DAF                      C         .ENDW
00002DB7                      C         .IF (esi == _sEXODUS_INTS_limit)
                              C           ; We're at the end
00002DBF  F9                  C             stc
00002DC0  E978040000          C             jmp     requestor_quit
00002DC5                      C         .ENDIF
                              C       ; If we're here, then it wasn't used.  We add it.
00002DC5  64880E              C         mov     byte ptr fs:[esi],cl
00002DC8  64885E01            C         mov     byte ptr fs:[esi+1],bl
                              C 
                              C       ; Now, create the IDT entry(s)
00002DCC  81E1FF000000        C         and     ecx,0ffh
                              C       ; Right now,  bl - starting interrupt number
                              C       ;            ecx - number of interrupts to intercept/keep
                              C       ;            edx - offset to ISR
00002DD2  8AC3                C         mov     al,bl
00002DD4  25FF000000          C         and     eax,0ffh
00002DD9  8B5D08              C         mov     ebx,dword ptr ss:[ebp+08]
00002DDC                      C         .REPEAT
                              C           ; Right now, eax - interrupt number to update
                              C           ;            edx - offset to ISR
                              C           ;             bx - selector to ISR
00002DDC  E83CD6FFFF          C             call    invUpdate_interrupt_descriptor32
00002DE1  40                  C             inc     eax
00002DE2                      C         .UNTILCXZ
00002DE4  F8                  C         clc
00002DE5                      C     .ELSEIF (eax == 'boot')
00002DF1                      C         .IF (ebx == 'logo')
00002DF9  1E                  C             push    ds
                              C 
00002DFA  B848000000          C             mov     eax,_sDATA
00002DFF  8ED8                C             mov     ds,eax
00002E01  BE6A070000          C             mov     esi,offset bootscreen_start
00002E06  B954130000          C             mov     ecx,offset bootscreen_end - bootscreen_start
00002E0B  2EFF1DEC1A0000      C             call    fword ptr cs:_VID_draw_exodus_boot_screen
                              C 
00002E12  1F                  C             pop     ds
00002E13                      C         .ENDIF
00002E13                      C     .ELSEIF (eax == 'find' && edi == 'func')
                              C       ; They want to find a function by it's call gate and an offset
                              C       ;
                              C       ; Upon entry:   edx - code segment
                              C       ;               ebx - instruction pointer
                              C       ;          ds:[esi] - far ptr where to store
                              C       ;               ecx - maximum # of bytes to store
                              C       ;
                              C       ; Upon exit:    If found it's inserted, if not then it's not
                              C       ;
                              C       ; [ebp+12]+ (other parameters)
                              C       ; [ebp+08] - cs
                              C       ; [ebp+04] - eip
                              C       ; [ebp+00] - ebp
00002E2F  C8140000            C         enter   20,0
                              C       ; [ebp-04] - dword, edx at start
                              C       ; [ebp-08] - dword, ebx at start
                              C       ; [ebp-12] - dword, Last pointer to primative that was found
                              C       ; [ebp-16] - dword, Distance from primative offset to ebx at start (indicates how far away from start of function it is)
                              C       ; [ebp-20] - dword, ecx at start
00002E33  8955FC              C         mov     dword ptr ss:[ebp-04],edx
00002E36  895DF8              C         mov     dword ptr ss:[ebp-08],ebx
00002E39  C745F4FFFFFFFF      C         mov     dword ptr ss:[ebp-12],0ffffffffh
00002E40  C745F0FFFFFFFF      C         mov     dword ptr ss:[ebp-16],0ffffffffh
00002E47  894DEC              C         mov     dword ptr ss:[ebp-20],ecx
                              C 
00002E4A  06                  C         push    es
00002E4B  B848000000          C         mov     eax,_sDATA
00002E50  668EC0              C         mov     es,ax
00002E53  8BC2                C         mov     eax,edx
00002E55  83E003              C         and     eax,011b
00002E58                      C         .IF (eax == 011b)
                              C           ; It's a ring-3 application
                              C ;; REMEMBER
                              C           ; Indicate it's an unknown user function
00002E5D  BF57050000          C             mov     edi,offset unknown_user_function_text
00002E62  F9                  C             stc
00002E63  E939010000          C             jmp     find_func_copy_text
00002E68                      C         .ELSE
00002E6D                      C             .IF (edx >= _MIN_PRIMATIVE*8 && edx <= _MAX_PRIMATIVE*8)
00002E85  B898000000          C                 mov     eax,_sPRIMATIVES
00002E8A  668EE0              C                 mov     fs,ax
00002E8D  BF08000000          C                 mov     edi,8                                       ; Start after this structure, see inf\primload.inf
00002E92                      C                 .WHILE (edi < dword ptr fs:[0])
00002E94                      C                     .IF (byte ptr fs:[edi+2] == 1)
                              C                       ; This one is active, lookup the GDT entry to determine the code selector and offset
00002E9B  640FB707            C                         movzx   eax,word ptr fs:[edi]               ; Get the GDT entry for this primative
00002E9F  E868D3FFFF          C                         call    invExtract_call_gate_descriptor32
00002EA4                      C                         .IF (edx == dword ptr ss:[ebp-04])
                              C                           ; It's the right code segment, is it the right offset?
00002EA9                      C                             .IF (ebx <= dword ptr ss:[ebp-08])
                              C                               ; It's before the current instruction pointer ... so it's a candidate
00002EAE  8B4DF8              C                                 mov     ecx,dword ptr ss:[ebp-08]
00002EB1  2BCB                C                                 sub     ecx,ebx
00002EB3                      C                                 .IF (ecx < dword ptr ss:[ebp-16])
                              C                                   ; We're closer than the previous one
00002EB8  897DF4              C                                     mov     dword ptr ss:[ebp-12],edi
00002EBB  894DF0              C                                     mov     dword ptr ss:[ebp-16],ecx
00002EBE                      C                                 .ENDIF
00002EBE                      C                             .ENDIF
00002EBE                      C                         .ENDIF
00002EBE                      C                     .ENDIF
00002EBE  640FB64703          C                     movzx   eax,byte ptr fs:[edi+3]
00002EC3  03F8                C                     add     edi,eax
00002EC5  83C704              C                     add     edi,4
00002EC8                      C                 .ENDW
00002ED0                      C                 .IF (dword ptr ss:[ebp-12] != 0ffffffffh)
                              C                   ; We found something
00002EDD  8B7DF4              C                     mov     edi,dword ptr ss:[ebp-12]
00002EE0  640FB64F03          C                     movzx   ecx,byte ptr fs:[edi+3]
00002EE5  83C704              C                     add     edi,4
00002EE8  8B45EC              C                     mov     eax,dword ptr ss:[ebp-20]
                              C                   ; Right now, fs:[edi] - far ptr to the name of this function
                              C                   ;                 ecx - length of the function name
                              C                   ;            ds:[esi] - far ptr to where we're supposed to store this name
                              C                   ;                 eax - maximum # of characters ds:[esi] can hold
00002EEB                      C                     .IF (eax > 4)
                              C                       ; Store the word " at "
00002EF0  C70620617420        C                         mov     dword ptr ds:[esi],' ta '
00002EF6  83C604              C                         add     esi,4
00002EF9  83E804              C                         sub     eax,4
00002EFC                      C                     .ELSEIF (eax > 1)
                              C                       ; Not enough room for the phrase " at ", so we just add a space and copy what we can
00002F03  C60620              C                         mov     byte ptr ds:[esi],32
00002F06  46                  C                         inc     esi
00002F07  48                  C                         dec     eax
00002F08                      C                     .ENDIF
                              C                   ; Now, copy the function name
00002F08                      C                     .WHILE (byte ptr fs:[edi] != 0 && ecx > 0 && eax > 0)
00002F0A  648A07              C                         mov     al,byte ptr fs:[edi]
00002F0D  8806                C                         mov     byte ptr ds:[esi],al
00002F0F  46                  C                         inc     esi
00002F10  47                  C                         inc     edi
00002F11  49                  C                         dec     ecx
00002F12  48                  C                         dec     eax
00002F13                      C                     .ENDW
                              C                   ; Ok, right now the name has been copied
00002F23                      C                     .IF (eax > 2)
                              C                       ; Store the () part of a function()
00002F28  66C7062829          C                         mov     word ptr ds:[esi],')('
00002F2D  83E802              C                         sub     eax,2
00002F30  83C602              C                         add     esi,2
00002F33                      C                     .ENDIF
00002F33                      C                     .IF (eax > 0)
                              C                       ; We need to try to copy the offset
00002F38  C6062B              C                         mov     byte ptr ds:[esi],"+"
00002F3B  46                  C                         inc     esi
00002F3C  48                  C                         dec     eax
00002F3D                      C                         .IF (eax > 0)
                              C                           ; Now, copy the offset text to the string
00002F42  8B55F0              C                             mov     edx,dword ptr ss:[ebp-16]
00002F45  B908000000          C                             mov     ecx,8
                              C                           ; Skip past any leading 0s
00002F4A                      C                           @@:
00002F4A  C1C204              C                             rol     edx,4
00002F4D  8ADA                C                             mov     bl,dl
00002F4F  80E30F              C                             and     bl,0fh
00002F52                      C                             .IF (bl != 0)
00002F57  EB0C                C                                 jmp     @F
00002F59                      C                             .ENDIF
00002F59  E2EF                C                             loop    @B
00002F5B                      C                             .IF (ecx == 0)
                              C                               ; There are no values to store
00002F60  B901000000          C                                 mov     ecx,1
00002F65                      C                             .ENDIF
                              C                           ; Write the string
00002F65                      C                           @@:
00002F65  8ADA                C                             mov     bl,dl
00002F67  80E30F              C                             and     bl,0fh
00002F6A                      C                             .IF (bl <= 9)                           ; Convert from ASCII to text, "0" to "9" or "a" to "f"
00002F6F  80C330              C                                 add     bl,'0'
00002F72                      C                             .ELSE
00002F74  80C357              C                                 add     bl,'a'-10
00002F77                      C                             .ENDIF
00002F77  881E                C                             mov     byte ptr ds:[esi],bl
00002F79  46                  C                             inc     esi
00002F7A  48                  C                             dec     eax
00002F7B                      C                             .IF (eax == 0)
00002F80  EB05                C                                 jmp     @F
00002F82                      C                             .ENDIF
00002F82  C1C204              C                             rol     edx,4
00002F85  E2DE                C                             loop    @B
00002F87                      C                           @@:
00002F87                      C                         .ENDIF
00002F87                      C                     .ENDIF
00002F87  F8                  C                     clc
00002F88  EB38                C                     jmp     find_func_quit
00002F8A                      C                 .ELSE
                              C                   ; We didn't find it
00002F8C  BF70050000          C                     mov     edi,offset unknown_primative_text
00002F91  F9                  C                     stc
00002F92  EB0D                C                     jmp     find_func_copy_text
00002F94                      C                 .ENDIF
00002F94                      C             .ELSEIF (edx == _sCODE)
                              C               ; It's Exodus itself!!!  WOAH!  This is bad.  We're not supposed to have any problems.  "It must be a human error."
00002F9B  BF39050000          C                 mov     edi,offset exodus_internal_text
00002FA0  F8                  C                 clc
00002FA1                      C               find_func_copy_text:
00002FA1  9C                  C                 pushfd
00002FA2                      C                 .WHILE (byte ptr es:[edi] != 0 && ecx > 0)
00002FA4  268A07              C                     mov     al,byte ptr es:[edi]
00002FA7  8806                C                     mov     byte ptr ds:[esi],al
00002FA9  46                  C                     inc     esi
00002FAA  47                  C                     inc     edi
00002FAB  49                  C                     dec     ecx
00002FAC                      C                 .ENDW
00002FB7  9D                  C                 popfd
00002FB8                      C             .ELSE
                              C               ; It's an unknown function
00002FBA  BF4C050000          C                 mov     edi,offset unknown_function_text
00002FBF  F9                  C                 stc
00002FC0  EBDF                C                 jmp     find_func_copy_text
00002FC2                      C             .ENDIF
00002FC2                      C         .ENDIF
                              C 
00002FC2                      C       find_func_quit:
00002FC2  07                  C         pop     es
00002FC3  C9                  C         leave
00002FC4                      C     .ELSEIF (eax == 'altr')
                              C       ; They want to alter something
00002FD0                      C         .IF (ebx == 'gdt ')
                              C           ; This function is used to alter the base/limit of a GDT entry
                              C           ;
                              C           ; Upon entry: edx - GDT slot
                              C           ;             esi - new base
                              C           ;             edi - new limit
                              C           ;
                              C           ; Upon exit:  carry? - clear if acceptable
                              C           ;
00002FD8                      C             .IF (edx == _sVGA/8 && (esi == _sVGA_base || esi == _sVGA_BACKUP_base) && (edi == _sVGA_limit || edi == _sVGA_BACKUP_limit))
                              C               ; It's the _sVGA, this one is acceptable to alter
00002FFD  E875D2FFFF          C                 call    invAlter_descriptor32_base_limit
00003002  F8                  C                 clc
00003003                      C             .ELSE
                              C               ; Unrecognized request
00003005  F9                  C                 stc
00003006                      C             .ENDIF
00003006                      C         .ELSE
                              C           ; Unrecognized request
00003008  F9                  C             stc
00003009                      C         .ENDIF
00003009                      C     .ELSEIF (eax == 'get ')
                              C       ; They want to get some information about something
00003019                      C         .IF (ebx == 'gdtd')
                              C           ; This function is used extract the base/limit of a data GDT entry
                              C           ;
                              C           ; Upon entry: edx - GDT slot
                              C           ;
                              C           ; Upon exit:  carry? - clear if acceptable
                              C           ;             ebx - base
                              C           ;             edx - limit
                              C           ;
00003021  F7450807000000      C             test    dword ptr ss:[ebp+08],111b
00003028                      C             .IF (zero?)
                              C               ; This function is only available to PL=00 tasks
0000302A  8BC2                C                 mov     eax,edx
0000302C  C1E003              C                 shl     eax,3
0000302F  E802D2FFFF          C                 call    invExtract_data_descriptor32
00003034  895DD8              C                 mov     dword ptr ss:[ebp-40],ebx
00003037  8955DC              C                 mov     dword ptr ss:[ebp-36],edx
0000303A  F8                  C                 clc
0000303B                      C             .ELSE
0000303D  F9                  C                 stc
0000303E                      C             .ENDIF
                              C 
0000303E                      C         .ELSEIF (ebx == 'gdtc')
                              C           ; This function is used extract the base/limit of a code GDT entry
                              C           ;
                              C           ; Upon entry: edx - GDT slot
                              C           ;
                              C           ; Upon exit:  carry? - clear if acceptable
                              C           ;             ebx - base
                              C           ;             edx - limit
                              C           ;
0000304B  F7450807000000      C             test    dword ptr ss:[ebp+08],111b
00003052                      C             .IF (zero?)
                              C               ; This function is only available to PL=00 tasks
00003054  8BC2                C                 mov     eax,edx
00003056  C1E003              C                 shl     eax,3
00003059  E86DD1FFFF          C                 call    invExtract_code_descriptor32
0000305E  895DD8              C                 mov     dword ptr ss:[ebp-40],ebx
00003061  8955DC              C                 mov     dword ptr ss:[ebp-36],edx
00003064  F8                  C                 clc
00003065                      C             .ELSE
00003067  F9                  C                 stc
00003068                      C             .ENDIF
                              C 
00003068                      C         .ELSEIF (ebx == 'gdt ')
                              C           ; This function is used extract the quadword GDT entry
                              C           ;
                              C           ; Upon entry: edx - GDT slot
                              C           ;
00003075  F7450807000000      C             test    dword ptr ss:[ebp+08],111b
0000307C                      C             .IF (zero?)
0000307E  1E                  C                 push    ds
0000307F  B810000000          C                 mov     eax,_sGDT
00003084  8ED8                C                 mov     ds,eax
00003086  8B1CD504000000      C                 mov     ebx,dword ptr ds:[edx*8+4]
0000308D  8B14D500000000      C                 mov     edx,dword ptr ds:[edx*8+0]
00003094  895DD8              C                 mov     dword ptr ss:[ebp-40],ebx
00003097  8955DC              C                 mov     dword ptr ss:[ebp-36],edx
0000309A  1F                  C                 pop     ds
0000309B  F8                  C                 clc
0000309C                      C             .ELSE
0000309E  F9                  C                 stc
0000309F                      C             .ENDIF
                              C 
0000309F                      C         .ELSEIF (ebx == 'tss ')
                              C           ; This function is used extract the TSS base address from a CALL GATE GDT entry
                              C           ;
                              C           ; Upon entry: edx - call gate GDT slot
                              C           ;
000030AC  F7450807000000      C             test    dword ptr ss:[ebp+08],111b
000030B3                      C             .IF (zero?)
000030B5  8BC2                C                 mov     eax,edx
000030B7  C1E003              C                 shl     eax,3
000030BA  E84DD1FFFF          C                 call    invExtract_call_gate_descriptor32
000030BF  8BC2                C                 mov     eax,edx
000030C1  E870D1FFFF          C                 call    invExtract_data_descriptor32
000030C6  895DD8              C                 mov     dword ptr ss:[ebp-40],ebx
000030C9  F8                  C                 clc
000030CA                      C             .ELSE
000030CC  F9                  C                 stc
000030CD                      C             .ENDIF
                              C 
000030CD                      C         .ELSEIF (ebx == 'base')
                              C           ; They want the base from an unknown selector (could be local, could be global)
                              C           ;
                              C           ; Upon entry: edx - offset in GDT
                              C           ;
                              C           ; Upon exit:  carry? - clear if found, set if not
                              C           ;                ecx - base if found
                              C           ;
000030D7  F7450807000000      C             test dword ptr ss:[ebp+08],111b
000030DE                      C             .IF (zero?)
000030E0  F745DC07000000      C                 test dword ptr ss:[ebp-36],111b                     ; Check edx
000030E7                      C                 .IF (zero?)
                              C                   ; It's a PL=00 descriptor
000030E9  8BC2                C                     mov     eax,edx
000030EB  E846D1FFFF          C                     call    invExtract_data_descriptor32
000030F0  895DE0              C                     mov     dword ptr ss:[ebp-32],ebx               ; Store base in ecx
000030F3  F8                  C                     clc
000030F4                      C                 .ELSE
                              C                   ; We have to find it the hard way
000030F6                      C                 .ENDIF
000030F6                      C             .ELSE
000030F8  F9                  C                 stc
000030F9                      C             .ENDIF
                              C 
000030F9                      C         .ELSEIF (ebx == 'limi')
                              C           ; They want the limit from an unknown selector (could be local, could be global)
                              C           ;
                              C           ; Upon entry: edx - offset in GDT
                              C           ;
                              C           ; Upon exit:  carry? - clear if found, set if not
                              C           ;                ecx - limit if found
                              C           ;
00003103  F7450807000000      C             test dword ptr ss:[ebp+08],111b
0000310A                      C             .IF (zero?)
0000310C  F745DC07000000      C                 test dword ptr ss:[ebp-36],111b                     ; Check edx
00003113                      C                 .IF (zero?)
                              C                   ; It's a PL=00 descriptor
00003115  8BC2                C                     mov     eax,edx
00003117  E81AD1FFFF          C                     call    invExtract_data_descriptor32
0000311C  8955E0              C                     mov     dword ptr ss:[ebp-32],edx               ; Store limit in ecx
0000311F  F8                  C                     clc
00003120                      C                 .ELSE
                              C                   ; We have to find it the hard way
00003122                      C                 .ENDIF
00003122                      C             .ELSE
00003124  F9                  C                 stc
00003125                      C             .ENDIF
                              C 
00003125                      C         .ELSE
                              C           ; Unrecognized request
00003127  F9                  C             stc
00003128                      C         .ENDIF
00003128                      C     .ELSEIF (eax == 'set ')
                              C       ; They want to set some information about something
00003134                      C         .IF (ebx == 'gdtd')
                              C           ; This function is used extract the base/limit of a data GDT entry
                              C           ;
                              C           ; Upon entry: edx - GDT slot
                              C           ;             esi - base
                              C           ;             edi - limit
                              C           ;
                              C           ; Upon exit:  carry? - clear if acceptable
                              C           ;
0000313C  F7450807000000      C             test    dword ptr ss:[ebp+08],111b
00003143                      C             .IF (zero?)
                              C               ; This function is only available to PL=00 tasks
00003145                      C                 .IF (edx == _sDEBI_temp/8)
0000314A  8BC2                C                     mov     eax,edx
0000314C  8BDE                C                     mov     ebx,esi
0000314E  8BD7                C                     mov     edx,edi
00003150  E809D0FFFF          C                     call    invCreate_data_descriptor32
00003155                      C                 .ENDIF
00003155  F8                  C                 clc
00003156                      C             .ELSE
00003158  F9                  C                 stc
00003159                      C             .ENDIF
                              C 
00003159                      C         .ELSEIF (ebx == 'gdtc')
                              C           ; This function is used extract the base/limit of a code GDT entry
                              C           ;
                              C           ; Upon entry: edx - GDT slot
                              C           ;             esi - base
                              C           ;             edi - limit
                              C           ;
                              C           ; Upon exit:  carry? - clear if acceptable
                              C           ;
00003163  F7450807000000      C             test    dword ptr ss:[ebp+08],111b
0000316A                      C             .IF (zero?)
                              C               ; This function is only available to PL=00 tasks
0000316C                      C                 .IF (edx == _sDEBI_temp/8)
00003171  8BC2                C                     mov     eax,edx
00003173  8BDE                C                     mov     ebx,esi
00003175  8BD7                C                     mov     edx,edi
00003177  E86FCFFFFF          C                     call    invCreate_code_descriptor32
0000317C                      C                 .ENDIF
0000317C  F8                  C                 clc
0000317D                      C             .ELSE
0000317F  F9                  C                 stc
00003180                      C             .ENDIF
                              C 
00003180                      C         .ELSE
                              C           ; Unrecognized request
00003182  F9                  C             stc
00003183                      C         .ENDIF
00003183                      C     .ELSEIF (eax == 'stop')
00003193                      C         .IF (ebx == 'load')
                              C           ; An error occurred during initialization
                              C           ;
                              C           ; Upon entry: ds:[esi] - far ptr to null-terminated ID string to display
                              C           ;
                              C           ; Upon exit:  No exit. This routine locks up Debi
                              C           ;
                              C           ; Clear the screens for this message
                              C           ; Mono
0000319F  B830000000          C             mov     eax,_sMONO
000031A4  8EC0                C             mov     es,eax
000031A6  8EE0                C             mov     fs,eax
000031A8  33FF                C             xor     edi,edi
000031AA  B9E8030000          C             mov     ecx,80*2*25 / 4
000031AF  33C0                C             xor     eax,eax
000031B1  F3AB                C             rep     stosd
                              C 
                              C           ; VGA
000031B3  B838000000          C             mov     eax,_sVGA
000031B8  8EC0                C             mov     es,eax
000031BA  33FF                C             xor     edi,edi
000031BC  B9E8030000          C             mov     ecx,80*2*25 / 4
000031C1  33C0                C             xor     eax,eax
000031C3  F3AB                C             rep     stosd
                              C 
                              C           ; Store the name they've provided
000031C5  B950000000          C             mov     ecx,80
000031CA  33FF                C             xor     edi,edi
000031CC                      C             .REPEAT
000031CC  8A06                C                 mov     al,byte ptr ds:[esi]
000031CE                      C                 .IF (al != 0 && ecx != 80)
000031D7  46                  C                     inc     esi
000031D8                      C                 .ELSE
000031DA  B020                C                     mov     al,32
000031DC                      C                 .ENDIF
000031DC  268807              C                 mov     byte ptr es:[edi],al                        ; VGA
000031DF  648807              C                 mov     byte ptr fs:[edi],al                        ; Mono
000031E2  47                  C                 inc     edi
000031E3  B070                C                 mov     al,112
000031E5  268807              C                 mov     byte ptr es:[edi],al
000031E8  648807              C                 mov     byte ptr fs:[edi],al
000031EB  47                  C                 inc     edi
000031EC                      C             .UNTILCXZ
                              C 
                              C           ; Store the generic text
000031EE  BE141D0000          C             mov     esi,offset failed
000031F3  BF20030000          C             mov     edi,80*2*5
000031F8                      C             .WHILE (esi < offset failed_end)
000031FA  2E8A06              C                 mov     al,byte ptr cs:[esi]
000031FD  46                  C                 inc     esi
000031FE                      C                 .IF (al == 13)
                              C                   ; Move to start of current line
00003202  33D2                C                     xor     edx,edx
00003204  8BC7                C                     mov     eax,edi
00003206  BBA0000000          C                     mov     ebx,80*2
0000320B  F7F3                C                     div     ebx
0000320D  F7E3                C                     mul     ebx
0000320F  8BF8                C                     mov     edi,eax
00003211                      C                 .ELSEIF (al == 10)
                              C                   ; Move down one line
00003217  81C7A0000000        C                     add     edi,80*2
0000321D                      C                 .ELSE
0000321F  268807              C                     mov     byte ptr es:[edi],al
00003222  648807              C                     mov     byte ptr fs:[edi],al
00003225  47                  C                     inc     edi
00003226  B007                C                     mov     al,7
00003228  268807              C                     mov     byte ptr es:[edi],al
0000322B  648807              C                     mov     byte ptr fs:[edi],al
0000322E  47                  C                     inc     edi
0000322F                      C                 .ENDIF
0000322F                      C             .ENDW
                              C 
                              C           ; Lock up the system
00003237                      C           @@:
00003237  F4                  C             hlt
00003238  EBFD                C             jmp @B
0000323A                      C         .ENDIF
0000323A                      C     .ELSE
0000323C  F9                  C         stc
0000323D                      C     .ENDIF
                              C 
0000323D                      C   requestor_quit:
0000323D  61                  C     popad
0000323E  0FA1                C     pop     fs
00003240  C9                  C     leave
00003241  CB                  C     retf
00003242                      C requestor       ENDP

00003242                        end_of_32_bit_segment:
00003242                        _TEXT32 ENDS


                                END


Macros:

                N a m e                 Type

@CatStr  . . . . . . . . . . . .        Func
@Environ . . . . . . . . . . . .        Func
@IO_pause  . . . . . . . . . . .        Proc
@InStr . . . . . . . . . . . . .        Func
@SizeStr . . . . . . . . . . . .        Func
@SubStr  . . . . . . . . . . . .        Func
callf  . . . . . . . . . . . . .        Proc
callfp . . . . . . . . . . . . .        Proc
callg  . . . . . . . . . . . . .        Proc
jmpg . . . . . . . . . . . . . .        Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

_TEXT32  . . . . . . . . . . . .        32 Bit   00003242 Byte    Public  'CODE'
DGROUP . . . . . . . . . . . . .        GROUP
_TEXT  . . . . . . . . . . . . .        16 Bit   0A9D     Word    Public  'CODE'
_DATA  . . . . . . . . . . . . .        16 Bit   0000     Word    Public  'DATA'


Procedures, parameters and locals:

                N a m e                 Type     Value    Segment  Length

VID_display_hex_string_ecx_mono         P Near   000026AC _TEXT32  00000049 Public   
  @C0067 . . . . . . . . . . . .        L Near   000026F1 _TEXT32
  @C0068 . . . . . . . . . . . .        L Near   000026EF _TEXT32
  @C0069 . . . . . . . . . . . .        L Near   000026BD _TEXT32
  @C006A . . . . . . . . . . . .        L Near   000026F1 _TEXT32
VID_display_radix_in_edx_mono  .        P Near   0000260C _TEXT32  00000017 Public   
VID_display_string_ecx_mono  . .        P Near   00002681 _TEXT32  0000002B Public   
  @C0064 . . . . . . . . . . . .        L Near   000026A5 _TEXT32
  @C0065 . . . . . . . . . . . .        L Near   0000269A _TEXT32
  @C0066 . . . . . . . . . . . .        L Near   000026A7 _TEXT32
  @C0063 . . . . . . . . . . . .        L Near   000026A7 _TEXT32
VID_display_string_mono  . . . .        P Near   00002656 _TEXT32  0000002B Public   
  @C0060 . . . . . . . . . . . .        L Near   00002677 _TEXT32
  @C0061 . . . . . . . . . . . .        L Near   0000266C _TEXT32
  @C0062 . . . . . . . . . . . .        L Near   0000267C _TEXT32
adjust_al  . . . . . . . . . . .        P Near   01D0     _TEXT    000F     Public   
  @C0005 . . . . . . . . . . . .        L Near   01DC     _TEXT
  @C0006 . . . . . . . . . . . .        L Near   01DE     _TEXT
create_call_gate_descriptor  . .        P Near   0839     _TEXT    0023     Public   
create_code_descriptor . . . . .        P Near   0689     _TEXT    0035     Public   
create_data_descriptor . . . . .        P Near   0594     _TEXT    004F     Public   
  @C000A . . . . . . . . . . . .        L Near   05CB     _TEXT
  @C000B . . . . . . . . . . . .        L Near   05D6     _TEXT
create_data_descriptor_pl  . . .        P Near   05E3     _TEXT    0057     Public   
  @C000D . . . . . . . . . . . .        L Near   062D     _TEXT
  @C000C . . . . . . . . . . . .        L Near   0622     _TEXT
create_exodus_tss_descriptor . .        P Near   0710     _TEXT    0129     Public   
create_interrupt_descriptor_32_bit         P Near   06BE     _TEXT    002E     Public   
create_interrupt_descriptors . .        P Near   06EC     _TEXT    0024     Public   
  L&_0003  . . . . . . . . . . .        L Near   0706     _TEXT
create_ldt_descriptor  . . . . .        P Near   063A     _TEXT    004F     Public   
  @C000E . . . . . . . . . . . .        L Near   0671     _TEXT
  @C000F . . . . . . . . . . . .        L Near   067C     _TEXT
create_null_data_descriptor  . .        P Near   0582     _TEXT    0012     Public   
create_task_gate_descriptor  . .        P Near   085C     _TEXT    0019     Public   
default_interrupt_handler32  . .        P Near   00002605 _TEXT32  00000007 Public   
default_primative_response . . .        P Near   000023F4 _TEXT32  0000002B Public   
display_crc_comparitive  . . . .        P Near   0186     _TEXT    001B     Public   
enable_gate_a20  . . . . . . . .        P Near   0216     _TEXT    0023     Public   
  eg_loop1 . . . . . . . . . . .        L Near   0219     _TEXT
  eg_loop2 . . . . . . . . . . .        L Near   0225     _TEXT
  eg_loop3 . . . . . . . . . . .        L Near   0231     _TEXT
extract_word_to_ds_di  . . . . .        P Near   01A1     _TEXT    002F     Public   
hex_adjust_al_dl . . . . . . . .        P Near   000026F5 _TEXT32  0000001D Public   
  @C006D . . . . . . . . . . . .        L Near   0000270F _TEXT32
  @C006E . . . . . . . . . . . .        L Near   00002711 _TEXT32
  @C006B . . . . . . . . . . . .        L Near   00002702 _TEXT32
  @C006C . . . . . . . . . . . .        L Near   00002705 _TEXT32
iString_generate_radix_string  .        P Near   00002623 _TEXT32  00000033 Public   
  L&_0006  . . . . . . . . . . .        L Near   00002634 _TEXT32
  L&_0007  . . . . . . . . . . .        L Near   00002652 _TEXT32
  @C005E . . . . . . . . . . . .        L Near   00002642 _TEXT32
  @C005F . . . . . . . . . . . .        L Near   00002645 _TEXT32
init_failed  . . . . . . . . . .        P Near   00002712 _TEXT32  00000082 Public   
  L&_0008  . . . . . . . . . . .        L Near   00002791 _TEXT32
  @C0074 . . . . . . . . . . . .        L Near   00002755 _TEXT32
  @C0075 . . . . . . . . . . . .        L Near   0000275D _TEXT32
  @C0076 . . . . . . . . . . . .        L Near   00002765 _TEXT32
  @C0077 . . . . . . . . . . . .        L Near   0000276D _TEXT32
  @C0070 . . . . . . . . . . . .        L Near   0000272E _TEXT32
  @C0071 . . . . . . . . . . . .        L Near   00002791 _TEXT32
  @C0072 . . . . . . . . . . . .        L Near   0000273E _TEXT32
  @C0073 . . . . . . . . . . . .        L Near   00002789 _TEXT32
  @C0078 . . . . . . . . . . . .        L Near   00002775 _TEXT32
  @C0079 . . . . . . . . . . . .        L Near   0000277E _TEXT32
  @C006F . . . . . . . . . . . .        L Near   00002789 _TEXT32
invAdd_primative . . . . . . . .        P Near   000024E6 _TEXT32  00000052 Public   
  @C004D . . . . . . . . . . . .        L Near   0000250D _TEXT32
  @C004E . . . . . . . . . . . .        L Near   00002520 _TEXT32
  @C004F . . . . . . . . . . . .        L Near   00002519 _TEXT32
  @C004B . . . . . . . . . . . .        L Near   00002535 _TEXT32
  @C004C . . . . . . . . . . . .        L Near   0000251E _TEXT32
invAlter_descriptor32_base_limit         P Near   00000277 _TEXT32  0000006F Public   
  @C0020 . . . . . . . . . . . .        L Near   000002AB _TEXT32
  @C001E . . . . . . . . . . . .        L Near   000002E4 _TEXT32
  @C001F . . . . . . . . . . . .        L Near   000002A3 _TEXT32
invCopy_this_part  . . . . . . .        P Near   0000241F _TEXT32  00000020 Public   
  @C004A . . . . . . . . . . . .        L Near   00002437 _TEXT32
  @C0048 . . . . . . . . . . . .        L Near   00002432 _TEXT32
  @C0049 . . . . . . . . . . . .        L Near   0000242A _TEXT32
invCreate_call_gate_descriptor32         P Near   0000004E _TEXT32  00000045 Public   
  @C0010 . . . . . . . . . . . .        L Near   00000091 _TEXT32
invCreate_code_descriptor32  . .        P Near   000000EB _TEXT32  00000073 Public   
  @C0014 . . . . . . . . . . . .        L Near   00000140 _TEXT32
  @C0015 . . . . . . . . . . . .        L Near   0000014E _TEXT32
  @C0013 . . . . . . . . . . . .        L Near   0000015C _TEXT32
invCreate_data_descriptor32  . .        P Near   0000015E _TEXT32  0000006D Public   
  @C0016 . . . . . . . . . . . .        L Near   000001C9 _TEXT32
  @C0017 . . . . . . . . . . . .        L Near   000001B0 _TEXT32
  @C0018 . . . . . . . . . . . .        L Near   000001BE _TEXT32
invCreate_interrupt_task_gate_descriptor32         P Near   000000BF _TEXT32  0000002C Public   
  @C0012 . . . . . . . . . . . .        L Near   000000E9 _TEXT32
invCreate_task_gate_descriptor32         P Near   00000093 _TEXT32  0000002C Public   
  @C0011 . . . . . . . . . . . .        L Near   000000BD _TEXT32
invCreate_tss32  . . . . . . . .        P Near   00000360 _TEXT32  00000080 Public   
invCreate_tss_descriptor32 . . .        P Near   00000311 _TEXT32  0000004F Public   
  @C0022 . . . . . . . . . . . .        L Near   0000035E _TEXT32
invDetermine_Exodus_ini_ownership         P Near   00002C6A _TEXT32  00000001 Public   
invExtract_call_gate_descriptor32         P Near   0000020C _TEXT32  0000002A Public   
  @C001B . . . . . . . . . . . .        L Near   00000234 _TEXT32
invExtract_code_descriptor32 . .        P Near   000001CB _TEXT32  00000041 Public   
  @C001A . . . . . . . . . . . .        L Near   000001F6 _TEXT32
  @C0019 . . . . . . . . . . . .        L Near   0000020A _TEXT32
invExtract_data_descriptor32 . .        P Near   00000236 _TEXT32  00000041 Public   
  @C001D . . . . . . . . . . . .        L Near   00000261 _TEXT32
  @C001C . . . . . . . . . . . .        L Near   00000275 _TEXT32
invExtract_linear_offset_into_edx_from_ds         P Near   000002E6 _TEXT32  0000002B Public   
  @C0021 . . . . . . . . . . . .        L Near   0000030E _TEXT32
invFind_Exodus_ini . . . . . . .        P Near   00002794 _TEXT32  000000CE Public   
  L&_0010  . . . . . . . . . . .        L Near   00002856 _TEXT32
  L&_0009  . . . . . . . . . . .        L Near   000027FA _TEXT32
  @C0080 . . . . . . . . . . . .        L Near   00002859 _TEXT32
  @C0081 . . . . . . . . . . . .        L Near   00002825 _TEXT32
  @C0082 . . . . . . . . . . . .        L Near   00002837 _TEXT32
  @C0083 . . . . . . . . . . . .        L Near   00002832 _TEXT32
  finished . . . . . . . . . . .        L Near   00002859 _TEXT32
  @C007D . . . . . . . . . . . .        L Near   000027DA _TEXT32
  @C007E . . . . . . . . . . . .        L Near   000027FA _TEXT32
  @C007F . . . . . . . . . . . .        L Near   000027F8 _TEXT32
  @C007A . . . . . . . . . . . .        L Near   000027DD _TEXT32
  @C007B . . . . . . . . . . . .        L Near   000027C3 _TEXT32
  @C007C . . . . . . . . . . . .        L Near   000027E2 _TEXT32
invMove_temp_gdts_to_permanent .        P Near   0000243F _TEXT32  000000A7 Public   
invParse_Exodus_ini  . . . . . .        P Near   00002862 _TEXT32  00000387 Public   
  @C00A9 . . . . . . . . . . . .        L Near   00002ACB _TEXT32
  cask_finished  . . . . . . . .        L Near   00002B28 _TEXT32
  @C00B4 . . . . . . . . . . . .        L Near   00002B4B _TEXT32
  @C00B5 . . . . . . . . . . . .        L Near   00002B49 _TEXT32
  @C00B6 . . . . . . . . . . . .        L Near   00002B44 _TEXT32
  @C00B7 . . . . . . . . . . . .        L Near   00002B5E _TEXT32
  next_line  . . . . . . . . . .        L Near   00002B82 _TEXT32
  @C00B0 . . . . . . . . . . . .        L Near   00002B2E _TEXT32
  @C00B1 . . . . . . . . . . . .        L Near   00002B2A _TEXT32
  @C008D . . . . . . . . . . . .        L Near   000028FF _TEXT32
  @C00B2 . . . . . . . . . . . .        L Near   00002B3E _TEXT32
  @C008E . . . . . . . . . . . .        L Near   00002905 _TEXT32
  @C00B3 . . . . . . . . . . . .        L Near   00002B3E _TEXT32
  @C008F . . . . . . . . . . . .        L Near   000029F5 _TEXT32
  @C008A . . . . . . . . . . . .        L Near   000028EF _TEXT32
  @C008B . . . . . . . . . . . .        L Near   00002910 _TEXT32
  @C00B8 . . . . . . . . . . . .        L Near   00002B6F _TEXT32
  @C008C . . . . . . . . . . . .        L Near   0000290B _TEXT32
  @C00B9 . . . . . . . . . . . .        L Near   00002B8B _TEXT32
  @C00C0 . . . . . . . . . . . .        L Near   00002BDB _TEXT32
  do_next_cask . . . . . . . . .        L Near   00002A1A _TEXT32
  @C00C1 . . . . . . . . . . . .        L Near   00002BCE _TEXT32
  @C009D . . . . . . . . . . . .        L Near   00002B71 _TEXT32
  @C00C2 . . . . . . . . . . . .        L Near   00002BC7 _TEXT32
  @C009E . . . . . . . . . . . .        L Near   00002A0C _TEXT32
  @C009F . . . . . . . . . . . .        L Near   00002A13 _TEXT32
  @C009A . . . . . . . . . . . .        L Near   00002997 _TEXT32
  @C009B . . . . . . . . . . . .        L Near   000029A2 _TEXT32
  @C009C . . . . . . . . . . . .        L Near   00002B82 _TEXT32
  @C00AD . . . . . . . . . . . .        L Near   00002B15 _TEXT32
  @C00AE . . . . . . . . . . . .        L Near   00002B07 _TEXT32
  do_next_data_item  . . . . . .        L Near   00002A86 _TEXT32
  @C00AF . . . . . . . . . . . .        L Near   00002B0E _TEXT32
  @C00AA . . . . . . . . . . . .        L Near   00002AD1 _TEXT32
  @C0084 . . . . . . . . . . . .        L Near   00002BDE _TEXT32
  @C0085 . . . . . . . . . . . .        L Near   000028CF _TEXT32
  @C00AB . . . . . . . . . . . .        L Near   00002AE8 _TEXT32
  @C00AC . . . . . . . . . . . .        L Near   00002B28 _TEXT32
  @C0086 . . . . . . . . . . . .        L Near   00002BE8 _TEXT32
  @C0087 . . . . . . . . . . . .        L Near   000028DF _TEXT32
  @C0088 . . . . . . . . . . . .        L Near   000028DB _TEXT32
  @C0089 . . . . . . . . . . . .        L Near   000028EF _TEXT32
  finished . . . . . . . . . . .        L Near   00002BE8 _TEXT32
  @C00BD . . . . . . . . . . . .        L Near   00002BB1 _TEXT32
  @C00BE . . . . . . . . . . . .        L Near   00002B99 _TEXT32
  @C00BF . . . . . . . . . . . .        L Near   00002BC0 _TEXT32
  @C0094 . . . . . . . . . . . .        L Near   00002945 _TEXT32
  @C00BA . . . . . . . . . . . .        L Near   00002B9D _TEXT32
  @C0095 . . . . . . . . . . . .        L Near   0000295F _TEXT32
  @C00BB . . . . . . . . . . . .        L Near   00002B8D _TEXT32
  @C0096 . . . . . . . . . . . .        L Near   0000295F _TEXT32
  @C00BC . . . . . . . . . . . .        L Near   00002BB1 _TEXT32
  @C0097 . . . . . . . . . . . .        L Near   0000297A _TEXT32
  @C0090 . . . . . . . . . . . .        L Near   00002929 _TEXT32
  @C0091 . . . . . . . . . . . .        L Near   0000293B _TEXT32
  @C0092 . . . . . . . . . . . .        L Near   0000293B _TEXT32
  @C0093 . . . . . . . . . . . .        L Near   0000294F _TEXT32
  @C00A4 . . . . . . . . . . . .        L Near   00002AA5 _TEXT32
  @C00A5 . . . . . . . . . . . .        L Near   00002ADA _TEXT32
  @C0098 . . . . . . . . . . . .        L Near   00002995 _TEXT32
  @C00A6 . . . . . . . . . . . .        L Near   00002ADA _TEXT32
  @C0099 . . . . . . . . . . . .        L Near   0000299D _TEXT32
  @C00A7 . . . . . . . . . . . .        L Near   00002AAF _TEXT32
  @C00A0 . . . . . . . . . . . .        L Near   00002AE8 _TEXT32
  @C00A1 . . . . . . . . . . . .        L Near   00002A9B _TEXT32
  @C00A2 . . . . . . . . . . . .        L Near   00002B01 _TEXT32
  @C00A3 . . . . . . . . . . . .        L Near   00002B01 _TEXT32
  @C00A8 . . . . . . . . . . . .        L Near   00002AAA _TEXT32
invParse_Exodus_ini_store_error         P Near   00002BE9 _TEXT32  00000081 Public   
  L&_0011  . . . . . . . . . . .        L Near   00002C0B _TEXT32
  @C00CA . . . . . . . . . . . .        L Near   00002C51 _TEXT32
  @C00CB . . . . . . . . . . . .        L Near   00002C5F _TEXT32
  @C00C4 . . . . . . . . . . . .        L Near   00002C22 _TEXT32
  @C00C5 . . . . . . . . . . . .        L Near   00002C18 _TEXT32
  @C00C6 . . . . . . . . . . . .        L Near   00002C45 _TEXT32
  @C00C7 . . . . . . . . . . . .        L Near   00002C3D _TEXT32
  @C00C3 . . . . . . . . . . . .        L Near   00002C2B _TEXT32
  @C00C8 . . . . . . . . . . . .        L Near   00002C4B _TEXT32
  @C00C9 . . . . . . . . . . . .        L Near   00002C59 _TEXT32
invSet_80x25_text_mode . . . . .        P Near   000004CE _TEXT32  00000042 Public   
invSetup_memory_blocks . . . . .        P Near   0000045A _TEXT32  00000074 Public   
invSetup_native_primatives . . .        P Near   00001EBD _TEXT32  00000537 Public   
  note_offset  . . . . . . . . .        L Near   00002219 _TEXT32
  @C0024 . . . . . . . . . . . .        L Near   00001EDB _TEXT32
  @C0025 . . . . . . . . . . . .        L Near   00001EE8 _TEXT32
  @C0026 . . . . . . . . . . . .        L Near   0000214F _TEXT32
  @C0027 . . . . . . . . . . . .        L Near   00001F59 _TEXT32
  next_native_primative  . . . .        L Near   0000214C _TEXT32
  @C0023 . . . . . . . . . . . .        L Near   00001EE1 _TEXT32
  @C0028 . . . . . . . . . . . .        L Near   00002159 _TEXT32
  @C0029 . . . . . . . . . . . .        L Near   0000214C _TEXT32
  L&_0004  . . . . . . . . . . .        L Near   00002141 _TEXT32
  main_offset  . . . . . . . . .        L Near   000023D2 _TEXT32
  @C0034 . . . . . . . . . . . .        L Near   00002141 _TEXT32
  @C0035 . . . . . . . . . . . .        L Near   00002296 _TEXT32
  @C0036 . . . . . . . . . . . .        L Near   00002171 _TEXT32
  @C0037 . . . . . . . . . . . .        L Near   000022A2 _TEXT32
  @C0030 . . . . . . . . . . . .        L Near   00002113 _TEXT32
  @C0031 . . . . . . . . . . . .        L Near   000020F0 _TEXT32
  @C0032 . . . . . . . . . . . .        L Near   00002118 _TEXT32
  @C0033 . . . . . . . . . . . .        L Near   00002141 _TEXT32
  prim_offset  . . . . . . . . .        L Near   000021DA _TEXT32
  @C0038 . . . . . . . . . . . .        L Near   00002284 _TEXT32
  @C0039 . . . . . . . . . . . .        L Near   00002222 _TEXT32
  @C0044 . . . . . . . . . . . .        L Near   00002368 _TEXT32
  @C0045 . . . . . . . . . . . .        L Near   00002378 _TEXT32
  @C0046 . . . . . . . . . . . .        L Near   00002372 _TEXT32
  @C0047 . . . . . . . . . . . .        L Near   000023A1 _TEXT32
  @C0040 . . . . . . . . . . . .        L Near   000023EA _TEXT32
  id_offset  . . . . . . . . . .        L Near   00002282 _TEXT32
  @C0041 . . . . . . . . . . . .        L Near   00002349 _TEXT32
  @C0042 . . . . . . . . . . . .        L Near   0000234E _TEXT32
  @C0043 . . . . . . . . . . . .        L Near   00002373 _TEXT32
  @C002D . . . . . . . . . . . .        L Near   0000208C _TEXT32
  @C002E . . . . . . . . . . . .        L Near   00002084 _TEXT32
  @C002F . . . . . . . . . . . .        L Near   0000208E _TEXT32
  @C002A . . . . . . . . . . . .        L Near   00001F91 _TEXT32
  @C002B . . . . . . . . . . . .        L Near   00001F96 _TEXT32
  @C002C . . . . . . . . . . . .        L Near   00001FFC _TEXT32
  @C003D . . . . . . . . . . . .        L Near   0000226F _TEXT32
  @C003E . . . . . . . . . . . .        L Near   000023DF _TEXT32
  @C003F . . . . . . . . . . . .        L Near   000022F8 _TEXT32
  @C003A . . . . . . . . . . . .        L Near   00002222 _TEXT32
  @C003B . . . . . . . . . . . .        L Near   00002245 _TEXT32
  @C003C . . . . . . . . . . . .        L Near   0000224A _TEXT32
invUpdate_interrupt_descriptor16         P Near   000003E0 _TEXT32  0000003D Public   
invUpdate_interrupt_descriptor32         P Near   0000041D _TEXT32  0000003D Public   
invUpdate_required_primatives  .        P Near   00002538 _TEXT32  000000CD Public   
  L&_0005  . . . . . . . . . . .        L Near   000025BE _TEXT32
  @C005D . . . . . . . . . . . .        L Near   000025FF _TEXT32
  @C005A . . . . . . . . . . . .        L Near   000025AD _TEXT32
  @C005B . . . . . . . . . . . .        L Near   000025B4 _TEXT32
  @C005C . . . . . . . . . . . .        L Near   000025FE _TEXT32
  next_primative . . . . . . . .        L Near   000025DD _TEXT32
  @C0054 . . . . . . . . . . . .        L Near   0000257E _TEXT32
  @C0055 . . . . . . . . . . . .        L Near   000025D1 _TEXT32
  @C0056 . . . . . . . . . . . .        L Near   000025C4 _TEXT32
  @C0057 . . . . . . . . . . . .        L Near   000025B6 _TEXT32
  @C0050 . . . . . . . . . . . .        L Near   000025E9 _TEXT32
  @C0051 . . . . . . . . . . . .        L Near   00002569 _TEXT32
  @C0052 . . . . . . . . . . . .        L Near   000025F2 _TEXT32
  @C0053 . . . . . . . . . . . .        L Near   000025C9 _TEXT32
  @C0058 . . . . . . . . . . . .        L Near   0000259E _TEXT32
  @C0059 . . . . . . . . . . . .        L Near   000025B8 _TEXT32
requestor  . . . . . . . . . . .        P Near   00002C6B _TEXT32  000005D7 Public   
  @C0125 . . . . . . . . . . . .        L Near   000030CC _TEXT32
  L&_0015  . . . . . . . . . . .        L Near   00003237 _TEXT32
  L&_0012  . . . . . . . . . . .        L Near   00002F4A _TEXT32
  @C0126 . . . . . . . . . . . .        L Near   000030CD _TEXT32
  L&_0013  . . . . . . . . . . .        L Near   00002F65 _TEXT32
  @C0127 . . . . . . . . . . . .        L Near   000030FB _TEXT32
  @C0120 . . . . . . . . . . . .        L Near   00003068 _TEXT32
  @C00CD . . . . . . . . . . . .        L Near   00002C93 _TEXT32
  @C0121 . . . . . . . . . . . .        L Near   000030A4 _TEXT32
  @C00CE . . . . . . . . . . . .        L Near   00002D46 _TEXT32
  @C0122 . . . . . . . . . . . .        L Near   0000309E _TEXT32
  @C00CF . . . . . . . . . . . .        L Near   00002D3E _TEXT32
  @C0123 . . . . . . . . . . . .        L Near   0000309F _TEXT32
  @C00CC . . . . . . . . . . . .        L Near   00002D4C _TEXT32
  @C0128 . . . . . . . . . . . .        L Near   000030F8 _TEXT32
  @C0129 . . . . . . . . . . . .        L Near   000030F6 _TEXT32
  @C010D . . . . . . . . . . . .        L Near   00002FA4 _TEXT32
  @C010E . . . . . . . . . . . .        L Near   00002FB7 _TEXT32
  @C010F . . . . . . . . . . . .        L Near   00002FB7 _TEXT32
  @C00F4 . . . . . . . . . . . .        L Near   00002ED0 _TEXT32
  @C00F5 . . . . . . . . . . . .        L Near   00002EBE _TEXT32
  @C00F6 . . . . . . . . . . . .        L Near   00002EBE _TEXT32
  @C010A . . . . . . . . . . . .        L Near   00002FC2 _TEXT32
  @C00F7 . . . . . . . . . . . .        L Near   00002EBE _TEXT32
  @C010B . . . . . . . . . . . .        L Near   00002FBA _TEXT32
  @C010C . . . . . . . . . . . .        L Near   00002FAC _TEXT32
  @C00F0 . . . . . . . . . . . .        L Near   00002FC2 _TEXT32
  @C00F1 . . . . . . . . . . . .        L Near   00002F96 _TEXT32
  requestor_quit . . . . . . . .        L Near   0000323D _TEXT32
  @C00F2 . . . . . . . . . . . .        L Near   00002EC8 _TEXT32
  @C00F3 . . . . . . . . . . . .        L Near   00002E94 _TEXT32
  @C00F8 . . . . . . . . . . . .        L Near   00002EBE _TEXT32
  @C00F9 . . . . . . . . . . . .        L Near   00002F8C _TEXT32
  @C0134 . . . . . . . . . . . .        L Near   00003155 _TEXT32
  @C0135 . . . . . . . . . . . .        L Near   00003159 _TEXT32
  @C0136 . . . . . . . . . . . .        L Near   00003183 _TEXT32
  @C00DD . . . . . . . . . . . .        L Near   00002D71 _TEXT32
  @C0137 . . . . . . . . . . . .        L Near   00003182 _TEXT32
  @C00DE . . . . . . . . . . . .        L Near   00002D64 _TEXT32
  @C0130 . . . . . . . . . . . .        L Near   00003125 _TEXT32
  @C00DF . . . . . . . . . . . .        L Near   00002D61 _TEXT32
  @C0131 . . . . . . . . . . . .        L Near   00003188 _TEXT32
  @C0132 . . . . . . . . . . . .        L Near   0000315B _TEXT32
  find_func_copy_text  . . . . .        L Near   00002FA1 _TEXT32
  @C0133 . . . . . . . . . . . .        L Near   00003158 _TEXT32
  @C00DA . . . . . . . . . . . .        L Near   00002D27 _TEXT32
  @C00DB . . . . . . . . . . . .        L Near   00002D45 _TEXT32
  @C00DC . . . . . . . . . . . .        L Near   0000323D _TEXT32
  @C0138 . . . . . . . . . . . .        L Near   0000317F _TEXT32
  @C0139 . . . . . . . . . . . .        L Near   0000317C _TEXT32
  @C011D . . . . . . . . . . . .        L Near   00003128 _TEXT32
  @C011E . . . . . . . . . . . .        L Near   0000306D _TEXT32
  @C011F . . . . . . . . . . . .        L Near   00003067 _TEXT32
  @C011A . . . . . . . . . . . .        L Near   00003043 _TEXT32
  @C011B . . . . . . . . . . . .        L Near   0000303D _TEXT32
  @C011C . . . . . . . . . . . .        L Near   0000303E _TEXT32
  find_func_quit . . . . . . . .        L Near   00002FC2 _TEXT32
  @C0144 . . . . . . . . . . . .        L Near   00003237 _TEXT32
  @C0104 . . . . . . . . . . . .        L Near   00002F59 _TEXT32
  @C0145 . . . . . . . . . . . .        L Near   00003213 _TEXT32
  @C0105 . . . . . . . . . . . .        L Near   00002F65 _TEXT32
  @C0146 . . . . . . . . . . . .        L Near   0000322F _TEXT32
  @C0106 . . . . . . . . . . . .        L Near   00002F74 _TEXT32
  @C0147 . . . . . . . . . . . .        L Near   0000321F _TEXT32
  @C0107 . . . . . . . . . . . .        L Near   00002F77 _TEXT32
  @C0140 . . . . . . . . . . . .        L Near   000031DA _TEXT32
  @C00ED . . . . . . . . . . . .        L Near   00002E13 _TEXT32
  @C0100 . . . . . . . . . . . .        L Near   00002F23 _TEXT32
  @C0141 . . . . . . . . . . . .        L Near   000031DC _TEXT32
  @C0101 . . . . . . . . . . . .        L Near   00002F33 _TEXT32
  @C00EE . . . . . . . . . . . .        L Near   00002FC9 _TEXT32
  @C0142 . . . . . . . . . . . .        L Near   0000322F _TEXT32
  @C00EF . . . . . . . . . . . .        L Near   00002E6D _TEXT32
  @C0102 . . . . . . . . . . . .        L Near   00002F87 _TEXT32
  @C0143 . . . . . . . . . . . .        L Near   000031FA _TEXT32
  @C0103 . . . . . . . . . . . .        L Near   00002F87 _TEXT32
  @C00EA . . . . . . . . . . . .        L Near   00002DDC _TEXT32
  @C00EB . . . . . . . . . . . .        L Near   00002DE4 _TEXT32
  @C00EC . . . . . . . . . . . .        L Near   00002E18 _TEXT32
  @C0108 . . . . . . . . . . . .        L Near   00002F82 _TEXT32
  @C0109 . . . . . . . . . . . .        L Near   00002F94 _TEXT32
  @C012D . . . . . . . . . . . .        L Near   00003124 _TEXT32
  @C012E . . . . . . . . . . . .        L Near   00003122 _TEXT32
  @C00D4 . . . . . . . . . . . .        L Near   00002D27 _TEXT32
  @C012F . . . . . . . . . . . .        L Near   00003122 _TEXT32
  @C00D5 . . . . . . . . . . . .        L Near   00002CD2 _TEXT32
  @C00D6 . . . . . . . . . . . .        L Near   00002D25 _TEXT32
  @C00D7 . . . . . . . . . . . .        L Near   00002D20 _TEXT32
  @C012A . . . . . . . . . . . .        L Near   000030F6 _TEXT32
  @C00D0 . . . . . . . . . . . .        L Near   00002D30 _TEXT32
  @C012B . . . . . . . . . . . .        L Near   000030F9 _TEXT32
  @C00D1 . . . . . . . . . . . .        L Near   00002CA1 _TEXT32
  @C012C . . . . . . . . . . . .        L Near   00003127 _TEXT32
  @C00D2 . . . . . . . . . . . .        L Near   00002D3C _TEXT32
  @C00D3 . . . . . . . . . . . .        L Near   00002D2D _TEXT32
  @C00D8 . . . . . . . . . . . .        L Near   00002D17 _TEXT32
  @C00D9 . . . . . . . . . . . .        L Near   00002D18 _TEXT32
  @C0114 . . . . . . . . . . . .        L Near   00002FE5 _TEXT32
  @C0115 . . . . . . . . . . . .        L Near   00002FFD _TEXT32
  @C0116 . . . . . . . . . . . .        L Near   00002FF5 _TEXT32
  @C0117 . . . . . . . . . . . .        L Near   00003006 _TEXT32
  @C00FD . . . . . . . . . . . .        L Near   00002F13 _TEXT32
  @C0110 . . . . . . . . . . . .        L Near   0000300E _TEXT32
  @C00FE . . . . . . . . . . . .        L Near   00002F0A _TEXT32
  @C0111 . . . . . . . . . . . .        L Near   00003008 _TEXT32
  @C00FF . . . . . . . . . . . .        L Near   00002F23 _TEXT32
  @C0112 . . . . . . . . . . . .        L Near   00003005 _TEXT32
  @C0113 . . . . . . . . . . . .        L Near   00002FED _TEXT32
  @C00FA . . . . . . . . . . . .        L Near   00002EFE _TEXT32
  @C00FB . . . . . . . . . . . .        L Near   00002F08 _TEXT32
  @C00FC . . . . . . . . . . . .        L Near   00002F08 _TEXT32
  @C0118 . . . . . . . . . . . .        L Near   00003009 _TEXT32
  @C0119 . . . . . . . . . . . .        L Near   0000312D _TEXT32
  @C013D . . . . . . . . . . . .        L Near   000031EC _TEXT32
  @C013E . . . . . . . . . . . .        L Near   000031CC _TEXT32
  @C00E4 . . . . . . . . . . . .        L Near   00002DB7 _TEXT32
  @C013F . . . . . . . . . . . .        L Near   000031EE _TEXT32
  @C00E5 . . . . . . . . . . . .        L Near   00002DAC _TEXT32
  @C00E6 . . . . . . . . . . . .        L Near   00002DA6 _TEXT32
  @C00E7 . . . . . . . . . . . .        L Near   00002D9E _TEXT32
  @C013A . . . . . . . . . . . .        L Near   00003180 _TEXT32
  @C00E0 . . . . . . . . . . . .        L Near   00002D6C _TEXT32
  @C013B . . . . . . . . . . . .        L Near   0000323C _TEXT32
  @C00E1 . . . . . . . . . . . .        L Near   00002DEA _TEXT32
  @C013C . . . . . . . . . . . .        L Near   0000323A _TEXT32
  @C00E2 . . . . . . . . . . . .        L Near   00002DAF _TEXT32
  @C00E3 . . . . . . . . . . . .        L Near   00002D8C _TEXT32
  @C00E8 . . . . . . . . . . . .        L Near   00002DC5 _TEXT32
  @C00E9 . . . . . . . . . . . .        L Near   00002DE2 _TEXT32
  L&_0014  . . . . . . . . . . .        L Near   00002F87 _TEXT32
  @C0124 . . . . . . . . . . . .        L Near   000030CF _TEXT32
setup_pmode_variables  . . . . .        P Near   0239     _TEXT    0349     Public   
  @C0007 . . . . . . . . . . . .        L Near   025B     _TEXT
  @C0008 . . . . . . . . . . . .        L Near   0254     _TEXT
  @C0009 . . . . . . . . . . . .        L Near   025D     _TEXT
update_crc16_value . . . . . . .        P Near   01DF     _TEXT    0037     Public   
  F515 . . . . . . . . . . . . .        L Near   01F1     _TEXT
  I518 . . . . . . . . . . . . .        L Near   0206     _TEXT
  I519 . . . . . . . . . . . . .        L Near   0208     _TEXT
verify_crc16 . . . . . . . . . .        P Near   00F2     _TEXT    0094     Public   
  L&_0002  . . . . . . . . . . .        L Near   0171     _TEXT
  L&_0001  . . . . . . . . . . .        L Near   0136     _TEXT
  @C0004 . . . . . . . . . . . .        L Near   0174     _TEXT
  @C0001 . . . . . . . . . . . .        L Near   017A     _TEXT
  @C0002 . . . . . . . . . . . .        L Near   0115     _TEXT
  @C0003 . . . . . . . . . . . .        L Near   0180     _TEXT
  next_one . . . . . . . . . . .        L Near   0174     _TEXT


Symbols:

                N a m e                 Type       Value     Attr

@CodeSize  . . . . . . . . . . .        Number             0h 
@DataSize  . . . . . . . . . . .        Number             0h 
@Interface . . . . . . . . . . .        Number             0h 
@Model . . . . . . . . . . . . .        Number             1h 
@code  . . . . . . . . . . . . .        Text   _TEXT
@data  . . . . . . . . . . . . .        Text   DGROUP
@stack . . . . . . . . . . . . .        Text   DGROUP
GDT_ptr  . . . . . . . . . . . .        Word             A97h _TEXT 
IDT_ptr  . . . . . . . . . . . .        Word             A91h _TEXT 
_BOCHS1  . . . . . . . . . . . .        Number      12345678h 
_BOCHS2  . . . . . . . . . . . .        Number      87654321h 
_BOCHS_GET_MONO_CURSOR . . . . .        Number             1h 
_BOCHS_GET_MONO_MOUSE_XY . . . .        Number             0h 
_BOOT_DT_days  . . . . . . . . .        Number             1h 
_BOOT_DT_entry_type  . . . . . .        Number             Ah 
_BOOT_DT_np_offset . . . . . . .        Number             Bh 
_BOOT_DT_object_type . . . . . .        Number             0h 
_BOOT_DT_rp_offset . . . . . . .        Number             8h 
_BOOT_DT_seconds . . . . . . . .        Number             5h 
_BOOT_PB_crc16 . . . . . . . . .        Number            1Ch 
_BOOT_PB_dt_offset . . . . . . .        Number            1Ah 
_BOOT_PB_end_head  . . . . . . .        Number            10h 
_BOOT_PB_end_sector  . . . . . .        Number            12h 
_BOOT_PB_end_track . . . . . . .        Number            11h 
_BOOT_PB_entry_type  . . . . . .        Number            14h 
_BOOT_PB_linear_offset . . . . .        Number            16h 
_BOOT_PB_main  . . . . . . . . .        Number             4h 
_BOOT_PB_requestor . . . . . . .        Number             8h 
_BOOT_PB_size  . . . . . . . . .        Number             0h 
_BOOT_PB_start_head  . . . . . .        Number             Ch 
_BOOT_PB_start_sector  . . . . .        Number             Eh 
_BOOT_PB_start_track . . . . . .        Number             Dh 
_BOOT_PB_structure_size  . . . .        Number            20h 
_BOOT_RP_disk_offset . . . . . .        Number             Ch 
_BOOT_RP_end_head  . . . . . . .        Number            10h 
_BOOT_RP_end_sector  . . . . . .        Number            12h 
_BOOT_RP_end_track . . . . . . .        Number            11h 
_BOOT_RP_length  . . . . . . . .        Number             0h 
_BOOT_RP_main  . . . . . . . . .        Number             8h 
_BOOT_RP_nuserved  . . . . . . .        Number            10h 
_BOOT_RP_requestor . . . . . . .        Number             4h 
_BOOT_RP_start_head  . . . . . .        Number             Ch 
_BOOT_RP_start_sector  . . . . .        Number             Eh 
_BOOT_RP_start_track . . . . . .        Number             Dh 
_CW_DM . . . . . . . . . . . . .        Number             2h 
_CW_IM . . . . . . . . . . . . .        Number             1h 
_CW_INFINITY . . . . . . . . . .        Number          1000h 
_CW_OM . . . . . . . . . . . . .        Number             8h 
_CW_PM . . . . . . . . . . . . .        Number            20h 
_CW_PRECISION  . . . . . . . . .        Number           300h 
_CW_PRECISION_00 . . . . . . . .        Number             0h 
_CW_PRECISION_01 . . . . . . . .        Number           100h 
_CW_PRECISION_10 . . . . . . . .        Number           200h 
_CW_PRECISION_11 . . . . . . . .        Number           300h 
_CW_ROUNDING . . . . . . . . . .        Number           C00h 
_CW_ROUNDING_00  . . . . . . . .        Number             0h 
_CW_ROUNDING_01  . . . . . . . .        Number           400h 
_CW_ROUNDING_10  . . . . . . . .        Number           800h 
_CW_ROUNDING_11  . . . . . . . .        Number           C00h 
_CW_UM . . . . . . . . . . . . .        Number            10h 
_CW_ZM . . . . . . . . . . . . .        Number             4h 
_DISK_INVALID_DRIVE  . . . . . .        Number             1h 
_DISK_INVALID_PARAMETERS . . . .        Number             3h 
_DISK_INVALID_REQUEST  . . . . .        Number             2h 
_EFLAGS_ACF  . . . . . . . . . .        Number             4h 
_EFLAGS_ACF_MASK . . . . . . . .        Number            10h 
_EFLAGS_CF . . . . . . . . . . .        Number             0h 
_EFLAGS_CF_MASK  . . . . . . . .        Number             1h 
_EFLAGS_DF . . . . . . . . . . .        Number             Ah 
_EFLAGS_DF_MASK  . . . . . . . .        Number           400h 
_EFLAGS_IF . . . . . . . . . . .        Number             9h 
_EFLAGS_IF_MASK  . . . . . . . .        Number           200h 
_EFLAGS_IOPL . . . . . . . . . .        Number             Ch 
_EFLAGS_IOPL_MASK  . . . . . . .        Number          3000h 
_EFLAGS_NT . . . . . . . . . . .        Number             Eh 
_EFLAGS_NT_MASK  . . . . . . . .        Number          4000h 
_EFLAGS_OF . . . . . . . . . . .        Number             Bh 
_EFLAGS_OF_MASK  . . . . . . . .        Number           800h 
_EFLAGS_PF . . . . . . . . . . .        Number             2h 
_EFLAGS_PF_MASK  . . . . . . . .        Number             4h 
_EFLAGS_RF . . . . . . . . . . .        Number            10h 
_EFLAGS_RF_MASK  . . . . . . . .        Number         10000h 
_EFLAGS_SF . . . . . . . . . . .        Number             7h 
_EFLAGS_SF_MASK  . . . . . . . .        Number            80h 
_EFLAGS_TF . . . . . . . . . . .        Number             8h 
_EFLAGS_TF_MASK  . . . . . . . .        Number           100h 
_EFLAGS_VM . . . . . . . . . . .        Number            11h 
_EFLAGS_VM_MASK  . . . . . . . .        Number         20000h 
_EFLAGS_ZF . . . . . . . . . . .        Number             6h 
_EFLAGS_ZF_MASK  . . . . . . . .        Number            40h 
_EXODUS_BRACKET_HANDLE . . . . .        Number            10h 
_EXODUS_BRACKET_LENGTH . . . . .        Number            1Eh 
_EXODUS_BRACKET_NAME . . . . . .        Number             Ch 
_EXODUS_BRACKET_NEXT . . . . . .        Number             0h 
_EXODUS_BRACKET_PAREN_CASKS  . .        Number             4h 
_EXODUS_BRACKET_REQUESTOR  . . .        Number            14h 
_EXODUS_BRACKET_REQUESTOR_FUNC .        Number            16h 
_EXODUS_BRACKET_SCRATCH_AREA . .        Number            1Ah 
_EXODUS_BRACKET_TOTAL_PARENS . .        Number             8h 
_EXODUS_DATA_DATA_ITEM_LENGTH  .        Number             8h 
_EXODUS_DATA_DATA_ITEM_SOURCE  .        Number             4h 
_EXODUS_DATA_LENGTH  . . . . . .        Number             Ch 
_EXODUS_DATA_NEXT  . . . . . . .        Number             0h 
_EXODUS_INI_FIRST_BRACKET  . . .        Number             0h 
_EXODUS_INI_HEADER_LENGTH  . . .        Number            10h 
_EXODUS_INI_TOTAL_BRACKET_GROUPS         Number             8h 
_EXODUS_INI_TOTAL_BYTES  . . . .        Number             4h 
_EXODUS_INI_TOTAL_PAREN_CASKS  .        Number             Ch 
_EXODUS_INTS_size  . . . . . . .        Number             2h 
_EXODUS_MEM_base . . . . . . . .        Number             4h 
_EXODUS_MEM_gdt  . . . . . . . .        Number             Ch 
_EXODUS_MEM_ldt  . . . . . . . .        Number             Eh 
_EXODUS_MEM_limit  . . . . . . .        Number             8h 
_EXODUS_MEM_size . . . . . . . .        Number            10h 
_EXODUS_MEM_type . . . . . . . .        Number             0h 
_EXODUS_PAREN_DATA_ITEMS . . . .        Number             8h 
_EXODUS_PAREN_HANDLE . . . . . .        Number            18h 
_EXODUS_PAREN_LENGTH . . . . . .        Number            26h 
_EXODUS_PAREN_NEXT . . . . . . .        Number             0h 
_EXODUS_PAREN_NEXT_SAME_LINE . .        Number             4h 
_EXODUS_PAREN_REQUESTOR  . . . .        Number            1Ah 
_EXODUS_PAREN_REQUESTOR_FUNC . .        Number            1Eh 
_EXODUS_PAREN_SCRATCH_AREA . . .        Number            22h 
_EXODUS_PAREN_SOURCE_LINE  . . .        Number            10h 
_EXODUS_PAREN_SOURCE_LINE_LENGTH         Number            14h 
_EXODUS_PAREN_TOTAL_DATA_ITEMS .        Number             Ch 
_EXODUS_PORTS_size . . . . . . .        Number            10h 
_EXODUS_dot_com  . . . . . . . .        Word            1AEAh _TEXT32 
_EXODUS_requestor  . . . . . . .        Word            1ABEh _TEXT32 
_FDC_INVALID_DRIVE . . . . . . .        Number             4h 
_FDC_INVALID_MEDIA . . . . . . .        Number             6h 
_FDC_INVALID_PARAMETERS  . . . .        Number             1h 
_FDC_SECTOR_NOT_FOUND  . . . . .        Number             7h 
_FDC_SEEK_FAILED . . . . . . . .        Number             2h 
_FDC_TIMEOUT . . . . . . . . . .        Number             3h 
_FDC_UNKNOWN_DRIVE_TYPE  . . . .        Number             5h 
_MAX_PRIMATIVE . . . . . . . . .        Number           BB3h 
_MIN_PRIMATIVE . . . . . . . . .        Number            C8h 
_NO  . . . . . . . . . . . . . .        Number             0h 
_OBJECT_NOT_FOUND  . . . . . . .        Number             1h 
_RQ_UNKNOWN_REQUEST  . . . . . .        Number             1h 
_RQ_iDISK_DRIVE_NOT_FOUND  . . .        Number           3E8h 
_SW_BUSY . . . . . . . . . . . .        Number          8000h 
_SW_C0 . . . . . . . . . . . . .        Number           100h 
_SW_C1 . . . . . . . . . . . . .        Number           200h 
_SW_C2 . . . . . . . . . . . . .        Number           400h 
_SW_C3 . . . . . . . . . . . . .        Number          4000h 
_SW_DE . . . . . . . . . . . . .        Number             2h 
_SW_ERROR_SUMMARY  . . . . . . .        Number            80h 
_SW_IE . . . . . . . . . . . . .        Number             1h 
_SW_OE . . . . . . . . . . . . .        Number             8h 
_SW_PE . . . . . . . . . . . . .        Number            20h 
_SW_STACK_FAULT  . . . . . . . .        Number            40h 
_SW_TOS  . . . . . . . . . . . .        Number          3800h 
_SW_UE . . . . . . . . . . . . .        Number            10h 
_SW_ZE . . . . . . . . . . . . .        Number             4h 
_SYSTEM_182S_OF_A_SECOND . . . .        Number             Bh 
_SYSTEM_BUILD  . . . . . . . . .        Number            12h 
_SYSTEM_DAY  . . . . . . . . . .        Number             Ch 
_SYSTEM_DAY_OF_YEAR  . . . . . .        Number            10h 
_SYSTEM_HOURS  . . . . . . . . .        Number             8h 
_SYSTEM_MINUTES  . . . . . . . .        Number             9h 
_SYSTEM_MONO_VIDEO_MODE  . . . .        Number            25h 
_SYSTEM_MONTH  . . . . . . . . .        Number             Dh 
_SYSTEM_SECONDS  . . . . . . . .        Number             Ah 
_SYSTEM_SECONDS_SINCE_BOOTUP . .        Number             0h 
_SYSTEM_SECONDS_SINCE_MIDNIGHT .        Number             4h 
_SYSTEM_TOTAL_MEMORY . . . . . .        Number            1Ch 
_SYSTEM_VGA_HORIZONTAL . . . . .        Number            20h 
_SYSTEM_VGA_VERTICAL . . . . . .        Number            22h 
_SYSTEM_VGA_VIDEO_MODE . . . . .        Number            24h 
_SYSTEM_YEAR . . . . . . . . . .        Number             Eh 
_SYSTEM_i_BASE . . . . . . . . .        Number           812h 
_SYSTEM_i_CODE_GDT_OFFSET  . . .        Number           824h 
_SYSTEM_i_DATA_GDT_OFFSET  . . .        Number           828h 
_SYSTEM_i_DWORD_TO_COPY  . . . .        Number           81Ah 
_SYSTEM_i_FATAL  . . . . . . . .        Number           800h 
_SYSTEM_i_GDT_TO_ASSIGN  . . . .        Number           834h 
_SYSTEM_i_IRQ6_INDICATOR . . . .        Number           810h 
_SYSTEM_i_IRQ6_INDICATOR_LAST  .        Number           811h 
_SYSTEM_i_LAST_GDT_REFERENCED  .        Number           81Ch 
_SYSTEM_i_LIMIT  . . . . . . . .        Number           816h 
_SYSTEM_i_MAIN_GDT_OFFSET  . . .        Number           82Ch 
_SYSTEM_i_REQUESTOR_GDT_OFFSET .        Number           830h 
_SYSTEM_i_SCRATCH_DWORD1 . . . .        Number           BFCh 
_SYSTEM_i_SCRATCH_DWORD2 . . . .        Number           BF8h 
_SYSTEM_i_TASKS_BY_ERROR . . . .        Number           80Ch 
_SYSTEM_i_TASKS_BY_USER  . . . .        Number           808h 
_SYSTEM_i_TASKS_CREATED  . . . .        Number           804h 
_SYSTEM_i_USER_GDT_TO_ASSIGN . .        Number           836h 
_TASK_NOT_FOUND  . . . . . . . .        Number             0h 
_TSS_BACK_LINK . . . . . . . . .        Number             0h 
_TSS_CR3 . . . . . . . . . . . .        Number            1Ch 
_TSS_CS  . . . . . . . . . . . .        Number            4Ch 
_TSS_DS  . . . . . . . . . . . .        Number            54h 
_TSS_EAX . . . . . . . . . . . .        Number            28h 
_TSS_EBP . . . . . . . . . . . .        Number            3Ch 
_TSS_EBX . . . . . . . . . . . .        Number            34h 
_TSS_ECX . . . . . . . . . . . .        Number            2Ch 
_TSS_EDI . . . . . . . . . . . .        Number            44h 
_TSS_EDX . . . . . . . . . . . .        Number            30h 
_TSS_EFLAGS  . . . . . . . . . .        Number            24h 
_TSS_EIP . . . . . . . . . . . .        Number            20h 
_TSS_ES  . . . . . . . . . . . .        Number            48h 
_TSS_ESI . . . . . . . . . . . .        Number            40h 
_TSS_ESP . . . . . . . . . . . .        Number            38h 
_TSS_ESP0  . . . . . . . . . . .        Number             4h 
_TSS_ESP1  . . . . . . . . . . .        Number             Ch 
_TSS_ESP2  . . . . . . . . . . .        Number            14h 
_TSS_FPU_SAVE_AREA . . . . . . .        Number            68h 
_TSS_FS  . . . . . . . . . . . .        Number            58h 
_TSS_GS  . . . . . . . . . . . .        Number            5Ch 
_TSS_IO_MAP  . . . . . . . . . .        Number            66h 
_TSS_LDT . . . . . . . . . . . .        Number            60h 
_TSS_SS  . . . . . . . . . . . .        Number            50h 
_TSS_SS0 . . . . . . . . . . . .        Number             8h 
_TSS_SS1 . . . . . . . . . . . .        Number            10h 
_TSS_SS2 . . . . . . . . . . . .        Number            18h 
_TSS_TRAP_BIT  . . . . . . . . .        Number            64h 
_TSS_TRAP_BIT_MASK . . . . . . .        Number             1h 
_UNKNOWN_OBJECT_EVENT  . . . . .        Number             4h 
_UNKNOWN_OBJECT_PROPERTY . . . .        Number             3h 
_UNKNOWN_OBJECT_TYPE . . . . . .        Number             2h 
_VID_clear_screen_vga  . . . . .        Word            1AC0h _TEXT32 
_VID_display_decimal_in_edx_nr_vga         Word            1AC2h _TEXT32 
_VID_display_string_ecx_nr_vga .        Word            1AC4h _TEXT32 
_VID_display_string_ecx_vga  . .        Word            1AC6h _TEXT32 
_VID_display_string_nr_vga . . .        Word            1AC8h _TEXT32 
_VID_display_string_vga  . . . .        Word            1ACAh _TEXT32 
_VID_draw_exodus_boot_screen . .        Word            1AECh _TEXT32 
_VID_draw_logo . . . . . . . . .        Word            1ADEh _TEXT32 
_VID_freeze_frame_mono . . . . .        Word            1AE4h _TEXT32 
_VID_freeze_frame_vga  . . . . .        Word            1ACCh _TEXT32 
_VID_g_display_radix_in_edx_mono         Word            1AE2h _TEXT32 
_VID_g_mono_clear_screen . . . .        Word            1AD6h _TEXT32 
_VID_g_mono_display_text . . . .        Word            1AD2h _TEXT32 
_VID_g_mono_display_text_mode  .        Word            1AD4h _TEXT32 
_VID_g_set_font_16x16  . . . . .        Word            1ADCh _TEXT32 
_VID_g_set_font_8x14 . . . . . .        Word            1ADAh _TEXT32 
_VID_g_set_font_8x8  . . . . . .        Word            1AD8h _TEXT32 
_VID_mono_enter_graphics_mode  .        Word            1AD0h _TEXT32 
_VID_move_to_next_line_vga . . .        Word            1AE6h _TEXT32 
_VID_position_cursor_vga . . . .        Word            1ACEh _TEXT32 
_VID_requestor . . . . . . . . .        Word            1AE0h _TEXT32 
_VID_set_attribute_vga . . . . .        Word            1AE8h _TEXT32 
_YES . . . . . . . . . . . . . .        Number             1h 
_cgTEMP_PRIMATIVE_MAIN . . . . .        Number          5DA0h 
_cgTEMP_PRIMATIVE_REQUESTOR  . .        Number          5DA8h 
_csTEMP_PRIMATIVE  . . . . . . .        Number          5DB0h 
_dsTEMP_PRIMATIVE  . . . . . . .        Number          5DB8h 
_firstASSIGNMENT . . . . . . . .        Number            32h 
_firstUSER_ASSIGNMENT  . . . . .        Number           BB8h 
_lastASSIGNMENT  . . . . . . . .        Number            C7h 
_lastGDT . . . . . . . . . . . .        Number           FFFh 
_lastUSER_ASSIGNMENT . . . . . .        Number           FFFh 
_sALL_MEM  . . . . . . . . . . .        Number            40h 
_sALL_MEM_base . . . . . . . . .        Number             0h 
_sALL_MEM_limit  . . . . . . . .        Number      FFFFFFFFh 
_sCODE . . . . . . . . . . . . .        Number            20h 
_sCODE_base  . . . . . . . . . .        Number         10000h 
_sCODE_limit . . . . . . . . . .        Number         40000h 
_sDATA . . . . . . . . . . . . .        Number            48h 
_sDATA_base  . . . . . . . . . .        Number         10000h 
_sDATA_limit . . . . . . . . . .        Number         30000h 
_sDEBI_dt  . . . . . . . . . . .        Number           138h 
_sDEBI_dt_base . . . . . . . . .        Number        240000h 
_sDEBI_dt_limit  . . . . . . . .        Number          8000h 
_sDEBI_memory  . . . . . . . . .        Number            D8h 
_sDEBI_memory_base . . . . . . .        Number        279400h 
_sDEBI_memory_limit  . . . . . .        Number          8000h 
_sDEBI_np  . . . . . . . . . . .        Number           140h 
_sDEBI_np_base . . . . . . . . .        Number        248000h 
_sDEBI_np_limit  . . . . . . . .        Number          8000h 
_sDEBI_rp  . . . . . . . . . . .        Number           148h 
_sDEBI_rp_base . . . . . . . . .        Number        250000h 
_sDEBI_rp_limit  . . . . . . . .        Number          8000h 
_sDEBI_screen  . . . . . . . . .        Number            D0h 
_sDEBI_screen2 . . . . . . . . .        Number            F0h 
_sDEBI_screen2_base  . . . . . .        Number        258000h 
_sDEBI_screen2_limit . . . . . .        Number         28000h 
_sDEBI_screen_base . . . . . . .        Number        281400h 
_sDEBI_screen_limit  . . . . . .        Number          8000h 
_sDEBI_temp  . . . . . . . . . .        Number            F8h 
_sEXODUS_INI . . . . . . . . . .        Number           190h 
_sEXODUS_INI_ERRORS  . . . . . .        Number           198h 
_sEXODUS_INI_ERRORS_base . . . .        Number        210000h 
_sEXODUS_INI_ERRORS_limit  . . .        Number          4000h 
_sEXODUS_INI_base  . . . . . . .        Number        200000h 
_sEXODUS_INI_limit . . . . . . .        Number         10000h 
_sEXODUS_INTS  . . . . . . . . .        Number            60h 
_sEXODUS_INTS_base . . . . . . .        Number         97E00h 
_sEXODUS_INTS_limit  . . . . . .        Number           200h 
_sEXODUS_MEM . . . . . . . . . .        Number            50h 
_sEXODUS_MEM_base  . . . . . . .        Number         70C00h 
_sEXODUS_MEM_limit . . . . . . .        Number          4000h 
_sEXODUS_OBJECTS . . . . . . . .        Number           100h 
_sEXODUS_OBJECTS_base  . . . . .        Number         50000h 
_sEXODUS_OBJECTS_limit . . . . .        Number          8000h 
_sEXODUS_PORTS . . . . . . . . .        Number            58h 
_sEXODUS_PORTS_base  . . . . . .        Number         6CC00h 
_sEXODUS_PORTS_limit . . . . . .        Number          4000h 
_sEXODUS_REQUESTOR . . . . . . .        Number            B0h 
_sEXODUS_SLAVE_TASK_GATE . . . .        Number            88h 
_sEXODUS_SLAVE_TSS . . . . . . .        Number            80h 
_sEXODUS_SLAVE_TSS_base  . . . .        Number         68200h 
_sEXODUS_SLAVE_TSS_limit . . . .        Number           100h 
_sEXODUS_TASK_GATE . . . . . . .        Number            78h 
_sEXODUS_TSS . . . . . . . . . .        Number            70h 
_sEXODUS_TSS_base  . . . . . . .        Number         68100h 
_sEXODUS_TSS_limit . . . . . . .        Number           100h 
_sFLOPPY_TRACK . . . . . . . . .        Number            E0h 
_sFLOPPY_TRACK_base  . . . . . .        Number         74C00h 
_sFLOPPY_TRACK_limit . . . . . .        Number          4800h 
_sGDT  . . . . . . . . . . . . .        Number            10h 
_sGDT_base . . . . . . . . . . .        Number           800h 
_sGDT_init . . . . . . . . . . .        Number            C7h 
_sGDT_limit  . . . . . . . . . .        Number          8000h 
_sGRAPHICS . . . . . . . . . . .        Number            28h 
_sGRAPHICS_base  . . . . . . . .        Number         A0000h 
_sGRAPHICS_limit . . . . . . . .        Number         10000h 
_sIDT  . . . . . . . . . . . . .        Number             8h 
_sIDT_base . . . . . . . . . . .        Number         8A000h 
_sIDT_limit  . . . . . . . . . .        Number           800h 
_sMONO . . . . . . . . . . . . .        Number            30h 
_sMONO_base  . . . . . . . . . .        Number         B0000h 
_sMONO_limit . . . . . . . . . .        Number          8000h 
_sPRIMATIVES . . . . . . . . . .        Number            98h 
_sPRIMATIVES_base  . . . . . . .        Number         8D380h 
_sPRIMATIVES_limit . . . . . . .        Number          4000h 
_sPRIMATIVE_LOAD_INFO  . . . . .        Number            A0h 
_sPRIMATIVE_LOAD_INFO_base . . .        Number         8C380h 
_sPRIMATIVE_LOAD_INFO_limit  . .        Number          1000h 
_sSTACK  . . . . . . . . . . . .        Number            18h 
_sSTACK0 . . . . . . . . . . . .        Number           120h 
_sSTACK0_base  . . . . . . . . .        Number         95380h 
_sSTACK0_limit . . . . . . . . .        Number          2000h 
_sSTACK1 . . . . . . . . . . . .        Number           128h 
_sSTACK1_base  . . . . . . . . .        Number         93380h 
_sSTACK1_limit . . . . . . . . .        Number          2000h 
_sSTACK2 . . . . . . . . . . . .        Number           130h 
_sSTACK2_base  . . . . . . . . .        Number         91380h 
_sSTACK2_limit . . . . . . . . .        Number          2000h 
_sSTACK_base . . . . . . . . . .        Number         98000h 
_sSTACK_limit  . . . . . . . . .        Number          8000h 
_sSYSTEM . . . . . . . . . . . .        Number            A8h 
_sSYSTEM_RING1 . . . . . . . . .        Number            B8h 
_sSYSTEM_RING2 . . . . . . . . .        Number            C0h 
_sSYSTEM_RING3 . . . . . . . . .        Number            C8h 
_sSYSTEM_USER_limit  . . . . . .        Number           800h 
_sSYSTEM_base  . . . . . . . . .        Number         89400h 
_sSYSTEM_limit . . . . . . . . .        Number           C00h 
_sTASK_STACK . . . . . . . . . .        Number           118h 
_sTASK_STACK_base  . . . . . . .        Number        220000h 
_sTASK_STACK_limit . . . . . . .        Number          8000h 
_sTASK_SWITCH_TASK_GATE  . . . .        Number           110h 
_sTASK_SWITCH_TSS  . . . . . . .        Number           108h 
_sTASK_SWITCH_TSS_base . . . . .        Number         68000h 
_sTASK_SWITCH_TSS_limit  . . . .        Number           100h 
_sTASK_SYSTEM  . . . . . . . . .        Number           1A0h 
_sTASK_SYSTEM_base . . . . . . .        Number        210000h 
_sTASK_SYSTEM_limit  . . . . . .        Number         10000h 
_sVGA  . . . . . . . . . . . . .        Number            38h 
_sVGA_BACKUP . . . . . . . . . .        Number            E8h 
_sVGA_BACKUP_base  . . . . . . .        Number         60000h 
_sVGA_BACKUP_limit . . . . . . .        Number          8000h 
_sVGA_base . . . . . . . . . . .        Number         B8000h 
_sVGA_limit  . . . . . . . . . .        Number          8000h 
boot_dt_linear . . . . . . . . .        DWord            A85h _TEXT 
boot_np_linear . . . . . . . . .        DWord            A89h _TEXT 
boot_parameter_block . . . . . .        DWord            A7Bh _TEXT 
boot_parameter_count . . . . . .        Word             A7Fh _TEXT 
boot_rp_linear . . . . . . . . .        DWord            A8Dh _TEXT 
bootscreen_end . . . . . . . . .        L Near          1ABEh _TEXT32 
bootscreen_start . . . . . . . .        L Near           76Ah _TEXT32 
bootup_id1 . . . . . . . . . . .        Byte             875h _TEXT 
bootup_id2 . . . . . . . . . . .        Byte             8C5h _TEXT 
code_gdt_offset  . . . . . . . .        DWord            528h _TEXT32 
comma_space  . . . . . . . . . .        Byte[3]          767h _TEXT32 
crc_comparitive  . . . . . . . .        Byte[12]         95Bh _TEXT 
crc_error_code . . . . . . . . .        Byte[25]         987h _TEXT 
crc_error_end  . . . . . . . . .        L Near           A7Bh _TEXT 
crc_error_start  . . . . . . . .        Byte[32]         967h _TEXT 
data_gdt_offset  . . . . . . . .        DWord            52Ch _TEXT32 
enabling_gate_a20  . . . . . . .        Byte             924h _TEXT 
end_of_16_bit_segment  . . . . .        L Near           A9Dh _TEXT 
end_of_32_bit_segment  . . . . .        L Near          3242h _TEXT32 
entering_pmode . . . . . . . . .        Byte             942h _TEXT 
error_loading_exodus_ini_1 . . .        Byte[54]         585h _TEXT32 
error_loading_exodus_ini_2 . . .        Byte[62]         5BBh _TEXT32 
error_loading_exodus_ini_3 . . .        Byte[68]         5F9h _TEXT32 
error_loading_exodus_ini_4 . . .        Byte[61]         63Dh _TEXT32 
exodus_internal_text . . . . . .        Byte[19]         539h _TEXT32 
failed . . . . . . . . . . . . .        Byte[8]         1D14h _TEXT32 
failed_end . . . . . . . . . . .        L Near          1EBDh _TEXT32 
first_pmode_instruction  . . . .        L Near             0h _TEXT32 
found_it_text  . . . . . . . . .        Byte[13]         6BDh _TEXT32 
last_item  . . . . . . . . . . .        Byte[5]          762h _TEXT32 
line_text  . . . . . . . . . . .        Byte             6CAh _TEXT32 
loading_drivers  . . . . . . . .        Byte[18]         74Bh _TEXT32 
loading_primatives . . . . . . .        Byte[21]         736h _TEXT32 
loading_primatives_displayed . .        Byte             735h _TEXT32 
main_gdt_offset  . . . . . . . .        DWord            530h _TEXT32 
next_item  . . . . . . . . . . .        Byte[5]          75Dh _TEXT32 
next_linear_address  . . . . . .        DWord            A81h _TEXT 
no_support_for_primative . . . .        Byte             510h _TEXT32 
parse_bracket_group_name_too_long         Byte[46]         707h _TEXT32 
parse_expected_bracket_paren . .        Byte[16]         6D5h _TEXT32 
parse_expected_paren . . . . . .        Byte[11]         6E5h _TEXT32 
parse_unexpected_end_of_file . .        Byte[23]         6F0h _TEXT32 
requestor_gdt_offset . . . . . .        DWord            534h _TEXT32 
required_native_primatives . . .        Byte[21]        1AF2h _TEXT32 
setup_pmode_vars . . . . . . . .        Byte             932h _TEXT 
start  . . . . . . . . . . . . .        L Near             0h _TEXT 
system_halted  . . . . . . . . .        Byte[67]         67Ah _TEXT32 
unknown_function_text  . . . . .        Byte[11]         54Ch _TEXT32 
unknown_primative_text . . . . .        Byte[21]         570h _TEXT32 
unknown_user_function_text . . .        Byte[25]         557h _TEXT32 
verifying_crc  . . . . . . . . .        Byte             915h _TEXT 
vga_kbd_support  . . . . . . . .        Byte             538h _TEXT32 

bootup.asm: 282 lines, 3 passes, 30000 ms, 0 warnings, 0 errors
