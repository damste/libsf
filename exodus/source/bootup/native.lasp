// native.asp
//
// Exodus Native Primatives declaration
// December 24, 2000
//
// * Refer to inf\native.inf for more information
// * Note, the mechanical operations of this process are governed by inf\primload.inf
// * Native Primatives run in the call gate range of 200 - 2999
//
//  Functions:
//    - invSetup_native_primatives               // sets up the native primates specified as boot drivers
//    - default_primative_response               // provides a system for undefined primatives
//    - invCopy_this_part                        // copies a portion of data (called multiple times)
//    - invMove_temp_gdts_to_permanent           // copies the temporary primative GDT entries to their permanent locations
//    - invAdd_primative                         // adds a primative to between _MIN_PRIMATIVE and _MAX_PRIMATIVE call gates
//    + invUpdate_required_primatives            // updates an driver/program with the required call gates to run
//
//





function invSetup_native_primatives    NEAR
{
// This routine is responsible for setting up all Exodus native primatives
//
// Upon entry:   It is known that the GDT slots setup in the init16 algorithms are used
//
// Upon exit:    The native primative call gates are defined in the GDT and IDT
//
    push    gs
    push    fs
    push    es
    push    ds
  // * Note:  Can't use EBP here because it is returned as a parameter from the primatives
  // * Note:  These references all use ESP.  No PUSH/POP's are to be used unless they are self-terminating
  //          and in-between references of [esp+xx].
    sub     esp,68
  // [esp+64] - <Used for debugging>
  // [esp+60] - temporary
  // [esp+56] - temporary
  // [esp+52] - temporary
  // [esp+48] - temporary
  // [esp+44] - holds primative selector
  // [esp+40] - ptr to NP in linear memory
  // [esp+36] - ptr to DT in linear memory
  // [esp+32] - holds current value of esi (boot_parameter_block)
  // [esp+28] - temporary "Length of definition block" ptr into _sPRIMATIVE_LOAD_INFO
  // [esp+24] - requestor(-1) ebp - ptr to author text (null-terminated)
  // [esp+20] - requestor(-1) ebx - ptr to version text (null-terminated)
  // [esp+16] - requestor(-1) edi - ptr to driver self-identified name (null-terminated)
  // [esp+12] - requestor(-1) esi - ptr to native primative structure for this driver
  // [esp+08] - --Nuserved
  // [esp+04] - requestor(-1) ecx - actual number of bytes to keep after each driver is initialized
  // [esp+00] - driver name from NP (linear offset in memory)
  //

    cld
   // Setup the parameters for the default primative response
    xor     eax,eax
    mov     ebx,offset default_primative_response                   // Offset to function
    xor     ecx,ecx                                                 // Number of dword to copy if privledge level change
    mov     dx,_sCODE                                               // Code segment selector
    mov     eax,_MIN_PRIMATIVE
    while (eax <= _MAX_PRIMATIVE)
    {
        invCreate_call_gate_descriptor32()
        inc     eax
    }

   // Initialize our primative memory areas
    mov     eax,_sPRIMATIVES
    mov     es,eax
    xor     edi,edi
    mov     ecx,_sPRIMATIVES_limit
    mov     al,0ffh
    rep     stosb
    mov     u32 ptr es:[0],8
    mov     u32 ptr es:[4],_MIN_PRIMATIVE

    mov     eax,_sPRIMATIVE_LOAD_INFO
    mov     es,eax
    xor     edi,edi
    mov     ecx,_sPRIMATIVE_LOAD_INFO_limit
    xor     al,al
    rep     stosb
    mov     u32 ptr es:[0],4

   // Now, process all of the drivers that were loaded at bootup
    mov     eax,_sALL_MEM
    mov     ds,eax
    mov     esi,cs:boot_parameter_block
    inc     esi                                                     // Move passed the boot drive letter
    mov     ebx,cs:boot_dt_linear
    mov     ecx,cs:boot_np_linear
    mov     u32 ptr [esp+36],ebx
    mov     u32 ptr [esp+40],ecx
    mov     u32 ptr [esp+64],0                                 // Used for debugging
    while (byte ptr ds:[esi+_BOOT_PB_entry_type] != 0ffh)
    {
      // Let's see what this bad boy is
        mov     al,u8 ptr ds:[esi+_BOOT_PB_entry_type]
        and     al,1111b
        if (al == 011b)
        {
          // It's a driver
          // Store driver name (linear offset to it)
            mov     u32 ptr [esp+32],esi
            mov     ebx,u32 ptr [esp+36]
            mov     edx,u32 ptr [esp+40]

            xor     eax,eax
            mov     ax,u16 ptr ds:[esi+_BOOT_PB_dt_offset]
            add     ebx,eax
            if (word ptr ds:[ebx+_BOOT_DT_np_offset] != 0ffffh)
            {
              // Name was specified
                mov     edx,cs:boot_np_linear
                xor     eax,eax
                mov     ax,u16 ptr ds:[esi+_BOOT_DT_np_offset]
                add     edx,eax
            
            } else {
                mov     edx,0ffffffffh
            }
            mov     u32 ptr [esp+00],edx

           // Build the temporary GDT entries for our initialization

          // Build the temporary code segment
            mov     eax,_csTEMP_PRIMATIVE / 8
            mov     ebx,u32 ptr ds:[esi+_BOOT_PB_linear_offset]
            mov     edx,u32 ptr ds:[esi+_BOOT_PB_size]
            invCreate_code_descriptor32()

          // Build the temporary data segment
            mov     eax,_dsTEMP_PRIMATIVE / 8
            mov     ebx,u32 ptr ds:[esi+_BOOT_PB_linear_offset]
            mov     edx,u32 ptr ds:[esi+_BOOT_PB_size]
            invCreate_data_descriptor32()

          // Build the temporary call gates
            mov     eax,_cgTEMP_PRIMATIVE_MAIN / 8
            mov     ebx,u32 ptr ds:[esi+_BOOT_PB_main]
            xor     ecx,ecx
            mov     dx,_csTEMP_PRIMATIVE
            invCreate_call_gate_descriptor32()

            mov     eax,_cgTEMP_PRIMATIVE_REQUESTOR / 8
            mov     ebx,u32 ptr ds:[esi+_BOOT_PB_requestor]
            xor     ecx,ecx
            mov     dx,_csTEMP_PRIMATIVE
            invCreate_call_gate_descriptor32()

;; Call the requestor function to get "Program Information"
;; 'info'

          // Ok, the temporary code segment, data segment and call gate are built
          // Now, we need to call the requestor function so it can work its magic
            mov     eax,_dsTEMP_PRIMATIVE
            mov     ds,eax
            mov     eax,'info'                                      // Requestor function for "Program Information"
            _cgTEMP_PRIMATIVE_REQUESTOR()
          // Right now, the information specified in INF\REQUESTR.INF is supposed to be available
            if (eax != 'nati')
            {
              // This program was identified as a driver in DT, but it's not a native primative.  This is a fatal error.
                init_failed()                                 // at the bottom of this source file
                // * Note:  The init_failed() routine is terminal.  Control will never return here.
            }
          // It is a driver.  We should treat it as such. :)
          // Store the information it provided to us
            mov     u32 ptr [esp+04],ecx
            mov     u32 ptr [esp+12],esi
            mov     u32 ptr [esp+16],edi
            mov     u32 ptr [esp+20],ebx
            mov     u32 ptr [esp+24],ebp

          // Now, let's copy the relevent information
            mov     eax,_sPRIMATIVES
            mov     es,eax
            mov     eax,_sPRIMATIVE_LOAD_INFO
            mov     fs,eax
            mov     eax,_sALL_MEM
            mov     gs,eax

          // Copy the this driver's code and data segment GDT entries from their temporary area to a permanent area
            mov     eax,u32 ptr es:[4]
            shl     eax,3                                           // Multiply by 8
            mov     esi,u32 ptr [esp+32]
            invMove_temp_gdts_to_permanent()
            shr     eax,3                                           // Divide by 8
            mov     u32 ptr es:[4],eax

          // Get our starting offsets into the two memory areas
            mov     edi,u32 ptr fs:[0]
            mov     ebx,u32 ptr es:[0]


           // Do the load info structure
           // * Refer to inf\primload.inf for information on this structure
            mov     u16 ptr fs:[edi],bx                            // store the offset in our load info structure
            mov     eax,edi
            add     eax,2
            mov     u32 ptr [esp+28],eax                       // Now, store a ptr to the location where we'll eventually
                                                                    //   store the length of the primative structure this driver
                                                                    //   has requested (the ptr is stored in temp variable space)
          // Move past those two word entries
            add     edi,4

          // Store the driver's filename
          // A small degree of indirection here :)
            mov     eax,u32 ptr [esp+32]                       // Get a pointer to this driver's boot_parameter_block entry
            xor     ebx,ebx
            mov     bx,u16 ptr gs:[eax+_BOOT_PB_dt_offset]         // Which tells us where our DT entry is
            add     ebx,2                                           // Move past the sector indicator
            add     ebx,u32 ptr [esp+36]
            mov     bx,u16 ptr gs:[ebx+_BOOT_DT_np_offset]         // Which tells us where our NP entry is
            and     ebx,0ffffh
            add     ebx,2
            add     ebx,u32 ptr [esp+40]
            xor     ecx,ecx
            mov     cl,u8 ptr gs:[ebx]                            // Where we get our filename length
            inc     ecx
            repeat; And finally, where we copy the text from
            {
                mov     al,u8 ptr gs:[ebx]
                mov     u8 ptr fs:[edi],al
                inc     ebx
                inc     edi
            } untilcxz

          // Store the driver's self-assigned name (what it calls itself)
            mov     ebx,u32 ptr [esp+16]
            invCopy_this_part()

          // Store the driver's version text
            mov     ebx,u32 ptr [esp+20]
            invCopy_this_part()

          // Store the author's name text
            mov     ebx,u32 ptr [esp+24]
            invCopy_this_part()

          // Store the GDT offsets for the main portions of this function
            push    gs
            mov     eax,_sSYSTEM
            mov     gs,eax
            mov     eax,u32 ptr gs:[_SYSTEM_i_CODE_GDT_OFFSET]
            mov     u32 ptr fs:[edi],eax
            mov     ebp,eax
            add     edi,4
            mov     eax,u32 ptr gs:[_SYSTEM_i_DATA_GDT_OFFSET]
            mov     u32 ptr fs:[edi],eax
            add     edi,4
            mov     eax,u32 ptr gs:[_SYSTEM_i_MAIN_GDT_OFFSET]
            mov     u32 ptr fs:[edi],eax
            add     edi,4
            mov     eax,u32 ptr gs:[_SYSTEM_i_REQUESTOR_GDT_OFFSET]
            mov     u32 ptr fs:[edi],eax
            add     edi,4
            pop     gs

          // And, finally, update the next location pointer in this _sPRIMATIVE_LOAD_INFO structure
            mov     u32 ptr fs:[0],edi

           // Parse their primatives structure
           // * Refer to inf\primload.inf for information on the structure this information is converted to in Exodus
           // * Refer to inf\requestr.inf for information on the structure the driver provides
            mov     esi,u32 ptr [esp+12]
            xor     ecx,ecx
            while (byte ptr [esi] != 0ffh)
            {
                mov     cl,u8 ptr [esi]
                inc     esi
                mov     edx,u32 ptr [esi+ecx]                     // Offset to function
                mov     bx,u16 ptr [esi+ecx+4]                     // Dwords to copy
                mov     eax,u32 ptr es:[4]                        // Call gate for this primative
                shl     eax,3                                       // Multiply by 8 to get the call gate offset (rather than slot)
              // Right now,      ds:[esi] - far ptr to primative function name
              //                      ebp - code segment for this driver
              //                      eax - GDT slot
              //                      ecx - length
              //                      edx - offset into driver for access to this function
              //                       bx - dwords to copy

              // Let's add it
                invAdd_primative()
                inc     u32 ptr es:[4]                            // Move to the next primative SLOT

                add     esi,ecx                                     // Move past the function name
                add     esi,6                                       // Move past the function offset (dword)
            }


          // At this point, we've received all the information from this first REQUESTOR request
          // The additional request, 'prim' and 'ints' are not executed until after *ALL* the drivers are loaded (in case they're
          //                         loaded out of order.  Look below for the followup loads that take place once all the
          //                         primatives have been installed.

          // Phew!
          // It's loaded and all processed and everything
            if (cs:vga_kbd_support == 0)
            {
              // We don't have our VGA/keyboard drivers installed yet, let's see if this most recent driver installed any of them
                mov     eax,_sDATA
                mov     ds,eax

                mov     esi,offset required_native_primatives
                mov     edi,offset _VID_clear_screen_vga
                invUpdate_required_primatives()
                if (!carry?)
                {
                  // All required primatives were found
                  // We have the ability to display stuff on the screen and get a key
                    mov     ds:vga_kbd_support,1
                }
            }

          @@:
          // Proceed along happily to the next driver :)
            mov     eax,_sALL_MEM
            mov     ds,eax
            mov     esi,u32 ptr [esp+32]
        }

      next_native_primative:
        add     esi,_BOOT_PB_structure_size
    }


  // If we're here, then everything has loaded ok, or the ones that didn't load correctly were ignored
  // Now, since all of the drivers were loaded we need to go ahead and call the remaining requestor() functions, 'prim' and 'ints'
  // Once those are called we call main() in each one in the order loaded
  //
  // * Note:  When we get here, all of the [esp+xx] references above are no longer in use
  //



  // Setup the video information for the following portion of code.  From here on out we're fully digital, baby! :)
  //
    mov     eax,_sDATA
    mov     es,eax
    mov     ebx,_sPRIMATIVE_LOAD_INFO
    mov     fs,ebx
    mov     eax,4
    while (eax < u32 ptr fs:[0])
    {

        xor     ecx,ecx
        add     eax,4
        mov     cl,u8 ptr fs:[eax]                                // Get the length of the driver file name
        inc     eax
        add     eax,ecx
        mov     cl,u8 ptr fs:[eax]                                // Get the length of the driver's self-assigned name
        inc     eax
        add     eax,ecx
        mov     cl,u8 ptr fs:[eax]                                // Get the length of the version text
        inc     eax
        add     eax,ecx
        mov     cl,u8 ptr fs:[eax]                                // Get the length of the author text
        inc     eax
        add     eax,ecx
        mov     edi,eax

      //
      // Right now, fs:[edi] - far ptr to GDT offsets for:
      //
      //                     Offset  Length  Description             How to access
      //                     ------  ------  --------------------    -------------------------------------
      //                        0      4     code segment            to access (word ptr fs:[eax+0])
      //                        4      4     data segment            to access (word ptr fs:[eax+4])
      //                        8      4     main call gate          to access (call u48 ptr fs:[eax+4])
      //                        12     4     requestor, call gate    to access (call u48 ptr fs:[eax+8])
      //

      // Physically call the primative
        push    eax

        xor     ebx,ebx
        mov     bx,u16 ptr fs:[eax+12]                             // Modify the selector for this primative
        mov     esi,offset id_offset
        mov     u16 ptr es:[esi],bx
        mov     esi,offset prim_offset
        mov     u16 ptr es:[esi],bx
        mov     esi,offset note_offset
        mov     u16 ptr es:[esi],bx
        jmp     $+2                                                 // Clear the prefetch cache (just in case)

        mov     eax,'prim'                                          // requested primative function
        mov     ds,u16 ptr fs:[edi+4]                              // this primative's permanent data segment
        mov     ebx,u32 ptr fs:[edi+8]                            // main() call gate
        mov     ecx,u32 ptr fs:[edi+12]                           // requestor() call gate
        xor     edx,edx
        xor     esi,esi
        xor     edi,edi
        xor     ebp,ebp
        mov     es,edx
        mov     fs,edx
        mov     gs,edx
//        call    invExtract_linear_offset_into_edx_from_ds
      //
      // Right now, eax - 'prim', indicating what requestor() function we're calling
      //             bx - main() call gate
      //             cx - requestor() call gate
      //            edx - null
      //            esi - null
      //            edi - null
      //            ebp - null
      //             ds - permanent data segment for this primative
      //             es - null
      //             fs - null
      //             gs - null
        u8  9ah                     // Call immed16:32
        u32 0                       // Offset (the value here doesn't matter because we're calling a call gate)
      prim_offset:
        u16 0                       // Selector (this part changes for each primative, see the code above (before jmp $+2))

      // Right now, esi - offset to list of names to find
      //            edi - offset to corresponding call gate area
        if (esi != 0ffffffffh)
        {
          // They have specified a list of primatives they need
            invUpdate_required_primatives()
            if (carry?)
            {
              // Not all of them are available, we need to call the driver and tell them
                mov     eax,_sSYSTEM
                mov     fs,eax
                mov     eax,'note'
                mov     ebx,'prim'
                mov     ecx,u32 ptr fs:[_SYSTEM_i_SCRATCH_DWORD1]     // Total
                mov     ebp,u32 ptr fs:[_SYSTEM_i_SCRATCH_DWORD2]     // Number that weren't found
                xor     edx,edx
                xor     esi,esi
                xor     edi,edi
                mov     fs,edx
              // Now, call the 'note' requestor function
                u8  9ah             // Call immed16:32
                u32 0               // Offset (the value here doesn't matter because we're calling a call gate)
              note_offset:
                u16 0               // Selector (this part changes for each primative, see the code above (before jmp $+2))

                if (carry?)
                {
                  // They've indicated this driver cannot continue without those primatives
                    init_failed()
                }
            }

          // Right now, everything's loaded OK.
            mov     ebx,_sPRIMATIVE_LOAD_INFO
            mov     fs,ebx
            mov     eax,u32 ptr [esp]                          // Get our offset off the stack
            add     eax,16                                          // And move to the next location to see WHERE IT'S AT! (Got 2 turn tables and a microphone...)
            push    ds
            pushad
            mov     esi,offset _VID_display_string_vga + 4
            if (eax < u32 ptr fs:[0])
            {
                mov     esi,offset next_item
            
            } else {
                mov     esi,offset last_item
            }
            mov     eax,_sDATA
            mov     ds,eax
            if (ds:loading_primatives_displayed == _NO)
            {
                mov     ds:loading_primatives_displayed,_YES
                pushad
                mov     esi,offset loading_primatives
                call    u48 ptr cs:_VID_display_string_nr_vga
                popad
            }
            call    u48 ptr cs:_VID_display_string_vga
            popad
            pop     ds
          // Ask the driver to identify itself on the VGA display
            mov     eax,'id  '
            u8  9ah                 // Call immed16:32
            u32 0                   // Offset (the value here doesn't matter because we're calling a call gate)
          id_offset:
            u16 0                   // Selector (this part changes for each primative, see the code above (before jmp $+2))

        }

        pop     eax
      // Reset the data segments for use in our procedure
        mov     ebx,_sDATA
        mov     es,ebx
        mov     ebx,_sPRIMATIVE_LOAD_INFO
        mov     fs,ebx

        add     eax,16
    }


  // At this point, all of the requestor() functions have been setup for all drivers
  // Now, it's time to call main() on each one of them
  // Before we do that we need to setup Exodus's requestor() memory blocks
    mov     eax,_sEXODUS_MEM
    mov     ds,eax
    mov     u32 ptr ds:[0],4                                      // Starting location to write data for memory blocks
    mov     eax,_sEXODUS_PORTS
    mov     ds,eax
    mov     u32 ptr ds:[0],4                                      // Starting location to write data for port requests
    mov     eax,_sEXODUS_INTS
    mov     ds,eax
    mov     u32 ptr ds:[0],4                                      // Starting location to write data for interrupt requests

  // Display the driver's name before we begin call main()
    mov     eax,_sDATA
    mov     ds,eax
    mov     esi,offset loading_drivers
    call    u48 ptr cs:_VID_display_string_nr_vga

    mov     ebx,_sPRIMATIVE_LOAD_INFO
    mov     ds,ebx
    mov     eax,4
    mov     ebp,esp
    while (eax < u32 ptr ds:[0])
    {
        xor     ecx,ecx
        add     eax,4
        mov     cl,u8 ptr ds:[eax]                                // Get the length of the driver file name
        inc     eax
        add     eax,ecx
        mov     cl,u8 ptr ds:[eax]                                // Get the length of the driver's self-assigned name
        inc     eax
        mov     u32 ptr [ebp+48],eax                           // Save for later use (below)
        mov     u32 ptr [ebp+52],ecx                           // Save for later use (below)
        add     eax,ecx
        mov     cl,u8 ptr ds:[eax]                                // Get the length of the version text
        inc     eax
        mov     u32 ptr [ebp+56],eax                           // Save for later use (below)
        mov     u32 ptr [ebp+60],ecx                           // Save for later use (below)
        add     eax,ecx
        mov     cl,u8 ptr ds:[eax]                                // Get the length of the author text
        inc     eax
        add     eax,ecx
        mov     edi,eax
        push    eax

        xor     ebx,ebx
        mov     bx,u16 ptr fs:[eax+4]                              // Get the data segment for this primative
        mov     u32 ptr [ebp+44],ebx
        mov     bx,u16 ptr fs:[eax+8]                              // Get the main() selector for this primative
        mov     esi,offset main_offset
        mov     u16 ptr es:[esi],bx
      //
      // Right now,          ds - data segment for this primative's name in the _sPRIMATIVE_LOAD_INFO structure
      //            [ebp+48] - ptr to offset of driver's self-assigned name
      //            [ebp+52] - length of the name at that location
      //
        add     edi,16
        if (edi < u32 ptr ds:[0])
        {
            mov     esi,offset next_item
        
        } else {
            mov     esi,offset last_item
        }

        push    ds
        mov     eax,_sDATA
        mov     ds,eax
        call    u48 ptr cs:_VID_display_string_vga
        pop     ds

      // Display what the driver calls itself
        mov     esi,u32 ptr [ebp+48]
        mov     ecx,u32 ptr [ebp+52]
      // This code removes anything that comes after the ASCII-255 (indicating not-displayed information)
        mov     eax,ecx
        while (eax > 0)
        {
            if (byte ptr ds:[esi+eax-1] == 255)
            {
                mov     ecx,eax
                dec     ecx
            }
            dec     eax
        }
        if (ecx != 0 && ecx < 7fffffffh)
        {
          // Display the name
            call    u48 ptr cs:_VID_display_string_ecx_vga

            push    ds
            mov     eax,_sDATA
            mov     ds,eax
            mov     esi,offset comma_space
            call    u48 ptr cs:_VID_display_string_vga
            pop     ds
        }

      // Display the version information
        mov     esi,u32 ptr [ebp+56]
        mov     ecx,u32 ptr [ebp+60]
        call    u48 ptr cs:_VID_display_string_ecx_nr_vga

        pushad
        push    ds
        push    es
        push    fs
        push    gs
        mov     ds,u16 ptr [ebp+44]
        xor     ebp,ebp
        xor     eax,eax
        xor     ebx,ebx
        xor     ecx,ecx
        xor     edx,edx
        xor     esi,esi
        xor     edi,edi
        mov     es,eax
        mov     fs,eax
        mov     gs,eax
      // Ok, we've displayed its name on the screen....
      // Right now:  ds - The primative data segment
      //             everything else is NULL
      // Now, we let it initialize itself
        u8  9ah                     // Call immed16:32
        u32 0                       // Offset (the value here doesn't matter because we're calling a call gate)
      main_offset:
        u16 0                       // Selector (this part changes for each primative, see the code near "offset main_offset")
        pop     gs
        pop     fs
        pop     es
        pop     ds
        popad

        pop     eax
        add     eax,16
    }

    add     esp,68
    pop     ds
    pop     es
    pop     fs
    pop     gs
    ret
}




function default_primative_response    NEAR
{
// This routine is called on any primative that has not been defined.
//
// * The primative call gates represent a range defined at the top of this program
//   Any primative call gate that has not been used by a defined function points to this routine
//   It returns the text "no support for primative" in the registers
//
    mov     eax,u32 ptr cs:no_support_for_primative[00]
    mov     ebx,u32 ptr cs:no_support_for_primative[04]
    mov     ecx,u32 ptr cs:no_support_for_primative[08]
    mov     edx,u32 ptr cs:no_support_for_primative[12]
    mov     esi,u32 ptr cs:no_support_for_primative[16]
    mov     edi,u32 ptr cs:no_support_for_primative[20]
    stc
    retf
}




function invCopy_this_part    NEAR
{
// This routine is used to copy data from ds:[ebx] to fs:[edi]
//
// Upon entry:   ds:[ebx] - ptr to source string
//               fs:[edi] - ptr to destination string
//
// Upon exit:    ecx - number of bytes copied
//
    push    edx
    push    ecx
    push    ebx
    push    eax

    mov     edx,edi
    inc     edi
    xor     ecx,ecx
    while (byte ptr ds:[ebx] != 0)
    {
        mov     al,u8 ptr ds:[ebx]
        mov     u8 ptr fs:[edi],al
        inc     ebx
        inc     edi
        inc     ecx
    }
    mov     u8 ptr fs:[edx],cl

    pop     eax
    pop     ebx
    pop     ecx
    pop     edx
    ret
}




function invMove_temp_gdts_to_permanent    NEAR
{
// This routine is used to copy the temporary primative GDT entries to their permanent location
//
// Upon entry:   eax - starting GDT offset to use
//               ecx - actual code segment/data segment length
//               _csTEMP_PRIMATIVE - defined as Code segment
//               _dsTEMP_PRIMATIVE - defined as Data segment
//          _cgTEMP_PRIMATIVE_MAIN - defined as call gate to main()
//     _cgTEMP_PRIMATIVE_REQUESTOR - defined as call gate to requestor()
//
// Upon exit:    _csTEMP_PRIMATIVE - copied to the next available location
//               _dsTEMP_PRIMATIVE - copied to the one after that
//                             eax - next GDT offset to use
//                                   * Note:  If the value in ebx != 0, then the limit of the
//
    push    edi
    push    ebx
    push    ds
    push    es
    push    fs
    push    gs

    mov     ebx,_sGDT
    mov     ds,ebx
    mov     ebx,_sSYSTEM
    mov     es,ebx
    mov     ebx,_sDATA
    mov     fs,ebx
    mov     ebx,_sSYSTEM
    mov     gs,ebx

  // Copy the code segment
    mov     edi,_csTEMP_PRIMATIVE
    mov     ebx,u32 ptr [edi]
    mov     u32 ptr [eax],ebx
    mov     ebx,u32 ptr [edi+4]
    mov     u32 ptr [eax+4],ebx
  // Derive the GDT information (to see if we need to adjust it)
    invExtract_code_descriptor32()
//    .IF (ecx < edx)
//      // We need to make the limit field shorter because they don't need all of the memory in the file
//        push    eax
//        shr     eax,3                                               // Divide by 8
//        mov     edx,ecx                                             // Decrease the limit to the value specified by requestor()
//        call    invCreate_code_descriptor32
//        pop     eax
//    .ENDIF
    mov     u32 ptr gs:[_SYSTEM_i_CODE_GDT_OFFSET],eax
    add     eax,8

  // Copy the data segment
    mov     edi,_dsTEMP_PRIMATIVE
    mov     ebx,u32 ptr [edi]
    mov     u32 ptr [eax],ebx
    mov     ebx,u32 ptr [edi+4]
    mov     u32 ptr [eax+4],ebx
    invExtract_data_descriptor32()
//    .IF (ecx < edx)
//      // We need to make the limit field shorter because they don't need all of the memory in the file
//        push    eax
//        shr     eax,3                                               // Divide by 8
//        mov     edx,ecx                                             // Decrease the limit to the value specified by requestor()
//        call    invCreate_data_descriptor32
//        pop     eax
//    .ENDIF
    mov     u32 ptr gs:[_SYSTEM_i_DATA_GDT_OFFSET],eax
    add     eax,8

  // Copy the main call gate
    mov     edi,_cgTEMP_PRIMATIVE_MAIN
    mov     ebx,u32 ptr [edi]
    mov     u32 ptr [eax],ebx
    mov     ebx,u32 ptr [edi+4]
    mov     u32 ptr [eax+4],ebx
    mov     u32 ptr gs:[_SYSTEM_i_MAIN_GDT_OFFSET],eax
  // Now, update the code segment selector for this newly located code segment (see above)
    mov     ebx,u32 ptr gs:[_SYSTEM_i_CODE_GDT_OFFSET]
    mov     u16 ptr [eax+2],bx
    add     eax,8

  // Copy the requestor call gate
    mov     edi,_cgTEMP_PRIMATIVE_REQUESTOR
    mov     ebx,u32 ptr [edi]
    mov     u32 ptr [eax],ebx
    mov     ebx,u32 ptr [edi+4]
    mov     u32 ptr [eax+4],ebx
    mov     u32 ptr gs:[_SYSTEM_i_REQUESTOR_GDT_OFFSET],eax
  // And, update this one's code selector also (see above)
    mov     ebx,u32 ptr gs:[_SYSTEM_i_CODE_GDT_OFFSET]
    mov     u16 ptr [eax+2],bx
    add     eax,8

    pop     gs
    pop     fs
    pop     es
    pop     ds
    pop     ebx
    pop     edi
    ret
}




function invAdd_primative    NEAR
{
// This routine is used to add a primative to the following items:
//   #1 - The _sPRIMATIVE structure
//   #2 - The GDT as a call gate
//
// Upon entry:        eax - GDT offset for this primative's call gate
//               ds:[esi] - far ptr to primative function name
//                     bx - dword to copy
//                    ecx - length
//                    edx - offset into the driver for this function
//                    ebp - Code segment for the driver this primative comes from
//
// Upon exit:    This routine is self contained
//               If control is returned to the calling function then it can be assumed that it is ok to continue
//               The data is added (or not added)
//
    pushad
    push    es

    if (eax < _MAX_PRIMATIVE*8)
    {
      // We're within the range for this primative
        mov     edi,_sPRIMATIVES
        mov     es,edi

        mov     edi,u32 ptr es:[0]
        mov     u16 ptr es:[edi],ax                                // store the call gate
        add     edi,2

        mov     u8 ptr es:[edi],1                                 // active? (0-No, 1-Yes)
        inc     edi

        mov     u8 ptr es:[edi],cl                                // length of the function name
        inc     edi

      // Store the primative function name
      // Right now, ds:[esi] - far ptr to their primative name
      //            es:[edi] - far ptr to store it
      //                 ecx - length of that name
        push    eax
        repeat
        {
            mov     al,u8 ptr [esi]
            if (al >= "A" && al <= "Z")
            {
                or      al,20h                                      // force the name to lower-case
            }
            inc     esi
            mov     u8 ptr es:[edi],al
            inc     edi
        } untilcxz
        pop     eax

      // Update for the next location
        mov     u32 ptr es:[0],edi

      // Now, physically create the call gate to this primative
        mov     ecx,ebx                                             // dwords to copy
        mov     ebx,edx                                             // Offset to start of function
        mov     edx,ebp                                             // Code segment
        shr     eax,3                                               // Divide by 8 to get the GDT slot
        invCreate_call_gate_descriptor32()
    }

    pop     es
    popad
    ret
}




function invUpdate_required_primatives    NEAR
{
// This routine is used to update the required primatives required by a particular function
// * Refer to inf\
//
// Upon entry:   ds:[esi] - Offset to name structure of the required primatives
//               ds:[edi] - Offset to the start of the structure used for the call gates to assign to them
//
// Upon exit:    carry? - CLEAR=all functions were found (meaning they've already been installed)
//                          SET=error
//                              + ecx - number of functions not found
//
    pushad
    push    es
    push    fs
    enter   20,0
  // [ebp-04] - dword, --Nuserved
  // [ebp-08] - dword, current value of eax
  // [ebp-12] - dword, current value of ecx for inner loop
  // [ebp-16] - dword, current value of esi
  // [ebp-20] - dword, curent value of ecx for outter loop
    mov     eax,_sPRIMATIVES
    mov     es,eax
    mov     eax,_sSYSTEM
    mov     fs,eax

    mov     u32 ptr fs:[_SYSTEM_i_SCRATCH_DWORD1],0               // Holds total number of primative names found
    mov     u32 ptr fs:[_SYSTEM_i_SCRATCH_DWORD2],0               // Holds total number not matched with installed primatives

    xor     ecx,ecx
    while (byte ptr ds:[esi] != 0ffh)
    {
        mov     u32 ptr [ebp-16],esi
        mov     cl,u8 ptr ds:[esi]
        mov     u32 ptr [ebp-20],ecx
        inc     u32 ptr fs:[_SYSTEM_i_SCRATCH_DWORD1]

      // Start at the beginning of the _sPRIMATIVE structure for each pass
        mov     eax,8
      // Right now, es:[eax] - far ptr to start of primative's structure, refer to inf\primload.inf for information
        while (eax < u32 ptr es:[0])
        {
            mov     cl,u8 ptr es:[eax+3]
            mov     u32 ptr [ebp-12],ecx
            mov     esi,u32 ptr [ebp-16]
            if (byte ptr es:[eax+2] == 1 && cl == u8 ptr ds:[esi])
            {
                mov     bx,u16 ptr es:[eax]                        // Get the call gate
                mov     u32 ptr [ebp-08],eax
                add     eax,4
                inc     esi
              // Right now, es:[eax] - far ptr to _sPRIMATIVE name
              //            ds:[esi] - far ptr to current native primative name the application is requiring
              //                 ecx - length
              //                  bx - call gate for this primative
                repeat
                {
                    mov     dl,u8 ptr ds:[esi]
                    if (dl >= 'A' && dl <= 'Z')
                    {
                        add     dl,020h                             // force lowercase
                    }
                    if (dl != u8 ptr es:[eax])
                    {
                      // It wasn't a match
                        jmp     @F
                    }
                    inc     eax
                    inc     esi
                } untilcxz
              // If we're here, then this was a match
                mov     u16 ptr ds:[edi+4],bx
                jmp     next_primative

              @@:
                mov     ecx,u32 ptr [ebp-12]
                mov     eax,u32 ptr [ebp-08]
            }
            add     eax,ecx
            add     eax,4
        }
      // If we're here, then the item wasn't found
        mov     u16 ptr ds:[edi+4],0ffffh                          // Set it so it will indicate it "wasn't found"
        inc     u32 ptr fs:[_SYSTEM_i_SCRATCH_DWORD2]             // Increase the number of items not found

      next_primative:
        mov     ecx,u32 ptr [ebp-20]
        mov     esi,u32 ptr [ebp-16]
        add     esi,ecx
        inc     esi
        add     edi,2
    }


    if (dword ptr fs:[_SYSTEM_i_SCRATCH_DWORD2] != 0)
    {
        stc
    
    } else {
        clc
    }

    leave
    pop     fs
    pop     es
    popad
    ret
}




function default_interrupt_handler32
{
// This is the default interrupt handler
// All IDT entries are initially setup to this in init16.asp
// invSetup_native_primatives updates those that are relevant to
    push    eax
    mov     al,20h
    out     20h,al
    pop     eax
    iretd
}




//VID_display_radix_in_edx_vga    PROC
//    pushad
//    push    ds
//    sub     esp,16                                                  // Assume a maximum length of 12 chars (4 extra for boundary)
//    mov     ebp,esp
//
//    call    iString_generate_radix_string
//    call    VID_display_string_vga
//
//    add     esp,16
//    pop     ds
//    popad
//    ret
//VID_display_radix_in_edx_vga    ENDP




function VID_display_radix_in_edx_mono
{
    pushad
    push    ds
    sub     esp,16                                                  // Assume a maximum length of 12 chars (4 extra for boundry)
    mov     ebp,esp

    iString_generate_radix_string()
    VID_display_string_mono()

    add     esp,16
    pop     ds
    popad
    ret
}




function iString_generate_radix_string
{
    mov     u8 ptr [ebp+12],0                                 // NULL terminate the string we're building
    mov     esi,ebp
    add     esi,11
    mov     eax,edx
    and     ebx,0ffffh
  @@:
    xor     edx,edx
    div     ebx
    if (dl > 9)
    {
        add     dl,'a'-10                                       // Make it a letter if it's above 9 (10+ cannot be represented in 1 digit)
    
    } else {
        add     dl,'0'                                          // Make it a number
    }
    mov     u8 ptr ss:[esi],dl
    dec     esi                                                 // Decrement (move to next position to store data)
    cmp     esi,ebp
    jz      @F
    cmp     eax,0
    jnz     @B
  @@:
    push    ss
    pop     ds
    inc     esi                                                 // Add back for the one we decremented above
  // Right now, ds:[esi] - pointer to the value to display
    ret
}




//VID_display_string_vga    PROC
;; ds:[esi] - far pointer to null-terminated string
;;      edi - offset into video memory to write
//    pushad
//    push    es
//    push    fs
//
//    mov     eax,_sDATA
//    mov     es,eax
//    mov     eax,_sVGA
//    mov     fs,eax
//    mov     ah,7
//    .WHILE (byte ptr ds:[esi] != 0)                                 // Loop until the NULL terminated string is found
//        lodsb
//        mov     u8 ptr fs:[edi],al                                // Write character
//        inc     di
//        mov     u8 ptr fs:[edi],ah                                // Write color
//        inc     di
//    .ENDW
//
//    pop     fs
//    pop     es
//    popad
//    ret
//VID_display_string_vga    ENDP




function VID_display_string_mono
{
// ds:[esi] - far pointer to null-terminated string
//      edi - offset into video memory to write
    pushad
    push    es
    push    fs

    mov     eax,_sDATA
    mov     es,eax
    mov     eax,_sMONO
    mov     fs,eax
    mov     ah,7
    while (byte ptr ds:[esi] != 0)                                 // Loop until the NULL terminated string is found
    {
        lodsb
        mov     u8 ptr fs:[edi],al                                // Write character
        inc     di
        mov     u8 ptr fs:[edi],ah                                // Write color
        inc     di
    }

    pop     fs
    pop     es
    popad
    ret
}




//VID_display_string_ecx_vga      PROC
;; ds:[esi] - far pointer to null-terminated string
;;      edi - offset into video memory to write
;;      ecx - count
//    pushad
//    push    es
//    push    fs
//
//    mov     eax,_sDATA
//    mov     es,eax
//    mov     eax,_sVGA
//    mov     fs,eax
//    mov     ah,7
//    .REPEAT
//        lodsb
//        mov     u8 ptr fs:[edi],al                                // Write character
//        inc     di
//        mov     u8 ptr fs:[edi],ah                                // Write color
//        inc     di
//    .UNTILCXZ
//
//    pop     fs
//    pop     es
//    popad
//    ret
//VID_display_string_ecx_vga      ENDP
//
//
//
//
function VID_display_string_ecx_mono
{
// ds:[esi] - far pointer to null-terminated string
//      edi - offset into video memory to write
//      ecx - count
    pushad
    push    es
    push    fs

    if (ecx != 0)
    {
        mov     eax,_sDATA
        mov     es,eax
        mov     eax,_sMONO
        mov     fs,eax
        mov     ah,7
        repeat
        {
            lodsb
            mov     u8 ptr fs:[edi],al                                // Write character
            inc     di
            mov     u8 ptr fs:[edi],ah                                // Write color
            inc     di
        } untilcxz
    }

    pop     fs
    pop     es
    popad
    ret
}
//
//
//
//
//
function VID_display_hex_string_ecx_mono
{
// ds:[esi] - far pointer to null-terminated string
//     ecx - number of hexidecimal digits to display
// offset_mono- pointer into the screen where to start writing
    pushad
    push    gs

    if (ecx != 0)
    {
        mov     eax,_sMONO
        mov     gs,eax
        mov     ah,7
        repeat
        {
            lodsb
            mov     dl,al
            hex_adjust_al_dl()
            mov     u8 ptr gs:[edi],32                                // Write a space before hexidecimal values
            inc     di
            mov     u8 ptr gs:[edi],ah                                // Write color
            inc     di
            mov     u8 ptr gs:[edi],dl                                // Write left 1/2 of hexidecimal values character
            inc     di
            mov     u8 ptr gs:[edi],ah                                // Write color
            inc     di
            mov     u8 ptr gs:[edi],al                                // Write right 1/2 of hexidecimal values character
            inc     di
            mov     u8 ptr gs:[edi],ah                                // Write color
            inc     di
            mov     u8 ptr gs:[edi],32                                // Write a space after hexidecimal value
            inc     di
            mov     u8 ptr gs:[edi],ah                                // Write color
            inc     di
        } untilcxz
    }

    pop     gs
    popad
    ret
}




function hex_adjust_al_dl
{
    shr     dl,4
    if (dl <= 9)
    {
        add     dl,'0'
    
    } else {
        add     dl,'a'-10
    }
    and     al,0fh
    if (al <= 9)
    {
        add     al,'0'
    
    } else {
        add     al,'a'-10
    }
    ret
}




function init_failed    NEAR
{
// This routine returns to real mode and goes to a section of code that indicates a failed to boot message.
// It is called when Exodus is trying to boot up but received unexpected information from a device driver before VGA/keyboard
// support had been installed.
//
    mov     eax,_sVGA
    mov     fs,eax
    mov     eax,_sMONO
    mov     gs,eax
    mov     edi,6*80*2

    mov     esi,offset failed
    mov     ah,7
    while (esi < offset failed_end)
    {
        mov     al,u8 ptr cs:[esi]
        inc     esi
        if (al == 13)
        {
          // It's a carriage return
            add     edi,80*2
        
        } else if (al == 10) {
          // It's a line feed
            push    eax
            xor     edx,edx
            mov     eax,edi
            mov     ebx,80*2
            div     ebx
            mul     ebx
            mov     edi,eax
            pop     eax
        
        } else if (al == 'ô') {
            mov     ah,112
        
        } else if (al == 'õ') {
            mov     ah,7
        
        } else if (al == 'Ý') {
            mov     ah,15
        
        } else if (al == 'Þ') {
            mov     ah,7
        
        } else if (al == '¨') {
            add     ah,128
        
        } else {
            mov     u16 ptr fs:[edi],ax
            mov     u16 ptr gs:[edi],ax
            add     edi,2
        }
    }

  @@:
    hlt
    jmp     @B
}
