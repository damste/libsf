// debi.asm
//
// +---------------+
// | Debi Debugger |
// +---------------+
//
// Exodus native primative debugger, called Debi. :)
//
// -----
//   00000 - Window Supportive Algorithms/Handlers
//   11111 - External interfaces (Timer, Mouse, Kbd)
//   22222 - Screen related functions
//   33333 - MOUSE Events
//   44444 - MENU system
//   55555 - MENUs for screen objects
//   66666 - Actions taken when various menu items are selected
//   77777 - Menu bar events
//   88888 - DRAG and DRAG RELEASE handlers
//   99999 - Keyboard Events
//   AAAAA - INCLUDE files
//


// Debi Debugger

    
    
#include "\exodus\source\common\keylist.asp"
#include "\exodus\source\common\equates.asp"
#include "\exodus\source\common\macros.asp"
#include "debi_mac.asp"                                                // Macros used for DEBI
#include "debi_eq.asp"                                                 // Equates used for DEBI

    
code text32
| at offset 0
{
    
// These are required to be the first 2 dwords in the file
dd  offset main
dd  offset requestor



    function requestor
    {
    // This routine is called by Exodus.  When this function is called multi-tasking is not installed.  This is a linear function.
    //
    // Upon entry:   eax - requested function
    //                ds - temporary ORG 0h data segment for use with these requestor() functions
    //
    // Upon exit:    results vary based on value of eax
    //
        if (eax == 'info')
        {
          // Program information
            mov     eax,'nati'                              // Identifying this program as a native primative
            mov     ecx,offset end_of_required_data         // The maximum number of bytes to retain after loading

            mov     esi,offset driver_primatives            // Offset to the native primatives structure
            mov     edi,offset driver_name
            mov     ebx,offset version
            mov     edx,offset copyright
            mov     ebp,offset author
            clc
        
        } else if (eax == 'prim') {
          // Native primatives this program will use
            mov     ds:data_segment,ds
            mov     esi,offset required_primatives          // This primative requires these functions
            mov     edi,offset primative_call_gates
            clc
        
        } else if (eax == 'id  ') {
          // Display this program's ID on the VGA monitor
            mov     esi,offset driver_name
            call    u48 ptr cs:_VID_display_string_nr_vga
            clc
        
        } else if (eax == 'note') {
            mov     eax,'stop'
            mov     ebx,'load'
            mov     esi,offset driver_name
            call    u48 ptr cs:_EXODUS_requestor
        
        } else {
            stc
        }
        retf
    }




    function main
    {
    // This routine is called once by Exodus once initialization is complete (all calls to requestor() are finished)
    // It is used by Exodus to allow this driver to properly initialize itself.
    // When this function is called multi-tasking is not installed.  This is a linear function.
    //
    // Upon entry:   Nothing
    //
    // Upon exit:    A "continued status of execution" is expected by Exodus.  This indicates whether or not everything
    //               initialized ok or is available.  If everything is OK the carry? flag is CLEAR.  If there is an error
    //               and this driver cannot continue then the carry? should be SET.
    //               carry? - CLEAR=Ok to continue
    //                          SET=Error initializing
    //
        mov     ds,cs:data_segment
        mov     ds:bootup,0
        initialize_driver()
      // Right now, carry? is SET or CLEAR indicating status of driver
        retf
    }




    function initialize_driver
    {
    // This routine is used to initialize the driver
    // We trap all interrupts that are generated by the CPU during an error condition
        push    es

      // Take ownership of the VID_g subsystem in the video driver (DEBI requires monochrome graphics mode)
        call    u48 ptr cs:_VID_g_claim_ownership
        call    u48 ptr cs:_VID_g_mono_enter_graphics_mode

      // INT0 - Divide error
        mov     ecx,1                                               // We only allocate one interrupt at a time (used on all)
        mov     eax,'bint'
        mov     bl,0
        mov     edx,offset invDEBI_int0_handler
        call    u48 ptr cs:_EXODUS_requestor
        jc      init_failed

      // INT1 - Single-step (or debug exception)
        mov     eax,'bint'
        mov     bl,1
        mov     edx,offset invDEBI_int1_handler
        call    u48 ptr cs:_EXODUS_requestor
        jc      init_failed

      // INT2 - No description
        mov     eax,'bint'
        mov     bl,2
        mov     edx,offset invDEBI_int2_handler
        call    u48 ptr cs:_EXODUS_requestor
        jc      init_failed

      // INT3 - Breakpoint exception
        mov     eax,'bint'
        mov     bl,3
        mov     edx,offset invDEBI_int3_handler
        call    u48 ptr cs:_EXODUS_requestor
        jc      init_failed

      // INT4 - Overflow exception
        mov     eax,'bint'
        mov     bl,4
        mov     edx,offset invDEBI_int4_handler
        call    u48 ptr cs:_EXODUS_requestor
        jc      init_failed

      // INT5 - BOUND range exceeded exception
        mov     eax,'bint'
        mov     bl,5
        mov     edx,offset invDEBI_int5_handler
        call    u48 ptr cs:_EXODUS_requestor
        jc      init_failed

      // INT6 - Invalid opcode exception
        mov     eax,'bint'
        mov     bl,6
        mov     edx,offset invDEBI_int6_handler
        call    u48 ptr cs:_EXODUS_requestor
        jc      init_failed

      // INT7 - Device not available exception
        mov     eax,'bint'
        mov     bl,7
        mov     edx,offset invDEBI_int7_handler
        call    u48 ptr cs:_EXODUS_requestor
        jc      init_failed

      // INT8 - Double fault exception
        mov     eax,'bint'
        mov     bl,8
        mov     edx,offset invDEBI_int8_handler
        call    u48 ptr cs:_EXODUS_requestor
        jc      init_failed

      // INT9 - Coprocessor segment overrun
        mov     eax,'bint'
        mov     bl,9
        mov     edx,offset invDEBI_int9_handler
        call    u48 ptr cs:_EXODUS_requestor
        jc      init_failed

      // INT10 - Invalid TSS exception
        mov     eax,'bint'
        mov     bl,10
        mov     edx,offset invDEBI_int10_handler
        call    u48 ptr cs:_EXODUS_requestor
        jc      init_failed

      // INT11 - Segment not present
        mov     eax,'bint'
        mov     bl,11
        mov     edx,offset invDEBI_int11_handler
        call    u48 ptr cs:_EXODUS_requestor
        jc      init_failed

      // INT12 - Stack fault exception
        mov     eax,'bint'
        mov     bl,12
        mov     edx,offset invDEBI_int12_handler
        call    u48 ptr cs:_EXODUS_requestor
        jc      init_failed

      // INT13 - General protection fault
        mov     eax,'bint'
        mov     bl,13
        mov     edx,offset invDEBI_int13_handler
        call    u48 ptr cs:_EXODUS_requestor
        jc      init_failed

      // INT14 - Page fault exception
        mov     eax,'bint'
        mov     bl,14
        mov     edx,offset invDEBI_int14_handler
        call    u48 ptr cs:_EXODUS_requestor
        jc      init_failed

      // INT15 - Because it might be implemented in future Intel cpus
        mov     eax,'bint'
        mov     bl,15
        mov     edx,offset invDEBI_int15_handler
        call    u48 ptr cs:_EXODUS_requestor
        jc      init_failed

      // INT16 - Floating point error
        mov     eax,'bint'
        mov     bl,16
        mov     edx,offset invDEBI_int16_handler
        call    u48 ptr cs:_EXODUS_requestor
        jc      init_failed

      // INT17 - Alignment check exception
        mov     eax,'bint'
        mov     bl,17
        mov     edx,offset invDEBI_int17_handler
        call    u48 ptr cs:_EXODUS_requestor
        jc      init_failed

      // INT18 - Machine check exception
        mov     eax,'bint'
        mov     bl,18
        mov     edx,offset invDEBI_int18_handler
        call    u48 ptr cs:_EXODUS_requestor
        jc      init_failed

      // Initialize the memory area
        mov     eax,_sDEBI_memory
        mov     es,ax
        mov     u32 ptr es:[0],4                                  // Indicate the starting offset for the next data item
        mov     edi,4
        mov     ecx,_sDEBI_memory_limit - 4                         // Reset everything in the memory area to 0ffh
        mov     al,0ffh
        cld
        rep     stosb

      init_ok:
        mov     esi,offset debi_boot_logo
        call    u48 ptr cs:_VID_draw_logo
        clc
        jmp     init_quit

      init_failed:
        stc

      init_quit:
        pop     es
        ret
    }





    function DEBI_debug
    {
    // This procedure is called during a fatal error.  The system will be halted.
    //
    // Upon entry:   Stack is arranged as below
    //               eax - ptr to the type of error encountered
    //
    // Upon exit:    The errant program continues
    //
      // * Note that esp = current value of ebp+60
      // [ebp+60] - eflags
      // [ebp+56] - cs
      // [ebp+52] - eip
      // [ebp+48] - <error code>
      // [ebp+44] - eax
      // [ebp+40] - ebx
      // [ebp+36] - ecx
      // [ebp+32] - edx
      // [ebp+28] - esi
      // [ebp+24] - edi
      // [ebp+20] - ds
      // [ebp+16] - es
      // [ebp+12] - fs
      // [ebp+08] - gs
      // [ebp+04] - ss
      // [ebp+00] - ebp
      // [ebp-04] - esp
        push    ebx
        push    ecx
        push    edx
        push    esi
        push    edi
        push    ds
        push    es
        push    fs
        push    gs
        push    ss
        enter   200,0
        mov     u32 ptr [ebp-04],ebp
        add     u32 ptr [ebp-04],64                            // Make this value of ESP be what it was originally
      // [ebp-004] - (see above)
      // [ebp-008] -  dword,  Current font increment
      // * Note:  This public stack frame is used by all routines in Debi.
      //          It cannot be changed without the express written permission of Major League Baseball
      //------
      // invDEBI_draw_objects
      // [ebp-092] -  dword,  Temporary variable used in
      //------
      // invDEBI_populate_debug_screen
      // [ebp-080] - offset into _sDEBI_memory for next item
      // [ebp-084] - segment of temp far address
      // [ebp-088] - offset of temp far address
      // [ebp-092] - (temp) used as a temporary holder for processing
      //------
      // [ebp-200] - 108 bytes, FPU save state
        fsave   [ebp-200]
        finit

        mov     ds,cs:data_segment
      // See if we're in a step-over condition
        if (ds:step_over == 1)
        {
          // We have to replace the byte that was updated
            pushad
            mov     ds:step_over,0
            mov     al,ds:step_replaced_byte
            mov     ebx,ds:step_offset
            push    fs
            mov     edx,_sDEBI_temp
            mov     fs,edx
            mov     u8 ptr fs:[ebx],al
            pop     fs
            inc     ebx
            if (dword ptr [ebp+52] == ebx)
            {
                dec     u32 ptr [ebp+52]
                mov     u32 ptr [esp+28],offset step_over_text
            }
            popad
        }

      // Right now ds:[eax] - far ptr to the error string (identified by the error trapping functions below)
        mov     esi,eax
        invDEBI_update_message()
      // Right now, ds:[edi] - far ptr to the end of the error string in the query window
      //                 ecx - number of bytes written
      // Try to find out what procedure caused the problem
        mov     ebx,u32 ptr [ebp+52]
        mov     edx,u32 ptr [ebp+56]
        mov     ecx,45
        mov     esi,edi
      // Right now:   edx - code segment
      //              ebx - instruction pointer
      //         ds:[esi] - far ptr where to store
      //              ecx - maximum # of bytes to store
        mov     eax,'find'
        mov     edi,'func'
        call    u48 ptr ds:_EXODUS_requestor

      // Draw the DEBI screen
        call    u48 ptr ds:_VID_g_set_font_8x6                    // Set font at 8x6
        mov     u32 ptr [ebp-08],6
        inc     ds:debug_levels
        invDEBI_populate_debug_screen()
        mov     ds:debug_screen_shown,1
        mov     ds:mouse_status,0                                   // Indicate that the mouse is not currently being displayed
                                                                    // Note, it's not displayed until they move or click
      // Intercept what we need from the keyboard/mouse
        call    u48 ptr ds:_iKBD_activate_DEBI_intercept
        call    u48 ptr ds:_iMOUSE_activate_DEBI_intercept
        call    u48 ptr ds:_iTIMER_activate_DEBI_timer_feed
        invDEBI_show_mouse_pointer()

      // Now, we wait.  This is an object oriented system.
      // When interrupts (mouse or keyboard) are triggered they will be acted on accordingly by the procedures below.
      // The only thing we have to look for is our exit code when it's available
        mov     ds:debi_ok_to_quit,0
        sti                                                         // Allow interrupts (they're needed for mouse/keyboard)
      @@:
        hlt
        if (ds:debi_ok_to_quit == 1)
        {
          // They're single stepping
            mov     ds,u32 ptr [ebp+56]
            mov     esi,u32 ptr [ebp+52]
            mov     al,u8 ptr ds:[esi]
            if (al == 0eah || al == 09ah)
            {
              // They're issuing an explicit JMP FAR or CALL FAR
              // We have to see if it's going to a CALL GATE
                movzx   edx,u16 ptr ds:[esi+5]
                test    edx,111b
                if (zero?)
                {
                    shr     edx,3                                   // Divide by 8 (to get slot)
                    mov     eax,'get '
                    mov     ebx,'gdt '
                    call    u48 ptr cs:_EXODUS_requestor
                    if (!carry?)
                    {
                      // Right now, ebx - upper dword
                      //            edx - lower dword
                        and     bh,11111b
                        if (bh == 00101b)
                        {
                          // It is a call gate
                            movzx   edx,u16 ptr ds:[esi+5]
                            shr     edx,3
                            mov     eax,'get '
                            mov     ebx,'tss '
                            call    u48 ptr cs:_EXODUS_requestor
                            mov     eax,_sALL_MEM
                            mov     ds,eax
//                            or      u8 ptr ds:[ebx+_TSS_TRAP_BIT],_TSS_TRAP_BIT_MASK
                            or      u32 ptr ds:[ebx+_TSS_EFLAGS],100000000b
//mov ds,cs:data_segment
//mov ds:hlt_now,1
                            jmp     bypass_our_eflags
                        }
                    }
                }
            }
            or      u32 ptr [ebp+60],100000000b
          bypass_our_eflags:
            mov     ds,cs:data_segment
        
        } else if (ds:debi_ok_to_quit == 2) {
          // They're continuing on from here
            mov     ds:single_step_history,-1
            jmp     no_single_step
        
        } else if (ds:debi_ok_to_quit == 3) {
          // They're stepping over this one
          no_single_step:
            and     u32 ptr [ebp+60],not 100000000b
        
        } else {
          // Nope, we're still waiting... :)
            jmp     @B
        }

      // Note, the code will only get here if they've done something to modify the status of debi_ok_to_quit
      //       This happens when they press key combinations or click on step/go/etc.
        invDEBI_hide_mouse_pointer()
        call    u48 ptr ds:_iTIMER_deactivate_DEBI_timer_feed
        call    u48 ptr ds:_iMOUSE_deactivate_DEBI_intercept
        call    u48 ptr ds:_iKBD_deactivate_DEBI_intercept
        mov     ds:force_cursor_off,1
        invDEBI_turn_cursor_off()
        dec     ds:debug_levels
        frstor  [ebp-200]
        leave
        pop     ss
        pop     gs
        pop     fs
        pop     es
        pop     ds
        pop     edi
        pop     esi
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
        add     esp,4                                               // Get past the error code
        iretd
    }




    function invDEBI_null
    {
    // This routine does nothing except return to the calling program
        ret
    }









//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// 00000 - Window Supportive Algorithms/Handlers
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    function invDEBI_update_message
    {
    // This routine is used to update the error message on screen (so we can see what error it was/is)
    //
    // Upon entry:   ds:[esi] - far ptr to error string
    //
    // Upon exit:    ds:[edi] - far ptr to where next bit of information would go on the current line
    //                    ecx - how many character were copied so far
    //
        push    es
        mov     es,ds:data_segment

        cld
        push    esi
      // Scroll line 2 to 3
        mov     edi,offset query_3
        mov     esi,offset query_2
        mov     ecx,sizeof query_2-2
        rep     movsb
      // Scroll line 1 to 2
        mov     edi,offset query_2
        mov     esi,offset query_1
        mov     ecx,sizeof query_1-2
        rep     movsb
      // Reset line 1 to spaces
        mov     edi,offset query_1
        mov     al,32
        mov     ecx,sizeof query_1-2
        rep     stosb
      // Copy the source string to line 1
        pop     esi
        mov     edi,offset query_1
        xor     ecx,ecx
        while (byte ptr ds:[esi] != 0 && ecx < (sizeof query_1-2))
        {
            lodsb
            stosb
            inc     ecx
        }

        pop     es
        ret
    }




    function invDEBI_clear_screen_and_redraw_windows
    {
    // This routine is called to clear the screen and then redraw all windows
    //
      // Clear the whole screen
        push    u32 ptr 0
        push    u32 ptr 0
        push    u32 ptr 720
        push    u32 ptr 348
        push    u32 ptr 2                                         // Clear
        push    u32 ptr 0                                         // Not used here, but required for spacer
        call    u48 ptr cs:_VID_g_mono_window_function
        // Note, this line is not executed because program flow will just fall right through
        //jmp     invDEBI_redraw_windows
    }




    function invDEBI_redraw_windows
    {
    // This routine forces a redraw of all windows
        push    eax
        movzx   eax,ds:force_screen_redraw
        push    eax

        mov     ds:force_screen_redraw,_YES
        invDEBI_populate_debug_screen()

        pop     eax
        mov     ds:force_screen_redraw,al
        pop     eax
        ret
    }




    function invDEBI_populate_debug_screen
    {
    // This routine is used to put the relevent information on the screen
    //
    // Upon entry:   The stack arrangement is provided directly from DEBI_debug()'s stack frame
    //               * Changes here must be reflected and made compatible with that algorithm
    //
    // Upon exit:    The various screens are populated
    //
      // [ebp-080] - offset into _sDEBI_memory (memory area) for next item
      // [ebp-084] - segment of temp far address
      // [ebp-088] - offset of temp far address
      // [ebp-092] - (temp) used as a temporary holder for processing
        mov     u32 ptr [ebp-080],0                            // Start at the beginning
        mov     u32 ptr [ebp-084],-1                           // Force an invalid address at the outset
        mov     u32 ptr [ebp-088],-1

        mov     esi,offset DEBI_screen_table
        xor     ecx,ecx
        while (ecx < 15)
        {
            if (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _YES)
            {
                push    esi
                push    ecx

              // After this, ds:[esi] - pointer to this screen table structure
              //             ds:[edi] - pointer to this item's objects
                mov     edi,u32 ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]     // Get the offset to the objects
                invDEBI_draw_objects()

                pop     ecx
                pop     esi
            }
            inc     ecx
            add     esi,_ST_LENGTH
        }
        ret
    }




    function invDEBI_draw_objects
    {
    // This routine is called to update some objects on the screen
    //
    // Upon entry:   ds:[esi] - far ptr to screen table structure
    //               ds:[edi] - far ptr to objects
    //               [ebp] - space is available indicated in DEBI_debug()
    //
    // Upon exit:    The object is drawn/redrawn
    //
        push    es
        pushad
        mov     eax,_sDEBI_memory                                   // All DEBI windows store memory here.   Well, at least those
        mov     es,eax                                              // not handled by _FUNCTION (and even they still might hehehe)
      // Right now, es:[0] - far ptr to the _sDEBI_memory structure
        while (byte ptr ds:[edi] != _END)
        {
            mov     al,u8 ptr ds:[edi]
            if (al == _OBJECT_MEM_SIZE)
            {
              // They're specifying how big this window's memory size is in the buffer
                if (dword ptr ds:[esi+_ST_OBJECT_MEMORY_OFFSET] == -1 && u8 ptr ds:[edi+1] != 0)
                {
                  // It hasn't already been allocated, so let's allocate some memory for this bad boy
                    mov     eax,u32 ptr es:[0]
                  // Right now, eax - offset into temp space where this item will go
                    mov     u32 ptr ds:[esi+_ST_OBJECT_MEMORY_OFFSET],eax
                    movzx   ebx,u8 ptr ds:[edi+1]                 // Indicate where the next one will go
                    add     u32 ptr es:[0],ebx

                    while (ebx > 0)                                // Initialize the memory area to 0ffh's
                    {
                        mov     u8 ptr es:[eax+ebx-1],0ffh
                        dec     ebx
                    }
                }
              // Finished, we skip past this fixed 2-byte structure (db _OBJECT_MEM_SIZE, <size>)
                add     edi,2
            
            } else if (al == _LOAD_TEMP) {
              // They want to indicate where to load a temporary variable
                mov     al,u8 ptr ds:[edi+1]
                if (al == _FAR_MEMORY_PTR)
                {
                    mov     eax,u32 ptr ds:[esi+_ST_OBJECT_MEMORY_OFFSET]
                    if (eax == -1)
                    {
                      // It hasn't yet been initialized, so we can't do anything
                        jmp     next_window
                    
                    } else {
                      // It's valid
                        mov     dl,u8 ptr es:[eax]
                        if (dl == _RAW_ADDRESS)
                        {
                          // Ok, the raw address they're working with is here
                            mov     edx,u32 ptr es:[eax+1]
                            mov     u32 ptr [ebp-084],edx
                            mov     edx,u32 ptr es:[eax+5]
                            mov     u32 ptr [ebp-088],edx
                            add     edi,3
                        
                        } else {
                          // Unsupported option (or invalid data)
                            jmp     next_window
                        }
                    }
                
                } else {
                  // Unknown item
                    jmp     next_window
                }
            
            } else if (al == _DISPLAY) {
              // They want to display something
                mov     al,u8 ptr ds:[edi+1]
                if (al == _TEMP_RELATIVE)
                {
                  // They're specifying an address relative to the previously loaded temporary address
                    add     edi,16
                    jmp     next_object

                
                } else if (al == _EBP_RELATIVE) {
                  // They're specifying that it's EBP relative (our EBP, not theirs)
                    movsx   ebx,u16 ptr ds:[edi+3]
                    mov     edx,u32 ptr [ebp+ebx]
                    mov     al,u8 ptr ds:[edi+2]
                    if (al == _UPPER_NIBBLE)
                    {
                        and     edx,0f0h
                        shr     edx,4
                        mov     ebx,2
                        mov     ecx,4
                    
                    } else if (al == _LOWER_NIBBLE) {
                        and     edx,00fh
                        mov     ebx,2
                        mov     ecx,4
                    
                    } else if (al == _8) {
                        and     edx,0ffh
                        mov     ebx,16
                        mov     ecx,2
                    
                    } else if (al == _16) {
                        and     edx,0ffffh
                        mov     ebx,16
                        mov     ecx,4
                    
                    } else if (al == _FPU_OPCODE) {
                        and     edx,0000011111111111b
                        or      edx,1101100000000000b
                        mov     ebx,16
                        mov     ecx,4
                    
                    } else if (al == _32) {
                        mov     ecx,8
                        mov     ebx,16
                    
                    } else if (al == _LOWER_NIBBLE3) {
                        and     edx,7
                        mov     ebx,2
                        mov     ecx,3
                    
                    } else if (al == _BINARY8) {
                        mov     ebx,2
                        mov     ecx,8
                    
                    } else if (al == _BINARY11) {
                        mov     ebx,2
                        mov     ecx,11
                    
                    } else if (al == _BINARY16) {
                        mov     ebx,2
                        mov     ecx,16
                    
                    } else if (al == _BINARY32) {
                        mov     ebx,2
                        mov     ecx,32
                    
                    } else {
                      // These are handled as text operations
                        if (al == _TBYTE || al == _IEEE_80)
                        {
                          // It is a floating point real to be displayed in hex format
                            mov     edx,offset trash_string
                            mov     ecx,10
                            while (ecx > 0)
                            {
                                mov     al,u8 ptr [ebp+ebx]
                                mov     ah,al
                                and     al,0fh
                                if (al > 9)
                                {
                                  // It gets a letter
                                    add     al,'a'-10
                                
                                } else {
                                  // It gets a number
                                    add     al,'0'
                                }
                                mov     u8 ptr ds:[edx],al
                                inc     edx
                                and     ah,0fh
                                if (ah > 9)
                                {
                                  // It gets a letter
                                    add     ah,'a'-10
                                
                                } else {
                                  // It gets a number
                                    add     ah,'0'
                                }
                                mov     u8 ptr ds:[edx],al
                                inc     edx
                                dec     ecx
                                inc     ebx
                            }
                            mov     u8 ptr ds:[edx],0
                          // Right now the string is created and null-terminated

                        
                        } else if (al == _ADJ_FLOAT14) {
                          // This is an abbreviated version of the floating point data, only 14 chars wide total
                            push    edi
                            mov     ecx,14
                            mov     edi,offset trash_string
                            invDEBI_check_stx_from_fpu_save_state()
                            if (!carry?)
                            {
                                finit
                                invDEBI_load_stx_from_ebx()
                              // Right now, st(0) - the value we need to display
                                invDEBI_convert_st0_to_string()
                                invDEBI_align_floating_point_string()
                            }
                            pop     edi
                        
                        } else if (al == _ADJ_FLOAT20) {
                          // This is a full width floating point data
                            push    edi
                            mov     ecx,20
                            mov     edi,offset trash_string
                            invDEBI_check_stx_from_fpu_save_state()
                            if (!carry?)
                            {
                                finit
                                invDEBI_load_stx_from_ebx()
                              // Right now, st(0) - the value we need to display
                                invDEBI_convert_st0_to_string()
                                invDEBI_align_floating_point_string()
                            }
                            pop     edi
                        
                        } else if (al == _ADJ_FLOAT21) {
                          // This is a full width floating point data
                            push    edi
                            mov     ecx,21
                            mov     edi,offset trash_string
                            invDEBI_check_stx_from_fpu_save_state()
                            if (!carry?)
                            {
                                finit
                                invDEBI_load_stx_from_ebx()
                              // Right now, st(0) - the value we need to display
                                invDEBI_convert_st0_to_string()
                                invDEBI_align_floating_point_string()
                            }
                            pop     edi
                        
                        } else {
                          // Unknown type
                            jmp     next_window
                        }
                        pushfd
                        push    0                           // write operation (0-overlay)
                        mov     eax,u32 ptr ds:[edi+6]
                        add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                        push    eax
                      // Y coordinate
                        mov     eax,u32 ptr ds:[edi+10]
                        add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                        push    eax
                        push    0                           // display mode (0-normal)
                        push    u32 ptr offset trash_string
                        cli
                        call    u48 ptr ds:_VID_g_mono_display_text_mode
                        popfd
                        add     edi,16
                        jmp     next_object
                    }
                  // Right now, edx - lower nibble contains the upper nibble specified
                  //            ebx - 2 (base-2 number, it will be displayed in binary)
                  //            ecx - number of digits to display
                  // X coordinate
                    pushfd
                    mov     eax,u32 ptr ds:[edi+6]
                    add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                    push    eax
                  // Y coordinate
                    mov     eax,u32 ptr ds:[edi+10]
                    add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                    push    eax
                  just_display1:
                    cli
                    call    u48 ptr ds:_VID_g_display_radix_in_edx_mono
                    popfd
                  skip1:
                    add     edi,16
                    jmp     next_object

                
                } else if (al == _EBP_RELATIVE_EFLAG) {
                  // They're specifying that it's EBP relative flag (our EBP, not theirs)
                    movsx   ebx,u16 ptr ds:[edi+2]             // Offset in our stack frame
                    mov     edx,u32 ptr [ebp+ebx]          // Value stored there
                    mov     ecx,u32 ptr ds:[edi+5]            // bit mask to use for flag
                    and     edx,ecx                             // mask off the value (used below)
                    mov     ebx,edi                             // Get a pointer to the text string to display
                    add     ebx,18
                    movzx   ecx,u8 ptr ds:[ebx-1]             // Length of this string
                    if (edx == 0)
                    {
                      // FLAG is down
                        mov     u8 ptr ds:[ebx+ecx-1],''
                    
                    } else {
                      // FLAG is up
                        mov     u8 ptr ds:[ebx+ecx-1],''
                    }
                  // X coordinate
                    pushfd
                    push    ecx
                    mov     eax,u32 ptr ds:[edi+9]
                    add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                    push    eax
                  // Y coordinate
                    mov     eax,u32 ptr ds:[edi+13]
                    add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                    push    eax
                    push    ebx                                 // offset to string
                    cli
                    call    u48 ptr ds:_VID_g_mono_display_text
                    pop     ecx
                    popfd
                    add     ebx,ecx                             // move past the string
                    inc     ebx                                 // for the trailing null
                    mov     edi,ebx
                    jmp     next_object

                
                } else if (al == _EBP_THROUGH_EBP_RELATIVE) {
                  // Something in the user's local variables
                    mov     edx,u32 ptr [ebp]              // Get their original EBP value
                    movsx   ebx,u16 ptr ds:[edi+3]             // Offset in their stack frame
                    add     edx,ebx
                    test    u32 ptr [ebp+56],111b
                    if (zero?)
                    {
                      // This is an Exodus core algorithm that's being debugged
                        mov     ebx,08000h
                    
                    } else {
                      // It's a user application, we need to find out exactly how big the stack is
                       // REMEMBER, hard-wired stack reference of 8000h ... needs to be dynamic
                        mov     ebx,08000h
                    }
                    if (edx < ebx && edx >= u32 ptr [ebp-04])
                    {
                      // The value of EBP is within the first 32k and it's greater than their value of ESP
                        mov     edx,u32 ptr ss:[edx]          // Value stored there
                        mov     ebx,16
                        mov     ecx,-8                          // The negative sign indicates leading 0's should be ú's
                      // Right now, edx - lower nibble contains the upper nibble specified
                      //            ebx - 16 (base-16 number, it will be displayed in hex)
                      //            ecx - number of digits to display
                      // X coordinate
                        pushfd
                        mov     eax,u32 ptr ds:[edi+6]
                        add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                        push    eax
                      // Y coordinate
                        mov     eax,u32 ptr ds:[edi+10]
                        add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                        push    eax
                        cli
                        call    u48 ptr ds:_VID_g_display_radix_in_edx_mono
                        popfd
                    
                    } else {
                      // Just display the empty string notation
                        pushfd
                        mov     eax,u32 ptr ds:[edi+6]
                        add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                        push    eax
                      // Y coordinate
                        mov     eax,u32 ptr ds:[edi+10]
                        add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                        push    eax
                        push    u32 ptr offset empty_dword_text
                        cli
                        call    u48 ptr ds:_VID_g_mono_display_text
                        popfd
                    }
                    add     edi,16
                    jmp     next_object

                
                } else if (al == _ESP_THROUGH_EBP_RELATIVE) {
                  // Something in the user's local variables
                    mov     edx,u32 ptr [ebp-04]           // Get their original ESP value
                    movsx   ebx,u16 ptr ds:[edi+3]             // Offset in their stack
                    add     edx,ebx
                    test    u32 ptr [ebp+56],111b
                    if (zero?)
                    {
                      // This is an Exodus core algorithm that's being debugged
                        mov     ebx,08000h
                    
                    } else {
                      // It's a user application, we need to find out exactly how big the stack is
                       // REMEMBER, hard-wired stack reference of 8000h ... needs to be dynamic
                        mov     ebx,08000h
                    }
                    if (edx < ebx)
                    {
                      // The value of EBP is within the first 32k and it's greater than their value of ESP
                        mov     edx,u32 ptr ss:[edx]          // Value stored there
                        mov     ebx,16
                        mov     ecx,-8                          // The -8 indicates leading ú's and not 0's
                      // Right now, edx - lower nibble contains the upper nibble specified
                      //            ebx - 16 (base-16 number, it will be displayed in hex)
                      //            ecx - number of digits to display
                      // X coordinate
                        pushfd
                        mov     eax,u32 ptr ds:[edi+6]
                        add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                        push    eax
                      // Y coordinate
                        mov     eax,u32 ptr ds:[edi+10]
                        add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                        push    eax
                        cli
                        call    u48 ptr ds:_VID_g_display_radix_in_edx_mono
                        popfd
                    
                    } else {
                      // Just display the empty string notation
                        pushfd
                        mov     eax,u32 ptr ds:[edi+6]
                        add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                        push    eax
                      // Y coordinate
                        mov     eax,u32 ptr ds:[edi+10]
                        add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                        push    eax
                        push    u32 ptr offset empty_dword_text
                        cli
                        call    u48 ptr ds:_VID_g_mono_display_text
                        popfd
                    }
                    add     edi,16
                    jmp     next_object

                
                } else {
                  // Unsupported option (or invalid data)
                    jmp     next_window
                }

            
            } else if (al == _INPUT) {
                jmp     next_window
            
            } else if (al == _POST_DISPLAY) {
                add     edi,10
                movzx   ecx,u8 ptr ds:[edi]
                add     edi,ecx
                inc     edi
            
            } else if (al == _POST_OBJECT) {
                jmp     next_window
            
            } else if (al == _FUNCTION) {
              // They've specified that a function will handle this item
                mov     ebx,u32 ptr ds:[edi+1]
                pushad
                pushfd
                push    ds
                push    es
                push    fs
                push    gs

                ebx()

                pop     gs
                pop     fs
                pop     es
                pop     ds
                popfd
                popad
                add     edi,5
            
            } else if (al == _DRAW_WINDOW_ALWAYS) {
              // Draw a DEBI window, regardless of whether or not the screen is shown
                jmp     force_draw_window
            
            } else if (al == _DRAW_WINDOW) {
              // Draw a DEBI window
                if (ds:debug_screen_shown == 0 || ds:force_screen_redraw != 0)
                {
                  force_draw_window:
                    pushad
                    mov     ebx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                    mov     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                    mov     edi,u32 ptr ds:[edi+1]
                  // Right now, ebx - horizontal starting pixel
                  //            eax - vertical starting pixel
                  //       ds:[edi] - far ptr to screen info
                    invDEBI_draw_window()
                    popad
                }
                add     edi,5
            
            } else {
              // What is it?  Dunno.  Why not?  'Cause I'm stupid.  Oh yeah. :)
                jmp     next_window
            }
          next_object:
        }
      next_window:
        popad
        pop     es
        ret
    }




    function invDEBI_draw_window
    {
    // This routine is used draw the contents of a window
    //
    // Upon entry:   ebx - horizontal starting pixel
    //               eax - vertical starting pixel
    //             [edi] - far ptr to screen info in current data segment
    //                ds - current data segment
    //
    // Upon exit:    The window is drawn
    //
        while (byte ptr ds:[edi] != 255)
        {
            push    ebx                                             // horizontal
            push    eax                                             // vertical
            push    edi                                             // start of window item
            call    u48 ptr ds:_VID_g_mono_display_text           //

            add     edi,ecx
            add     eax,u32 ptr [ebp-08]                       // Move down to next line

            if (byte ptr ds:[edi] == 254)
            {
              // They are specifying that this last line has to repeat a fixed number of times
                mov     edx,ecx
                xor     ecx,ecx
                mov     cl,u8 ptr ds:[edi+1]                      // Get the count
                sub     edi,edx
                repeat
                {
                    push    ecx
                    push    ebx
                    push    eax
                    push    edi
                    call    u48 ptr ds:_VID_g_mono_display_text
                    add     eax,u32 ptr [ebp-08]               // Next line
                    pop     ecx
                } untilcxz
                jmp     done_with_window
            }
        }
      done_with_window:
        ret
    }




    function invDEBI_load_stx_from_ebx
    {
    // This routine is used to load a particular ST(x) value from the FPU Save State on the stack
    //
    // Upon entry:   [ebp-200] - start of FPU save state on the stack
    //                        ebx - st(0) value on the FPU save state stack to load
    //
    // Upon exit:    st(0) is loaded with the value specified (or 0 if ebx is invalid)
    //
        if (ebx == 0)
        {
            mov     ebx,-200+28
        
        } else if (ebx == 1) {
            mov     ebx,-200+38
        
        } else if (ebx == 2) {
            mov     ebx,-200+48
        
        } else if (ebx == 3) {
            mov     ebx,-200+58
        
        } else if (ebx == 4) {
            mov     ebx,-200+68
        
        } else if (ebx == 5) {
            mov     ebx,-200+78
        
        } else if (ebx == 6) {
            mov     ebx,-200+88
        
        } else if (ebx == 7) {
            mov     ebx,-200+98
        
        } else {
          // It's invalid, load 0
            fldz
            jmp     quit
        }
        fld     tbyte ptr [ebp+ebx]
      quit:
        ret
    }




    function invDEBI_check_stx_from_fpu_save_state
    {
    // This routine is used as a precursor to invDEBI_convert_st0_to_string().  It determines whether or not a particular
    // st(x) value stored in the FPU Save State on the stack is valid or not (based on the TAG word).  If it is valid then it
    // does nothing.  If it is invalid then it populates the ds:[edi] string with the appropriate text.
    //
    // Upon entry:   ebx - st(x) value (0-7)
    //               ecx - maximum string width
    //          ds:[edi] - Where to store the string (if generated)
    //
    // Upon exit:    ds:[edi] - may be updated with the generated string
    //               carry? - CLEAR if not updated, SET if updated
    //
        pushad
        movzx   eax,u16 ptr [ebp-200+8]                         // Load TAG word
        movzx   edx,u16 ptr [ebp-200+4]                         // Load STATUS word
        invDEBI_adjust_for_fpu_tos()                          // Adjust the current TAG word for top-of-stack
        cmp     ebx,0                                               // They want us to examine st(0)
        jz      next_part
        shr     eax,2
        cmp     ebx,1                                               // st(1)
        jz      next_part
        shr     eax,2
        cmp     ebx,2                                               // st(2)
        jz      next_part
        shr     eax,2
        cmp     ebx,3                                               // st(3)
        jz      next_part
        shr     eax,2
        cmp     ebx,4                                               // st(4)
        jz      next_part
        shr     eax,2
        cmp     ebx,5                                               // st(5)
        jz      next_part
        shr     eax,2
        cmp     ebx,6                                               // st(6)
        jz      next_part
        shr     eax,2
        cmp     ebx,7                                               // st(7)
        jz      next_part
      // If we're here it wasn't found
      // It's an error so we go ahead and display the value numerically (which will catch NaN's and the like)
        clc
        jmp     quit

      next_part:
        and     eax,11b
        if (eax != 11b)
        {
          // It's something that needs to be represented numerically
            clc                                                     // Clear the flag (we didn't copy anything)
            jmp     quit
        }

      // It's empty, so we copy the string
        mov     esi,offset number_empty
        mov     ebx,ecx
        xor     ecx,ecx
        while (byte ptr ds:[esi+ecx] != 0 && ebx > 0)
        {
            mov     al,u8 ptr ds:[esi+ecx]
            mov     u8 ptr ds:[edi+ecx],al
            inc     ecx
            if (al != '®' && al != '¯')
            {
                dec     ebx
            }
        }
        while (ebx > 0)
        {
            mov     u8 ptr ds:[edi+ecx],' '
            inc     ecx
            dec     ebx
        }
        mov     u8 ptr ds:[edi+ecx],0
        stc                                                         // Set the flag (indicating we copied something)

      quit:
        popad
        ret
    }




    function invDEBI_adjust_for_fpu_tos
    {
    // This algorithm is used to adjust the currently requested
    //
    // Upon entry:  eax - TAG word
    //              ebx - st(x) value they're desiring
    //              edx - STATUS word
    //
    // Upon exit:   eax - adjusted properly for current TOS pointer
    //
        shr     edx,11                                              // Shift it over 11 bits (to get TOS down to the lower 3 bits)
        cmp     edx,00
        jz      quit                                                // if branch we're good to go (TOS is already at 0)
        rol     ax,2
        cmp     edx,7
        jz      quit                                                // in branch it was at 7
        rol     ax,2
        cmp     edx,6
        jz      quit                                                // in branch it was at 6
        rol     ax,2
        cmp     edx,5
        jz      quit                                                // in branch it was at 5
        rol     ax,2
        cmp     edx,4
        jz      quit                                                // in branch it was at 4
        rol     ax,2
        cmp     edx,3
        jz      quit                                                // in branch it was at 3
        rol     ax,2
        cmp     edx,2
        jz      quit                                                // in branch it was at 2
        rol     ax,2
      // If we get all the way to here then it was 1

      quit:
        ret
    }




    function invDEBI_convert_st0_to_string
    {
    // This routine is used to convert the value currently stored in ST0 to it's standard numeric equivalent
    //
    // Upon entry:   st0 - IEEE 80-bit to convert to string
    //               ecx - maximum string width
    //          ds:[edi] - where to store the trash string
    //
    // Upon exit:    ds:[edi] is updated with the string to display
    //
        pushad
        push    es
        mov     es,cs:data_segment

        mov     es:exponent,0
        fxam                                                        // Examine the # for weird values
        fstsw   es:FPStat
        mov     bx,es:FPStat

      // Copy high bits to low.
        mov     bl,bh
        shr     bh,3
        and     bh,008h
        and     bl,007h
        or      bl,bh
      // bl now has C3, C2, C1 and C0 in low 4 bits

        if (bl != 4 && bl != 6)
        {
            if (bl == 0)
            {
                mov     esi,offset bad_number0
            
            } else if (bl == 1) {
                mov     esi,offset bad_number1
            
            } else if (bl == 2) {
                mov     esi,offset bad_number2
            
            } else if (bl == 3) {
                mov     esi,offset bad_number3
            
            } else if (bl == 5) {
                mov     esi,offset bad_number5
            
            } else if (bl == 7) {
                mov     esi,offset bad_number7
            
            } else if (bl == 8) {
                mov     al,'+'
                jmp     skip_alignment
            
            } else if (bl == 9) {
                mov     esi,offset bad_number9
            
            } else if (bl == 10) {
                mov     al,'-'
                fchs
                jmp     skip_alignment
            
            } else if (bl == 11) {
                mov     esi,offset bad_number11
            
            } else if (bl == 12) {
                mov     esi,offset bad_number12
            
            } else if (bl == 13) {
                mov     esi,offset bad_number13
            
            } else if (bl == 14) {
                mov     esi,offset bad_number14
            
            } else if (bl == 15) {
                mov     esi,offset bad_number13
            
            } else {
                jmp     do_the_number
            }

          // Note, this bit of code is duplicated in the invDEBI_check_stx() algorithm
            mov     ebx,ecx
            xor     ecx,ecx
            while (byte ptr es:[esi+ecx] != 0 && ebx > 0)
            {
                mov     al,u8 ptr es:[esi+ecx]
                mov     u8 ptr ds:[edi+ecx],al
                inc     ecx
                dec     ebx
            }

            inc     ebx
            while (ebx > 0)
            {
                mov     u8 ptr ds:[edi+ecx],' '
                inc     ecx
                dec     ebx
            }
            mov     u8 ptr ds:[edi+ecx],0
            jmp     quit
        }

      do_the_number:
      // Is it greater than zero?
        ftst
        fstsw   ax
        mov     es:FPStat,ax
        sahf
        if (carry?)
        {
          // It is < than zero...Put a minus sign
            mov     al,"-"
            fchs
        
        } else {
          // It is > than zero...Put a plus sign
            mov     al,"+"
        }

      // While the number is less than 1 multiply by 10 and decrement exponent
        push    eax
      @@:
        fld1
        fcomp
        fstsw   ax
        sahf
        jc      @F
        dec     es:exponent
        fild    es:number10
        fmul
        jmp     @B
      @@:

      // While the number is greater than or equal to 10, divide it by 10 and increment the exponent
      @@:
        ficom   es:number10
        fstsw   ax
        sahf
        jc      @F
        inc     es:exponent
        fild    es:number10
        fdivp   st(1),st
        jmp     @B
      @@:
      // The value is now a number in the range of 1.0<=Number<10
        pop     eax

      skip_alignment:
        mov     u8 ptr ds:[edi],al
        inc     edi
      // Now set up rounding by chopping
        fstcw   es:FPCtrl
        movzx   eax,es:FPCtrl
        and     eax,0f3ffh
        or      eax,0c00h
        mov     es:FPCtrl,ax
        fldcw   es:FPCtrl

        invDEBI_extract_digit()
        mov     u8 ptr ds:[edi],al
        inc     edi
        mov     al,"."
        mov     u8 ptr ds:[edi],al
        inc     edi

      // Now get 18 decimals
        mov     ecx,18
        repeat
        {
            invDEBI_extract_digit()
            mov     u8 ptr ds:[edi],al
            inc     edi
        } untilcxz

      // Now write the exponent
        mov     u8 ptr ds:[edi],'e'
        inc     edi
        mov     edx,es:exponent
        invDEBI_signed_convert_dword_to_decimal()         // Store the exponent as signed text

      quit:
        fistp   es:trash_dword
        pop     es
        popad
        ret
    }




    function invDEBI_extract_digit    NEAR
    {
    // This routine is called to extract the left-most digit from a number in the format of #.######
    //
    // Upon entry:   the value is in st(0)
    //
    // Upon exit:    al - extracted digit
    //
        fld     st(0)                                               // Duplicate st(0)
        frndint                                                     // Convert this value to an int
        fsub    st(1),st(0)                                         // Get the "remainder" portion
        fistp   es:digit                                            // Store it
        fild    es:number10                                         // Now update our the value by our multiplier
        fmulp   st(1),st(0)

      // Get the digit and convert it and write it
        mov     eax,es:digit
        add     al,"0"
        ret
    }




    function invDEBI_signed_convert_dword_to_decimal
    {
    // This routine takes the value in edx and outputs it to ds:[edi]
    //
    // Upon entry:   edx - value to convert
    //          ds:[edi] - where to store the signed quantity
    //
    // Upon exit:    The value is converted
    //               edi - pointer to end of string
    //
        enter   10,0
        pushad
        mov     esi,ebp
        sub     esi,10
      // Right now, ss:[esi] - far ptr to string to build
        mov     u8 ptr ss:[esi],0
        inc     esi

        if (edx > 7fffffffh)
        {
            mov     al,"-"
            neg     edx
        
        } else {
            mov     al,"+"
        }
        stosb

        mov     eax,edx
        mov     ebx,10
      @@:
        xor     edx,edx
        div     ebx
        add     dl,'0'
        mov     u8 ptr ss:[esi],dl
        inc     esi
        cmp     eax,0
        jnz     @B

      // Right now we've extracted all of the values
        mov     ecx,2                                               // Default to 2, one for +/- above, one for trailing NULL
        dec     esi
        while (byte ptr ss:[esi] != 0)
        {
            mov     dl,u8 ptr ss:[esi]
            mov     u8 ptr ds:[edi],dl
            inc     edi
            dec     esi
            inc     ecx
        }
        mov     u8 ptr ds:[edi],0                                 // NULL terminate

        mov     es:signed_digits,ecx                                // Indicate how many digits were written in the exponent
        add     u32 ptr [esp+00],ecx                           // Update edi on the stack

        popad
        leave
        ret
    }




    function invDEBI_align_floating_point_string
    {
    // This routine is used to adjust a floating pointer string that was just created
    //
    // Upon entry:   cs:exponent - # of digits in the exponent portion
    //               ds:[edi] - far ptr to string to adjust
    //                    ecx - maximum width for value
    //
    // Upon exit:    String at ds:[edi] is adjusted (if possible) to represent it in the number of digits specified in ecx
    //               * Note:  If the string cannot be represented in the specified length then it will appear in +1.234e+289 form
    //
        enter   4,0
      // [ebp-04] - dword, used to hold the NEG exponent value for a negative exponent (this gives it the positive appearance)
        pushad
        push    es
        mov     es,cs:data_segment
        if (es:exponent == 0)
        {
          // The number is already adjusted properly for decimal alignment
          // All we have to worry about is the width
          truncate_as_necessary:
            xor     ebx,ebx
            while (ebx < ecx && u8 ptr ds:[edi+ebx] != 'e' && u8 ptr ds:[edi+ebx] != '<')
            {
                if (byte ptr ds:[edi+ebx] == '®' || u8 ptr ds:[edi+ebx] == '¯')
                {
                    inc     ecx
                }
                inc     ebx
            }
            if (byte ptr ds:[edi+ebx] == '<')
            {
              // This is one of the conditions, it's not a number
                while (ebx < ecx)
                {
                    if (byte ptr ds:[edi+ebx] == '®' || u8 ptr ds:[edi+ebx] == '¯')
                    {
                        inc     ecx
                    }
                    if (byte ptr ds:[edi+ebx] == 0)
                    {
                        mov     u8 ptr ds:[edi+ebx],32
                    }
                    inc     ebx
                }
            
            } else {
                if (ebx < ecx)
                {
                  // We need to pad with spaces
                    while (ebx < ecx)
                    {
                        if (byte ptr ds:[edi+ebx] == '®' || u8 ptr ds:[edi+ebx] == '¯')
                        {
                            inc     ecx
                        }
                        mov     u8 ptr ds:[edi+ebx],' '
                        inc     ebx
                    }
                }
            }
            mov     u8 ptr ds:[edi+ebx],0
        
        } else if (es:exponent > 80000000h) {
          // It's negative
            mov     ebx,es:exponent
            neg     ebx
            mov     u32 ptr [ebp-04],ebx
            if (ebx < ecx)
            {
              // We an adjust it
              // Exchange the first digit and its decimal point
                mov     al,u8 ptr ds:[edi+1]
                xchg    al,u8 ptr ds:[edi+2]
                mov     u8 ptr ds:[edi+1],al
                mov     edx,20
                sub     edx,ebx
                mov     esi,edi
                push    ebx
                while (edx > 1)
                {
                    mov     al,u8 ptr ds:[edi+edx]
                    mov     u8 ptr ds:[esi+20],al
                    dec     esi
                    dec     edx
                }
                pop     ebx
                mov     ebx,u32 ptr [ebp-04]
                while (ebx > 1)
                {
                    mov     u8 ptr ds:[esi+20],'0'
                    dec     esi
                    dec     ebx
                }
              // Now, put the first 2 characters back where they're supposed to be
                mov     u16 ptr ds:[edi+1],'.0'
                mov     u32 ptr ds:[edi+21],' 0+e'                // Note, there's a NULL embedded on this line '<null>0+e'
                jmp     truncate_as_necessary
            }
        
        } else {
          // It's positive
            if (es:exponent < ecx)
            {
              // We can adjust it
                mov     ebx,es:exponent
                mov     esi,edi
                while (ebx > 0)
                {
                    mov     al,u8 ptr ds:[esi+3]                  // Move to the "1" in "+2.1234567890"
                    mov     u8 ptr ds:[esi+2],al                  // Move to the "." in same
                    inc     esi
                    dec     bx
                }
                mov     u8 ptr ds:[esi+2],'.'
                jmp     truncate_as_necessary
            }
        }

      quit:
        pop     es
        popad
        leave
        ret
    }




    function invDEBI_quick_watch_add_item
    {
    // This routine is used to add a line item to the quick watch window
    //
    // Upon entry:   ds:[esi] - ptr to item to add
    //               cs:[edi] - ptr to text to preceed item to add
    //                          * Note:  If edi = -1, then only ds:[esi] is used
    //
    // Upon exit:    Item is added and the quick watch window is updated
    //
        pushfd
        push    es
        push    ds
        pushad

        mov     es,cs:data_segment
        if (edi == -1)
        {
            jmp     doing_ds_esi_only
        }
      do_again_cs_edi:
        invDEBI_quick_watch_scroll_data()
        mov     ebx,offset quick_1
        mov     ecx,sizeof quick_1 - 2
        while (ecx > 0 && u8 ptr es:[edi] != 0)
        {
            mov     al,u8 ptr es:[edi]
            inc     edi
            mov     u8 ptr es:[ebx],al
            inc     ebx
            dec     ecx
        }
        if (byte ptr es:[edi] != 0)
        {
          // Still more to do
            jmp     do_again_cs_edi
        }

      do_again_ds_esi:
        while (byte ptr ds:[esi] != 0 && ecx > 0)
        {
            lodsb
            mov     u8 ptr es:[ebx],al
            inc     ebx
            dec     ecx
        }
        if (byte ptr ds:[esi] != 0)
        {
          // Still more to do
          doing_ds_esi_only:
            invDEBI_quick_watch_scroll_data()
            mov     ebx,offset quick_1
            mov     ecx,sizeof quick_1 - 2
            jmp     do_again_ds_esi
        }
        invDEBI_quick_watch_refresh_window()

        popad
        pop     ds
        pop     es
        popfd
        ret
    }




    function invDEBI_quick_watch_add_item_ecx
    {
    // This routine is used to add a line item to the quick watch window
    //
    // Upon entry:   ds:[esi] - ptr to item to add
    //               cs:[edi] - ptr to text to preceed item to add
    //
    // Upon exit:    Item is added and the quick watch window is updated
    //
        pushfd
        push    es
        push    ds
        pushad

        mov     es,cs:data_segment
        if (edi == -1)
        {
            jmp     doing_ds_esi_only
        }
      do_again_cs_edi:
        invDEBI_quick_watch_scroll_data()
        mov     ebx,offset quick_1
        mov     edx,sizeof quick_1 - 2
        while (byte ptr es:[edi] != 0 && edx > 0)
        {
            mov     al,u8 ptr es:[edi]
            inc     edi
            mov     u8 ptr es:[ebx],al
            inc     ebx
            dec     edx
        }
        if (byte ptr es:[edi] != 0)
        {
          // Still more to do
            jmp     do_again_cs_edi
        }

      do_again_ds_esi:
        while (byte ptr ds:[esi] != 0 && ecx > 0)
        {
            lodsb
            mov     u8 ptr es:[ebx],al
            inc     ebx
            dec     ecx
        }
        if (byte ptr ds:[esi] != 0)
        {
          // Still more to do
          doing_ds_esi_only:
            invDEBI_quick_watch_scroll_data()
            mov     ebx,offset quick_1
            mov     ecx,sizeof quick_1 - 2
            jmp     do_again_ds_esi
        }
        invDEBI_quick_watch_refresh_window()

        popad
        pop     ds
        pop     es
        popfd
        ret
    }




    function invDEBI_quick_watch_refresh_window
    {
    // This routine physically redraws the quick watch window
    //
    // Upon entry:   Nothing
    //
    // Upon exit:    The window is redrawn
    //
        pushfd
        pushad
        push    ds

      // Now, physically draw the window (update it)
        mov     ds,cs:data_segment
        mov     esi,offset quick_watch_screen_object
        mov     ebx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        mov     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        mov     edi,offset DEBI_j_window

      // Right now, ebx - horizontal starting pixel
      //            eax - vertical starting pixel
      //       ds:[edi] - far ptr to screen info
        cli
        invDEBI_hide_mouse_pointer()
        invDEBI_turn_cursor_off()
        invDEBI_draw_window()
        invDEBI_show_mouse_pointer()

        pop     ds
        popad
        popfd
        ret
    }




    function invDEBI_quick_watch_add_radix_in_edx
    {
    // This routine is used to display the value in edx in a radix in ebx
    //
    // Upon entry:   edx - value to display
    //               ebx - radix to display in
    //               edi - ptr to text to add, or -1 if none
    //
    // Upon exit:    The value is displayed
    //
        push    ds
        pushad
        sub     esp,36                                                  // Assume a maximum length of 32 chars (4 extra for boundary)
        mov     ebp,esp

        mov     u8 ptr [ebp+32],0                                     // NULL terminate the string we're building
        mov     esi,ebp
        add     esi,31
        mov     eax,edx
        and     ebx,0ffffh
        if (ebx <= 1)
        {
          // They've forgotten to set the value, so we correct their little blunder
            mov     ebx,16
        }
      @@:
        xor     edx,edx
        div     ebx
        if (dl > 9)
        {
            add     dl,'a'-10                                           // Make it a letter if it's above 9 (10+ cannot be represented in 1 digit)
        
        } else {
            add     dl,'0'                                              // Make it a number
        }
        mov     u8 ptr ss:[esi],dl
        dec     esi                                                     // Decrement (move to next position to store data)
        cmp     esi,ebp
        jz      @F
        cmp     eax,0
        jnz     @B
      @@:
        push    ss
        pop     ds
        inc     esi                                                     // Add back for the one we decremented above
      // Right now, ds:[esi] - ptr to the value to display
      //            cs:[edi] - ptr to text to preceed this item
        mov     ebp,u32 ptr [esp+08+36]
        invDEBI_quick_watch_add_item()

        add     esp,36
        popad
        pop     ds
        ret
    }




    function invDEBI_quick_watch_add_real4_in_edx
    {
    // This routine is used to display the value in edx in a radix in ebx
    //
    // Upon entry:   edx - REAL4 value to display
    //               edi - ptr to text to add, or -1 if none
    //
    // Upon exit:    The value is displayed
    //
        pushad
        push    ds
        sub     esp,44                                                  // Allow for plenty of space

        push    ss
        pop     ds
        mov     u32 ptr [esp],edi
        mov     edi,esp
        add     edi,4
        mov     esi,edi
        mov     ecx,18
      // Right now, ds:[esi] - ptr to the value to display
      //            cs:[edi] - ptr to text to preceed this item
        mov     u32 ptr ds:[edi],edx
        fld     f32 ptr ds:[edi]
        invDEBI_convert_st0_to_string()
        mov     edi,u32 ptr [esp]
        invDEBI_quick_watch_add_item()

        add     esp,44
        pop     ds
        popad
        ret
    }




    function invDEBI_quick_watch_add_divider
    {
    // This routine is called to put a divider up between items in the quickwatch window
    //
    // Upon entry:   Nothing
    //
    // Upon exit:    The divider bar is displayed
    //
        push    ds
        push    esi
        push    edi

        mov     ds,cs:data_segment
        mov     esi,offset quick_watch_divider
        mov     edi,-1
        invDEBI_quick_watch_add_item()

        pop     edi
        pop     esi
        pop     ds
        ret
    }




    function invDEBI_quick_watch_scroll_data
    {
    // This routine physically copies the data in the watch window up one line
    //
    // Upon entry:   Nothing
    //
    // Upon exit:    Data is scrolled
    //
        pushfd
        push    ds
        push    es
        push    esi
        push    edi
        push    ecx
        push    eax

        mov     ds,cs:data_segment
        mov     es,cs:data_segment

        cld
        mov     esi,offset quick_11
        mov     edi,offset quick_12
        mov     ecx,sizeof quick_12 - 2
        rep     movsb
        mov     esi,offset quick_10
        mov     edi,offset quick_11
        mov     ecx,sizeof quick_11 - 2
        rep     movsb
        mov     esi,offset quick_9
        mov     edi,offset quick_10
        mov     ecx,sizeof quick_10 - 2
        rep     movsb
        mov     esi,offset quick_8
        mov     edi,offset quick_9
        mov     ecx,sizeof quick_9 - 2
        rep     movsb
        mov     esi,offset quick_7
        mov     edi,offset quick_8
        mov     ecx,sizeof quick_8 - 2
        rep     movsb
        mov     esi,offset quick_6
        mov     edi,offset quick_7
        mov     ecx,sizeof quick_7 - 2
        rep     movsb
        mov     esi,offset quick_5
        mov     edi,offset quick_6
        mov     ecx,sizeof quick_6 - 2
        rep     movsb
        mov     esi,offset quick_4
        mov     edi,offset quick_5
        mov     ecx,sizeof quick_5 - 2
        rep     movsb
        mov     esi,offset quick_3
        mov     edi,offset quick_4
        mov     ecx,sizeof quick_4 - 2
        rep     movsb
        mov     esi,offset quick_2
        mov     edi,offset quick_3
        mov     ecx,sizeof quick_3 - 2
        rep     movsb
        mov     esi,offset quick_1
        mov     edi,offset quick_2
        mov     ecx,sizeof quick_2 - 2
        rep     movsb
      // Reset the bottom line to spaces
        mov     edi,offset quick_1
        mov     ecx,sizeof quick_1 - 2
        mov     al,32
        rep     stosb

        pop     eax
        pop     ecx
        pop     edi
        pop     esi
        pop     es
        pop     ds
        popfd
        ret
    }




    function invDEBI_query_window
    {
    // This routine is called when updating the screen (it handles query window objects)
    //
    // Upon entry:   The stack is arranged as below
    //               ds:[esi] - ptr to screen table structure
    //               ds:[edi] - ptr to this item's objects
    //
    // Upon exit:    The window is populated or not
    //
      // [ebp-080] - offset into _sDEBI_memory for next item
      // [ebp-084] - segment of temp far address
      // [ebp-088] - offset of temp far address
      // [ebp-092] - (temp) used as a temporary holder for processing
        ret
    }
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// END - 00000 - Window Supportive Algorithms/Handlers
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// 11111 - External interfaces (Timer, Mouse, Kbd)
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    function iDEBI_kbd_interface
    {
    // This routine is called when the user presses a key after iKBD_activate_DEBI_intercept() has been called
    //
    // Upon entry:   eax - key
    //               ebx - keyboard flags
    //
    // Upon exit:    Nothing
    //
        if (cs:disable_kbd == 1)
        {
            retf
        }

      // Cancel the screen saver (if it's activated)
        push    ds
        mov     ds,cs:data_segment
        invDEBI_cancel_screen_saver()
        mov     ds:screen_saver_count,0

      // Process the key with whatever routine is receiving keyboard input
        if (cs:kbd_focus == -1)
        {
          // No handler is seutp, use DEBI generic
            invDEBI_kbd_handler()
        
        } else {
            push    es
            push    fs
            push    gs
            pushad

            mov     edx,ds:kbd_focus
            edx()

            popad
            pop     gs
            pop     fs
            pop     es
        }

        pop     ds
        retf
    }




    function iDEBI_mouse_interface
    {
    // This routine is called when the mouse status changes after iMOUSE_activate_DEBI_intercept() has been called
    //
    // Upon entry:   eax - X delta
    //               edx - Y delta
    //               ebx - button status
    //
    // Upon exit:    Nothing
    //
        if (cs:disable_mouse == 1)
        {
            retf
        }
        push    ds
        pushad
        mov     ds,cs:data_segment

       // Cancel screen saver if it's active
        invDEBI_cancel_screen_saver()
        mov     ds:screen_saver_count,0

       // Remove the mouse pointer that's already displayed
        if (ds:mouse_processing == 0 && ds:mouse_status == 1)
        {
            invDEBI_hide_mouse_pointer()
        }

       // Update the coordinates based on the signed displacement information sent to us from the mouse driver
        invDEBI_update_mouse_coordinates()

       // Process the mouse
        if (ds:mouse_processing == 0)
        {
          // No button status, just moving the mouse around. :)
            mov     ds:mouse_processing,1
            if (ds:dragging_something != 0)
            {
                pushad
                pushfd
                push    ds

              // Put the image back on the screen where it was
                cli
                if (ds:dragging_something != 1)
                {
                    push    u32 ptr ds:dragging_x
                    mov     edx,ds:dragging_offset_x
                    sub     u32 ptr [esp],edx
                    invDEBI_dragging_snap_x()

                    push    u32 ptr ds:dragging_y
                    mov     edx,ds:dragging_offset_y
                    sub     u32 ptr [esp],edx
                    invDEBI_dragging_snap_y()

                    mov     edx,ds:dragging_last_x
                    mov     ebx,ds:dragging_last_y
                    if (dword ptr [esp+4] == edx && u32 ptr [esp] == ebx)
                    {
                      // This will only be the case if they're using a dragging_snap_x and/or dragging_snap_y value
                        mov     ds:dragging_skipped,1
                        add     esp,8
                        jmp     skip_dragging_redraw
                    
                    } else {
                        mov     edx,u32 ptr [esp+4]
                        mov     ebx,u32 ptr [esp+0]
                        if (ds:dragging_skipped != 0)
                        {
                            mov     ds:dragging_skipped,0
                            mov     edx,ds:dragging_last_x
                            mov     ebx,ds:dragging_last_y
                            mov     u32 ptr [esp+4],edx
                            mov     u32 ptr [esp+0],ebx
                        
                        } else {
                            mov     ds:dragging_last_x,edx
                            mov     ds:dragging_last_y,ebx
                        }
                    }

                    push    u32 ptr [esp+4]
                    mov     edx,ds:dragging_width
                    add     u32 ptr [esp],edx

                    push    u32 ptr [esp+4]
                    mov     edx,ds:dragging_height
                    add     u32 ptr [esp],edx

                    push    0
                    push    0
                    mov     eax,_sDEBI_screen
                    mov     ds,ax
                    call    u48 ptr cs:_VID_g_mono_window_function
                
                } else {
                    inc     ds:dragging_something
                    mov     eax,_sDEBI_screen
                    mov     ds,ax
                }

              // Get the image at the new location
                push    u32 ptr cs:mouse_current_x
                mov     edx,cs:dragging_offset_x
                sub     u32 ptr [esp],edx
                invDEBI_dragging_snap_x()

                push    u32 ptr cs:mouse_current_y
                mov     edx,cs:dragging_offset_y
                sub     u32 ptr [esp],edx
                invDEBI_dragging_snap_y()

                push    u32 ptr [esp+4]
                mov     edx,cs:dragging_width
                add     u32 ptr [esp],edx

                push    u32 ptr [esp+4]
                mov     edx,cs:dragging_height
                add     u32 ptr [esp],edx

                push    1
                push    0
                call    u48 ptr cs:_VID_g_mono_window_function

              // Draw it at its new location
                push    u32 ptr cs:mouse_current_x
                mov     edx,cs:dragging_offset_x
                sub     u32 ptr [esp],edx
                invDEBI_dragging_snap_x()

                push    u32 ptr cs:mouse_current_y
                mov     edx,cs:dragging_offset_y
                sub     u32 ptr [esp],edx
                invDEBI_dragging_snap_y()

                push    u32 ptr [esp+4]
                mov     edx,cs:dragging_width
                add     u32 ptr [esp],edx

                push    u32 ptr [esp+4]
                mov     edx,cs:dragging_height
                add     u32 ptr [esp],edx

                push    0
                push    u32 ptr 4000h
                call    u48 ptr cs:_VID_g_mono_window_function

              // Update the dragging_coordinates
              skip_dragging_redraw:
                pop     ds
                popfd
                mov     edx,ds:mouse_current_x
                mov     ds:dragging_x,edx
                mov     edx,ds:mouse_current_y
                mov     ds:dragging_y,edx
                popad
            }
            if (ebx != 0 || ebx != ds:mouse_last_buttons)
            {
              // There is button activity
              // This process might take a bit of time to complete so we indicate we're processing thereby removing
              // the possibility of attempted processing in the future until such time as all the processing we're about
              // to start gets completed.
                invDEBI_mouse_button_activity()
            
            } else {
              // No button activity
              // We still have to see if we're over anything that needs to be updated because we also display information about
              // certain things in the Quick Watch window.  Isn't it great? :)
                mov     edx,ds:mouse_current_x
                mov     ds:mouse_hovering_x,edx
                mov     edx,ds:mouse_current_y
                mov     ds:mouse_hovering_y,edx
                mov     ds:mouse_hovering_count,91
                mov     ds:mouse_last_event,_HOVER
                mov     ds:mouse_immediate_count,_IMMEDIATE_COUNT
                invDEBI_show_mouse_pointer()
            }
            mov     ds:mouse_processing,0
        }

        popad
        pop     ds
        retf
    }




;; Bochs hack
    function iDEBI_bochs_mouse_interface
    {
    // Called from the mouse handler, simulates mouse input as though it came from a real mouse.
    // When working with Bochs, the MoMo maintains mouse pointer position, which is fed here.
    //
    // Upon entry:   eax - X delta
    //               ebx - Y delta
    //               ecx - button status
    //
    // Upon exit:    Nothing
    //
        push    ds
        pushad
        mov     ds,cs:data_segment

        // See if anything's changed
        if (eax != ds:mouse_current_x && ebx != ds:mouse_current_y)
        {
            // It has
            mov     edx,ebx         // Update Y coord for iDEBI_mouse_interface
            mov     ebx,ecx         // Update button for iDEBI_mouse_interface
            push    cs
            iDEBI_mouse_interface()
        }

        popad
        pop     ds
        retf
    }
;; Bochs hack




    function invDEBI_dragging_snap_x
    {
    // This routine is called to adjust the snap-to coordinates of the mouse movement
    //
    // Upon entry:   [esp+4] - value to snap
    //               ds:dragging_snap_x - value to snap to
    //
    // Upon exit:    Value on stack is updated to upper-most region
    //
      // [esp+8] - X coord to snap
      // [esp+4] - calling EIP
      // [esp+0] - ds
        if (cs:dragging_snap_x != 0)
        {
            push    ds
            mov     ds,cs:data_segment
            mov     eax,u32 ptr [esp+8]
            mov     ebx,ds:dragging_snap_x
            xor     edx,edx
            div     ebx
            mul     ebx
            mov     u32 ptr [esp+8],eax
            pop     ds
        }
        ret
    }




    function invDEBI_dragging_snap_y
    {
    // This routine is called to adjust the snap-to coordinates of the mouse movement
    //
    // Upon entry:   [esp+4] - value to snap
    //               ds:dragging_snap_y - value to snap to
    //
    // Upon exit:    Value on stack is updated to left-most region
    //
      // [esp+8] - Y coord to snap
      // [esp+4] - calling EIP
      // [esp+0] - ds
        if (cs:dragging_snap_y != 0)
        {
            push    ds
            mov     ds,cs:data_segment
            mov     eax,u32 ptr [esp+8]
            mov     ebx,ds:dragging_snap_y
            xor     edx,edx
            div     ebx
            mul     ebx
            mov     u32 ptr [esp+8],eax
            pop     ds
        }
        ret
    }




    function invDEBI_update_mouse_coordinates
    {
    // This routine is used to update the mouse coordinates
    //
    // Upon entry:   eax - change in X
    //               edx - change in Y
    //
    // Upon exit:    values are updated
    //
;; Bochs hack
;;        shl     eax,1                                               // We multiply the X-coordinate by 2 because the
;;                                                                    // monochrome display is 720x348 (x is twice as big)
;;        add     ds:mouse_current_x,eax
;;        add     ds:mouse_current_y,edx
        mov     ds:mouse_current_x,eax
        mov     ds:mouse_current_y,edx
;; Bochs hack
        if (ds:dragging_something == 0)
        {
          // Verify X
            if (ds:mouse_current_x > 7fffffffh || ds:mouse_current_x == 0)
            {
              // It's negative (it's off the left of the screen or it's at the very left of the screen)
                mov     ds:mouse_current_x,1
            
            } else if (ds:mouse_current_x > 718) {
              // It's heading off the right side of the screen
                mov     ds:mouse_current_x,718
            }

          // Verify Y
            if (ds:mouse_current_y > 7fffffffh || ds:mouse_current_y == 0)
            {
              // It's negative (it's above the top of the screen or it's at the very top of the screen)
                mov     ds:mouse_current_y,1
            
            } else if (ds:mouse_current_y > 346) {
              // It's heading off the bottom of the screen
                mov     ds:mouse_current_y,346
            }
        
        } else {
          // The mouse is only allowed to move in certain areas when something is being dragged
          // This logic is a little more complex than the above no-drag logic

          // Make sure they're not negative
            if (ds:mouse_current_x > 7fffffffh)
            {
                neg     ds:mouse_current_x
            }
            if (ds:mouse_current_y > 7fffffffh)
            {
                neg     ds:mouse_current_y
            }

          // Verify X
            push    ebx
            mov     ebx,ds:mouse_current_x
            sub     ebx,ds:dragging_offset_x
            if (carry?)
            {
              // We're less than zero
                neg     ebx
                add     ds:mouse_current_x,ebx
            
            } else {
              // We're good on the left-side.  Now, how about the right?
                mov     ebx,ds:mouse_current_x
                sub     ebx,ds:dragging_offset_x
                add     ebx,ds:dragging_width
                if (ebx > 720)
                {
                  // We're to far
                    sub     ebx,720
                    sub     ds:mouse_current_x,ebx
                }
            }

          // Verify Y
            mov     ebx,ds:mouse_current_y
            sub     ebx,ds:dragging_offset_y
            if (carry?)
            {
              // We're less than zero
                neg     ebx
                add     ds:mouse_current_y,ebx
            
            } else {
              // We're good on the top.  Now, how about the bottom?
                mov     ebx,ds:mouse_current_y
                sub     ebx,ds:dragging_offset_y
                add     ebx,ds:dragging_height
                if (ebx > 348)
                {
                  // We're to far
                    sub     ebx,348
                    sub     ds:mouse_current_y,ebx
                }
            }
            pop     ebx
        }
        ret
    }




    function iDEBI_timer_interface
    {
    // This routine is called 182 times per second from the timer handler.  It is used to determine how long objects
    // have been displayed, how long a mouse has been hovering over an object prior to display, etc.  It's very handy. :)
    //
    // Upon entry:   Nothing
    //
    // Upon exit:    Nothing
    //
        if (cs:disable_timer == 1)
        {
            retf
        }
        push    ds
        mov     ds,cs:data_segment
        inc     ds:timer_interface_count
        inc     ds:screen_saver_count
        if (ds:screen_saver_count > 18200 && ds:screen_saver == 0)
        {
          // This is 100 seconds
            //call    invDEBI_activate_screen_saver
        }

;; Bochs hack
        if (ds:screen_saver_count > 10)
        {
            mov     ds:screen_saver_count,0
            call    u48 ptr ds:_iMOUSE_bochs_DEBI_intercept
        }
;; Bochs hack


        inc     ds:cursor_count
        if (ds:force_cursor_off == 0 && ds:cursor_count > 60 && ds:screen_saver == 0)
        {
          // About every 182/60 second the cursor toggles
            invDEBI_toggle_cursor()
        }

        if (ds:draw_menu != 0)
        {
           // Draw the menu
            mov     ds:draw_menu,0
            pushad
            pushfd
            cli
            invDEBI_hide_mouse_pointer()
            invDEBI_turn_cursor_off()
            invDEBI_save_screen2()
            popfd
            popad
            invDEBI_menu_refresh()
        }

        sub     ds:mouse_immediate_count,1
        if (carry?)
        {
            push    edx
            mov     dl,ds:mouse_last_event
            invDEBI_check_immediate()
            pop     edx
        }

        sub     ds:mouse_hovering_count,1
        if (carry?)
        {
          // We've rolled over (which means our countdown has completed)
            invDEBI_check_hovering()
        }

        sub     ds:mouse_clicking_count,1
        if (carry?)
        {
          // We've rolled over (which means our countdown has completed)
            invDEBI_check_objects_click()
        }
        pop     ds
        retf
    }
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// END - 11111 - External interfaces (Timer, Mouse, Kbd)
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// 22222 - Screen related functions
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    function invDEBI_hide_mouse_pointer
    {
    // This routine is used to hide the mouse pointer
    //
    // Upon entry:   ds:mouse_current_x - current x coord
    //               ds:mouse_current_y - current y coord
    //
    // Upon exit:    The mouse pointer is hidden
    //
        if (cs:mouse_status == 1 && cs:mouse_allowed == 1)
        {
            push    ds
            pushfd
//            cli
            mov     ds,cs:data_segment
//            push    u32 ptr ds:mouse_current_x
//            sub     u32 ptr [esp],1                            // hot-spot on mouse is at 1,1
//            push    u32 ptr ds:mouse_current_y
//            sub     u32 ptr [esp],1
//            push    u32 ptr 0                                     // Hide the mouse
//            push    u32 ptr offset mouse_save_area
//            call    u48 ptr ds:_VID_g_mono_mouse_pointer
            mov     ds:mouse_status,0
            popfd
            pop     ds
        }
        ret
    }




    function invDEBI_show_mouse_pointer
    {
    // This routine is used to display the mouse pointer
    //
    // Upon entry:   ds:mouse_current_x - current x coord
    //               ds:mouse_current_y - current y coord
    //
    // Upon exit:    The mouse pointer is displayed
    //
        if (cs:mouse_status == 0 && cs:mouse_allowed == 1)
        {
            push    ds
            pushfd
//            cli
            mov     ds,cs:data_segment
//            push    u32 ptr ds:mouse_current_x
//            sub     u32 ptr [esp],1                            // hot-spot on mouse is at 1,1
//            push    u32 ptr ds:mouse_current_y
//            sub     u32 ptr [esp],1
//            push    u32 ptr 1                                     // Show the mouse
//            push    u32 ptr offset mouse_save_area
//            call    u48 ptr ds:_VID_g_mono_mouse_pointer
            mov     ds:mouse_status,1
            popfd
            pop     ds
        }
        ret
    }




    function invDEBI_activate_screen_saver
    {
    // This routine is used to activate the screen saver.  It copies the screen buffer to a save area and then clear it off
    //
    // Upon entry:   ds - DEBI's data segment
    //
    // Upon exit:    The screen is blanked and the screen_saver variable is set to 1
    //
        if (ds:screen_saver == 0)
        {
            pushfd
            cli
            pushad
            push    ds
            push    es

            mov     ds:screen_saver,1                               // Turn on screen saver indicator
            invDEBI_hide_mouse_pointer()
            invDEBI_turn_cursor_off()
            mov     ds:mouse_allowed,0                              // Indicate the mouse cannot be drawn

          // Copy the screen to the save buffer
            mov     eax,_sDEBI_screen                               // Copy from the MONO screen to the _sDEBI_screen buffer
            mov     es,ax
            xor     edi,edi
            mov     eax,_sMONO
            mov     ds,ax
            xor     esi,esi
            mov     ecx,7fffh                                       // Copy 32k
            cld
            rep     movsb
          // Clear off the screen
            mov     eax,_sMONO
            mov     es,ax
            xor     edi,edi
            mov     al,0
            mov     ecx,7fffh
            rep     stosb

            pop     es
            pop     ds
            popad
            popfd
        }
        ret
    }




    function invDEBI_save_screen2
    {
    // This routine is used to save the current screen contents to a save area during a popup dialogue, menu or other item
    //
    // Upon entry:   Nothing
    //
    // Upon exit:    The screen is saved
    //
        pushad
        push    ds
        push    es

      // Copy the screen to the save buffer
        mov     eax,_sDEBI_screen2                                  // Copy from the MONO screen to the _sDEBI_screen2 buffer
        mov     es,ax
        xor     edi,edi
        mov     eax,_sMONO
        mov     ds,ax
        xor     esi,esi
        mov     ecx,7fffh                                           // Copy 32k
        cld
        rep     movsb

        pop     es
        pop     ds
        popad
        ret
    }




    function invDEBI_restore_screen2
    {
    // This routine is used to save the current screen contents to a save area during a popup dialogue, menu or other item
    //
    // Upon entry:   Nothing
    //
    // Upon exit:    The screen is saved
    //
        pushad
        push    ds
        push    es

      // Copy the screen to the save buffer
        mov     eax,_sDEBI_screen2                                  // Copy from the _sDEBI_screen buffer to the MONO screen
        mov     ds,ax
        xor     esi,esi
        mov     eax,_sMONO
        mov     es,ax
        xor     edi,edi
        mov     ecx,7fffh                                           // Copy 32k
        cld
        rep     movsb

        pop     es
        pop     ds
        popad
        ret
    }




    function invDEBI_toggle_cursor
    {
    // This routine is used to toggle the cursor
    //
    // Upon entry:   ds - DEBI's data segment
    //
    // Upon exit:    The cursor may be updated
    //
        if (cs:force_cursor_off == 0)
        {
          // We need to toggle the cursor
            push    ds
            pushad
            pushfd
            cli
            mov     ds,cs:data_segment
            mov     eax,ds:mouse_status
            invDEBI_hide_mouse_pointer()
            push    u32 ptr ds:cursor_x
            push    u32 ptr ds:cursor_y
            if (ds:insert_mode == ON)
            {
                call    u48 ptr ds:_VID_g_mono_cursor
            
            } else {
                call    u48 ptr ds:_VID_g_mono_cursor_no_insert
            }
            not     ds:cursor
            if (eax != 0)
            {
                invDEBI_show_mouse_pointer()
            }
            mov     ds:cursor_count,0
            popfd
            popad
            pop     ds
        }
        ret
    }




    function invDEBI_turn_cursor_off
    {
    // This routine is used to toggle the cursor
    //
    // Upon entry:   ds - DEBI's data segment
    //
    // Upon exit:    The cursor may be updated
    //
        if (cs:force_cursor_off == 0 && cs:cursor != 0)
        {
          // We need to turn the cursor off
            push    ds
            push    eax
            mov     ds,cs:data_segment
            mov     eax,ds:cursor_count
            invDEBI_toggle_cursor()
            mov     ds:cursor_count,eax
            pop     eax
            pop     ds
        }
        ret
    }




    function invDEBI_turn_cursor_on
    {
    // This routine is used to toggle the cursor
    //
    // Upon entry:   ds - DEBI's data segment
    //
    // Upon exit:    The cursor may be updated
    //
        if (cs:force_cursor_off == 0 && cs:cursor == 0)
        {
          // We need to turn the cursor on
            push    ds
            push    eax
            mov     ds,cs:data_segment
            mov     eax,ds:cursor_count
            invDEBI_toggle_cursor()
            mov     ds:cursor_count,eax
            pop     eax
            pop     ds
        }
        ret
    }




    function invDEBI_cancel_screen_saver
    {
    // This routine is used to cancel a previous screen saver.  It restores the screen from the previously saved buffer
    //
    // Upon entry:   ds - DEBI's data segment
    //
    // Upon exit:    The screen is blanked and the screen_saver variable is set to 1
    //
        if (cs:screen_saver == 1)
        {
            pushfd
            pushad
            push    ds
            push    es

            cli
            mov     ds,cs:data_segment
            mov     ds:screen_saver,0                               // Turn off screen saver indicator
            mov     ds:screen_saver_count,0
            mov     ds:mouse_allowed,1                              // Indicate the mouse can once again be drawn

            mov     eax,_sDEBI_screen                               // Copy from the _sDEBI_screen buffer to the MONO screen
            mov     ds,ax
            xor     esi,esi
            mov     eax,_sMONO
            mov     es,ax
            xor     edi,edi
            mov     ecx,7fffh                                       // Copy 32k
            cld
            rep     movsb

            pop     es
            pop     ds
            popad
            popfd
        }
        ret
    }
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// END - 22222 - Screen related functions
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// 33333 - MOUSE Events
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    function invDEBI_mouse_button_activity
    {
    // This routine is used to check for objects the mouse is currently hovering over (without anything being clicked)
    //
    // Upon entry:   ds:mouse_current_x - current x coord
    //               ds:mouse_current_y - current y coord
    //            ds:mouse_last_buttons - previous button status
    //                              ebx - new button status (from mouse driver)
    //                                    * Note:  Bits 2,1,0 are set depending on button status (2-middle, 1-right, 0-left)
    //
    // Upon exit:    Some items may be deselected or selected for display
    //
        pushad
        if (ds:mouse_last_button_left == 0)
        {
          // The left mouse button was previously UP (not pressed)
            test    ebx,01b
            if (!zero?)
            {
              // The left button has changed
                inc     ds:mouse_button_left
                mov     ds:mouse_clicking_count,-1
                mov     ds:mouse_last_button_left,1
                mov     edx,ds:mouse_current_x
                mov     ds:mouse_left_click_x_start,edx
                mov     edx,ds:mouse_current_y
                mov     ds:mouse_left_click_y_start,edx
                mov     ds:mouse_hovering_count,-1
            }
        
        } else {
          // The left mouse button was previously DOWN (pressed)
            test    ebx,01b
            if (zero?)
            {
              // The left buton has changed
                test    ebx,10b
                if (zero?)
                {
                  // The other button isn't down, so we're good to go
                    mov     ds:mouse_clicking_count,30
                    mov     ds:mouse_immediate_count,_IMMEDIATE_COUNT
                    mov     ds:mouse_last_event,_LEFT_SINGLE_CLICK
                }
                mov     ds:mouse_last_button_left,0
                mov     edx,ds:mouse_current_x
                mov     ds:mouse_left_click_x_stop,edx
                mov     edx,ds:mouse_current_y
                mov     ds:mouse_left_click_y_stop,edx
                if (ds:mouse_left_dragging != 0)
                {
                    invDEBI_check_drag_stop()
                    mov     ds:mouse_left_dragging,0
                    mov     ds:mouse_button_left,0
                    mov     ds:mouse_clicking_count,-1
                }
            
            } else if (ds:mouse_left_dragging == 0) {
              // We need to check to see if the delta-x and delta-y are far enough that something is being dragged
                test    ebx,10b
                if (zero?)
                {
                  // The other button isn't down, so we're good to go
                    mov     edx,ds:mouse_current_x
                    sub     edx,ds:mouse_left_click_x_start
                    invDEBI_absolute_edx()
                    mov     eax,edx
                    mov     edx,ds:mouse_current_y
                    sub     edx,ds:mouse_left_click_y_start
                    invDEBI_absolute_edx()
                    if (edx > ds:vertical_dragging_threshold || eax > ds:horizontal_dragging_threshold)
                    {
                      // They're dragging
                        mov     ds:mouse_left_dragging,1
                        invDEBI_check_drag_start()
                    }
                }
            
            } else if (ds:mouse_left_dragging != 0) {
              // A button is down, so they're dragging something
                mov     ds:mouse_hovering_x,-1
                mov     ds:mouse_hovering_y,-1
                mov     ds:mouse_hovering_count,-1
                invDEBI_check_drag_start()
            }
        }

        if (ds:mouse_last_button_right == 0)
        {
          // The right mouse button was previously UP
            test    ebx,10b
            if (!zero?)
            {
              // The right buton has changed
                inc     ds:mouse_button_right
                mov     ds:mouse_clicking_count,-1
                mov     ds:mouse_last_button_right,1
                mov     edx,ds:mouse_current_x
                mov     ds:mouse_right_click_x_start,edx
                mov     edx,ds:mouse_current_y
                mov     ds:mouse_right_click_y_start,edx
                mov     ds:mouse_hovering_count,-1
            }
        
        } else {
          // The right mouse button was previously DOWN
            test    ebx,10b
            if (zero?)
            {
              // The right buton has changed
                test    ebx,01b
                if (zero?)
                {
                  // The other button isn't down, so we're good to go
                    mov     ds:mouse_clicking_count,30
                    mov     ds:mouse_immediate_count,_IMMEDIATE_COUNT
                    mov     ds:mouse_last_event,_RIGHT_SINGLE_CLICK
                }
                mov     ds:mouse_last_button_right,0
                mov     edx,ds:mouse_current_x
                mov     ds:mouse_right_click_x_stop,edx
                mov     edx,ds:mouse_current_y
                mov     ds:mouse_right_click_y_stop,edx
                if (ds:mouse_right_dragging != 0)
                {
                    invDEBI_check_drag_stop()
                    mov     ds:mouse_right_dragging,0
                    mov     ds:mouse_button_right,0
                    mov     ds:mouse_clicking_count,-1
                }
            
            } else if (ds:mouse_right_dragging == 0) {
              // We need to check to see if the delta-x and delta-y are far enough that something is being dragged
                test    ebx,01b
                if (zero?)
                {
                  // The other button isn't down, so we're good to go
                    mov     edx,ds:mouse_current_x
                    sub     edx,ds:mouse_right_click_x_start
                    invDEBI_absolute_edx()
                    mov     eax,edx
                    mov     edx,ds:mouse_current_y
                    sub     edx,ds:mouse_right_click_y_start
                    invDEBI_absolute_edx()
                    if (edx > ds:vertical_dragging_threshold || eax > ds:horizontal_dragging_threshold)
                    {
                      // They're dragging
                        mov     ds:mouse_right_dragging,1
                        invDEBI_check_drag_start()
                    }
                }
            
            } else if (ds:mouse_right_dragging != 0) {
              // A button is down, so they're dragging something
                mov     ds:mouse_hovering_x,-1
                mov     ds:mouse_hovering_y,-1
                mov     ds:mouse_hovering_count,-1
                invDEBI_check_drag_start()
            }
        }
        mov     ds:mouse_last_buttons,ebx

      quit:
        popad
        ret
    }




    function invDEBI_absolute_edx
    {
    // This routine is used to compute the absolute value of the value in edx
    //
    // Upon entry:   edx - value to compute absolute value
    //
    // Upon exit:    edx - abs(edx)
    //
        if (edx > 7fffffffh)
        {
          // It's negative
            neg     edx
        }
        ret
    }




    function invDEBI_check_drag_start
    {
    // This routine is used to check to see what object they're trying to drag
    //
    // Upon enry:    ds:mouse_current_x - current mouse X coordinate
    //               ds:mouse_current_y - current mouse Y coordinate
    //               ds:mouse_right_click_x_start - starting mouse X coordinate if right dragging
    //               ds:mouse_right_click_y_start - starting mouse Y coordinate if right dragging
    //               ds:mouse_left_click_x_start - starting mouse X coordinate if left dragging
    //               ds:mouse_left_click_y_start - starting mouse Y coordinate if left dragging
    //
    // Upon exit:    If dragging some object, it is currently underway
    //
        if (ds:mouse_left_dragging == 1)
        {
            inc     ds:mouse_left_dragging
            mov     ds:mouse_last_event,_LEFT_DRAG_START
            mov     dl,_LEFT_DRAG_START
            invDEBI_check_mouse_event()
        }
        if (ds:mouse_right_dragging == 1)
        {
            inc     ds:mouse_right_dragging
            mov     ds:mouse_last_event,_RIGHT_DRAG_START
            mov     dl,_RIGHT_DRAG_START
            invDEBI_check_mouse_event()
        }

        ret
    }




    function invDEBI_check_drag_stop
    {
    // This routine is called when an object being dragged is released
    //
    // Upon entry:
    //
    // Upon exit:    The object is released
    //
        if (ds:mouse_left_dragging != 0)
        {
            mov     ds:mouse_last_event,_LEFT_DRAG_STOP
            mov     dl,_LEFT_DRAG_STOP
            invDEBI_check_mouse_event()
        }
        if (ds:mouse_right_dragging != 0)
        {
            mov     ds:mouse_last_event,_RIGHT_DRAG_STOP
            mov     dl,_RIGHT_DRAG_STOP
            invDEBI_check_mouse_event()
        }
        if (ds:dragging_something != 0)
        {
          // No event was at the release point, so we just call the default handler to cancel the drag
            invDEBI_drag_stop()
        }
        mov     ds:mouse_last_event,_HOVER

        ret
    }




    function invDEBI_check_hovering
    {
    // This routine is used to check for objects the mouse is currently hovering over (without anything being clicked)
    //
    // Upon entry:   ds:mouse_hovering_x - current x coord
    //               ds:mouse_hovering_y - current y coord
    //
    // Upon exit:    The quick watch window may be updated
    //
        pushad

        if (ds:object_mode == 0)
        {
          // We're in root object mode (meaning they're the default Debi objects, not a pop-up or dialogue box)
            mov     esi,offset DEBI_screen_table_end - _ST_LENGTH
            xor     ecx,ecx
            while (ecx < 15)
            {
                if (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _YES)
                {
                    mov     edi,u32 ptr ds:[esi+_ST_OBJECT_MOUSE_OFFSET]
                    if (edi != -1)
                    {
                        while (byte ptr ds:[edi] != _END)
                        {
                            mov     al,u8 ptr ds:[edi]
                            if (al == _ABANDON_IF_NOT)
                            {
                              // We are to abandon this item if the mouse isn't within its data area
                                invDEBI_check_mouse_object_coordinate()
                                jc      next_screen_object
                            
                            } else if (al == _HOVER) {
                              // This is a hover item, we need to check the coordinates to see if it's the one!
                                invDEBI_check_mouse_object_coordinate()
                                jc      next_mouse_object1

                              // This is a match
                                mov     ebx,u32 ptr ds:[edi+_MO_FUNC]
                                pushad
                                pushfd
                                push    ds
                                push    es
                                push    fs
                                push    gs

                                ebx()

                                pop     gs
                                pop     fs
                                pop     es
                                pop     ds
                                popfd
                                popad
                                jc      quit
                            }

                          next_mouse_object1:
                            add     edi,_MO_LENGTH
                        }
                    }
                }

              next_screen_object:
                sub     esi,_ST_LENGTH
                inc     ecx
            }
        
        } else {
          // We're currently on one of the pop-up objects
            mov     edi,ds:mouse_objects
            mov     esi,ds:screen_object
            while (byte ptr ds:[edi] != _END)
            {
                mov     al,u8 ptr ds:[edi]
                if (al == _ABANDON_IF_NOT)
                {
                  // We are to abandon this item if the mouse isn't within its data area
                    invDEBI_check_mouse_object_coordinate()
                    jc      quit
                
                } else if (al == _HOVER) {
                  // This is the correct thing, we need to check the coordinates to see if it's the one!
                    invDEBI_check_mouse_object_coordinate()
                    jc      next_mouse_object2

                  // This is a match
                    mov     ebx,u32 ptr ds:[edi+_MO_FUNC]
                    pushad
                    pushfd
                    push    ds
                    push    es
                    push    fs
                    push    gs

                    ebx()

                    pop     gs
                    pop     fs
                    pop     es
                    pop     ds
                    popfd
                    popad
                    jc      quit
                }

              next_mouse_object2:
                add     edi,_MO_LENGTH
            }
        }

      quit:
        popad
        ret
    }




    function invDEBI_check_mouse_event
    {
    // This routine is used to check for objects the mouse has done something on/near
    //
    // Upon entry:   ds:mouse_current_x - current x coord
    //               ds:mouse_current_y - current y coord
    //                               dl - mouse activity to search for
    //
    // Upon exit:    The quick watch window may be updated
    //
        pushad

        if (ds:object_mode == 0)
        {
          // We're in root object mode (meaning they're the default Debi objects, not a pop-up or dialogue box)
            mov     esi,offset DEBI_screen_table_end - _ST_LENGTH
            xor     ecx,ecx
            while (ecx < 15)
            {
                if (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _YES)
                {
                    mov     edi,u32 ptr ds:[esi+_ST_OBJECT_MOUSE_OFFSET]
                    if (edi != -1)
                    {
                        while (byte ptr ds:[edi] != _END)
                        {
                            mov     al,u8 ptr ds:[edi]
                            if (al == _ABANDON_IF_NOT)
                            {
                              // We are to abandon this item if the mouse isn't within its data area
                                invDEBI_check_mouse_object_coordinate()
                                jc      next_screen_object

                            
                            } else if (al == dl || al == _ANY_CLICK) {
                              // This is the correct thing, we need to check the coordinates to see if it's the one!
                                if (dl == _LEFT_DRAG_START || dl == _RIGHT_DRAG_START)
                                {
                                    invDEBI_check_mouse_object_coordinate_drag_start()
                                
                                } else if (dl == _LEFT_DRAG_STOP || dl == _RIGHT_DRAG_STOP) {
                                    invDEBI_check_mouse_object_coordinate_drag_stop()
                                
                                } else {
                                    invDEBI_check_mouse_object_coordinate()
                                }
                                jc      next_mouse_object1

                              // This is a match
                                mov     ebx,u32 ptr ds:[edi+_MO_FUNC]
                                pushad
                                pushfd
                                push    ds
                                push    es
                                push    fs
                                push    gs

                                ebx()

                                pop     gs
                                pop     fs
                                pop     es
                                pop     ds
                                popfd
                                popad
                                jc      quit

                            
                            } else if (dl == _LEFT_SINGLE_CLICK && al == _EDIT) {
                              // This is an edit item, they might be wanting to edit something possibly?
                                invDEBI_check_mouse_object_coordinate()
                                jc      next_mouse_object1

                              // This is a match
                                invDEBI_edit_variable()
                            }

                          next_mouse_object1:
                            add     edi,_MO_LENGTH
                        }
                    }
                }

              next_screen_object:
                sub     esi,_ST_LENGTH
                inc     ecx
            }
        
        } else {
          // We're currently on one of the pop-up objects
            mov     edi,ds:mouse_objects
            mov     esi,ds:screen_object
            while (byte ptr ds:[edi] != _END)
            {
                mov     al,u8 ptr ds:[edi]
                if (al == _ABANDON_IF_NOT)
                {
                  // We are to abandon this item if the mouse isn't within its data area
                    invDEBI_check_mouse_object_coordinate()
                    jc      quit

                
                } else if (al == dl || al == _ANY_CLICK) {
                  // This is the correct thing, we need to check the coordinates to see if it's the one!
                    invDEBI_check_mouse_object_coordinate()
                    jc      next_mouse_object2                      // If branch, the mouse isn't over this item

                  // This is a match
                    mov     ebx,u32 ptr ds:[edi+_MO_FUNC]
                    pushad
                    pushfd
                    push    ds
                    push    es
                    push    fs
                    push    gs

                    ebx()

                    pop     gs
                    pop     fs
                    pop     es
                    pop     ds
                    popfd
                    popad
                    jc      quit

                
                } else if (dl == _LEFT_SINGLE_CLICK && al == _EDIT) {
                  // This is an edit item, they might be wanting to edit something possibly?
                    invDEBI_check_mouse_object_coordinate()
                    jc      next_mouse_object2

                  // This is a match
                    invDEBI_edit_variable()
                }

              next_mouse_object2:
                add     edi,_MO_LENGTH
            }
        }

      quit:
        popad
        ret
    }




    function invDEBI_check_immediate
    {
    // This routine is used to check for objects the mouse has done something on/near
    //
    // Upon entry:   ds:mouse_current_x - current x coord
    //               ds:mouse_current_y - current y coord
    //                               dl - mouse activity to search for
    //
    // Upon exit:    The quick watch window may be updated
    //
        pushad

        if (ds:object_mode == 0)
        {
          // We're in root object mode (meaning they're the default Debi objects, not a pop-up or dialogue box)
            mov     esi,offset DEBI_screen_table_end - _ST_LENGTH
            xor     ecx,ecx
            while (ecx < 15)
            {
                if (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _YES)
                {
                    mov     edi,u32 ptr ds:[esi+_ST_OBJECT_MOUSE_OFFSET]
                    if (edi != -1)
                    {
                        while (byte ptr ds:[edi] != _END)
                        {
                            mov     al,u8 ptr ds:[edi]
                            if (al == _IMMEDIATE)
                            {
                              // We know now that there are immediates, so we will setup the count for continued use
                                if (byte ptr ds:[edi+_MO_TYPE] == dl)
                                {
                                  // This is the correct thing, we need to check the coordinates to see if it's the one!
                                    invDEBI_check_mouse_object_coordinate()
                                    jc      next_mouse_object1

                                  // This is a match
                                    mov     ebx,u32 ptr ds:[edi+_MO_FUNC]
                                    pushad
                                    pushfd
                                    push    ds
                                    push    es
                                    push    fs
                                    push    gs

                                    ebx()

                                    pop     gs
                                    pop     fs
                                    pop     es
                                    pop     ds
                                    popfd
                                    popad
                                    jc      quit
                                }
                            
                            } else {
                                jmp     next_screen_object
                            }

                          next_mouse_object1:
                            add     edi,_MO_LENGTH
                        }
                    }
                }

              next_screen_object:
                sub     esi,_ST_LENGTH
                inc     ecx
            }
        
        } else {
          // We're currently on one of the pop-up objects
            mov     edi,ds:mouse_objects
            mov     esi,ds:screen_object
            while (byte ptr ds:[edi] != _END)
            {
                mov     al,u8 ptr ds:[edi]
                if (al == _IMMEDIATE)
                {
                  // We know now that there are immediates, so we will setup the count for continued use
                    if (byte ptr ds:[edi+_MO_TYPE] == dl)
                    {
                      // This is the correct thing, we need to check the coordinates to see if it's the one!
                        invDEBI_check_mouse_object_coordinate()
                        jc      next_mouse_object2

                      // This is a match
                        mov     ebx,u32 ptr ds:[edi+_MO_FUNC]
                        pushad
                        pushfd
                        push    ds
                        push    es
                        push    fs
                        push    gs

                        ebx()

                        pop     gs
                        pop     fs
                        pop     es
                        pop     ds
                        popfd
                        popad
                        jc      quit
                    }
                
                } else {
                    jmp     quit
                }

              next_mouse_object2:
                add     edi,_MO_LENGTH
            }
        }

      quit:
        popad
        ret
    }




    function invDEBI_check_mouse_object_coordinate
    {
    // This routine is used to check the current mouse coordinate against the screen object coordinate plus the mouse object
    // relative displacement
    //
    // Upon entry:   ds:[esi] - far ptr to screen object
    //               ds:[edi] - far ptr to mouse object
    //
    // Upon exit:    carry? - SET if mouse not in this object's coordinates, CLEAR if it is within
    //
        push    edx

        mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        add     edx,u32 ptr ds:[edi+_MO_X1]
        cmp     ds:mouse_current_x,edx
        jb      fail
      // We're >= the left-most X coordinate

        mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        add     edx,u32 ptr ds:[edi+_MO_X2]
        cmp     ds:mouse_current_x,edx
        ja      fail
      // We're <= the right-most X coordinate

        mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        add     edx,u32 ptr ds:[edi+_MO_Y1]
        cmp     ds:mouse_current_y,edx
        jb      fail
      // We're >= the top-most Y coordinate

        mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        add     edx,u32 ptr ds:[edi+_MO_Y2]
        cmp     ds:mouse_current_y,edx
        ja      fail
      // We're <= the bottom-most Y coordinate

      // This is it!
        clc
        jmp     quit

      fail:
        stc

      quit:
        pop     edx
        ret
    }




    function invDEBI_check_mouse_object_coordinate_drag_start
    {
    // This routine is used to check the current mouse coordinate against the starting object coordinate plus the mouse object
    // relative displacement
    //
    // Upon entry:   ds:[esi] - far ptr to screen object
    //               ds:[edi] - far ptr to mouse object
    //                     dl - drag start type
    //
    // Upon exit:    carry? - SET if mouse not in this object's coordinates, CLEAR if it is within
    //
        push    edx

        if (dl == _LEFT_DRAG_START)
        {
          // It's a left-drag start
            mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            add     edx,u32 ptr ds:[edi+_MO_X1]
            cmp     ds:mouse_left_click_x_start,edx
            jb      fail
          // We're >= the left-most X coordinate

            mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            add     edx,u32 ptr ds:[edi+_MO_X2]
            cmp     ds:mouse_left_click_x_start,edx
            ja      fail
          // We're <= the right-most X coordinate

            mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            add     edx,u32 ptr ds:[edi+_MO_Y1]
            cmp     ds:mouse_left_click_y_start,edx
            jb      fail
          // We're >= the top-most Y coordinate

            mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            add     edx,u32 ptr ds:[edi+_MO_Y2]
            cmp     ds:mouse_left_click_y_start,edx
            ja      fail
          // We're <= the bottom-most Y coordinate
        
        } else {
          // It's a right-drag start
            mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            add     edx,u32 ptr ds:[edi+_MO_X1]
            cmp     ds:mouse_right_click_x_start,edx
            jb      fail
          // We're >= the left-most X coordinate

            mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            add     edx,u32 ptr ds:[edi+_MO_X2]
            cmp     ds:mouse_right_click_x_start,edx
            ja      fail
          // We're <= the right-most X coordinate

            mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            add     edx,u32 ptr ds:[edi+_MO_Y1]
            cmp     ds:mouse_right_click_y_start,edx
            jb      fail
          // We're >= the top-most Y coordinate

            mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            add     edx,u32 ptr ds:[edi+_MO_Y2]
            cmp     ds:mouse_right_click_y_start,edx
            ja      fail
        }

      // This is it!
        clc
        jmp     quit

      fail:
        stc

      quit:
        pop     edx
        ret
    }




    function invDEBI_check_mouse_object_coordinate_drag_stop
    {
    // This routine is used to check the current mouse coordinate against the starting object coordinate plus the mouse object
    // relative displacement
    //
    // Upon entry:   ds:[esi] - far ptr to screen object
    //               ds:[edi] - far ptr to mouse object
    //                     dl - drag start type
    //
    // Upon exit:    carry? - SET if mouse not in this object's coordinates, CLEAR if it is within
    //
        push    edx

        if (dl == _LEFT_DRAG_STOP)
        {
          // It's a left-drag start
            mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            add     edx,u32 ptr ds:[edi+_MO_X1]
            cmp     ds:mouse_left_click_x_stop,edx
            jb      fail
          // We're >= the left-most X coordinate

            mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            add     edx,u32 ptr ds:[edi+_MO_X2]
            cmp     ds:mouse_left_click_x_stop,edx
            ja      fail
          // We're <= the right-most X coordinate

            mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            add     edx,u32 ptr ds:[edi+_MO_Y1]
            cmp     ds:mouse_left_click_y_stop,edx
            jb      fail
          // We're >= the top-most Y coordinate

            mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            add     edx,u32 ptr ds:[edi+_MO_Y2]
            cmp     ds:mouse_left_click_y_stop,edx
            ja      fail
          // We're <= the bottom-most Y coordinate
        
        } else {
          // It's a right-drag start
            mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            add     edx,u32 ptr ds:[edi+_MO_X1]
            cmp     ds:mouse_right_click_x_stop,edx
            jb      fail
          // We're >= the left-most X coordinate

            mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            add     edx,u32 ptr ds:[edi+_MO_X2]
            cmp     ds:mouse_right_click_x_stop,edx
            ja      fail
          // We're <= the right-most X coordinate

            mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            add     edx,u32 ptr ds:[edi+_MO_Y1]
            cmp     ds:mouse_right_click_y_stop,edx
            jb      fail
          // We're >= the top-most Y coordinate

            mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            add     edx,u32 ptr ds:[edi+_MO_Y2]
            cmp     ds:mouse_right_click_y_stop,edx
            ja      fail
        }

      // This is it!
        clc
        jmp     quit

      fail:
        stc

      quit:
        pop     edx
        ret
    }




    function invDEBI_check_objects_click
    {
    // This routine is used to check for objects the mouse is currently hovering over (without anything being clicked)
    //
    // Upon entry:   ds:mouse_hovering_x - current x coord
    //               ds:mouse_hovering_y - current y coord
    //
    // Upon exit:    Some items may be deselected or selected for display
    //
        pushad

      // See what the left button has done
        mov     ds:mouse_left_click,0
        if (ds:mouse_button_left == 1)
        {
          // Single click
            mov     ds:mouse_left_click,1
        
        } else if (ds:mouse_button_left == 2) {
          // Double-click
            mov     ds:mouse_left_click,2
        }
        mov     ds:mouse_button_left,0

      // See what the right button has done
        mov     ds:mouse_right_click,0
        if (ds:mouse_button_right == 1)
        {
          // Single click
            mov     ds:mouse_right_click,1
        
        } else if (ds:mouse_button_right == 2) {
          // Double-click
            mov     ds:mouse_right_click,2
        }
        mov     ds:mouse_button_right,0

      // If no activity, quit
        if (ds:mouse_left_click == 0 && ds:mouse_right_click == 0)
        {
            jmp     quit
        }

      // See if it was a both-button action
        mov     edx,ds:mouse_left_click
        if (ds:mouse_right_click == edx)
        {
          // Both buttons were pressed the same number of times
            if (edx == 1)
            {
              // It's a both_single_click
                mov     ds:mouse_both_click,1
            
            } else {
              // It's a both_double_click
                mov     ds:mouse_both_click,2
            }
            mov     ds:mouse_left_click,0
            mov     ds:mouse_right_click,0
        }

      // Now, call the invDEBI_check_mouse_event with the appropriate activity to search for
        if (ds:mouse_both_click != 0)
        {
            if (ds:mouse_both_click == 1)
            {
                mov     dl,_BOTH_SINGLE_CLICK
            
            } else {
                mov     dl,_BOTH_DOUBLE_CLICK
            }
            invDEBI_check_mouse_event()
        }

        if (ds:mouse_left_click != 0)
        {
            if (ds:mouse_left_click == 1)
            {
                mov     dl,_LEFT_SINGLE_CLICK
            
            } else {
                mov     dl,_LEFT_DOUBLE_CLICK
            }
            invDEBI_check_mouse_event()
        }

        if (ds:mouse_right_click != 0)
        {
            if (ds:mouse_right_click == 1)
            {
                mov     dl,_RIGHT_SINGLE_CLICK
            
            } else {
                mov     dl,_RIGHT_DOUBLE_CLICK
            }
            invDEBI_check_mouse_event()
        }

      // Now, reset the mouse variables
        mov     ds:mouse_left_click,0
        mov     ds:mouse_right_click,0
      quit:
        mov     ds:mouse_both_click,0
        mov     ds:mouse_last_event,_HOVER

        popad
        ret
    }
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// END - 33333 - MOUSE Events
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// 44444 - MENU system
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    function invDEBI_menu
    {
    // This function is called when a menu needs to be displayed
    //
    // Upon entry:   ds:[esi] - far ptr to the screen object
    //               ds:[edi] - far ptr to the mouse object
    //               ds:[ebx] - far ptr to the start of the menu objects
    //
    // Upon exit:    The menu is displayed and internal variables are setup for mouse menu processing
    //
        enter   40,0
        pushad
        pushfd
        push    es
      // [ebp-04] - [ebx]
      // [ebp-08] - [edi]
      // [ebp-12] - [esi]
      // [ebp-16] - widest item
      // [ebp-20] - number of items
      // [ebp-24] - Y distance
      // [ebp-28] - temp storage
      // [ebp-32] - temp storage
      // [ebp-36] - build mouse listing Y
      // [ebp-40] - Maximum size of menu area
        mov     u32 ptr [ebp-04],ebx
        mov     u32 ptr [ebp-08],edi
        mov     u32 ptr [ebp-12],esi
        mov     u32 ptr [ebp-16],0
        mov     u32 ptr [ebp-20],0
        mov     u32 ptr [ebp-24],16                            // For top and bottom parts
        mov     u32 ptr [ebp-32],0
        mov     es,ds:data_segment
        mov     ds:menu_restore_screen_after,_YES


       // Perform a preliminary pass to determine the longest menu items
        mov     esi,ebx
        while (byte ptr ds:[esi] != _END)
        {
            mov     al,u8 ptr ds:[esi]
            if (al == _MENU_ITEM)
            {
              // Find out how long this item is
                movzx   ecx,u8 ptr ds:[esi+1]
                if (ecx > u32 ptr [ebp-16])
                {
                    mov     u32 ptr [ebp-16],ecx
                }
                add     esi,ecx
                add     esi,2
                inc     u32 ptr [ebp-20]
                add     u32 ptr [ebp-24],8
            
            } else if (al == _MENU_ITEM_EVENT) {
                add     esi,6
            
            } else if (al == _MENU_BAR) {
                inc     esi
            
            } else {
              // unknown option, we can't process this menu
                jmp     quit
            }
        }
      // Right now, [ebp-16] - widest item
      //            [ebp-20] - number of items
        add     u32 ptr [ebp-16],2
        mov     ecx,u32 ptr [ebp-16]
        if (ecx == 0 || ecx > 74 || u32 ptr [ebp-20] > 60)
        {
            jmp     quit
        }


       // Initialize our menu area
        mov     edi,offset menu_area
        mov     ecx,sizeof menu_area / 4
        cld
        mov     eax,-1
        rep     stosd

       // Initialize our mouse object area
        mov     edi,offset menu_mouse_objects
        mov     ecx,sizeof menu_mouse_objects / 4
        cld
        mov     eax,-1
        rep     stosd


       // Initialize the top line
        mov     edi,offset menu_area
        mov     u32 ptr [ebp-40],edi
        add     u32 ptr [ebp-40],sizeof menu_area
        mov     ecx,u32 ptr [ebp-16]
        mov     al,'ô'
        stosb
        mov     al,'+'                                              // UL corner char
        stosb
        mov     al,'ô'
        stosb
        mov     al,'-'                                              // top char
        rep     stosb
        mov     al,'ô'
        stosb
        mov     al,'+'                                              // UR corner
        stosb
        xor     al,al
        stosb


       // Build the menu text and mouse objects
        mov     esi,u32 ptr [ebp-04]
        xor     edx,edx
        mov     ebx,offset menu_mouse_objects + _ST_LENGTH + _MO_LENGTH
        mov     u32 ptr [ebp-36],0
        while (byte ptr ds:[esi] != _END && edi < u32 ptr [ebp-40])
        {
            mov     al,u8 ptr ds:[esi]
            if (al == _MENU_ITEM)
            {
                add     u32 ptr [ebp-36],FONT_Y
                mov     u32 ptr [ebp-28],edi
                mov     ecx,u32 ptr [ebp-16]
                mov     al,'ô'
                stosb
                mov     al,'|'                                      // left side char
                stosb
                mov     al,'ô'
                stosb
                mov     al,' '
                rep     stosb
                mov     al,'ô'
                stosb
                mov     al,'|'                                      // right side char
                stosb
                xor     al,al
                stosb

                mov     edi,u32 ptr [ebp-28]
                add     edi,4
                movzx   ecx,u8 ptr ds:[esi+1]
                add     esi,2
                rep     movsb

                mov     edi,u32 ptr [ebp-28]
                add     edi,u32 ptr [ebp-16]
                add     edi,6                                       // move past all the extra characters
            
            } else if (al == _MENU_ITEM_EVENT) {
              // Build the activity for this item
                invDEBI_menu_write_common_header()
                mov     al,u8 ptr ds:[esi+1]
                mov     u8 ptr ds:[ebx+_MO_OBJECT_TYPE],al
                mov     eax,u32 ptr ds:[esi+2]
                mov     u32 ptr ds:[ebx+_MO_FUNC],eax

                add     ebx,_MO_LENGTH
                add     esi,6
            
            } else if (al == _MENU_BAR) {
                add     u32 ptr [ebp-36],FONT_Y
                mov     u32 ptr [ebp-28],edi
                mov     ecx,u32 ptr [ebp-16]
                mov     al,'ô'
                stosb
                mov     al,'|'                                      // left side char
                stosb
                mov     al,'ô'
                stosb
                mov     al,'-'
                rep     stosb
                mov     al,'ô'
                stosb
                mov     al,'|'                                      // right side char
                stosb
                xor     al,al
                stosb

                mov     edi,u32 ptr [ebp-28]
                add     edi,u32 ptr [ebp-16]
                add     edi,6                                       // move past all the extra characters
                inc     esi                                         // move past the _MENU_BAR character
            
            } else {
              // unknown option, we can't process this menu
                jmp     quit
            }
            inc     edx
        }
      // Note, this space is reserved for a final entry that will terminate the menu if they click anywhere on the screen
        mov     u32 ptr [ebp-28],ebx
        add     ebx,_MO_LENGTH
        mov     u8 ptr ds:[ebx],_END


       // Initialize the bottom line
        mov     ecx,u32 ptr [ebp-16]
        mov     al,'ô'
        stosb
        mov     al,'+'                                              // bottom left char
        stosb
        mov     al,'ô'
        stosb
        mov     al,'-'                                              // bottom char
        rep     stosb
        mov     al,'ô'
        stosb
        mov     al,'+'                                              // bottom right char
        stosb
        xor     al,al
        stosb
       // Terminate the window
        not     al
        stosb


       // Determine the maximum height and width of the window (in pixels)
        add     u32 ptr [ebp-16],2                             // for border characters
        mov     eax,u32 ptr [ebp-16]
        mov     ebx,FONT_X
        mul     ebx
        mov     u32 ptr [ebp-16],eax                           // width - multiply by FONT_X
        add     u32 ptr [ebp-20],2                             // for top and bottom
        mov     eax,u32 ptr [ebp-20]
        mov     ebx,FONT_Y
        mul     ebx
        mov     u32 ptr [ebp-20],eax                           // height - multiply by FONT_Y

       // Right now, [ebp-32] - free

       // Determine the position of the menu
        mov     edx,u32 ptr [ebp-16]
        mov     u32 ptr [ebp-32],edx                           // Save for below
        mov     edx,ds:mouse_current_x
        add     edx,u32 ptr [ebp-16]
        if (edx < 720)
        {
            mov     ebx,ds:mouse_current_x
        
        } else {
            mov     ebx,720
            sub     ebx,u32 ptr [ebp-16]
        }
      // Now, see if we can position the menu 1/2 way left from the current mouse coordinate
        shr     u32 ptr [ebp-16],1
        mov     ecx,ds:mouse_current_x
        sub     ecx,u32 ptr [ebp-16]
        if (carry?)
        {
            xor     ebx,ebx
        
        } else {
            sub     ebx,u32 ptr [ebp-16]
        }

        mov     edx,ds:mouse_current_y
        add     edx,u32 ptr [ebp-36]
        add     edx,FONT_Y * 2
        if (edx < 348)
        {
            mov     eax,ds:mouse_current_y
        
        } else {
            mov     eax,348
            sub     eax,u32 ptr [ebp-36]
            sub     eax,FONT_Y * 2
            jmp     skip_height_adjustment
        }
      // Now, see if we can position the menu 1/2 way up from the current mouse coordinate
        shr     u32 ptr [ebp-20],1
        mov     ecx,ds:mouse_current_y
        sub     ecx,u32 ptr [ebp-20]
        if (carry?)
        {
            xor     eax,eax
        
        } else {
          // we can
            sub     eax,u32 ptr [ebp-20]
        }

      skip_height_adjustment:
      // Right now, eax - vertical
      //            ebx - horizontal
        mov     edx,offset menu_mouse_objects
        mov     byte  ptr ds:[edx+_ST_OBJECT_ALTERABLE],0
        mov     u32 ptr ds:[edx+_ST_OBJECT_UL_HORIZONTAL],ebx
        mov     u32 ptr ds:[edx+_ST_OBJECT_UL_VERTICAL],eax
        mov     ecx,u32 ptr [ebp-32]
        mov     u32 ptr ds:[edx+_ST_OBJECT_WIDTH],ecx
        mov     ecx,u32 ptr [ebp-36]
        add     ecx,FONT_Y * 2                                      // for top and bottom bars around menu
        mov     u32 ptr ds:[edx+_ST_OBJECT_HEIGHT],ecx
        mov     u32 ptr ds:[edx+_ST_OBJECT_MOUSE_OFFSET],offset menu_mouse_objects + _ST_LENGTH
        mov     u32 ptr ds:[edx+_ST_OBJECT_SCREEN_OFFSET],offset menu_area
        mov     ds:draw_menu,1
        inc     ds:menu_queue
        mov     ds:last_menu_item,0ffh

       // Now, add the _ANY_CLICK option that will work outside the range of the mouse window
       // This will call the invDEBI_menu_cancel algorithm if they click anywhere outside the menu
       // And finally, build the mouse-movement activity for this item
        mov     edx,u32 ptr [ebp-28]
        mov     ecx,offset menu_mouse_objects + _ST_LENGTH
      // Right now, edx - far ptr to _ANY_CLICK item
      //            ecx - far ptr to _IMMEDIATE/_HOVER item
        mov     u8 ptr ds:[edx+_MO_OBJECT_TYPE],_ANY_CLICK
        neg     eax
        neg     ebx
        mov     u32 ptr ds:[edx+_MO_X1],ebx
        mov     u32 ptr ds:[edx+_MO_Y1],eax
        mov     u32 ptr ds:[ecx+_MO_X1],ebx
        mov     u32 ptr ds:[ecx+_MO_Y1],eax

        add     ebx,720
        add     eax,348
        mov     u32 ptr ds:[edx+_MO_X2],ebx
        mov     u32 ptr ds:[edx+_MO_Y2],eax
        mov     u32 ptr ds:[edx+_MO_FUNC],offset invDEBI_menu_cancel

        mov     u32 ptr ds:[ecx+_MO_X2],ebx
        mov     u32 ptr ds:[ecx+_MO_Y2],eax
        mov     byte  ptr ds:[ecx+_MO_OBJECT_TYPE],_IMMEDIATE
        mov     u32 ptr ds:[ecx+_MO_FUNC],offset invDEBI_menu_change
        mov     byte  ptr ds:[ecx+_MO_TYPE],_HOVER

      quit:
        pop     es
        popfd
        popad
        leave
        ret
    }




    function invDEBI_menu_write_common_header
    {
    // This routine writes common information for the mouse object headers
        mov     u32 ptr ds:[ebx+_MO_X1],FONT_X
        mov     eax,u32 ptr [ebp-36]
        mov     u32 ptr ds:[ebx+_MO_Y1],eax
        add     eax,FONT_Y - 1
        mov     u32 ptr ds:[ebx+_MO_Y2],eax

        push    ebx
        push    edx
        mov     eax,u32 ptr [ebp-16]
        mov     ebx,FONT_X
        mul     ebx
        pop     edx
        pop     ebx
        add     eax,FONT_X - 1                                      // To encompass all of the last character)
        mov     u32 ptr ds:[ebx+_MO_X2],eax
        ret
    }




    function invDEBI_menu_cancel
    {
    // This routine is called from the menu itself when the user clicks anywhere except on one of the options
    //
    // Upon entry:   ds:[esi] - far ptr to screen objects
    //               ds:[edi] - far ptr to this mouse object
    //
    // Upon exit:    The menu is cancelled and the screen is restored
    //
        if (ds:menu_queue != 0)
        {
            dec     ds:menu_queue
            mov     ds:object_mode,0
            if (ds:menu_restore_screen_after == _YES)
            {
                pushad
                pushfd
                cli
                invDEBI_hide_mouse_pointer()
                invDEBI_turn_cursor_off()
                invDEBI_restore_screen2()
                popfd
                popad
            }
        }
        ret
    }




    function invDEBI_menu_change
    {
    // This routine is called repeatedly whenever a mouse moves over a menu.  It constantly updates the menu item that's being
    // selected based on the location of the mouse pointer
    //
    // Upon entry:   ds:[esi] - far ptr to screen objects
    //               ds:[edi] - far ptr to this mouse object
    //               ds:mouse_current_x - X coordinate for mouse
    //               ds:mouse_current_y - Y coordinate for mouse
    //
    // Upon entry:   If the mouse has moved away from the previously displayed item in the menu then the menu is updated
    //               Otherwise, nothing happens
    //
        if (ds:menu_queue != 0)
        {
          // See which item needs to be updated
            pushad
            mov     ebx,ds:mouse_current_x
            mov     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            if (ebx < eax)
            {
                mov     al,0ffh
                jmp     continue_updating_menu
            }
          // We might be on the menu, we could be past the right-side
            add     eax,u32 ptr ds:[esi+_ST_OBJECT_WIDTH]
            if (ebx > eax)
            {
              // We are not on the menu
                mov     al,0ffh
                jmp     continue_updating_menu
            }
          // We are horizontally on the menu
          // See if we're vertically on the menu
            mov     eax,ds:mouse_current_y
            mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            if (eax < edx)
            {
              // We're above the menu
                mov     al,0ffh
                jmp     continue_updating_menu
            }
            add     edx,u32 ptr ds:[esi+_ST_OBJECT_HEIGHT]
            if (eax > edx)
            {
              // We're below the menu
                mov     al,0ffh
                jmp     continue_updating_menu
            }

           // Ok, we know for a fact that the mouse poniter is somewhere on the menu
            mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            sub     eax,edx
            mov     edx,u32 ptr ds:[esi+_ST_OBJECT_HEIGHT]
            sub     edx,FONT_Y
            if (eax >= edx && eax <= ds:[esi+_ST_OBJECT_HEIGHT])
            {
              // It's on the bottom-most line (which is actually the border)
                mov     al,0ffh
                jmp     continue_updating_menu
            }
            mov     ebx,FONT_Y
            xor     edx,edx
            div     ebx
            if (al == 0)
            {
              // It's on the top most line (which is actually the border)
                mov     al,0ffh
                jmp     continue_updating_menu
            }

          continue_updating_menu:
            if (al != ds:last_menu_item)
            {
               // Right now, eax - contains the item number we're on
                mov     ds:last_menu_item,al
                xor     ecx,ecx
                mov     esi,u32 ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]
                while (byte ptr ds:[esi] != 255)
                {
                    xor     edx,edx
                    while (byte ptr ds:[esi] != 0)
                    {
                        mov     bl,u8 ptr ds:[esi]
                        if (bl == 'ô' || bl == 'õ')
                        {
                            if (edx == 1)
                            {
                                if (eax == ecx && u8 ptr ds:[esi+1] != '-')
                                {
                                  // This is the one they're on (and it's not a menu bar)
                                    mov     u8 ptr ds:[esi],'õ'
                                
                                } else {
                                  // They're not on this one
                                    mov     u8 ptr ds:[esi],'ô'
                                }
                            }
                            inc     edx
                        }
                        inc     esi
                    }
                    inc     ecx
                    inc     esi
                }

               // Right now, the menu has been updated
                invDEBI_menu_refresh()
            }

            popad
        }
        ret
    }




    function invDEBI_menu_refresh
    {
    // This routine is used to refresh the menu
    //
    // Upon entry:   Nothing
    //
    // Upon exit:    The menu is drawn on the screen
    //
        if (ds:draw_menu == 0)
        {
            pushad
            pushfd
            mov     edi,offset menu_area
            mov     esi,offset menu_mouse_objects
            mov     ebx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            mov     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            cli
            invDEBI_hide_mouse_pointer()
            invDEBI_turn_cursor_off()
            invDEBI_draw_window()
            invDEBI_show_mouse_pointer()
            mov     ds:object_mode,1
            mov     ds:mouse_objects,offset menu_mouse_objects + _ST_LENGTH
            mov     ds:screen_object,offset menu_mouse_objects
            mov     ds:draw_menu,0
            mov     ds:mouse_immediate_count,0                      // This will force it to fire immediately (because 0-1 = carry?)
            popfd
            popad
        }
        ret
    }
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// END - 44444 - MENU system
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// 55555 - MENUs for screen objects
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// Upon entry:   ds:[esi] - far ptr to this object's screen table entry
//               es:[edi] - far ptr to this object's mouse object information
//
    function invDEBI_general_menu
    {
        mov     ds:general_menu_esi,esi
        mov     ds:general_menu_edi,edi
        mov     ebx,offset DEBI_general_menu
        invDEBI_menu()
        ret
    }




    function invDEBI_cfsca_menu
    {
        mov     ebx,offset DEBI_cfsca_menu
        invDEBI_menu()
        ret
    }




    function invDEBI_fpu_menu
    {
    // This routine is called when a right-click is recognized on one of the stx fields
    //
    // Upon entry:   ds:[esi] - far ptr to screen object
    //               ds:[edi] - far ptr to mouse object
    //               ds:mouse_right_click_x_start - X coord where right-click happened
    //               ds:mouse_right_click_y_start - Y coord
    //
    // Upon exit:    The FPU menu is displayed, temporary variables are stored
    //
        mov     ds:fpu_esi,esi
        mov     ds:fpu_edi,edi
        mov     eax,ds:mouse_right_click_x_start
        mov     ds:fpu_x,eax
        mov     eax,ds:mouse_right_click_y_start
        mov     ds:fpu_y,eax
        mov     ebx,offset DEBI_fpu_menu
        invDEBI_menu()
        ret
    }




    function invDEBI_mmx_menu
    {
    // This routine is called when a right-click is recognized on one of the stx fields
    //
    // Upon entry:   ds:[esi] - far ptr to screen object
    //               ds:[edi] - far ptr to mouse object
    //               ds:mouse_right_click_x_start - X coord where right-click happened
    //               ds:mouse_right_click_y_start - Y coord
    //
    // Upon exit:    The FPU menu is displayed, temporary variables are stored
    //
        mov     ds:fpu_esi,esi
        mov     ds:fpu_edi,edi
        mov     eax,ds:mouse_right_click_x_start
        mov     ds:fpu_x,eax
        mov     eax,ds:mouse_right_click_y_start
        mov     ds:fpu_y,eax
        invDEBI_determine_mmx_variable()
        mov     ds:fpu_data,edx
        if (edx != -1)
        {
            mov     ebx,offset DEBI_mmx_menu
            invDEBI_menu()
        }
        ret
    }
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// END - 55555 - MENUs for screen objects
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// 66666 - Actions taken when various menu items are selected
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    function invDEBI_fpu_finit
    {
        invDEBI_menu_cancel()
        finit
        fsave   [ebp-200]
        invDEBI_FPU_update_display()
    }




    function invDEBI_FPU_update_display
    {
        push    ebx

      // These are all FPU windows
        mov     ebx,offset DEBI_e_screen_objects
        invDEBI_update_all_windows_of_type()
        mov     ebx,offset DEBI_f_screen_objects
        invDEBI_update_all_windows_of_type()
        mov     ebx,offset DEBI_q_screen_objects
        invDEBI_update_all_windows_of_type()
        mov     ebx,offset DEBI_r_screen_objects
        invDEBI_update_all_windows_of_type()

      // This is an MMX window (but it is also affected)
        mov     ebx,offset DEBI_s_screen_objects
        invDEBI_update_all_windows_of_type()

        pop     ebx
        ret
    }




    function invDEBI_update_all_windows_of_type
    {
    // This routine is used to update all windows of a particular flavor
    //
    // Upon entry:   ebx - offset of screen_objects variable (such as DEBI_a_screen_objects:) to update
    //
    // Upon exit:    Those window(s) are updated (if any)
    //
        pushad
        pushfd

      // Remove any impediments to this process
        cli
        invDEBI_hide_mouse_pointer()
        invDEBI_turn_cursor_off()

      // And execute the process
        mov     esi,offset DEBI_screen_table
        xor     ecx,ecx
        while (ecx < 15)
        {
            if (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _YES)
            {
                mov     edi,u32 ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]     // Get the offset to the objects
              // Right now, ds:[esi] - pointer to this screen table structure
              //            ds:[edi] - pointer to this item's objects
              // Now, parse the objects and act accordingly
                if (edi == ebx)
                {
                    pushad
                    invDEBI_draw_objects()
                    popad
                }
            }

            add     esi,_ST_LENGTH
            inc     ecx
        }

        popfd
        popad
        ret
    }




    function invDEBI_fpu_force_0
    {
        invDEBI_menu_cancel()
        finit
        fldz
        jmp     invDEBI_stx_store_st0
    }




    function invDEBI_fpu_force_1
    {
        invDEBI_menu_cancel()
        finit
        fld1
        jmp     invDEBI_stx_store_st0
    }




    function invDEBI_fpu_force_10
    {
        invDEBI_menu_cancel()
        finit
        push    u32 ptr 10
        fild    u32 ptr [esp]
        add     esp,4
        jmp     invDEBI_stx_store_st0
    }




    function invDEBI_fpu_force_pi
    {
        invDEBI_menu_cancel()
        finit
        fldpi
        jmp     invDEBI_stx_store_st0
    }




    function invDEBI_stx_store_st0
    {
    // This routine is used to store the current value in st0 to the location specified when they right-clicked
    //
    // Upon entry:   ds:[fpu_esi] - far ptr to screen object
    //               ds:[fpu_edi] - far ptr to mouse object
    //                   ds:fpu_x - X coordinate where mouse was clicked
    //                   ds:fpu_y - Y coordinate where mouse was clicked
    //                        st0 - value to store there
    //
    // Upon exit:    The particular stx value right-clicked on is updated
    //
        pushad
        invDEBI_fpu_get_stx_offset_in_ebx()
        fstp    tbyte ptr [ebp+ebx]
        invDEBI_FPU_update_display()
        popad
        ret
    }




    function invDEBI_fpu_swap_sign
    {
        invDEBI_menu_cancel()
        pushad
        invDEBI_fpu_get_stx_offset_in_ebx()
        finit
        fld     tbyte ptr [ebp+ebx]
        fchs
        fstp    tbyte ptr [ebp+ebx]
        invDEBI_FPU_update_display()
        popad
        ret
    }




    function invDEBI_fpu_fld_0
    {
        invDEBI_menu_cancel()
        frstor  [ebp-200]
        fldz
        fsave   [ebp-200]
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_fpu_fld_1
    {
        invDEBI_menu_cancel()
        frstor  [ebp-200]
        fld1
        fsave   [ebp-200]
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_fpu_fld_10
    {
        invDEBI_menu_cancel()
        frstor  [ebp-200]
        push    u32 ptr 10
        fild    u32 ptr [esp]
        add     esp,4
        fsave   [ebp-200]
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_fpu_fld_pi
    {
        invDEBI_menu_cancel()
        frstor  [ebp-200]
        fldpi
        fsave   [ebp-200]
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_fpu_ffree
    {
        invDEBI_menu_cancel()
        frstor  [ebp-200]
        fistp   ds:trash_dword
        fsave   [ebp-200]
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_fpu_fmulp
    {
        invDEBI_menu_cancel()
        frstor  [ebp-200]
        fmulp   st(1),st(0)
        fsave   [ebp-200]
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_fpu_fdivp
    {
        invDEBI_menu_cancel()
        frstor  [ebp-200]
        fdivp   st(1),st(0)
        fsave   [ebp-200]
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_fpu_fdivrp
    {
        invDEBI_menu_cancel()
        frstor  [ebp-200]
        fdivrp  st(1),st(0)
        fsave   [ebp-200]
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_fpu_save
    {
        invDEBI_menu_cancel()
        frstor  [ebp-200]
        fsave   ds:FPU_fsave_scratch
        ret
    }




    function invDEBI_fpu_restore
    {
        invDEBI_menu_cancel()
        frstor  ds:FPU_fsave_scratch
        fsave   [ebp-200]
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_fpu_get_stx_offset_in_ebx
    {
        push    edi
        push    esi
        push    edx
        push    eax

        mov     esi,ds:fpu_esi
        mov     edi,ds:fpu_edi
        mov     eax,ds:fpu_y
        sub     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        sub     eax,u32 ptr ds:[edi+_MO_Y1]
        xor     edx,edx
        mov     ebx,FONT_Y
        div     ebx
      // Find out which slot to store it in
        if (al == 0)
        {
          // st7
            mov     ebx,-200+98
        
        } else if (al == 1) {
          // st6
            mov     ebx,-200+88
        
        } else if (al == 2) {
          // st5
            mov     ebx,-200+78
        
        } else if (al == 3) {
          // st4
            mov     ebx,-200+68
        
        } else if (al == 4) {
          // st3
            mov     ebx,-200+58
        
        } else if (al == 5) {
          // st2
            mov     ebx,-200+48
        
        } else if (al == 6) {
          // st1
            mov     ebx,-200+38
        
        } else {
          // st0
            mov     ebx,-200+28
        }

        pop     eax
        pop     edx
        pop     esi
        pop     edi
        ret
    }




    function invDEBI_mmx_emms
    {
        invDEBI_menu_cancel()
        u8  0fh, 77h    // emms
        finit
        fsave   [ebp-200]
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_mmx_emms_zero
    {
        invDEBI_menu_cancel()
        u8  0fh, 77h    // emms
        finit
        fsave   [ebp-200]
        finit
        fldz
        fistp   u64 ptr [ebp-200+28]
        fldz
        fistp   u64 ptr [ebp-200+38]
        fldz
        fistp   u64 ptr [ebp-200+48]
        fldz
        fistp   u64 ptr [ebp-200+58]
        fldz
        fistp   u64 ptr [ebp-200+68]
        fldz
        fistp   u64 ptr [ebp-200+78]
        fldz
        fistp   u64 ptr [ebp-200+88]
        fldz
        fistp   u64 ptr [ebp-200+98]
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_mmx_pnot
    {
        invDEBI_menu_cancel()
        mov     edx,ds:fpu_data
        not     u32 ptr [ebp+edx+4]
        not     u32 ptr [ebp+edx+0]
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_mmx_pror_mmx_32
    {
        invDEBI_menu_cancel()
        mov     edx,ds:fpu_data
        mov     eax,u32 ptr [ebp+edx]
        mov     ebx,u32 ptr [ebp+edx+4]
        mov     u32 ptr [ebp+edx+4],eax
        mov     u32 ptr [ebp+edx],ebx
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_mmx_pror_mmx_16
    {
        invDEBI_menu_cancel()
        mov     edx,ds:fpu_data
        mov     ax,u16 ptr [ebp+edx]

        mov     bx,u16 ptr [ebp+edx+2]
        mov     u16 ptr [ebp+edx],bx

        mov     bx,u16 ptr [ebp+edx+4]
        mov     u16 ptr [ebp+edx+2],bx

        mov     bx,u16 ptr [ebp+edx+6]
        mov     u16 ptr [ebp+edx+4],bx

        mov     u16 ptr [ebp+edx+6],ax
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_mmx_pror_mmx_8
    {
        invDEBI_menu_cancel()
        mov     edx,ds:fpu_data
        mov     al,u8 ptr [ebp+edx]
        mov     bl,u8 ptr [ebp+edx+1]
        mov     u8 ptr [ebp+edx],bl

        mov     bl,u8 ptr [ebp+edx+2]
        mov     u8 ptr [ebp+edx+1],bl

        mov     bl,u8 ptr [ebp+edx+3]
        mov     u8 ptr [ebp+edx+2],bl

        mov     bl,u8 ptr [ebp+edx+4]
        mov     u8 ptr [ebp+edx+3],bl

        mov     bl,u8 ptr [ebp+edx+5]
        mov     u8 ptr [ebp+edx+4],bl

        mov     bl,u8 ptr [ebp+edx+6]
        mov     u8 ptr [ebp+edx+5],bl

        mov     bl,u8 ptr [ebp+edx+7]
        mov     u8 ptr [ebp+edx+6],bl

        mov     u8 ptr [ebp+edx+7],al
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_mmx_pror_mmx_1
    {
        invDEBI_menu_cancel()
        mov     edx,ds:fpu_data
        mov     eax,u32 ptr [ebp+edx+0]
        shr     eax,1
        rcr     u32 ptr [ebp+edx+4],1
        rcr     u32 ptr [ebp+edx+0],1
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_mmx_pshr_mmx_1
    {
        invDEBI_menu_cancel()
        mov     edx,ds:fpu_data
        shr     u32 ptr [ebp+edx+4],1
        rcr     u32 ptr [ebp+edx+0],1
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_mmx_prol_mmx_16
    {
        invDEBI_menu_cancel()
        mov     edx,ds:fpu_data
        mov     ax,u16 ptr [ebp+edx+6]

        mov     bx,u16 ptr [ebp+edx+4]
        mov     u16 ptr [ebp+edx+6],bx

        mov     bx,u16 ptr [ebp+edx+2]
        mov     u16 ptr [ebp+edx+4],bx

        mov     bx,u16 ptr [ebp+edx+0]
        mov     u16 ptr [ebp+edx+2],bx

        mov     u16 ptr [ebp+edx+0],ax
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_mmx_prol_mmx_8
    {
        invDEBI_menu_cancel()
        mov     edx,ds:fpu_data
        mov     al,u8 ptr [ebp+edx+7]
        mov     bl,u8 ptr [ebp+edx+6]
        mov     u8 ptr [ebp+edx+7],bl

        mov     bl,u8 ptr [ebp+edx+5]
        mov     u8 ptr [ebp+edx+6],bl

        mov     bl,u8 ptr [ebp+edx+4]
        mov     u8 ptr [ebp+edx+5],bl

        mov     bl,u8 ptr [ebp+edx+3]
        mov     u8 ptr [ebp+edx+4],bl

        mov     bl,u8 ptr [ebp+edx+2]
        mov     u8 ptr [ebp+edx+3],bl

        mov     bl,u8 ptr [ebp+edx+1]
        mov     u8 ptr [ebp+edx+2],bl

        mov     bl,u8 ptr [ebp+edx+0]
        mov     u8 ptr [ebp+edx+1],bl

        mov     u8 ptr [ebp+edx+0],al
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_mmx_prol_mmx_1
    {
        invDEBI_menu_cancel()
        mov     edx,ds:fpu_data
        mov     eax,u32 ptr [ebp+edx+4]
        shl     eax,1
        rcl     u32 ptr [ebp+edx+0],1
        rcl     u32 ptr [ebp+edx+4],1
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_mmx_pshl_mmx_1
    {
        invDEBI_menu_cancel()
        mov     edx,ds:fpu_data
        shl     u32 ptr [ebp+edx+0],1
        rcl     u32 ptr [ebp+edx+4],1
        invDEBI_FPU_update_display()
        ret
    }




    function invDEBI_mmx_movq_ffff_ffff_ffff_ffff
    {
        push    u32 ptr 0ffffffffh
        push    u32 ptr 0ffffffffh
        jmp     invDEBI_mmx_movq
    }




    function invDEBI_mmx_movq_0000_ffff_ffff_ffff
    {
        push    u32 ptr 00000ffffh
        push    u32 ptr 0ffffffffh
        jmp     invDEBI_mmx_movq
    }




    function invDEBI_mmx_movq_0000_0000_ffff_ffff
    {
        push    u32 ptr 000000000h
        push    u32 ptr 0ffffffffh
        jmp     invDEBI_mmx_movq
    }




    function invDEBI_mmx_movq_0000_0000_0000_ffff
    {
        push    u32 ptr 000000000h
        push    u32 ptr 00000ffffh
        jmp     invDEBI_mmx_movq
    }




    function invDEBI_mmx_movq_0000_0000_0000_0fff
    {
        push    u32 ptr 000000000h
        push    u32 ptr 000000fffh
        jmp     invDEBI_mmx_movq
    }




    function invDEBI_mmx_movq_0000_0000_0000_00ff
    {
        push    u32 ptr 000000000h
        push    u32 ptr 0000000ffh
        jmp     invDEBI_mmx_movq
    }




    function invDEBI_mmx_movq_0000_0000_0000_000f
    {
        push    u32 ptr 000000000h
        push    u32 ptr 00000000fh
        jmp     invDEBI_mmx_movq
    }




    function invDEBI_mmx_movq_0000_0000_0000_0000
    {
        push    u32 ptr 000000000h
        push    u32 ptr 000000000h
        jmp     invDEBI_mmx_movq
    }




    function invDEBI_mmx_pand_ffff_0000_0000_0000
    {
        push    u32 ptr 0ffff0000h
        push    u32 ptr 000000000h
        jmp     invDEBI_mmx_pand
    }




    function invDEBI_mmx_pand_0000_ffff_0000_0000
    {
        push    u32 ptr 00000ffffh
        push    u32 ptr 000000000h
        jmp     invDEBI_mmx_pand
    }




    function invDEBI_mmx_pand_0000_0000_ffff_0000
    {
        push    u32 ptr 000000000h
        push    u32 ptr 0ffff0000h
        jmp     invDEBI_mmx_pand
    }




    function invDEBI_mmx_pand_0000_0000_0000_ffff
    {
        push    u32 ptr 000000000h
        push    u32 ptr 00000ffffh
        jmp     invDEBI_mmx_pand
    }




    function invDEBI_mmx_pand_0000_0000_0000_0fff
    {
        push    u32 ptr 000000000h
        push    u32 ptr 000000fffh
        jmp     invDEBI_mmx_pand
    }




    function invDEBI_mmx_pand_0000_0000_0000_00ff
    {
        push    u32 ptr 000000000h
        push    u32 ptr 0000000ffh
        jmp     invDEBI_mmx_pand
    }




    function invDEBI_mmx_pand_0000_0000_0000_000f
    {
        push    u32 ptr 000000000h
        push    u32 ptr 00000000fh
        jmp     invDEBI_mmx_pand
    }




    function invDEBI_mmx_pand_ffff_ffff_0000_0000
    {
        push    u32 ptr 0ffffffffh
        push    u32 ptr 000000000h
        jmp     invDEBI_mmx_pand
    }




    function invDEBI_mmx_pand_0000_0000_ffff_ffff
    {
        push    u32 ptr 000000000h
        push    u32 ptr 0ffffffffh
        jmp     invDEBI_mmx_pand
    }




    function invDEBI_mmx_pand_ffff_0000_ffff_0000
    {
        push    u32 ptr 0ffff0000h
        push    u32 ptr 0ffff0000h
        jmp     invDEBI_mmx_pand
    }




    function invDEBI_mmx_pand_0000_ffff_0000_ffff
    {
        push    u32 ptr 00000ffffh
        push    u32 ptr 00000ffffh
        jmp     invDEBI_mmx_pand
    }




    function invDEBI_mmx_por_ffff_0000_0000_0000
    {
        push    u32 ptr 0ffff0000h
        push    u32 ptr 000000000h
        jmp     invDEBI_mmx_por
    }




    function invDEBI_mmx_por_0000_ffff_0000_0000
    {
        push    u32 ptr 00000ffffh
        push    u32 ptr 000000000h
        jmp     invDEBI_mmx_por
    }




    function invDEBI_mmx_por_0000_0000_ffff_0000
    {
        push    u32 ptr 000000000h
        push    u32 ptr 0ffff0000h
        jmp     invDEBI_mmx_por
    }




    function invDEBI_mmx_por_0000_0000_0000_ffff
    {
        push    u32 ptr 000000000h
        push    u32 ptr 00000ffffh
        jmp     invDEBI_mmx_por
    }




    function invDEBI_mmx_por_0000_0000_0000_0fff
    {
        push    u32 ptr 000000000h
        push    u32 ptr 000000fffh
        jmp     invDEBI_mmx_por
    }




    function invDEBI_mmx_por_0000_0000_0000_00ff
    {
        push    u32 ptr 000000000h
        push    u32 ptr 0000000ffh
        jmp     invDEBI_mmx_por
    }




    function invDEBI_mmx_por_0000_0000_0000_000f
    {
        push    u32 ptr 000000000h
        push    u32 ptr 00000000fh
        jmp     invDEBI_mmx_por
    }




    function invDEBI_mmx_por_ffff_ffff_0000_0000
    {
        push    u32 ptr 0ffffffffh
        push    u32 ptr 000000000h
        jmp     invDEBI_mmx_por
    }




    function invDEBI_mmx_por_0000_0000_ffff_ffff
    {
        push    u32 ptr 000000000h
        push    u32 ptr 0ffffffffh
        jmp     invDEBI_mmx_por
    }




    function invDEBI_mmx_por_ffff_0000_ffff_0000
    {
        push    u32 ptr 0ffff0000h
        push    u32 ptr 0ffff0000h
        jmp     invDEBI_mmx_por
    }




    function invDEBI_mmx_por_0000_ffff_0000_ffff
    {
        push    u32 ptr 00000ffffh
        push    u32 ptr 00000ffffh
        jmp     invDEBI_mmx_por
    }




    function invDEBI_mmx_pandn_ffff_0000_0000_0000
    {
        push    u32 ptr 0ffff0000h
        push    u32 ptr 000000000h
        jmp     invDEBI_mmx_pandn
    }




    function invDEBI_mmx_pandn_0000_ffff_0000_0000
    {
        push    u32 ptr 00000ffffh
        push    u32 ptr 000000000h
        jmp     invDEBI_mmx_pandn
    }




    function invDEBI_mmx_pandn_0000_0000_ffff_0000
    {
        push    u32 ptr 000000000h
        push    u32 ptr 0ffff0000h
        jmp     invDEBI_mmx_pandn
    }




    function invDEBI_mmx_pandn_0000_0000_0000_ffff
    {
        push    u32 ptr 000000000h
        push    u32 ptr 00000ffffh
        jmp     invDEBI_mmx_pandn
    }




    function invDEBI_mmx_pandn_0000_0000_0000_0fff
    {
        push    u32 ptr 000000000h
        push    u32 ptr 000000fffh
        jmp     invDEBI_mmx_pandn
    }




    function invDEBI_mmx_pandn_0000_0000_0000_00ff
    {
        push    u32 ptr 000000000h
        push    u32 ptr 0000000ffh
        jmp     invDEBI_mmx_pandn
    }




    function invDEBI_mmx_pandn_0000_0000_0000_000f
    {
        push    u32 ptr 000000000h
        push    u32 ptr 00000000fh
        jmp     invDEBI_mmx_pandn
    }




    function invDEBI_mmx_pandn_ffff_ffff_0000_0000
    {
        push    u32 ptr 0ffffffffh
        push    u32 ptr 000000000h
        jmp     invDEBI_mmx_pandn
    }




    function invDEBI_mmx_pandn_0000_0000_ffff_ffff
    {
        push    u32 ptr 000000000h
        push    u32 ptr 0ffffffffh
        jmp     invDEBI_mmx_pandn
    }




    function invDEBI_mmx_pandn_ffff_0000_ffff_0000
    {
        push    u32 ptr 0ffff0000h
        push    u32 ptr 0ffff0000h
        jmp     invDEBI_mmx_pandn
    }




    function invDEBI_mmx_pandn_0000_ffff_0000_ffff
    {
        push    u32 ptr 00000ffffh
        push    u32 ptr 00000ffffh
        jmp     invDEBI_mmx_pandn
    }




    function invDEBI_mmx_movq
    {
        mov     edx,ds:fpu_data
        invDEBI_menu_cancel()

        mov     ebx,u32 ptr [esp+4]
        mov     u32 ptr [ebp+edx+4],ebx

        mov     ebx,u32 ptr [esp+0]
        mov     u32 ptr [ebp+edx+0],ebx
        invDEBI_FPU_update_display()
        add     esp,8
        ret
    }




    function invDEBI_mmx_pand
    {
        mov     edx,ds:fpu_data
        invDEBI_menu_cancel()

        mov     ebx,u32 ptr [esp+4]
        and     u32 ptr [ebp+edx+4],ebx

        mov     ebx,u32 ptr [esp+0]
        and     u32 ptr [ebp+edx+0],ebx
        invDEBI_FPU_update_display()
        add     esp,8
        ret
    }




    function invDEBI_mmx_por
    {
        mov     edx,ds:fpu_data
        invDEBI_menu_cancel()

        mov     ebx,u32 ptr [esp+4]
        or      u32 ptr [ebp+edx+4],ebx

        mov     ebx,u32 ptr [esp+0]
        or      u32 ptr [ebp+edx+0],ebx
        invDEBI_FPU_update_display()
        add     esp,8
        ret
    }




    function invDEBI_mmx_pandn
    {
        mov     edx,ds:fpu_data
        invDEBI_menu_cancel()

        mov     ebx,u32 ptr [esp+4]
        not     ebx
        and     u32 ptr [ebp+edx+4],ebx

        mov     ebx,u32 ptr [esp+0]
        not     ebx
        and     u32 ptr [ebp+edx+0],ebx
        invDEBI_FPU_update_display()
        add     esp,8
        ret
    }




    function invDEBI_quick_watch_show_EBP_relative_selector
    {
        invDEBI_quick_watch_add_divider()
        movsx   ebx,u16 ptr ds:[edi+_MO_DATA]
        mov     edx,u32 ptr [ebp+ebx]
        mov     ebx,16
        mov     edi,offset hex_text
        invDEBI_quick_watch_add_radix_in_edx()
        mov     ebx,10
        mov     edi,offset dec_text
        invDEBI_quick_watch_add_radix_in_edx()
        mov     ebx,2
        mov     edi,offset bin_text
        invDEBI_quick_watch_add_radix_in_edx()
        if (edx == 08h)
        {
            mov     esi,offset _sIDT_text
        
        } else if (edx == 010h) {
            mov     esi,offset _sGDT_text
        
        } else if (edx == 018h) {
            mov     esi,offset _sSTACK_text
        
        } else if (edx == 020h) {
            mov     esi,offset _sCODE_text
        
        } else if (edx == 028h) {
            mov     esi,offset _sGRAPHICS_text
        
        } else if (edx == 030h) {
            mov     esi,offset _sMONO_text
        
        } else if (edx == 038h) {
            mov     esi,offset _sVGA_text
        
        } else if (edx == 040h) {
            mov     esi,offset _sALL_MEM_text
        
        } else if (edx == 048h) {
            mov     esi,offset _sDATA_text
        
        } else if (edx == 050h) {
            mov     esi,offset _sEXODUS_MEM_text
        
        } else if (edx == 058h) {
            mov     esi,offset _sEXODUS_PORTS_text
        
        } else if (edx == 060h) {
            mov     esi,offset _sEXODUS_INTS_text
//        .ELSEIF (edx == 068h)
//          // Not used, this is slot 13.  13 is bad luck. :)
        
        } else if (edx == 070h) {
            mov     esi,offset _sEXODUS_TSS_text
        
        } else if (edx == 078h) {
            mov     esi,offset _sEXODUS_TSS_GATE_text
        
        } else if (edx == 080h) {
            mov     esi,offset _sSTACK0_text
        
        } else if (edx == 088h) {
            mov     esi,offset _sSTACK1_text
        
        } else if (edx == 090h) {
            mov     esi,offset _sSTACK2_text
        
        } else if (edx == 098h) {
            mov     esi,offset _sPRIMATIVES_text
        
        } else if (edx == 0a0h) {
            mov     esi,offset _sPRIMATIVES_LOAD_INFO_text
        
        } else if (edx == 0a8h) {
            mov     esi,offset _sSYSTEM_text
        
        } else if (edx == 0b0h) {
            mov     esi,offset _sEXODUS_REQUESTOR_text
        
        } else if (edx == 0b8h) {
            mov     esi,offset _sSYSTEM_RING1_text
        
        } else if (edx == 0c0h) {
            mov     esi,offset _sSYSTEM_RING2_text
        
        } else if (edx == 0c8h) {
            mov     esi,offset _sSYSTEM_RING3_text
        
        } else if (edx == 0d0h) {
            mov     esi,offset _sDEBI_screen_text
        
        } else if (edx == 0d8h) {
            mov     esi,offset _sDEBI_memory_text
        
        } else if (edx == 0e0h) {
            mov     esi,offset _sFLOPPY_TRACK_text
        
        } else if (edx == 0e8h) {
            mov     esi,offset _sVGA_BACKUP_text
        
        } else if (edx == 0190h) {
            mov     esi,offset _sEXODUS_INI_text
        
        } else if (edx == 0198h) {
            mov     esi,offset _sEXODUS_INI_ERRORS_text
        
        } else if (edx == 01a0h) {
            mov     esi,offset _sTASK_SYSTEM_text
        
        } else {
            jmp     @F
        }
        mov     edi,offset _selector_text
        invDEBI_quick_watch_add_item()
      @@:
        ret
    }




    function invDEBI_quick_watch_show_EBP_relative_32
    {
    // This routine displays a 32-bit value that's in the data Debi saved when it was called
        movsx   ebx,u16 ptr ds:[edi+_MO_DATA]
        mov     edx,u32 ptr [ebp+ebx]
        invDEBI_quick_watch_common_32()
        ret
    }




    function invDEBI_quick_watch_common_32
    {
    // This routine displays the value in edx in three different formats
    //
    // Upon entry:   edx - value to display
    //
    // Upon exit:    It is displayed in hex, decimal and binary
    //
        invDEBI_quick_watch_add_divider()
        mov     ebx,16
        mov     edi,offset hex_text
        invDEBI_quick_watch_add_radix_in_edx()
        mov     ebx,10
        mov     edi,offset dec_text
        invDEBI_quick_watch_add_radix_in_edx()
        mov     ebx,2
        mov     edi,offset bin_text
        invDEBI_quick_watch_add_radix_in_edx()
        mov     edi,offset real4_text
        invDEBI_quick_watch_add_real4_in_edx()
        ret
    }




    function invDEBI_quick_watch_show_fpu_cw
    {
        movsx   ebx,u16 ptr ds:[edi+_MO_DATA]
        movzx   edx,u16 ptr [ebp+ebx]

      // Show the value in binary
        invDEBI_quick_watch_add_divider()
        mov     ebx,16
        mov     edi,offset hex_text
        invDEBI_quick_watch_add_radix_in_edx()
        mov     ebx,2
        mov     edi,offset bin_text
        invDEBI_quick_watch_add_radix_in_edx()

        mov     ebx,edx
        and     ebx,_CW_ROUNDING
        if (ebx == _CW_ROUNDING_00)
        {
          // Round to nearest
            mov     esi,offset round_to_nearest
        
        } else if (ebx == _CW_ROUNDING_01) {
          // Round down
            mov     esi,offset round_down
        
        } else if (ebx == _CW_ROUNDING_10) {
          // Round up
            mov     esi,offset round_up
        
        } else {
          // Truncate
            mov     esi,offset round_truncate
        }
        mov     edi,offset rounding_text
        invDEBI_quick_watch_add_item()

        mov     ebx,edx
        and     ebx,_CW_PRECISION
        if (ebx == _CW_PRECISION_00)
        {
          // Single (23 bit w/1)
            mov     esi,offset precision_single
        
        } else if (ebx == _CW_PRECISION_01) {
          // Reserved
            mov     esi,offset precision_reserved
        
        } else if (ebx == _CW_PRECISION_10) {
          // Double (53 bit w/1)
            mov     esi,offset precision_double
        
        } else {
          // Extended (64 bit w/1)
            mov     esi,offset precision_extended
        }
        mov     edi,offset precision_prefix_text
        invDEBI_quick_watch_add_item()

        mov     edi,offset mask_text
        test    edx,_CW_PM
        if (!zero?)
        {
            mov     esi,offset precision_text
            invDEBI_quick_watch_add_item()
        }

        test    edx,_CW_UM
        if (!zero?)
        {
            mov     esi,offset underflow_text
            invDEBI_quick_watch_add_item()
        }

        test    edx,_CW_OM
        if (!zero?)
        {
            mov     esi,offset overflow_text
            invDEBI_quick_watch_add_item()
        }

        test    edx,_CW_ZM
        if (!zero?)
        {
            mov     esi,offset divide_by_zero_text
            invDEBI_quick_watch_add_item()
        }

        test    edx,_CW_DM
        if (!zero?)
        {
            mov     esi,offset denormalized_text
            invDEBI_quick_watch_add_item()
        }

        test    edx,_CW_IM
        if (!zero?)
        {
            mov     esi,offset invalid_text
            invDEBI_quick_watch_add_item()
        }

        ret
    }




    function invDEBI_quick_watch_show_fpu_sw
    {
        movsx   ebx,u16 ptr ds:[edi+_MO_DATA]
        movzx   edx,u16 ptr [ebp+ebx]

      // Show the value in binary
        invDEBI_quick_watch_add_divider()
        mov     ebx,16
        mov     edi,offset hex_text
        invDEBI_quick_watch_add_radix_in_edx()
        mov     ebx,2
        mov     edi,offset bin_text
        invDEBI_quick_watch_add_radix_in_edx()

        test    edx,_SW_BUSY
        if (!zero?)
        {
            mov     esi,offset busy
            invDEBI_quick_watch_add_item()
        }

      // Display the condition codes in binary
        mov     ebx,edx
        and     ebx,_SW_C3
        shr     ebx,11
        mov     ecx,edx
        and     ecx,_SW_C2 or _SW_C1 or _SW_C0
        shr     ecx,_SW_C0-1
        or      ebx,ecx
      // Right now, ecx contains the value
        push    edx
        mov     edx,ebx
        mov     ebx,2
        mov     edi,offset condition_codes_text
        invDEBI_quick_watch_add_radix_in_edx()
        pop     edx

      // Top of stack
        mov     ebx,edx
        and     ebx,_SW_TOS
        shr     ebx,11
        push    edx
        mov     edx,ebx
        mov     ebx,10
        mov     edi,offset top_of_stack_text
        invDEBI_quick_watch_add_radix_in_edx()
        pop     edx

      // Add all of the flags
        mov     edi,-1
        test    edx,_SW_ERROR_SUMMARY
        if (!zero?)
        {
            mov     esi,offset error_summary
            invDEBI_quick_watch_add_item()
        }

        test    edx,_SW_STACK_FAULT
        if (!zero?)
        {
            mov     esi,offset stack_fault
            invDEBI_quick_watch_add_item()
        }

        mov     edi,offset exception_prefix_text
        test    edx,_SW_PE
        if (!zero?)
        {
            mov     esi,offset precision_text
            invDEBI_quick_watch_add_item()
        }

        test    edx,_SW_UE
        if (!zero?)
        {
            mov     esi,offset underflow_text
            invDEBI_quick_watch_add_item()
        }

        test    edx,_SW_OE
        if (!zero?)
        {
            mov     esi,offset overflow_text
            invDEBI_quick_watch_add_item()
        }

        test    edx,_SW_ZE
        if (!zero?)
        {
            mov     esi,offset divide_by_zero_text
            invDEBI_quick_watch_add_item()
        }

        test    edx,_SW_DE
        if (!zero?)
        {
            mov     esi,offset denormalized_text
            invDEBI_quick_watch_add_item()
        }

        test    edx,_SW_IE
        if (!zero?)
        {
            mov     esi,offset invalid_text
            invDEBI_quick_watch_add_item()
        }
        ret
    }




    function invDEBI_quick_watch_show_fpu_tw
    {
        movsx   ebx,u16 ptr ds:[edi+_MO_DATA]
        movzx   edx,u16 ptr [ebp+ebx]

        invDEBI_quick_watch_add_divider()
        mov     ecx,8
        mov     edi,offset stx_text
        mov     u8 ptr ds:[edi+2],'7'
      @@:
        mov     bl,dl
        and     bl,11b
        if (bl == 00b)
        {
          // Valid
            mov     esi,offset tag_valid
        
        } else if (bl == 01b) {
          // Zero
            mov     esi,offset tag_zero
        
        } else if (bl == 10b) {
          // Special
            mov     esi,offset tag_special
        
        } else {
          // Empty
            mov     esi,offset tag_empty
        }
        invDEBI_quick_watch_add_item()
        dec     u8 ptr ds:[edi+2]
        ror     dx,2
        loop    @B
        ret
    }




    function invDEBI_quick_watch_stack_32
    {
    // This routine displays a 32-bit value that's on the user's stack
        movsx   ebx,u16 ptr ds:[edi+_MO_DATA]
        mov     edx,u32 ptr [ebp-04]
        mov     edx,u32 ptr ss:[edx+ebx]
        invDEBI_quick_watch_add_divider()
        invDEBI_quick_watch_common_32()
        ret
    }




    function invDEBI_quick_watch_locals_32
    {
    // This routine displays a 32-bit value that's on the user's stack
        movsx   ebx,u16 ptr ds:[edi+_MO_DATA]
        mov     edx,u32 ptr [ebp+00]
        mov     edx,u32 ptr ss:[edx+ebx]
        invDEBI_quick_watch_add_divider()
        invDEBI_quick_watch_common_32()
        ret
    }




    function invDEBI_quick_watch_show_fpu_opcode
    {
    // This routine displays the 11 bits of an FPU opcode.  It is known that the prefix bits are always 11011.
    // These 11-bits help to make up the entire opcode.  That opcode is used here and the corresponding FPU command is found.
    //
        push    ds
        mov     ebx,1101100000000000b
        movsx   edx,u16 ptr ds:[edi+_MO_DATA]
        movzx   edx,u16 ptr [ebp+edx]
        and     edx,0000011111111111b
        or      ebx,edx
      // Right now, ebx - opcode of last FPU instruction
        invDEBI_quick_watch_add_divider()
        call    u48 ptr ds:_X86_fpu_opcode
        mov     edi,offset disasm_text
        invDEBI_quick_watch_add_item_ecx()
        pop     ds
        ret
    }




    function invDEBI_mem1_window
    {
        mov     ah,0                                                // Ul X
        mov     al,1                                                // Ul Y
        mov     bh,14                                               // Lr X
        mov     bl,12                                               // Lr Y
        invDEBI_populate_mem_window()
        ret
    }




    function invDEBI_mem2_window
    {
        mov     ah,0                                                // Ul X
        mov     al,1                                                // Ul Y
        mov     bh,29                                               // Lr X
        mov     bl,12                                               // Lr Y
        invDEBI_populate_mem_window()
        ret
    }




    function invDEBI_mem3_window
    {
        mov     ah,0                                                // Ul X
        mov     al,1                                                // Ul Y
        mov     bh,44                                               // Lr X
        mov     bl,12                                               // Lr Y
        invDEBI_populate_mem_window()
        ret
    }




    function invDEBI_mem4_window
    {
        mov     ah,0                                                // Ul X
        mov     al,1                                                // Ul Y
        mov     bh,59                                               // Lr X
        mov     bl,12                                               // Lr Y
        invDEBI_populate_mem_window()
        ret
    }




    function invDEBI_populate_mem_window
    {
    // This routine is called to populate a memory window
    //
    // Upon entry:      ah,al - Upper left X,Y
    //                  bh,bl - Lower right X,Y
    //               ds:[esi] - far ptr to mem.x window object
    //
    // Upon exit:    The window is populated with whatever the current address expression suggests
    //
        if (dword ptr ds:[esi+_ST_MEMVAR_OFFSET] != -1)
        {
            push    es                                              // Copy data from the MEMVAR memory into local variables
            push    ebx
            push    esi
            mov     ebx,_sDEBI_memory
            mov     es,ebx
            mov     ebx,offset DEBI_exp_memvar_list
            mov     esi,u32 ptr ds:[esi+_ST_MEMVAR_OFFSET]
            invDEBI_from_object_memvar()
            pop     esi
            pop     ebx
            pop     es

          // See if we need to update the data there
            if (ds:live == 'X' || ds:force_func_windows == _YES)
            {
              // It is a live expression (which means whatever on the screen being displayed right now needs to be overwritten)
                pushfd
                cli
                invDEBI_get_mem_window_coords()
                mov     esi,offset text_22
                mov     ecx,sizeof text_22 - 1
                invDEBI_parse_expression()
                jc      quit                                        // Branch if error in expression
                mov     ds:mem_segment,eax
                mov     ds:mem_offset,ebx

              // Obtain limit for this selector (to find out when a pointer is going beyond readable memory)
                mov     edx,eax                                     // Selector
                mov     eax,'get '
                mov     ebx,'limi'
                call    u48 ptr ds:_EXODUS_requestor
                mov     ds:mem_limit,ecx

                mov     esi,offset disp_22
                mov     ecx,sizeof disp_22 - 1
                invDEBI_parse_expression()
                jc      quit                                        // Branch if error in expressions
                mov     ds:mem_displacement,ebx

              // Display the top line (if any)
                if (ds:show_addresses == 'X')
                {
                    invDEBI_pop_line_show_address()
                    mov     eax,1
                
                } else {
                    xor     eax,eax
                }
                sub     esp,4
              // [esp+0] - dword, holds current Y value (for each line displayed)

              // Now, for each line, parse the data
                mov     u32 ptr [esp+0],eax
                jmp     @F
                while (eax <= ds:mem_height)
                {
                  // Determine the window type and populate a line of data based on that type
                    if (ds:ascii_char == 'X')
                    {
                      default_window:
                        invDEBI_pop_line_mem_window_ascii_char()
                    
                    } else if (ds:_byte == 'X') {
                        invDEBI_pop_line_mem_window_byte()
                    
                    } else if (ds:_word == 'X') {
                        invDEBI_pop_line_mem_window_word()
                    
                    } else if (ds:_dword == 'X') {
                        invDEBI_pop_line_mem_window_dword()
                    
                    } else if (ds:_qword == 'X') {
                        invDEBI_pop_line_mem_window_qword()
                    
                    } else if (ds:float32 == 'X') {
                        invDEBI_pop_line_mem_window_float32()
                    
                    } else if (ds:float64 == 'X') {
                        invDEBI_pop_line_mem_window_float64()
                    
                    } else if (ds:float80 == 'X') {
                        invDEBI_pop_line_mem_window_float80()
                    
                    } else {
                        jmp     default_window
                    }
                    inc     u32 ptr [esp+0]                    // Move to next logical line
                    add     ds:mem_ul_y,FONT_Y                      // Move down to next displayable line
                  @@:
                    mov     eax,u32 ptr [esp+0]
                }

                add     esp,4
                popfd
            }
        }
      quit:
        ret
    }




    // All routines below receive the same input.
    //
    // Upon entry:     ds:mem_ul_x - starting X pixel coordinate
    //                 ds:mem_ul_y - starting Y pixel coordinate
    //                ds:mem_width - # of characters wide before spilling out of window
    //               ds:mem_height - # of lines tall before spilling out of window
    //              ds:mem_segment - segment to use for addresses
    //               ds:mem_offset - offset to use for addresses
    //         ds:mem_displacement - displacement to use for address
    //
    // Upon exit:    The memory window is populated
    //
    function invDEBI_pop_line_show_address
    {
    // This routine is used to show the address
        pushad
        push    ds
        push    es
        enter   16,0

      // Data gets stored to [esp] converted to es:[edi] (Note, esi is used below for display purposes)
        push    ss
        pop     es
        mov     edi,esp
        mov     esi,esp
        mov     u16 ptr es:[edi],'x0'
        add     edi,2
      // Store the segment
        mov     eax,ds:mem_segment
        ror     eax,12
        mov     ecx,4
        invDEBI_store_ecx_hexadecimal_in_eax()
        mov     al,':'
        stosb

      // Store the offset
        mov     eax,ds:mem_offset
        rol     eax,4
        mov     ecx,8
        invDEBI_store_ecx_hexadecimal_in_eax()
        xor     al,al
        stosb

      // Show the address
        push    ss
        pop     ds
        push    cs:mem_ul_x                                         // horizontal
        push    cs:mem_ul_y                                         // vertical
        push    esi                                                 // start of text we've just created to display
        call    u48 ptr cs:_VID_g_mono_display_text               //

        leave
        pop     es
        pop     ds
        popad

      // Move down to next displayable line
        add     ds:mem_ul_y,FONT_Y
        ret
    }




    function invDEBI_pop_line_mem_window_ascii_char
    {
    // This routine is called to display a line of data in an ASCII character format
        invDEBI_pop_line_show_displacement()
        if (ds:show_addresses == 'X')
        {
            add     ds:mem_temp_x,1*FONT_X                          // Move over one more space between displacement and data
        }
        pushad
        push    ds
        push    es
        enter   184,0                                               // Screen is 90 columns wide, must accomodate a potential max!

      // Get our temporary destination address
        push    ss
        pop     es
        mov     edi,esp

      // Get our source address
        mov     ds,ds:mem_segment
        mov     esi,cs:mem_offset
        add     esi,cs:mem_displacement

      // Now, copy the text to our temp area
        mov     edx,cs:mem_temp_x
        mov     ecx,cs:mem_max_x
        xor     ebx,ebx
        while (edx < ecx && ebx < 90)                              // while temp_x < max_x and count < 90)
        {
            add     edx,FONT_X
            if (edx < ecx)
            {
                mov     al,168                                      // Store the ¨ character (indicating the character to the right
                stosb                                               //                 should be displayed regardless of what it is)
            }
            if (esi <= cs:mem_limit)
            {
                lodsb
                or      al,al
                jnz     @F
                mov     al,-1
            
            } else {
                mov     al,'?'
            }
          @@:
            if (edx < ecx)
            {
                stosb
            }
            inc     ebx
        }
        xor     al,al
        stosb

      // Now, display what we've just copied
        push    ss
        pop     ds
        mov     esi,esp
        push    cs:mem_temp_x
        push    cs:mem_ul_y
        push    esi
        call    u48 ptr cs:_VID_g_mono_display_text

      // We're finished
        leave
        pop     es
        pop     ds
        add     ds:mem_displacement,ebx
        popad
        ret
    }




    function invDEBI_pop_line_mem_window_byte
    {
    // This routine is called to display a line of data in a BYTE format
        invDEBI_pop_line_show_displacement()
        if (ds:show_addresses == 'X')
        {
            add     ds:mem_temp_x,1*FONT_X                          // Move over one more space between displacement and data
        }
        pushad
        push    ds
        push    es
        enter   96,0                                                // Screen is 90 columns wide, must accomodate a potential max!
      // [ebp-04], dword - Maximum offset to achieve for the three-byte field used for BYTE data

      // Get our temporary destination address
        push    ss
        pop     es
        mov     edi,esp

      // Get our source address
        mov     ds,ds:mem_segment
        mov     esi,cs:mem_offset
        add     esi,cs:mem_displacement

      // Now, copy the text to our temp area
        mov     edx,cs:mem_temp_x
        mov     ecx,cs:mem_max_x
        mov     u32 ptr [ebp-04],ecx
        sub     u32 ptr [ebp-04],3*FONT_X
        xor     ebx,ebx
        while (edx < ecx && edx <= u32 ptr [ebp-04] && ebx < 90/3)
        {
          // The above line basically equates to:  while temp_x < max_x and (enough_space) and count < 30)

          // Get the character to display in BYTE format
            if (esi <= cs:mem_limit)
            {
                lodsb
            
            } else {
                xor     al,al
            }

          @@:
            invDEBI_store_byte_data_in_al()

            add     edx,FONT_X*3
            if (edx <= u32 ptr [ebp-04])
            {
              // Store space after
                mov     al,32
                stosb
            }

          // Move to next screen location
            inc     ebx
        }
        xor     al,al
        stosb

      // Now, display what we've just copied
        push    ss
        pop     ds
        mov     esi,esp
        push    cs:mem_temp_x
        push    cs:mem_ul_y
        push    esi
        call    u48 ptr cs:_VID_g_mono_display_text

      // We're finished
        leave
        pop     es
        pop     ds
        add     ds:mem_displacement,ebx
        popad
        ret
    }




    function invDEBI_pop_line_mem_window_word
    {
    // This routine is called to display a line of data in a WORD format
        invDEBI_pop_line_show_displacement()
        if (ds:show_addresses == 'X')
        {
            add     ds:mem_temp_x,1*FONT_X                          // Move over one more space between displacement and data
        }
        pushad
        push    ds
        push    es
        enter   96,0                                                // Screen is 90 columns wide, must accomodate a potential max!
      // [ebp-04], dword - Maximum offset to achieve for the three-byte field used for BYTE data

      // Get our temporary destination address
        push    ss
        pop     es
        mov     edi,esp

      // Get our source address
        sub     ds:mem_limit,2
        mov     ds,ds:mem_segment
        mov     esi,cs:mem_offset
        add     esi,cs:mem_displacement

      // Now, copy the text to our temp area
        mov     edx,cs:mem_temp_x
        mov     ecx,cs:mem_max_x
        mov     u32 ptr [ebp-04],ecx
        sub     u32 ptr [ebp-04],5*FONT_X
        xor     ebx,ebx
        while (edx < ecx && edx <= u32 ptr [ebp-04] && ebx < 2*90/5)
        {
          // The above line basically equates to:  while temp_x < max_x and (enough_space) and count < 18)

          // Get the character to display in WORD format
            if (esi <= cs:mem_limit)
            {
                lodsw
            
            } else {
                xor     ax,ax
            }

          @@:
          // Store upper high byte
            push    eax
            shr     eax,8
            invDEBI_store_byte_data_in_al()
            pop     eax

          // Store upper low byte
            invDEBI_store_byte_data_in_al()

            add     edx,FONT_X*5
            if (edx <= u32 ptr [ebp-04])
            {
              // Store space after
                mov     al,32
                stosb
            }

          // Move to next screen location
            add     ebx,2
        }
        xor     al,al
        stosb

      // Now, display what we've just copied
        push    ss
        pop     ds
        mov     esi,esp
        push    cs:mem_temp_x
        push    cs:mem_ul_y
        push    esi
        call    u48 ptr cs:_VID_g_mono_display_text

      // We're finished
        leave
        pop     es
        pop     ds
        add     ds:mem_displacement,ebx
        add     ds:mem_limit,2
        popad
        ret
    }




    function invDEBI_pop_line_mem_window_dword
    {
    // This routine is called to display a line of data in a DWORD format
        invDEBI_pop_line_show_displacement()
        if (ds:show_addresses == 'X')
        {
            add     ds:mem_temp_x,1*FONT_X                          // Move over one more space between displacement and data
        }
        pushad
        push    ds
        push    es
        enter   96,0                                                // Screen is 90 columns wide, must accomodate a potential max!
      // [ebp-04], dword - Maximum offset to achieve for the three-byte field used for BYTE data

      // Get our temporary destination address
        push    ss
        pop     es
        mov     edi,esp

      // Get our source address
        sub     ds:mem_limit,4
        mov     ds,ds:mem_segment
        mov     esi,cs:mem_offset
        add     esi,cs:mem_displacement

      // Now, copy the text to our temp area
        mov     edx,cs:mem_temp_x
        mov     ecx,cs:mem_max_x
        mov     u32 ptr [ebp-04],ecx
        sub     u32 ptr [ebp-04],10*FONT_X
        xor     ebx,ebx
        while (edx < ecx && edx <= u32 ptr [ebp-04] && ebx < 4*90/10)
        {
          // The above line basically equates to:  while temp_x < max_x and (enough_space) and count < whatever:) )

          // Get the character to display in DWORD format
            if (esi <= cs:mem_limit)
            {
                lodsd
            
            } else {
                xor     eax,eax
            }

          @@:
          // Store upper high byte of high word
            push    eax
            shr     eax,24
            invDEBI_store_byte_data_in_al()
            pop     eax

          // Store upper low byte of high word
            push    eax
            shr     eax,16
            invDEBI_store_byte_data_in_al()

          // Store period between high word and low word
            mov     al,'.'
            stosb
            pop     eax

          // Store upper high byte of low word
            push    eax
            shr     eax,8
            invDEBI_store_byte_data_in_al()
            pop     eax

          // Store upper low byte of low word
            invDEBI_store_byte_data_in_al()

            add     edx,FONT_X*10
            if (edx <= u32 ptr [ebp-04])
            {
              // Store one space after
                mov     al,32
                stosb
            }

          // Move to next screen location
            add     ebx,4
        }
        xor     al,al
        stosb

      // Now, display what we've just copied
        push    ss
        pop     ds
        mov     esi,esp
        push    cs:mem_temp_x
        push    cs:mem_ul_y
        push    esi
        call    u48 ptr cs:_VID_g_mono_display_text

      // We're finished
        leave
        pop     es
        pop     ds
        add     ds:mem_displacement,ebx
        add     ds:mem_limit,4
        popad
        ret
    }




    function invDEBI_pop_line_mem_window_qword
    {
    // This routine is called to display a line of data in a QWORD format
        invDEBI_pop_line_show_displacement()
        if (ds:show_addresses == 'X')
        {
            add     ds:mem_temp_x,1*FONT_X                          // Move over one more space between displacement and data
        }
        pushad
        push    ds
        push    es
        enter   96,0                                                // Screen is 90 columns wide, must accomodate a potential max!
      // [ebp-04], dword - Maximum offset to achieve for the three-byte field used for BYTE data

      // Get our temporary destination address
        push    ss
        pop     es
        mov     edi,esp

      // Get our source address
        sub     ds:mem_limit,8
        mov     ds,ds:mem_segment
        mov     esi,cs:mem_offset
        add     esi,cs:mem_displacement

      // Now, copy the text to our temp area
        mov     edx,cs:mem_temp_x
        mov     ecx,cs:mem_max_x
        mov     u32 ptr [ebp-04],ecx
        sub     u32 ptr [ebp-04],19*FONT_X
        xor     ebx,ebx
        while (edx < ecx && edx <= u32 ptr [ebp-04] && ebx < 8*90/19)
        {
          // The above line basically equates to:  while temp_x < max_x and (enough_space) and count < whatever:) )
            push    ecx

            mov     ecx,2
          top_loop:
              // Get the character to display in QWORD format
                if (esi <= cs:mem_limit)
                {
                    if (ecx == 2)
                    {
                        mov     eax,u32 ptr ds:[esi+4]
                    
                    } else {
                        mov     eax,u32 ptr ds:[esi+0]
                    }
                
                } else {
                    xor     eax,eax
                }

              @@:
              // Store upper high byte of high word
                push    eax
                shr     eax,24
                invDEBI_store_byte_data_in_al()
                pop     eax

              // Store upper low byte of high word
                push    eax
                shr     eax,16
                invDEBI_store_byte_data_in_al()

              // Store period between high word and low word
                mov     al,'.'
                stosb
                pop     eax

              // Store upper high byte of low word
                push    eax
                shr     eax,8
                invDEBI_store_byte_data_in_al()
                pop     eax

              // Store upper low byte of low word
                invDEBI_store_byte_data_in_al()

              // Store one space after
                if (ecx == 2)
                {
                    mov     al,'.'
                    stosb
                
                } else {
                    add     edx,FONT_X*19
                    if (edx <= u32 ptr [ebp-04])
                    {
                        mov     al,32
                        stosb
                    }
                }
                loop    top_loop

            pop     ecx
            add     esi,8
          // Move to next screen location
            add     ebx,8
        }
        xor     al,al
        stosb

      // Now, display what we've just copied
        push    ss
        pop     ds
        mov     esi,esp
        push    cs:mem_temp_x
        push    cs:mem_ul_y
        push    esi
        call    u48 ptr cs:_VID_g_mono_display_text

      // We're finished
        leave
        pop     es
        pop     ds
        add     ds:mem_displacement,ebx
        add     ds:mem_limit,8
        popad
        ret
    }




    function invDEBI_pop_line_show_displacement
    {
    // This routine is used to show the displacement for the current line
    //
    // Upon entry:   ds:show_addresses - set to 'X' if address should be displayed
    //                     ds:mem_ul_x - X coordinate on-screen to display
    //                     ds:mem_ul_y - Y coordinate on-screen to display
    //             ds:mem_displacement - displacement value to display
    //
    // Upon exit:    ds:mem_temp_x - set to next available X coordinate (to be compared with ds:mem_max_x)
    //
        mov     eax,ds:mem_ul_x
        mov     ds:mem_temp_x,eax
        if (ds:show_addresses == 'X')
        {
            push    ds
            push    es
            pushad
            enter   8,0
          // [ebp-16], 16-bytes, string set aside for display

          // Store the value to [esp] converted to es:[edi]
            mov     edi,esp
            push    ss
            pop     es

          // Always store 4 characters plus the sign
            mov     eax,ds:mem_displacement
            invDEBI_store_eax_sign()
            mov     ecx,3
            ror     eax,8
            invDEBI_store_ecx_hexadecimal_in_eax_no_sign()
            xor     al,al
            stosb

          // Now, display what we've just created
            push    ss
            pop     ds
            mov     esi,esp
            push    cs:mem_temp_x                                   // horizontal
            push    cs:mem_ul_y                                     // vertical
            push    esi                                             // start of text we've just created to display
            call    u48 ptr cs:_VID_g_mono_display_text           //

            leave
            popad
            pop     es
            pop     ds

          // Adjust for the data that will display now
            add     ds:mem_temp_x,4*FONT_X                          // 4 for "+000"
        }
        ret
    }




    function invDEBI_store_eax_sign
    {
    // This routine is used to store the sign in EAX
    //
    // Upon entry:        eax - value to examine
    //               es:[edi] - far ptr to where to store the sign
    //
    // Upon exit:    The sign is stored
    //
      // Store the sign
        if (eax > 7fffffffh)
        {
            mov     dl,'-'
        
        } else {
            mov     dl,'+'
        }
        mov     u8 ptr es:[edi],dl
        inc     edi
        ret
    }




    function invDEBI_store_ecx_hexadecimal_in_eax_no_sign
    {
    // This routine is used to store the data in eax to the output string
    //
    // Upon entry:        eax - value to convert to text (without regard to sign, meaning negative values are NEG'd)
    //                    ecx - # of characters to store
    //               es:[edi] - far ptr to where to store to
    //
    // Upon exit:    The data is stored for each character
    //
      // Store the data
        if (eax > 7fffffffh)
        {
          // Convert from - to + for display (the sign has already been displayed)
            neg     eax
        }
        // No return is here because this function will simply flow into the one below to complete the display
        //ret
    }




    function invDEBI_store_ecx_hexadecimal_in_eax
    {
    // This routine is used to store the data in eax to the output string
    //
    // Upon entry:        eax - value to convert to text
    //                    ecx - # of characters to store
    //               es:[edi] - far ptr to where to store to
    //
    // Upon exit:    The data is stored for each character
    //
      // Store the data
        while (ecx > 0)
        {
            mov     dl,al
            and     dl,0fh
            if (dl >= 0 && dl <= 9)
            {
                add     dl,'0'
            
            } else {
                add     dl,'a'-10
            }
            mov     u8 ptr es:[edi],dl
            inc     edi
            rol     eax,4
            dec     ecx
        }
        ret
    }




    function invDEBI_store_byte_data_in_al
    {
    // This routine is used to store the nibbles in al to es:[edi]
    //
    // Upon entry:         al - value to store
    //               es:[edi] - far ptr to where to store
    //
    // Upon exit:    data is stored and edi is moved
    //
      // Store upper nibble
        push    eax
        shr     al,4
        if (al >= 0 && al <= 9)
        {
            add     al,'0'
        
        } else {
            add     al,'a'-10
        }
        stosb
        pop     eax

      // Store lower nibble
        and     al,0fh
        if (al >= 0 && al <= 9)
        {
            add     al,'0'
        
        } else {
            add     al,'a'-10
        }
        stosb
        ret
    }




    function invDEBI_get_mem_window_coords
    {
    // This routine is used to determine the ul X,Y and lr X,Y coordinates for the current mem window update
    //
    // Upon entry:      ah,al - Upper left X,Y
    //                  bh,bl - Lower right X,Y
    //               ds:[esi] - far ptr to screen object
    //
    // Upon exit:      ds:mem_ul_x - Starting UL X pixel for data
    //                 ds:mem_ul_y - Starting UL Y pixel for data
    //                ds:mem_width - How many characters are available horizontally before spilling out of window
    //               ds:mem_height - How many lines are available vertically before spilling out of window
    //
        pushad
        enter   4,0
      // [ebp-04], dword - Ul Y
      //
      // Now, calculate the new pixel coordinates
        movzx   ecx,ah
        movzx   edx,al
        mov     u32 ptr [ebp-04],edx                           // Ul y

      // Determine how wide/high the window is
        sub     bh,ah
        sub     bl,al
      // Right now, bh - width of usable window
      //            bl - height of usable window
        movzx   eax,bh                                              // Width
        movzx   ebx,bl                                              // Height
        mov     ds:mem_width,eax
        mov     ds:mem_height,ebx

      // Now, adjust for the current font
        mov     eax,FONT_X
        mul     ecx                                                 // Ul x
        add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        mov     ds:mem_ul_x,eax

        mov     eax,FONT_Y
        mul     u32 ptr [ebp-04]                               // Ul y
        add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        mov     ds:mem_ul_y,eax

      // Determine the maximum X pixel (used in loops)
        mov     eax,ds:mem_width
        inc     eax
        mov     ebx,FONT_X
        mul     ebx
        add     eax,ds:mem_ul_x
        mov     ds:mem_max_x,eax

      // We're finished
        leave
        popad
        ret
    }




    function invDEBI_logo_window
    {
    // This routine is called when updating the screen.  It is called from the @FunctionHandlesObject macro
    //
    // Upon entry:   ds:[esi] - far ptr to screen info
    //               ds:[edi] - far ptr to function handle
    //
    // Upon exit:    The logo is redrawn
    //
//        mov     ebx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
//        mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
//
//        push    ebx                                                 // ul-x
//        push    edx                                                 // ul-y
//        add     ebx,30*FONT_X
//        push    ebx                                                 // lr-x
//        add     edx,4*FONT_Y-1
//        push    edx                                                 // lr-y
//        push    u32 ptr 0                                         // Put this string
//        push    u32 ptr offset debi_debugger_logo                 // Offset to the buffer
//        call    u48 ptr cs:_VID_g_mono_window_function
        ret
    }




  // These options all do the same thing, but they're individuall identified in the source code because at some point in
  // the future it might become advantageous to break them out individually (or to have one menu be different)
    invDEBI_descriptor_right_click:
    invDEBI_fpu_1_right_click:
    invDEBI_fpu_2_right_click:
    invDEBI_fpu_save_state_right_click:
    invDEBI_fpu_summary_right_click:
    invDEBI_locals_right_click:
    invDEBI_mem_1_right_click:
    invDEBI_mem_2_right_click:
    invDEBI_mem_3_right_click:
    invDEBI_mem_4_right_click:
    invDEBI_mmx_right_click:
    invDEBI_query_right_click:
    invDEBI_quick_watch_right_click:
    invDEBI_reg_1_right_click:
    invDEBI_reg_3_right_click:
    invDEBI_reg_right_click:
    invDEBI_stack_right_click:
        jmp     invDEBI_general_menu




    invDEBI_cfsca_1_right_click:
    invDEBI_cfsca_2_right_click:
    invDEBI_cfsca_3_right_click:
        jmp     invDEBI_cfsca_menu




    function invDEBI_change_window_cfsca_1
    {
        push    offset DEBI_t_keyboard_objects
        push    offset DEBI_t_mouse_objects
        push    offset DEBI_t_screen_objects
        jmp     invDEBI_change_window_common_cfsca
    }




    function invDEBI_change_window_cfsca_2
    {
        push    offset DEBI_c_keyboard_objects
        push    offset DEBI_c_mouse_objects
        push    offset DEBI_c_screen_objects
        jmp     invDEBI_change_window_common_cfsca
    }




    function invDEBI_change_window_cfsca_3
    {
        push    offset DEBI_d_keyboard_objects
        push    offset DEBI_d_mouse_objects
        push    offset DEBI_d_screen_objects
        jmp     invDEBI_change_window_common_cfsca
    }




    function invDEBI_change_window_common_cfsca
    {
    // There can only be one active CFSCA window at a time.  This algorithm will try to replace the existing one
    //
    // Upon entry:   The stack is arranged as below
    //
    // Upon exit:    The window is either replaced with the new one, or control goes to invDEBI_new_window_common
    //
      // [esp+12] - Calling function offset
      // [esp+08] - Keyboard objects
      // [esp+04] - Mouse objects
      // [esp+00] - Screen objects
        mov     esi,offset DEBI_screen_table
        xor     ecx,ecx
        while (ecx < 15)
        {
            if (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _YES)
            {
                mov     eax,u32 ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]
                if (eax == DEBI_d_screen_objects || eax == DEBI_c_screen_objects || eax == DEBI_t_screen_objects)
                {
                    mov     ds:menu_restore_screen_after,_NO        // Force the menu cancelation algorithm to not restore screen
                    mov     ds:single_step_top,0                    // Force the CFSCA window to reposition the current disassembly
                    mov     ds:single_step_end,0                    //  line to the top line of the CFSCA window

                  // Let's update the existing CFSCA item
                    mov     edx,u32 ptr [esp+08]
                    mov     u32 ptr ds:[esi+_ST_OBJECT_KBD_OFFSET],edx
                    mov     edx,u32 ptr [esp+04]
                    mov     u32 ptr ds:[esi+_ST_OBJECT_MOUSE_OFFSET],edx
                    mov     edx,u32 ptr [esp+00]
                    mov     u32 ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET],edx

                  // Redraw the new window
                    pushfd
                    cli
                    invDEBI_clear_screen_and_redraw_windows()
                    popfd
                    jmp     quit
                }
            }

          next_one:
            add     esi,_ST_LENGTH
            inc     ecx
        }
      // We didn't find one, so we do nothing

      quit:
        add     esp,12
        ret
    }




    // The following invDEBI_new_window_*() functions all receive the same information
    //
    // Upon entry:   ds:general_menu_esi - Offset to screen object which created this menu
    //
    // Upon exit:    If there is room, a new object is created
    //
    function invDEBI_new_window_descriptor
    {
        push    offset DEBI_keyboard_objects
        push    offset DEBI_a_mouse_objects
        push    offset DEBI_a_screen_objects
        jmp     invDEBI_new_window_common
    }




    function invDEBI_new_window_regs_1
    {
        push    offset DEBI_keyboard_objects
        push    offset DEBI_p_mouse_objects
        push    offset DEBI_p_screen_objects
        jmp     invDEBI_new_window_common
    }




    function invDEBI_new_window_regs_3
    {
        push    offset DEBI_keyboard_objects
        push    offset DEBI_b_mouse_objects
        push    offset DEBI_b_screen_objects
        jmp     invDEBI_new_window_common
    }




    function invDEBI_new_window_mmx
    {
        push    offset DEBI_keyboard_objects
        push    offset DEBI_s_mouse_objects
        push    offset DEBI_s_screen_objects
        jmp     invDEBI_new_window_common
    }




    function invDEBI_new_window_fpu_1
    {
        push    offset DEBI_keyboard_objects
        push    offset DEBI_q_mouse_objects
        push    offset DEBI_q_screen_objects
        jmp     invDEBI_new_window_common
    }




    function invDEBI_new_window_fpu_2
    {
        push    offset DEBI_keyboard_objects
        push    offset DEBI_r_mouse_objects
        push    offset DEBI_r_screen_objects
        jmp     invDEBI_new_window_common
    }




    function invDEBI_new_window_fpu_summary
    {
        push    offset DEBI_keyboard_objects
        push    offset DEBI_e_mouse_objects
        push    offset DEBI_e_screen_objects
        jmp     invDEBI_new_window_common
    }




    function invDEBI_new_window_fpu_savestate
    {
        push    offset DEBI_keyboard_objects
        push    offset DEBI_f_mouse_objects
        push    offset DEBI_f_screen_objects
        jmp     invDEBI_new_window_common
    }




    function invDEBI_new_window_mem_1
    {
        push    offset DEBI_keyboard_objects
        push    offset DEBI_m_mouse_objects
        push    offset DEBI_m_screen_objects
        jmp     invDEBI_new_window_common
    }




    function invDEBI_new_window_mem_2
    {
        push    offset DEBI_keyboard_objects
        push    offset DEBI_g_mouse_objects
        push    offset DEBI_g_screen_objects
        jmp     invDEBI_new_window_common
    }




    function invDEBI_new_window_mem_3
    {
        push    offset DEBI_keyboard_objects
        push    offset DEBI_n_mouse_objects
        push    offset DEBI_n_screen_objects
        jmp     invDEBI_new_window_common
    }




    function invDEBI_new_window_mem_4
    {
        push    offset DEBI_keyboard_objects
        push    offset DEBI_h_mouse_objects
        push    offset DEBI_h_screen_objects
        jmp     invDEBI_new_window_common
    }




    function invDEBI_new_window_locals
    {
        push    offset DEBI_keyboard_objects
        push    offset DEBI_l_mouse_objects
        push    offset DEBI_l_screen_objects
        jmp     invDEBI_new_window_common
    }




    function invDEBI_new_window_stack
    {
        push    offset DEBI_keyboard_objects
        push    offset DEBI_i_mouse_objects
        push    offset DEBI_i_screen_objects
        jmp     invDEBI_new_window_common
    }




    function invDEBI_new_window_common
    {
    // This routine is used to create a new common window (if there's room for one)
    //
    // Upon entry:   The stack is arranged as below
    //
    // Upon exit:    The window is either created or not
    //
      // [esp+48] - Calling function offset
      // [esp+44] - Keyboard objects
      // [esp+40] - Mouse objects
      // [esp+36] - Screen objects
      // [esp+32] - eax
      // [esp+28] - ecx
      // [esp+24] - edx
      // [esp+20] - ebx
      // [esp+16] - esp
      // [esp+12] - ebp
      // [esp+08] - esi
      // [esp+04] - edi
      // [esp+00] - eflags
        pushad
        pushfd

      // Determine if there's room
        mov     esi,offset DEBI_screen_table
        xor     ecx,ecx
        while (ecx < 15)
        {
            if (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _NO)
            {
              // We found where we can add it
                cli
                mov     u8 ptr ds:[esi+_ST_OBJECT_ALTERABLE],_YES
                mov     u8 ptr ds:[esi+_ST_OBJECT_ACTIVE],_YES
                mov     u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL],0       // Force it in the upper-left corner (they'll move it)
                mov     u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL],0
                mov     u32 ptr ds:[esi+_ST_MEMVAR_OFFSET],-1
                mov     edx,u32 ptr [esp+44]
                mov     u32 ptr ds:[esi+_ST_OBJECT_KBD_OFFSET],edx
                mov     u32 ptr ds:[esi+_ST_OBJECT_MEMORY_OFFSET],-1
                mov     edx,u32 ptr [esp+40]
                mov     u32 ptr ds:[esi+_ST_OBJECT_MOUSE_OFFSET],edx
                mov     edx,u32 ptr [esp+36]
                mov     u32 ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET],edx

              // Right now, ds:[esi] - far ptr to this object
                invDEBI_clear_screen_and_redraw_windows()

                mov     ds:menu_restore_screen_after,_NO
                jmp     quit
            }
            add     esi,_ST_LENGTH
            inc     ecx
        }

      quit:
        popfd
        popad
        add     esp,12
        ret
    }
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// END - 66666 - Actions taken when various menu items are selected
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// 77777 - Menu bar events
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    function invDEBI_menu_continue_click
    {
    // This routine is called when they click on the continue cask
        mov     ds:debi_ok_to_quit,2
        stc
        ret
    }




    function invDEBI_menu_break_click
    {
    // This routine is called when they click on the break cask
        ret
    }




    function invDEBI_menu_over_click
    {
    // This routine is called when they click on the over cask
        ret
    }




    function invDEBI_menu_step_click
    {
    // This routine is called when they click on the step cask
        mov     ds:debi_ok_to_quit,1
        stc
        ret
    }
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// END - 77777 - Menu bar events
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=










//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// 88888 - DRAG and DRAG RELEASE handlers
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    function invDEBI_object_drag_start
    {
    // This routine is called when an object needs to be dragged
    //
    // Upon entry:   ds:[esi] - far ptr to screen object
    //               ds:[edi] - far ptr to mouse object
    //
    // Upon exit:    The object is picked up and dragging begins
    //
        pushad
        mov     ds:dragging_esi,esi
        mov     ds:dragging_edi,edi
        mov     ds:dragging_object,_YES

      // Calculate starting coordinates
        mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        mov     ds:dragging_x,edx
        mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        mov     ds:dragging_y,edx

      // Grab the height and width
        mov     edx,u32 ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]
        movzx   eax,u16 ptr ds:[edx+_ST_OBJECT_SCREEN_WIDTH]
        mov     ds:dragging_width,eax
        movzx   eax,u16 ptr ds:[edx+_ST_OBJECT_SCREEN_HEIGHT]
        mov     ds:dragging_height,eax

      // Calculate the offset (the mouse wasn't at the upper-left corner when it was clicked, this tells how far away we were
        mov     edx,ds:mouse_left_click_x_start
        sub     edx,ds:dragging_x
        mov     ds:dragging_offset_x,edx

        mov     edx,ds:mouse_left_click_y_start
        sub     edx,ds:dragging_y
        mov     ds:dragging_offset_y,edx

      // Begin the dragging
        mov     ds:dragging_snap_x,8
        mov     ds:dragging_snap_y,6
        mov     dl,1
        invDEBI_drag_start()
        popad
        ret
    }




    function invDEBI_object_drag_stop
    {
    // This routine is called when an object needs to be dragged
    //
    // Upon entry:   ds:[esi] - far ptr to screen object
    //               ds:[edi] - far ptr to mouse object
    //
    // Upon exit:    The object is picked up and dragging begins
    //
      // Restore the original screen
        mov     ds:dragging_object,_NO
        invDEBI_drag_stop()
        invDEBI_restore_screen2()

        pushfd
        cli
        mov     esi,ds:dragging_esi
      // Drop the window at its new location
        mov     edx,ds:dragging_x
        sub     edx,ds:dragging_offset_x
        push    edx
        invDEBI_dragging_snap_x()
        pop     edx
        mov     u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL],edx
      // Now, update the mouse position (we were snapping the values, and may not be exactly where we ended up)
        add     edx,ds:dragging_offset_x
        mov     ds:mouse_current_x,edx

        mov     eax,ds:dragging_y
        sub     eax,ds:dragging_offset_y
        push    eax
        invDEBI_dragging_snap_y()
        pop     eax
        mov     u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL],eax
      // Now, update the mouse position
        add     eax,ds:dragging_offset_y
        mov     ds:mouse_current_y,eax

      // Now, force a redraw
        movzx   eax,ds:force_screen_redraw
        push    eax
        mov     ds:force_screen_redraw,_YES
        invDEBI_populate_debug_screen()
        pop     eax
        mov     ds:force_screen_redraw,al


        popfd

        ret
    }




    function invDEBI_stx_drag_start
    {
    // This routine is called when a left-drag event is recognized from the various stx regions
      // Save original information
        pushad
        mov     ds:fpu_esi,esi
        mov     ds:fpu_edi,edi

        mov     eax,ds:mouse_left_click_x_start
        mov     ds:fpu_x,eax
        mov     edx,ds:mouse_left_click_y_start
        mov     ds:fpu_y,edx
        invDEBI_determine_stx_variable()
        mov     ds:fpu_source,edx
      // Right now, edx - offset to reach the stx value on the stack
      //            ecx - x value of st(x)
      //            eax - position down the screen (0-st7, 1-st6, 7-st0)
        if (edx == -1)
        {
            jmp     quit
        }

      // Move down the specified number of stx's
        mov     ebx,FONT_Y
        mul     ebx
        mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        add     edx,u32 ptr ds:[edi+_MO_X1]
        mov     ds:dragging_x,edx

        mov     ds:fpu_data,eax
        sub     ds:fpu_y,eax
        add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        add     eax,u32 ptr ds:[edi+_MO_Y1]
        mov     ds:dragging_y,eax

      // Setup the variables for dragging
        mov     edx,u32 ptr ds:[edi+_MO_X2]
        sub     edx,u32 ptr ds:[edi+_MO_X1]
        add     edx,8
        and     edx,not 111b                                        // Round to nearest 8th pixel (so we only load multiples of 8)
        mov     ds:dragging_width,edx
        mov     ds:dragging_height,FONT_Y-1                         // change base-1 to base-0

      // Determine the offset
        mov     edx,ds:fpu_x
        sub     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        sub     edx,u32 ptr ds:[edi+_MO_X1]
        mov     ds:dragging_offset_x,edx

        mov     edx,ds:fpu_y
        sub     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        sub     edx,u32 ptr ds:[edi+_MO_Y1]
        mov     ds:dragging_offset_y,edx

        mov     dl,1
        invDEBI_drag_start()
      quit:
        popad
        ret
    }




    function invDEBI_stx_drag_stop
    {
    // This routine is called when something is dropped over an stx region
      // Cancel the dragging
        if (ds:dragging_object == _YES)
        {
            jmp     invDEBI_object_drag_stop
        }
        invDEBI_drag_stop()
        invDEBI_restore_screen2()

      // Determine where they landed
        mov     edi,ds:fpu_edi
        mov     eax,ds:mouse_left_click_x_stop
        sub     eax,ds:dragging_offset_x
      // Right now, eax is the upper left corner
      // But, the way things are dragged in this system we have to average out the location
        mov     ebx,u32 ptr ds:[edi+_MO_X2]
        sub     ebx,u32 ptr ds:[edi+_MO_X1]
        shr     ebx,1
        add     eax,ebx
      // Right now, eax is the average (to the nearest pixel) of the left side and right side
        mov     ds:fpu_x,eax

        mov     edx,ds:mouse_left_click_y_stop
        sub     edx,ds:dragging_offset_y
        add     edx,FONT_Y / 2
      // Right now, edx is the average (to the nearest pixel) of the top and bottom
        mov     ds:fpu_y,edx

        invDEBI_determine_stx_variable()
        if (edx != -1)
        {
            finit
            mov     ebx,ds:fpu_source
            fld     tbyte ptr [ebp+ebx]
            fstp    tbyte ptr [ebp+edx]
            invDEBI_FPU_update_display()
        }
        ret
    }




    function invDEBI_determine_stx_variable
    {
    // This routine is used to determine which stx variable was clicked on (assuming st7 is at the top, st0 at the bottom)
    //
    // Upon entry:   ds:fpu_x - X coord where click was made
    //               ds:fpu_y - Y coord
    //               ds:[esi] - far ptr to screen object
    //               ds:[edi] - far ptr to mouse object
    //
    // Upon exit:    edx - offset to get to stx variable on stack
    //               ecx - x value in stx, -1 if invalid range specified
    //
        push    ebx

        mov     edx,ds:fpu_y
        sub     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        sub     edx,u32 ptr ds:[edi+_MO_Y1]
      // Right now, edx - pixels down from upper-left coordinate of stx block
        mov     eax,edx
        xor     edx,edx
        mov     ebx,FONT_Y
        div     ebx
      // Right now, eax - the # of items down
        if (al == 0)
        {
          // st7
            mov     edx,-200+98
            mov     ecx,7
        
        } else if (al == 1) {
          // st6
            mov     edx,-200+88
            mov     ecx,6
        
        } else if (al == 2) {
          // st5
            mov     edx,-200+78
            mov     ecx,5
        
        } else if (al == 3) {
          // st4
            mov     edx,-200+68
            mov     ecx,4
        
        } else if (al == 4) {
          // st3
            mov     edx,-200+58
            mov     ecx,3
        
        } else if (al == 5) {
          // st2
            mov     edx,-200+48
            mov     ecx,2
        
        } else if (al == 6) {
          // st1
            mov     edx,-200+38
            mov     ecx,1
        
        } else if (al == 7) {
          // st0
            mov     edx,-200+28
            mov     ecx,0
        
        } else {
            mov     edx,-1
            mov     ecx,-1
        }

        pop     ebx
        ret
    }




    function invDEBI_mmx_drag_start
    {
    // This routine is called when a left-drag event is recognized from the various mmx regions
      // Save original information
        pushad
        mov     ds:fpu_esi,esi
        mov     ds:fpu_edi,edi

        mov     eax,ds:mouse_left_click_x_start
        mov     ds:fpu_x,eax
        mov     edx,ds:mouse_left_click_y_start
        mov     ds:fpu_y,edx
        invDEBI_determine_mmx_variable()
        mov     ds:fpu_source,edx
      // Right now, edx - offset to reach the mmx value on the stack
      //            eax - position down the screen (0-mm0, 1-mm1, 7-mm7)
        if (edx == -1)
        {
            jmp     quit
        }

      // Move down the specified number of mmx's
        mov     ebx,FONT_Y
        mul     ebx
        mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        add     edx,u32 ptr ds:[edi+_MO_X1]
        mov     ds:dragging_x,edx

        mov     ds:fpu_data,eax
        sub     ds:fpu_y,eax
        add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        add     eax,u32 ptr ds:[edi+_MO_Y1]
        mov     ds:dragging_y,eax

      // Setup the variables for dragging
        mov     edx,u32 ptr ds:[edi+_MO_X2]
        sub     edx,u32 ptr ds:[edi+_MO_X1]
        add     edx,8
        and     edx,not 111b                                        // Round to nearest 8th pixel (so we only load multiples of 8)
        mov     ds:dragging_width,edx
        mov     ds:dragging_height,FONT_Y-1                         // change base-1 to base-0

      // Determine the offset
        mov     edx,ds:fpu_x
        sub     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        sub     edx,u32 ptr ds:[edi+_MO_X1]
        mov     ds:dragging_offset_x,edx

        mov     edx,ds:fpu_y
        sub     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        sub     edx,u32 ptr ds:[edi+_MO_Y1]
        mov     ds:dragging_offset_y,edx

        mov     dl,1
        invDEBI_drag_start()
      quit:
        popad
        ret
    }




    function invDEBI_mmx_drag_stop
    {
    // This routine is called when something is dropped over an mmx region
      // Cancel the dragging
        if (ds:dragging_object == _YES)
        {
            jmp     invDEBI_object_drag_stop
        }
        invDEBI_drag_stop()
        invDEBI_restore_screen2()

      // Determine where they landed
        mov     edi,ds:fpu_edi
        mov     eax,ds:mouse_left_click_x_stop
        sub     eax,ds:dragging_offset_x
      // Right now, eax is the upper left corner
      // But, the way things are dragged in this system we have to average out the location
        mov     ebx,u32 ptr ds:[edi+_MO_X2]
        sub     ebx,u32 ptr ds:[edi+_MO_X1]
        shr     ebx,1
        add     eax,ebx
      // Right now, eax is the average (to the nearest pixel) of the left side and right side
        mov     ds:fpu_x,eax

        mov     edx,ds:mouse_left_click_y_stop
        sub     edx,ds:dragging_offset_y
        add     edx,FONT_Y / 2
      // Right now, edx is the average (to the nearest pixel) of the top and bottom
        mov     ds:fpu_y,edx

        invDEBI_determine_mmx_variable()
        if (edx != -1)
        {
            finit
            mov     ebx,ds:fpu_source
            fild    u64 ptr [ebp+ebx]
            fistp   u64 ptr [ebp+edx]
            invDEBI_FPU_update_display()
        }
        ret
    }




    function invDEBI_determine_mmx_variable
    {
    // This routine is used to determine which mmx variable was clicked on (assuming st7 is at the top, st0 at the bottom)
    //
    // Upon entry:   ds:fpu_x - X coord where click was made
    //               ds:fpu_y - Y coord
    //               ds:[esi] - far ptr to screen object
    //               ds:[edi] - far ptr to mouse object
    //
    // Upon exit:    edx - offset to get to mmx variable on stack
    //               ecx - x value in mmx, -1 if invalid range specified
    //
        push    ebx

        mov     edx,ds:fpu_y
        sub     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        sub     edx,u32 ptr ds:[edi+_MO_Y1]
      // Right now, edx - pixels down from upper-left coordinate of mmx block
        mov     eax,edx
        xor     edx,edx
        mov     ebx,FONT_Y
        div     ebx
      // Right now, eax - the # of items down
        if (al == 0)
        {
          // mm0
            mov     edx,-200+28
        
        } else if (al == 1) {
          // mm1
            mov     edx,-200+38
        
        } else if (al == 2) {
          // mm2
            mov     edx,-200+48
        
        } else if (al == 3) {
          // mm3
            mov     edx,-200+58
        
        } else if (al == 4) {
          // mm4
            mov     edx,-200+68
        
        } else if (al == 5) {
          // mm5
            mov     edx,-200+78
        
        } else if (al == 6) {
          // mm6
            mov     edx,-200+88
        
        } else if (al == 7) {
          // mm7
            mov     edx,-200+98
        
        } else {
            mov     edx,-1
            mov     ecx,-1
        }

        pop     ebx
        ret
    }




    function invDEBI_drag_start
    {
    // This routine is used to begin the process of grabbing something on the screen in preparation for dragging it
    //
    // Upon entry:   ds:dragging_* - setup
    //                          dl - How to grab?  0-grab object as is, 1-grab as NOT image of itself
        push    ds
        pushad
        pushfd

      // Save this object to the screen buffer (for dragging)
        if (dl == 0)
        {
          // Grab the image as is
            mov     eax,1
        
        } else {
          // Grab the NOT image of itself
            mov     eax,11
        }

        cli
      // Grab the image to be dragged
        push    u32 ptr ds:dragging_x
        push    u32 ptr ds:dragging_y
        mov     edx,ds:dragging_x
        add     edx,ds:dragging_width
        push    edx
        mov     edx,ds:dragging_y
        add     edx,ds:dragging_height
        push    edx
        push    eax                                                 // Get or Get_NOT
        push    u32 ptr 4000h
        mov     eax,_sDEBI_screen
        mov     ds,eax
        call    u48 ptr cs:_VID_g_mono_window_function

      // Clear the image of where it was dragged
        push    u32 ptr cs:dragging_x
        push    u32 ptr cs:dragging_y
        mov     eax,cs:dragging_x
        add     eax,cs:dragging_width
        push    eax
        mov     edx,cs:dragging_y
        add     edx,cs:dragging_height
        push    edx
        push    u32 ptr 2                                         // Clear
        push    u32 ptr 0                                         // Not used here, but required for spacer
        call    u48 ptr cs:_VID_g_mono_window_function

      // Save the screen after the area has been cleared
        invDEBI_save_screen2()

        popfd
        popad
        pop     ds
        mov     ds:dragging_something,1
        ret
    }




    function invDEBI_drag_stop
    {
        if (ds:dragging_object == _YES)
        {
          // We're dragging a window (no release point was specified because it could be released anywhere)
            invDEBI_object_drag_stop()
        
        } else {
          // We're just canceling the drag
            mov     ds:dragging_something,0
            mov     ds:dragging_skipped,0
        }
        ret
    }
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// END - 88888 - DRAG and DRAG RELEASE handlers
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=










//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// 99999 - Keyboard events
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    function invDEBI_clear_text_22
    {
    // This routine is called when there is input to process from the keyboard
    //
    // Upon entry:   eax - key
    //               ebx - flags
    //                ds - Debi's data segment
    //
    // Upon exit:    The key is either accepted and processed or ignored
    //               Note that processing might include moving to another field
    //
        if (ax == tab)
        {
          // Move to next item (or first one if we're on the last)
            mov     edx,1
            invDEBI_next_keyboard_item()
        
        } else if (ax == shift_tab) {
          // Move to previous item (or last one if we're on the first)
            mov     edx,-1
            invDEBI_next_keyboard_item()
        
        } else if (ax == enter_key || ax == grey_enter) {
          // They've selected this option
            invDEBI_lostFocus()
            mov     esi,offset text_22
            mov     ecx,22
            invDEBI_input_clear_field()
            mov     esi,ds:screen_object
            invDEBI_screen_refresh()
            mov     edi,offset text_22_object
            mov     ds:kbd_object,edi
            invDEBI_setFocus()
        }
        ret
    }




    function invDEBI_input_clear_var_click
    {
    // This routine is called when a mouse button is clicked on the "text_22" clear-item option
    //
    // Upon entry:   ds:[esi] - far ptr to screen object
    //               ds:[edi] - far ptr to mouse object
    //
    // Upon exit:    The input field is cleared, and the focus is set
    //
        mov     esi,u32 ptr ds:[edi+_MO_DATA1]
        movzx   ecx,u16 ptr ds:[edi+_MO_DATA2]
        invDEBI_input_clear_field()
        mov     esi,ds:screen_object
        invDEBI_screen_refresh()
        ret
    }




    function invDEBI_clear_disp_22
    {
    // This routine is called when there is input to process from the keyboard
    //
    // Upon entry:   eax - key
    //               ebx - flags
    //                ds - Debi's data segment
    //
    // Upon exit:    The key is either accepted and processed or ignored
    //               Note that processing might include moving to another field
    //
        if (ax == tab)
        {
          // Move to next item (or first one if we're on the last)
            mov     edx,1
            invDEBI_next_keyboard_item()
        
        } else if (ax == shift_tab) {
          // Move to previous item (or last one if we're on the first)
            mov     edx,-1
            invDEBI_next_keyboard_item()
        
        } else if (ax == enter_key || ax == grey_enter) {
          // They've selected this option
            invDEBI_lostFocus()
            mov     esi,offset disp_22
            mov     ecx,22
            invDEBI_input_clear_field()
            mov     esi,ds:screen_object
            invDEBI_screen_refresh()
            mov     edi,offset disp_22_object
            mov     ds:kbd_object,edi
            invDEBI_setFocus()
        }
        ret
    }




    function invDEBI_input_clear_field
    {
    // This routine is called to clear the contents of a field
    //
    // Upon entry:   ds:[esi] - far ptr to string
    //                    ecx - length of string
    //
    // Upon exit:    String is reset to spaces
        push    ecx
        push    esi
        while (ecx > 0)
        {
            mov     u8 ptr ds:[esi],32
            inc     esi
            dec     ecx
        }
        pop     esi
        pop     ecx
        ret
    }




    function invDEBI_checkbox_mouse_handler
    {
    // This routine is called to toggle a character from "X" to space, and back again
    //
    // Upon entry:   ds:[esi] - far ptr to screen objects
    //               ds:[edi] - far ptr to mouse objects
    //
    // Upon exit:    The data item pointed to by the mouse object is toggled
    //
        mov     ebx,u32 ptr ds:[edi+_MO_DATA]
        invDEBI_checkbox_toggle()
        ret
    }




    function invDEBI_checkbox_toggle
    {
    // This routine executes a toggle on the data item at ds:[ebx]
    //
    // Upon entry:   ds:[ebx] - The byte there is either a space or something else
    //
    // Upon exit:    If it's a space, it's changed to an 'X'
    //               If it's something else, it's changed to a space
    //               The screen is refreshed
    //
        mov     al,32
        if (byte ptr ds:[ebx] == al)
        {
          // It's a space
            mov     al,'X'
        }
        mov     u8 ptr ds:[ebx],al

      // Refresh the screen with the new data
        mov     esi,ds:screen_object
        invDEBI_screen_refresh()
        ret
    }




    function invDEBI_screen_refresh
    {
    // This routine is called when the current screen needs to be redrawn, then all keyboard objects contained within redrawn also
    //
    // Upon entry:   ds:[esi] - far ptr to screen objects to refresh
    //
    // Upon exit:    The screen is redrawn first, then any and all keyboard objects are redrawn afterwards
    //               This has the effect of rendering the victim extremely succeptable to ... er, suggestion.
    //               Oh, sorry.  Uhm, this has the effect of refreshing the current screen
    //
        pushad
        pushfd
      // Save current object
        push    ds:kbd_object

      // Save textbox items
        push    ds:textbox_x
        push    ds:textbox_y
        push    ds:textbox_offset
        push    ds:textbox_sel_end                                  // Note, only sel_end is used to determine if text is selected

      // Save checkbox items
        push    ds:checkbox_x
        push    ds:checkbox_y
        push    ds:checkbox_offset

      // Save button items
        push    ds:button_x
        push    ds:button_y
        push    ds:button_offset

      // Save function items
        push    ds:function_x
        push    ds:function_y

      // Turn off the mouse and cursor for this redisplay
        cli
        invDEBI_hide_mouse_pointer()
        invDEBI_turn_cursor_off()

      // Redraw the entire window
        mov     edi,u32 ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]
        invDEBI_draw_objects()

      // Initialize variables that might alter the appearance of the refresh
        mov     ds:textbox_offset,0
        mov     ds:textbox_sel_end,0

      // Now, redraw the displayable keyboard objects
        mov     edi,u32 ptr ds:[esi+_ST_OBJECT_KBD_OFFSET]
        while (byte ptr ds:[edi] != _END)
        {
            mov     ds:kbd_object,edi
            mov     edx,ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            add     edx,ds:[edi+_KO_X]
            mov     ebx,ds:[esi+_ST_OBJECT_UL_VERTICAL]
            add     ebx,ds:[edi+_KO_Y]
            mov     al,u8 ptr ds:[edi]
            if (al == _START)
            {
                inc     edi
                jmp     @F
            
            } else if (al == _KO_TEXTBOX) {
              // This needs redrawn
                mov     ds:textbox_x,edx
                mov     ds:textbox_y,ebx
                invDEBI_textbox_refresh()
            
            } else if (al == _KO_CHECKBOX) {
              // This needs redrawn
                movzx   eax,u8 ptr ds:[edi+_KO_X_OFFSET]
                mov     ds:checkbox_x,edx
                mov     ds:checkbox_y,ebx
                mov     ds:checkbox_offset,eax
                invDEBI_checkbox_refresh()
            
            } else if (al == _KO_BUTTON) {
              // This does not need to be redrawn
                movzx   eax,u8 ptr ds:[edi+_KO_X_OFFSET]
                mov     ds:button_x,edx
                mov     ds:button_y,ebx
                mov     ds:button_offset,eax
                invDEBI_button_refresh()
            
            } else if (al == _KO_FUNCTION) {
              // This might need to be redrawn.
              // We let the function decide that one. :)
                movzx   edx,u16 ptr ds:[edi+_KO_X_FUNCTION]
                add     edx,ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                movzx   ebx,u16 ptr ds:[edi+_KO_Y_FUNCTION]
                add     ebx,ds:[esi+_ST_OBJECT_UL_VERTICAL]
                mov     ds:function_x,edx
                mov     ds:function_y,ebx
                call    u32 ptr ds:[edi+_KO_REFRESH_FUNCTION]
            }
            add     edi,_KO_LENGTH
          @@:
        }

      // Restore function items
        pop     ds:function_y
        pop     ds:function_x

      // Restore button items
        pop     ds:button_offset
        pop     ds:button_y
        pop     ds:button_x

      // Restore checkbox items
        pop     ds:checkbox_offset
        pop     ds:button_y
        pop     ds:button_x

      // Restore textbox items
        pop     ds:textbox_sel_end
        pop     ds:textbox_offset
        pop     ds:textbox_y
        pop     ds:textbox_x

      // Restore current object
        pop     ds:kbd_object
        popfd
        popad
        ret
    }




    function invDEBI_textbox_kbd_handler
    {
    // This routine is called when there is input to process from the keyboard
    //
    // Upon entry:   eax - key
    //               ebx - flags
    //                ds - Debi's data segment
    //
    // Upon exit:    The key is either accepted and processed or ignored
    //               Note that processing might include moving to another field
    //
        if (ax == 0)
        {
            ret
        
        } else if (ax == home || ax == grey_home) {
          // They want to move to the beginning
            mov     ds:textbox_sel_end,0
            mov     ds:textbox_offset,0
        
        } else if (ax == end_key || ax == grey_end) {
            mov     ds:textbox_sel_end,0
            invDEBI_textbox_end()
        
        } else if (ax == left || ax == grey_left) {
            mov     ds:textbox_sel_end,0
            if (ds:textbox_offset > 0)
            {
                dec     ds:textbox_offset
            }
        
        } else if (ax == right || ax == grey_right) {
            mov     ds:textbox_sel_end,0
          right_key:
            mov     ecx,ds:textbox_offset
            invDEBI_textbox_get_length()
            if (ds:textbox_offset < ecx)
            {
                inc     ds:textbox_offset
            }
        
        } else if (ax == escape) {
            jmp     invDEBI_kbd_input_cancel
        
        } else if (ax == F8) {
            not     ds:insert_mode
        
        } else if (ax == backspace || ax == f5) {
            if (ds:textbox_sel_end != 0)
            {
                invDEBI_textbox_delete_selected()
                mov     ecx,ds:textbox_sel_start
                if (ecx > 0)
                {
                    dec     ecx
                }
                mov     ds:textbox_offset,ecx
            
            } else {
                if (ds:textbox_offset > 0)
                {
                    mov     ecx,ds:textbox_offset
                    mov     ds:textbox_sel_end,ecx
                    dec     ecx
                    mov     ds:textbox_sel_start,ecx
                    invDEBI_textbox_delete_selected()
                    dec     ds:textbox_offset
                }
            }
        
        } else if (ax == delete || ax == grey_delete) {
            if (ds:textbox_sel_end != 0)
            {
                invDEBI_textbox_delete_selected()
                mov     ecx,ds:textbox_sel_start
                mov     ds:textbox_offset,ecx
            
            } else {
                invDEBI_textbox_get_length()
                if (ds:textbox_offset < ecx)
                {
                    mov     ecx,ds:textbox_offset
                    mov     ds:textbox_sel_start,ecx
                    inc     ecx
                    mov     ds:textbox_sel_end,ecx
                    invDEBI_textbox_delete_selected()
                }
            }
        
        } else if (ax == tab || ax == enter_key || ax == grey_enter) {
          // Move to next item (or first one if we're on the last)
            mov     edx,1
            invDEBI_next_keyboard_item()
            jmp     do_not_refresh
        
        } else if (ax == shift_tab) {
          // Move to previous item (or last one if we're on the first)
            mov     edx,-1
            invDEBI_next_keyboard_item()
            jmp     do_not_refresh
        
        } else if (al >= 32) {
            if (ds:textbox_sel_end != 0)
            {
                invDEBI_textbox_delete_selected()
                mov     ecx,ds:textbox_sel_start
                mov     ds:textbox_offset,ecx
            }
            invDEBI_textbox_get_length()
            if (ds:textbox_offset < ecx)
            {
                invDEBI_textbox_insert()
                mov     edi,ds:kbd_object
                mov     edi,u32 ptr ds:[edi+_KO_VAR]
                mov     ecx,ds:textbox_offset
                mov     u8 ptr ds:[edi+ecx],al
                inc     ds:textbox_offset
            }
        }
        invDEBI_textbox_set_cursor()
        invDEBI_textbox_refresh()
      do_not_refresh:
        ret
    }




    function invDEBI_checkbox_kbd_handler
    {
    // This routine is called when there is input to process from the keyboard
    //
    // Upon entry:   eax - key
    //               ebx - flags
    //                ds - Debi's data segment
    //
    // Upon exit:    The key is either accepted and processed or ignored
    //               Note that processing might include moving to another field
    //
      // Rules:  X or x - Marks the checkbox to positive
      //         space or return - Toggle the checkbox setting
        mov     esi,ds:screen_object
        mov     edi,ds:kbd_object
        mov     ebx,u32 ptr ds:[edi+13]                       // Refer to DEBI\DEBI_MAC.ASP @DEBI_checkbox macro for offset
        if (al == 'X' || al == 'x')
        {
          // Time to set (we clear it here so it will toggle there)
            mov     u8 ptr ds:[ebx],32
            invDEBI_checkbox_toggle()
        
        } else if (al == 32 || al == 13) {
          // Time to toggle whatever it currently is
            invDEBI_checkbox_toggle()
        
        } else if (ax == tab) {
          // Move to next item (or first one if we're on the last)
            mov     edx,1
            invDEBI_next_keyboard_item()
        
        } else if (ax == shift_tab) {
          // Move to previous item (or last one if we're on the first)
            mov     edx,-1
            invDEBI_next_keyboard_item()
        }
        ret
    }




    function invDEBI_button_kbd_handler
    {
    // This routine is called when there is input to process from the keyboard
    //
    // Upon entry:   eax - key
    //               ebx - flags
    //                ds - Debi's data segment
    //
    // Upon exit:    The key is either accepted and processed or ignored
    //               Note that processing might include moving to another field
    //
        if (ax == tab)
        {
          // Move to next item (or first one if we're on the last)
            mov     edx,1
            invDEBI_next_keyboard_item()
        
        } else if (ax == shift_tab) {
          // Move to previous item (or last one if we're on the first)
            mov     edx,-1
            invDEBI_next_keyboard_item()
        
        } else if (ax == enter_key || ax == grey_enter) {
          // They've selected this button
            mov     edi,ds:kbd_object
            call    u32 ptr ds:[edi+_KO_FUNC]
        }
        ret
    }




    function invDEBI_next_keyboard_item
    {
    // This routine is used to move to the next or previous item (depending on the value in edx)
    //
    // Upon entry:   edx - Direction to move, 1=Next item, -1=Previous item
    //
    // Upon exit:    kbd_object - updated
    //                kbd_focus - updated
        pushad
        if (edx == -1)
        {
            mov     edx,-_KO_LENGTH
        
        } else {
            mov     edx,_KO_LENGTH
        }
        mov     edi,ds:kbd_object
        mov     ds:save_kbd_object,edi
        mov     esi,ds:screen_object
        mov     ebx,u32 ptr ds:[esi+_ST_OBJECT_KBD_OFFSET]
      // Right now, ds:[esi] - far ptr to the current screen object
      //            ds:[edi] - far ptr to the current KBD object
      //            ds:[ebx] - far ptr to the first KBD object
      //                 edx - direction to go
        invDEBI_lostFocus()                                   // Current item loses focus
      @@:
      // Move to the next object
        if (byte ptr ds:[edi] != _START)
        {
            add     edi,edx
        
        } else {
            if (edx == -_KO_LENGTH)
            {
              // Go backwards to previous item
                add     edi,edx
            
            } else {
              // Go forward to next item (since it's _START, we only move forward 1 byte)
                inc     edi
            }
        }
      // Now, see if we've gone too far
        if (edi < ebx)
        {
          // We've gone passed the top, so we start back over at the end
            mov     edi,ebx
            while (byte ptr ds:[edi] != _END)
            {
                if (byte ptr ds:[edi] == _START)
                {
                    inc     edi
                
                } else {
                    add     edi,_KO_LENGTH
                }
            }

            sub     edi,_KO_LENGTH
            jmp     @B
        
        } else if (byte ptr ds:[edi] == _END) {
          // We're at the end, so we start back over
            mov     edi,ebx
            jmp     @B
        }
      // We've found the next item
        mov     ds:kbd_object,edi
        invDEBI_setFocus()
        popad
        ret
    }




    function invDEBI_textbox_insert
    {
    // This routine is called to insert a space (if we're in insert mode)
    //
    // Upon entry:   ecx - Current textbox length
    //
    // Upon exit:    A space is inserted at the current location if in insert mode
    //
        if (ds:insert_mode != 0 && ecx != 1)
        {
          // We're in insert mode
            pushfd
            pushad
            push    es
          // Copy from ds:[esi] to es:[edi]
          // We're doing this backwards, so we start at the end of the string
            mov     es,ds:data_segment
            dec     ecx
            mov     esi,ds:kbd_object
            mov     edi,u32 ptr ds:[esi+_KO_VAR]
            add     edi,ecx
            mov     esi,edi
            dec     esi
            sub     ecx,ds:textbox_offset
          // Right now, ds:[esi] - far ptr to character before the last one in the string
          //            es:[edi] - far ptr to last string
          //                 ecx - # of characters to copy
            std
            rep     movsb

            pop     es
            popad
            popfd
        }
        ret
    }




    function invDEBI_textbox_delete_selected
    {
    // This routine is used to delete the selected text from the current textbox string
    //
    // Upon entry:   ds:textbox_sel_start - start of selected text
    //               ds:textbox_sel_end   - end of selected text
    //
    // Upon exit:    The string is updated and the
    //
        if (ds:textbox_sel_end == 0)
        {
            ret
        }

      // There is text that's selected, let's delete it
        pushfd
        pushad
        push    es
        mov     es,ds:data_segment
        mov     esi,ds:kbd_object
        mov     edi,u32 ptr ds:[esi+_KO_VAR]
        add     edi,ds:textbox_sel_start
        mov     esi,edi
        add     esi,ds:textbox_sel_end
        sub     esi,ds:textbox_sel_start

      // Right now, ds:[edi] - far ptr to string
      // Copy the text over the selected portion
        invDEBI_textbox_get_length()
        sub     ecx,ds:textbox_sel_end
        cld
        rep     movsb

      // Pad with spaces to the end
        mov     al,32
        while (byte ptr es:[edi] != 0)
        {
            stosb
        }

        pop     es
        popad
        popfd
        mov     ds:textbox_sel_end,0
        ret
    }




    function invDEBI_setFocus
    {
    // This routine is called to set focus on a particular item
    //
    // Upon entry:   ds:kbd_object - far ptr to object that should have kbd focus
    //            ds:screen_object - far ptr to screen object
    //
    // Upon exit:    Cursor is flashing at the appropriate location
    //               Keyboard input is routed to the appropriate handler
    //               Other unique-to-type-of-data settings are established
    //
        mov     esi,ds:screen_object
        mov     edi,ds:kbd_object
        pushfd
        cli
        invDEBI_hide_mouse_pointer()
        invDEBI_turn_cursor_off()

      // Determine where the item will be displayed
        mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        add     edx,u32 ptr ds:[edi+_KO_X]
        mov     ebx,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        add     ebx,u32 ptr ds:[edi+_KO_Y]
        mov     al,u8 ptr ds:[edi]
        if (al == _KO_TEXTBOX)
        {
            mov     ds:textbox_x,edx
            mov     ds:textbox_y,ebx
            invDEBI_textbox_end()                             // Position the cursor at the end of the line
            mov     ecx,ds:textbox_offset                           // Select everything on a setFocus
            mov     ds:textbox_sel_start,0                          //   (so if they press a key all is replaced)
            mov     ds:textbox_sel_end,ecx
            invDEBI_textbox_refresh()
            mov     ds:kbd_focus,offset invDEBI_textbox_kbd_handler     // Set the keyboard focus to the correct handler
            invDEBI_textbox_activate()
        
        } else if (al == _KO_CHECKBOX) {
          // It's a checkbox item
            movzx   eax,u8 ptr ds:[edi+_KO_X_OFFSET]
            mov     ds:checkbox_x,edx
            mov     ds:checkbox_y,ebx
            mov     ds:checkbox_offset,eax
            mov     ds:kbd_focus,offset invDEBI_checkbox_kbd_handler    // Set the keyboard focus to the correct handler
            invDEBI_checkbox_activate()
        
        } else if (al == _KO_BUTTON) {
          // It's a button
            movzx   eax,u8 ptr ds:[edi+_KO_X_OFFSET]
            mov     ds:button_x,edx
            mov     ds:button_y,ebx
            mov     ds:button_offset,eax
            mov     ds:kbd_focus,offset invDEBI_button_kbd_handler      // Set the keyboard focus to the correct handler
            invDEBI_button_activate()
        
        } else if (al == _KO_FUNCTION) {
          // It's a special function
            movzx   edx,u16 ptr ds:[edi+_KO_X_FUNCTION]
            add     edx,ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            movzx   ebx,u16 ptr ds:[edi+_KO_Y_FUNCTION]
            add     ebx,ds:[esi+_ST_OBJECT_UL_VERTICAL]
            mov     ds:function_x,edx
            mov     ds:function_y,ebx
            mov     eax,u32 ptr ds:[edi+_KO_KBD_FUNCTION]
            mov     ds:kbd_focus,eax
            invDEBI_function_set_cursor()
            call    u32 ptr ds:[edi+_KO_ACTIVATE_FUNCTION]
        }
        mov     ds:force_cursor_off,0
        popfd
        ret
    }




    function invDEBI_object_setFocus
    {
    // This routine is used when any button of a mouse is clicked in an area of a keyboard object (focus needs to be set there)
    //
    // Upon entry:   ds:[esi] - far ptr to screen objects
    //               ds:[edi] - far ptr to mouse object (* Note: The references below relate to offsets for the @AnyClick macro)
    //
    // Upon exit:    Whatever item currently has the focus loses it
    //               Whatever item they clicked on gets the focus (* Note: Could be the same thing)
    //
        push    eax
        push    ebx

      // See if we're moving to the same item
        mov     eax,ds:kbd_focus
        mov     ebx,u32 ptr ds:[edi+_MO_DATA]
        if (ebx != eax)
        {
          // It's a different one
            invDEBI_lostFocus()
            mov     ds:kbd_object,ebx
            invDEBI_setFocus()
        }

        pop     ebx
        pop     eax
        ret
    }




    function invDEBI_lostFocus
    {
    // This routine is called when the current item is about to lose focus
    //
    // Upon entry:   ds:kbd_object - far ptr to object that should have kbd focus
    //            ds:screen_object - far ptr to screen object
    //
    // Upon exit:    Cursor is flashing at the appropriate location
    //               Keyboard input is routed to the appropriate handler
    //               Other unique-to-type-of-data settings are established
    //
        pushad
        pushfd
        mov     esi,ds:screen_object
        mov     edi,ds:kbd_object
        cli
        invDEBI_hide_mouse_pointer()
        invDEBI_turn_cursor_off()

      // Determine where the item will be displayed
        mov     edx,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        add     edx,u32 ptr ds:[edi+_KO_X]
        mov     ebx,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        add     ebx,u32 ptr ds:[edi+_KO_Y]
        mov     al,u8 ptr ds:[edi]
        if (al == _KO_TEXTBOX && ds:textbox_sel_end != 0)
        {
          // During a lose focus we basically just un-higlight everything on the current item that's higlighted
            mov     ds:textbox_x,edx
            mov     ds:textbox_y,ebx
            mov     ds:textbox_sel_end,0                            // Force a deselect of anything on this item
            invDEBI_textbox_refresh()
        }
        popfd
        popad
        ret
    }




    function invDEBI_textbox_end
    {
    // This routine is called to move to the end of the current textbox
    //
    // Upon entry:   Nothing
    //
    // Upon exit:    textbox_offset - updated with new position
    //
        pushad

        invDEBI_textbox_get_length()
      // Now, move backwards to the first non-space
        mov     edi,ds:kbd_object
        mov     edx,u32 ptr ds:[edi+_KO_VAR]
        while (byte ptr ds:[edx+ecx-1] == 32 && ecx > 0)
        {
            dec     ecx
        }
        mov     ds:textbox_offset,ecx

        popad
        ret
    }




    function invDEBI_textbox_get_length
    {
    // This routine is used to get the length of the curren textbox item
    //
    // Upon entry:   ds - data_segment
    //
    // Upon exit:    ecx - length
    //
        push    edi
        push    edx

      // Move to the end of the variable (to find out how long it is)
        mov     edi,ds:kbd_object
        mov     edx,u32 ptr ds:[edi+_KO_VAR]
        xor     ecx,ecx
        while (byte ptr ds:[edx+ecx] != 0)
        {
            inc     ecx
        }

        pop     edx
        pop     edi
        ret
    }




    function invDEBI_force_lowercase_ds_edx
    {
    // This routine is used to force the null-terminated string at ds:[edx]
    //
    // Upon entry:   ds:[edx] - far ptr to null-terminated string
    //
    // Upon exit:    The string is forced to lower-case
    //
        push    edx
        push    eax

        while (byte ptr ds:[edx] != 0)
        {
            mov     al,u8 ptr ds:[edx]
            if (al >= 'A' && al <= 'Z')
            {
              // It is upper-case, let's lower the bad boy
                sub     u8 ptr ds:[edx],20h
            }
            inc     edx
        }

        pop     eax
        pop     edx
        ret
    }




    function invDEBI_textbox_refresh
    {
    // This routine is called to refresh the textbox item
    //
    // Upon entry:   ds:kbd_object - set to textbox object to refresh
    //               ds:textbox_* variables
    //
    // Upon exit:    The item is refreshed
    //
        pushad
        pushfd
        cli
        invDEBI_hide_mouse_pointer()
        invDEBI_turn_cursor_off()

        mov     edi,ds:kbd_object
        mov     eax,ds:textbox_x
        mov     ebx,ds:textbox_y
        mov     edx,u32 ptr ds:[edi+_KO_VAR]
      // Right now, eax - X coord
      //            ebx - Y coord
      //            edx - offset to variable
        push    eax                                                 // horizontal
        push    ebx                                                 // vertical
        push    edx                                                 // offset to variable
        call    u48 ptr ds:_VID_g_mono_display_text               //

        if (ds:textbox_sel_end != 0)
        {
          // Now, re-draw the selected portion only in reverse video
            mov     ecx,ds:textbox_sel_start
            while (ecx > 0)
            {
                inc     edx
                add     eax,FONT_X
                dec     ecx
            }
            mov     esi,offset trash_string
            mov     ecx,ds:textbox_sel_end
            sub     ecx,ds:textbox_sel_start
            push    eax
            while (ecx > 0)
            {
                mov     al,u8 ptr ds:[edx]
                mov     u8 ptr ds:[esi],al
                inc     edx
                inc     esi
                dec     ecx
            }
            pop     eax
            mov     u8 ptr ds:[esi],0
            push    0                                               // Write operation (0-overlay)
            push    eax                                             // horizontal
            push    ebx                                             // vertical
            push    1                                               // Display mode (1-reverse)
            push    u32 ptr offset trash_string
            call    u48 ptr ds:_VID_g_mono_display_text_mode
        }

        popfd
        popad
        ret
    }




    function invDEBI_textbox_activate
    {
    // This routine is used to activate a textbox item (basically it puts the cursor where it should be)
    //
    // Upon entry:   ds:textbox_offset - set to the offset in the textbox from the current item
    //                    ds:textbox_x - set based on the current item
    //                    ds:textbox_y - set based on the current item
    //
    // Upon exit:    ds:cursor_x - updated
    //               ds:cursor_y - updated
    //
        invDEBI_textbox_set_cursor()
        ret
    }




    function invDEBI_textbox_set_cursor
    {
    // This routine is used to put the cursor at the correction locaiton on the screen
    //
    // Upon entry:   ds:textbox_offset - offset into the current textbox item
    //                    ds:textbox_x - textbox item's X coordinate for left-most character
    //                    ds:textbox_y - textbox item's Y coordinate for left-most character
    //
    // Upon exit:    ds:cursor_x - updated
    //               ds:cursor_y - updated
    //
        pushad
        mov     eax,ds:textbox_offset
        mov     ebx,FONT_X
        mul     ebx
        add     eax,ds:textbox_x
        mov     ds:cursor_x,eax
        mov     ebx,ds:textbox_y
        mov     ds:cursor_y,ebx
        popad
        ret
    }




    function invDEBI_checkbox_refresh
    {
    // This routine is called to refresh the checkbox item
    //
    // Upon entry:   ds:kbd_object - set to checkbox object to refresh
    //               ds:checkbox_* variables
    //
    // Upon exit:    The item is refreshed
    //
        ret
    }




    function invDEBI_checkbox_activate
    {
    // This routine is used to activate a checkbox item (basically it puts the cursor where it should be)
    //
    // Upon entry:   ds:checkbox_x - set based on the current item
    //               ds:checkbox_y - set based on the current item
    //
    // Upon exit:    ds:cursor_x - updated
    //               ds:cursor_y - updated
    //
        pushad
        mov     eax,ds:checkbox_offset
        mov     ebx,FONT_X
        mul     ebx
        add     eax,ds:checkbox_x
        mov     ds:cursor_x,eax
        mov     eax,ds:checkbox_y
        mov     ds:cursor_y,eax
        popad
        ret
    }




    function invDEBI_button_refresh
    {
    // This routine is called to refresh the button item
    //
    // Upon entry:   ds:kbd_object - set to button object to refresh
    //               ds:button_* variables
    //
    // Upon exit:    The item is refreshed
    //
        ret
    }




    function invDEBI_button_activate
    {
    // This routine is used to activate a button item (basically it puts the cursor where it should be)
    //
    // Upon entry:   ds:button_x - set based on the current item
    //               ds:button_y - set based on the current item
    //
    // Upon exit:    ds:cursor_x - updated
    //               ds:cursor_y - updated
    //
        pushad
        mov     eax,ds:button_offset
        mov     ebx,FONT_X
        mul     ebx
        add     eax,ds:button_x
        mov     ds:cursor_x,eax
        mov     eax,ds:button_y
        mov     ds:cursor_y,eax
        popad
        ret
    }




    function invDEBI_function_set_cursor
    {
    // This routine is used to position the cursor on an item handled by a function
    //
    // Upon entry:   ds:function_x - set based on the current item
    //               ds:function_y - set based on the current item
    //
    // Upon exit:    ds:cursor_x - updated
    //               ds:cursor_y - updated
    //
        push    eax
        mov     eax,ds:function_x
        mov     ds:cursor_x,eax
        mov     eax,ds:function_y
        mov     ds:cursor_y,eax
        pop     eax
        ret
    }




    function invDEBI_kbd_input_cancel
    {
    // Note, one flaw in Debi's internal design is that multiple layes of input cannot be nested
    // There is only the top level (which is the main Debi screen that comes up when debugging)
    // and then there's the programmable level (which is whatever popup is being used)
    // That's why you see the "mov ds:object_mode,0" line below.  This puts Debi back into its top level object processing.
        pushfd
        cli

      // Cancel the focus
        mov     ds:kbd_focus,-1

      // Turn off the mouse, cursor and restore the screen
        invDEBI_hide_mouse_pointer()
        invDEBI_turn_cursor_off()
        mov     ds:force_cursor_off,1
        invDEBI_restore_screen2()

      // Cancel the popup mode
        mov     ds:object_mode,0
        popfd
        ret
    }




    function invDEBI_exp_screen_ok
    {
    // This routine is used when they click on the address expression window's OK button
    //
    // Upon entry:   ds:[esi] - far ptr to screen object
    //               ds:[edi] - far ptr to mouse object (the OK button object)
    //
    // Upon exit:    The address is parsed, if valid then it's encoded into the desired location and input is terminated
    //               If it's invalid, then they're not allowed to click OK (an invalid message appears in the Quick Watch
    //                                area and editing continues)
    //
    //-----
    // The allowable formats are:
    //   1 - exp                     - exp linear memory address
    //   2 - exp:exp                 - exp relative address in specified reg1 segment
    // Expressions can be:
    //   [const/reg] [*-/+] [const/reg] [*-/+] [const/reg]
    //
        push    es
        pushad
        mov     ebx,_sDEBI_memory
        mov     es,ebx

        mov     esi,offset text_22
        mov     ecx,sizeof text_22 - 1
        invDEBI_parse_expression()
        if (!carry?)
        {
            mov     esi,offset disp_22
            mov     ecx,sizeof disp_22 - 1
            invDEBI_parse_expression()
            if (!carry?)
            {
              // The expression is parsable
                mov     edi,ds:exp_esi
                mov     edi,u32 ptr ds:[edi+_ST_MEMVAR_OFFSET]
                mov     ebx,offset DEBI_exp_memvar_list
                invDEBI_into_object_memvar()
                invDEBI_kbd_input_cancel()

              // Now, refresh the screen with the new changes they've made
                movzx   eax,ds:force_screen_redraw
                push    eax
                movzx   eax,ds:force_func_windows
                push    eax
                mov     ds:force_screen_redraw,_YES
                mov     ds:force_func_windows,_YES
                mov     esi,ds:exp_esi                                          // Screen
                mov     edi,u32 ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]         // Object data
                invDEBI_draw_objects()
                pop     eax
                mov     ds:force_func_windows,al
                pop     eax
                mov     ds:force_screen_redraw,al
            }
        }
        popad
        pop     es
        ret
    }




    function invDEBI_into_object_memvar
    {
    // This routine is used to copy from local variables into an object's MEMVAR location
    //
    // Upon entry:   ds:[ebx] - far ptr to variable listing
    //               es:[edi] - far ptr to destination memory location
    //
    // Upon exit:    Data is copied
    //
        pushfd
        pushad
        cld
        while (dword ptr ds:[ebx+_MEMVAR_MEMORY_VARIABLE] != -1)
        {
            mov     esi,u32 ptr ds:[ebx+_MEMVAR_MEMORY_VARIABLE]
            mov     ecx,u32 ptr ds:[ebx+_MEMVAR_LENGTH]
            rep     movsb
            add     ebx,_MEMVAR_STRUCT_LENGTH
        }
        popad
        popfd
        ret
    }




    function invDEBI_from_object_memvar
    {
    // This routine is used to copy from an object's MEMVAR location to local variables
    //
    // Upon entry:   ds:[ebx] - far ptr to variable listing
    //               es:[esi] - far ptr to source memory location
    //
    // Upon exit:    Data is copied
    //
        pushfd
        pushad
        cld
        while (dword ptr ds:[ebx+_MEMVAR_MEMORY_VARIABLE] != -1)
        {
            mov     edi,u32 ptr ds:[ebx+_MEMVAR_MEMORY_VARIABLE]
            mov     ecx,u32 ptr ds:[ebx+_MEMVAR_LENGTH]
          // Copy from _sDEBI_memory memory location to variable
            while (ecx > 0)
            {
                mov     al,u8 ptr es:[esi]
                mov     u8 ptr ds:[edi],al
                inc     esi
                inc     edi
                dec     ecx
            }
            add     ebx,_MEMVAR_STRUCT_LENGTH
        }
        popad
        popfd
        ret
    }




    function invDEBI_parse_expression
    {
    // This routine is used to parse the text expression into a segment and offset
    //
    // Upon entry:   ds:[esi] - far ptr to address expression (has been lower-cased)
    //                    ecx - length
    //
    // Upon exit:    carry? - SET if error, CLEAR if OK
    //               +Â- SET
    //                | eax - error code if error
    //                +- CLEAR
    //                  eax - segment to use
    //                  ebx - offset if no error
    //
        if (byte ptr ds:[esi] == 32)
        {
          // Nothing to do, default to ds:0x0
            clc
            mov     eax,u32 ptr [ebp+_STACK_DS]
            xor     ebx,ebx
            ret
        
        } else if (ecx < 2) {
          // Not enough space to do anything
            stc
            ret
        }
        push    fs
        mov     fs,cs:data_segment

      // Initialize default values (in case they don't specify portions)
      // Note, that this algorithm assumes a segment override won't be specified and stores the calculation in offset_to_use
      //       until a ":" is found, at which time it is copied and the seg_specified variable is raised
        mov     fs:seg_specified,_NO                                // The default condition is "they haven't specified a data seg"
        mov     fs:last_operator,_NONE
        mov     ebx,u32 ptr [ebp+_STACK_DS]                    // The default segment is DS
        mov     fs:seg_to_use,ebx
        mov     fs:offset_to_use,0
        while (ecx > 0)
        {
            mov     ax,u16 ptr ds:[esi]
            if (al == 32)
            {
                inc     esi
                dec     ecx
            
            } else if (al == ':') {
              // It's the end of the segment section
                if (fs:seg_specified == _YES)
                {
                  // It's a syntax error (they've already specified something)
                    stc
                    jmp     quit_in_error
                }
                mov     fs:seg_specified,_YES
                mov     ebx,fs:offset_to_use
                mov     fs:seg_to_use,ebx
                inc     esi
                dec     ecx
            
            } else if (al == '+') {
                mov     al,_ADDITION
                jmp     skip_past_operator_byte
            
            } else if (al == '*') {
                mov     al,_MULTIPLICATION
                jmp     skip_past_operator_byte
            
            } else if (al == '/') {
                mov     al,_DIVISION
                jmp     skip_past_operator_byte
            
            } else if (al == '-') {
                mov     al,_SUBTRACTION
              skip_past_operator_byte:
                if (fs:last_operator != _NONE)
                {
                  // it's a syntax error (they've already specified an operator, but nothing to operate against)
                    stc
                    jmp     quit_in_error
                }
                mov     fs:last_operator,al
                inc     esi
                dec     ecx
            
            } else if (ecx > 2) {
                if (ax == '>>')
                {
                    mov     al,_SHIFT_RIGHT
                    jmp     skip_past_operator_word
                
                } else if (ax == '<<') {
                    mov     al,_SHIFT_LEFT
                  skip_past_operator_word:
                    if (fs:last_operator != _NONE)
                    {
                      // It's a syntax error (they've already specified an operator, but nothing to operate against)
                        stc
                        jmp     quit_in_error
                    }
                    mov     fs:last_operator,al
                    add     esi,2
                    sub     ecx,2
                
                } else if (ax == 'x0') {
                  // It's a hexadecimal constant
                    invDEBI_parse_hexadecimal_constant()
                    jmp     process_operator
                
                } else if (ax == 'y0') {
                  // It's a binary constant
                    invDEBI_parse_binary_constant()
                    jmp     process_operator
                
                } else if (ax == 'd0') {
                  // It's a decimal constant
                    invDEBI_parse_decimal_constant()
                    jmp     process_operator
                
                } else if (ax == 'o0') {
                  // It's an octal constant
                    invDEBI_parse_octal_constant()
                  process_operator:
                    if (fs:last_operator == _NONE)
                    {
                      // Ok, we just store it
                        mov     fs:offset_to_use,ebx
                    
                    } else {
                      // We have to operate on it
                        if (fs:last_operator == _ADDITION)
                        {
                            add     fs:offset_to_use,ebx
                        
                        } else if (fs:last_operator == _SUBTRACTION) {
                            sub     fs:offset_to_use,ebx
                        
                        } else if (fs:last_operator == _MULTIPLICATION) {
                            mov     eax,fs:offset_to_use
                            mul     ebx
                            mov     fs:offset_to_use,eax
                        
                        } else {
                          // It must be a division
                            if (ebx == 0)
                            {
                              // It's division by 0, error
                                stc
                                jmp     quit_in_error
                            }
                            mov     eax,fs:offset_to_use
                            xor     edx,edx
                            div     ebx
                            mov     fs:offset_to_use,eax
                        }
                        mov     fs:last_operator,_NONE
                    }
                
                } else {
                  // It must be a keyword
                    invDEBI_search_regs()
                    jnz     process_operator                        // Branch if found
                    invDEBI_search_keywords()
                    jnz     process_operator                        // Branch if found
                    stc
                    jmp     quit_in_error
                }
            
            } else {
              // No idea
                stc
                jmp     quit_in_error
            }
          next_part:
        }

      quit:
        mov     eax,fs:seg_to_use
        mov     ebx,fs:offset_to_use
        clc
      quit_in_error:
        pop     fs
        ret
    }




    function invDEBI_parse_hexadecimal_constant
    {
    // This routine is used to convert a hexadecimal number
    //
    // Upon entry:   ds:[esi] - far ptr to source (known to be lower-cased)
    //                    ecx - maximum number of chars left
    //
    // Upon exit:    ebx - converted value
    //               ds:[esi] - new ptr to first character after the number
    //
        add     esi,2                                               // Skip passed the "0x" part
        sub     ecx,2                                               // Decrease the count by the number of bytes in the "0x" part
        xor     edx,edx                                             // Initialize our output variable
        xor     ebx,ebx
        while (ecx > 0 && edx < 8)                                 // When edx == 8, we've loaded 8 characters (which account for
        {
            movzx   eax,u8 ptr ds:[esi]                           //                            all nibbles in a 32-bit quantity)
            if (al >= '0' && al <= '9')
            {
                sub     al,'0'                                      // It's 0-9
            
            } else if (al >= 'a' && al <= 'f') {
                sub     al,'a'                                      // It's a-f
            
            } else {
              // We're past the last character, we're done
                jmp     quit                                        // It's something else
            }
            shl     ebx,4                                           // Make room for the nibble
            or      ebx,eax                                         // Stick in in there

            dec     ecx                                             // Decrease count
            inc     esi                                             // Increase offset
            inc     edx                                             // Increase # of characters skipped
        }

      quit:
        ret
    }




    function invDEBI_parse_decimal_constant
    {
    // This routine is used to convert a decimal number
    //
    // Upon entry:   ds:[esi] - far ptr to source
    //                    ecx - maximum number of chars left
    //
    // Upon exit:    ebx - converted value
    //               ds:[esi] - new ptr to first character after the number
    //
        add     esi,2                                               // Skip passed the "0d" part
        sub     ecx,2                                               // Decrease the count by the number of bytes in the "0d" part
        xor     edx,edx                                             // Initialize our output variable
        xor     ebx,ebx
        while (ecx > 0 && edx < 10)                                // When edx == 10, we've loaded 10 characters (which account for
        {
            movzx   eax,u8 ptr ds:[esi]                           //                      all base-10 nibbles in a 32-bit quantity)
            if (al >= '0' && al <= '9')
            {
                sub     al,'0'                                      // Convert from ASCII to base-0 numeric
                push    eax
                push    ebx
                push    edx

                mov     eax,ebx                                     // Multiply by 10
                mov     ebx,10
                mul     ebx

                pop     edx
                pop     ebx
                mov     ebx,eax
                pop     eax
                add     ebx,eax
            
            } else {
              // We're past the last character, we're done
                jmp     quit                                        // It's something else
            }

            dec     ecx                                             // Decrease count
            inc     esi                                             // Increase offset
            inc     edx                                             // Increase # of characters skipped
        }

      quit:
        ret
    }




    function invDEBI_parse_octal_constant
    {
    // This routine is used to convert an octal number
    //
    // Upon entry:   ds:[esi] - far ptr to source
    //                    ecx - maximum number of chars left
    //
    // Upon exit:    ebx - converted value
    //               ds:[esi] - new ptr to first character after the number
    //                    edx - chars moved
    //
        add     esi,2                                               // Skip passed the "0o" part
        sub     ecx,2                                               // Decrease the count by the number of bytes in the "0o" part
        xor     edx,edx                                             // Initialize our output variable
        xor     ebx,ebx
        while (ecx > 0 && edx < 11)                                // When edx == 11, we've loaded 11 characters (which account for
        {
            movzx   eax,u8 ptr ds:[esi]                           //                        all octal-nibbles in a 32-bit quantity)
            if (al >= '0' && al <= '7')
            {
                sub     al,'0'                                      // It's 0-7
            
            } else {
              // We're past the last character, we're done
                jmp     quit                                        // It's something else
            }
            shl     ebx,3                                           // Make room for the nibble
            or      ebx,eax                                         // Stick in in there

            dec     ecx                                             // Decrease count
            inc     esi                                             // Increase offset
            inc     edx                                             // Increase # of characters skipped
        }

      quit:
        ret
    }




    function invDEBI_parse_binary_constant
    {
    // This routine is used to convert a binary number
    //
    // Upon entry:   ds:[esi] - far ptr to source
    //                    ecx - maximum number of chars left
    //
    // Upon exit:    ebx - converted value
    //               ds:[esi] - new ptr to first character after the number
    //                    edx - chars moved
    //
        add     esi,2                                               // Skip passed the "0y" part
        sub     ecx,2                                               // Decrease the count by the number of bytes in the "0y" part
        xor     edx,edx                                             // Initialize our output variable
        xor     ebx,ebx
        while (ecx > 0 && edx < 32)                                // When edx == 32, we've loaded 32 characters (which account for
        {
            movzx   eax,u8 ptr ds:[esi]                           //                                 all bits in a 32-bit quantity)
            if (al >= '0' && al <= '1')
            {
                sub     al,'0'                                      // It's 0-1
            
            } else {
              // We're past the last character, we're done
                jmp     quit                                        // It's something else
            }
            shl     ebx,1                                           // Make room for the nibble
            or      ebx,eax                                         // Stick in in there

            dec     ecx                                             // Decrease count
            inc     esi                                             // Increase offset
            inc     edx                                             // Increase # of characters skipped
        }

      quit:
        ret
    }




    function invDEBI_search_regs
    {
    // This routine is used to search the registers for a match
    //
    // Upon entry:   ds:[esi] - far ptr to source
    //                    ecx - maximum number of chars left in string
    //
    // Upon exit:       zero? - SET if not found, CLEAR if found
    //                    ebx - converted value (from the derived expression)
    //               ds:[esi] - new ptr to first character after the found text (if any where found)
    //                    ecx - new value
    //
        push    edi
        push    eax
        sub     esp,12
      // [esp+8], dword, original value of esp
      // [esp+4], dword, length of current item in reg_list
      // [esp+0], dword, hold value for reg_list pointer
        mov     u32 ptr [esp+8],esp
        add     u32 ptr [esp+8],12

        mov     edi,offset reg_list
        while (byte ptr fs:[edi] != -1)
        {
            mov     u32 ptr [esp+0],edi                        // Save pointer
            movzx   edx,u8 ptr fs:[edi]                           // Load length
            mov     u32 ptr [esp+4],edx                        // Save length
            inc     edi                                             // Move passed length
            xor     edx,edx                                         // Reset counter
            while (edx < u32 ptr [esp+4])                     // Continue for length
            {
                mov     al,u8 ptr ds:[esi+edx]                    // Compare source
                mov     ah,u8 ptr fs:[edi+edx]                    //   to list
                invDEBI_force_lowercase_ah_al()
                if (ah != al)
                {
                    jmp     next                                    // Branch if they don't match
                }
                inc     edx
            }
          // We've found a match
            mov     al,u8 ptr fs:[edi+edx]                        // Load the byte immediately after
            movsx   ebx,u8 ptr fs:[edi+edx+1]                     // Load the byte immediately after that
          // Right now, eax is hte byte after the found item.  It is a pointer into the stack indicating where we should get our value.
            if (al >= _CS && al <= _ECODE)
            {
              // It's a 32-bit reference
                mov     ebx,u32 ptr [ebp+ebx]
            
            } else if (al >= _AL && al <= _DH) {
              // It's an 8-bit reference
                movzx   ebx,u8 ptr [ebp+ebx]
            
            } else {
              // It's a 16-bit reference
                movzx   ebx,u16 ptr [ebp+ebx]
            }
            add     esi,u32 ptr [esp+4]
            sub     ecx,u32 ptr [esp+4]
          // We're done
            or      eax,1                                           // Lower ZERO?
            jmp     quit

          next:
            mov     edi,u32 ptr [esp+0]                        // get original pointer back
            add     edi,u32 ptr [esp+4]                        // for item
            add     edi,3                                           // for overhead
        }
        sub     eax,eax                                             // Set ZERO?

      quit:
        mov     esp,u32 ptr [esp+8]                            // This doesn't affect the ZERO? flag (as an add esp,12 would)
        pop     eax
        pop     edi
        ret
    }




    function invDEBI_search_keywords
    {
    // This routine is used to search the keywords for a match
    //
    // Upon entry:   ds:[esi] - far ptr to source
    //                    ecx - maximum number of chars left in string
    //
    // Upon exit:       zero? - SET if not found, CLEAR if found
    //                    ebx - converted value
    //               ds:[esi] - new ptr to first character after the number
    //                    ecx - new value
    //
        push    edi
        push    eax
        sub     esp,12
      // [esp+8], dword, original value of esp
      // [esp+4], dword, length of current item in reg_list
      // [esp+0], dword, hold value for reg_list pointer
        mov     u32 ptr [esp+8],esp
        add     u32 ptr [esp+8],12

        mov     edi,offset keyword_listing
        while (byte ptr fs:[edi] != -1)
        {
            mov     u32 ptr [esp+0],edi                        // Save pointer
            movzx   edx,u8 ptr fs:[edi]                           // Load length
            mov     u32 ptr [esp+4],edx                        // Save length
            inc     edi                                             // Move passed length
            xor     edx,edx                                         // Reset counter
            while (edx < u32 ptr [esp+4])                     // Continue for length
            {
                mov     al,u8 ptr ds:[esi+edx]                    // Compare source
                mov     ah,u8 ptr fs:[edi+edx]                    //   to list
                invDEBI_force_lowercase_ah_al()
                if (ah != al)
                {
                    jmp     next                                    // Branch if they don't match
                }
                inc     edx
            }
          // We've found a match
            movsx   ebx,u16 ptr fs:[edi+edx+1]                     // Load the word immediately after the trailing NULL
            add     esi,u32 ptr [esp+4]
            sub     ecx,u32 ptr [esp+4]
          // We're done
            or      eax,1                                           // Lower ZERO?
            jmp     quit

          next:
            mov     edi,u32 ptr [esp+0]                        // get original pointer back
            add     edi,u32 ptr [esp+4]                        // for item
            add     edi,4                                           // for overhead
        }
        sub     eax,eax                                             // Set ZERO?

      quit:
        mov     esp,u32 ptr [esp+8]                            // This doesn't affect the ZERO? flag (as an add esp,12 would)
        pop     eax
        pop     edi
        ret
    }




    function invDEBI_force_lowercase_ah_al
    {
    // This routine is used to force the characters in ah and al to lower-case
    //
    // Upon entry:   ah - character
    //               al - character
    //
    // Upon exit:    ah and al are lower-cased (if they're letters)
    //
        if (ah >= 'A' && ah <= 'Z')
        {
            or      ah,20h
        }
        if (al >= 'A' && al <= 'Z')
        {
            or      al,20h
        }
        ret
    }
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// END - 99999 - Keyboard events
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=










//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// AAAAA - INCLUDE files
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    // invDEBI_cfsca_1_window()
    // invDEBI_cfsca_2_window()
    // invDEBI_cfsca_3_window()
    // invDEBI_cfsca_1_click()
    // invDEBI_cfsca_2_click()
    // invDEBI_cfsca_3_click()
    #include "cfsca.asp"


    // Algorithms still being worked on (or slated to be completed at some point in the future)
    #include "todo.asp"


    // iDEBI_open_file()
    // iDEBI_close_file()
    // iDEBI_read_file()
    // iDEBI_write_file()
    // iDEBI_search_file()
    #include "disk.asp"
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// END - AAAAA - INCLUDE files
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=










//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// BBBBB - Interrupt handlers
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    function invDEBI_int0_handler
    {
        push    0                                                   // Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int0_text
        jmp     DEBI_debug

    // * Note: Each of these handlers never return from these procedure.  They call DEBI which will then execute the
    //         appropriate action
    }




    function invDEBI_int1_handler
    {
        push    0                                                   // Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int1_text
        jmp     DEBI_debug
    }




    function invDEBI_int2_handler
    {
        push    0                                                   // Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int2_text
        jmp     DEBI_debug
    }




    function invDEBI_int3_handler
    {
        push    0                                                   // Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int3_text
        jmp     DEBI_debug
    }




    function invDEBI_int4_handler
    {
        push    0                                                   // Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int4_text
        jmp     DEBI_debug
    }




    function invDEBI_int5_handler
    {
        push    0                                                   // Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int5_text
        jmp     DEBI_debug
    }




    function invDEBI_int6_handler
    {
        push    0                                                   // Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int6_text
        jmp     DEBI_debug
    }




    function invDEBI_int7_handler
    {
    // This interrupt should only be called when the user is single-stepping through their code and they go from one task
    // to another.  Under those circumstances the operating system hasn't yet had a chance to save the contents from what
    // it thinks is the previous task.  Little does it know that this really is the same task. :)
    // Still, rather than presenting this as an error we just clear the task-switched flag in CR0 and continue processing.
    // This could result in errant data, but since they're stepping through with their debugger they'll know this.
        clts
//        push    0
//        push    eax
        push    eax
        mov     al,20h
        out     20h,al
        pop     eax
//        mov     eax,offset int7_text
//        jmp     DEBI_debug
        iretd
    }




    function invDEBI_int8_handler
    {
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int8_text
        jmp     DEBI_debug
    }




    function invDEBI_int9_handler
    {
        push    0                                                   // Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int9_text
        jmp     DEBI_debug
    }




    function invDEBI_int10_handler
    {
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int10_text
        jmp     DEBI_debug
    }




    function invDEBI_int11_handler
    {
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int11_text
        jmp     DEBI_debug
    }




    function invDEBI_int12_handler
    {
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int12_text
        jmp     DEBI_debug
    }




    function invDEBI_int13_handler
    {
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int13_text
        jmp     DEBI_debug
    }




    function invDEBI_int14_handler
    {
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int14_text
        jmp     DEBI_debug
    }




    function invDEBI_int15_handler
    {
        push    0                                                   // Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int15_text
        jmp     DEBI_debug
    }




    function invDEBI_int16_handler
    {
        push    0                                                   // Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int16_text
        jmp     DEBI_debug
    }




    function invDEBI_int17_handler
    {
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int17_text
        jmp     DEBI_debug
    }




    function invDEBI_int18_handler
    {
        push    0                                                   // Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int18_text
        jmp     DEBI_debug
    }
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// END - BBBBB - Interrupt handlers
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









    #include "debidata.asp"

// DATA
    driver_name                             u8  "Low-Level Debi Debugger",255,"(source:debi.dbg)",0
    version                                 u8  "10.10.2010 BETA",0
    copyright                               u8  "(c) Copyright Beatleworks, Inc.",0
    author                                  u8  "Rick C. Hodgin",0
    debi_text                               u8  "Debi Debugger",0
    beatleworks_text                        u8  "(c) Beatleworks, Inc. 2010",0
    bootup                                  u8  1                   // Changed to 0 after bootup is complete

//    success_my_lord                         u8  "DEBI.Success my lord!",0
//    success_my_lord_clear                   u8  "                     ",0
    step_over_text                          u8  "#úú - step over",0
    int0_text                               u8  "#00 - divide error",0
    int1_text                               u8  "#01 - single-step",0
    int2_text                               u8  "#02 - no description",0
    int3_text                               u8  "#03 - breakpoint",0
    int4_text                               u8  "#04 - overflow",0
    int5_text                               u8  "#05 - bound range exceeded",0
    int6_text                               u8  "#06 - invalid opcode",0
    int7_text                               u8  "#07 - device not available",0
    int8_text                               u8  "#08 - double fault",0
    int9_text                               u8  "#09 - coprocessor segment overrun",0
    int10_text                              u8  "#10 - invalid tss",0
    int11_text                              u8  "#11 - segment not present",0
    int12_text                              u8  "#12 - stack fault",0
    int13_text                              u8  "#13 - general protection fault",0
    int14_text                              u8  "#14 - page fault",0
    int15_text                              u8  "#15 - no description",0
    int16_text                              u8  "#16 - floating point",0
    int17_text                              u8  "#17 - alignment check",0
    int18_text                              u8  "#18 - machine check",0

    quick_watch_divider                     u8  "-----------------------------",0
    round_to_nearest                        u8  "nearest",0
    round_down                              u8  "down",0
    round_up                                u8  "up",0
    round_truncate                          u8  "|chop|",0
    precision_single                        u8  "24-bit [w/1]",0
    precision_reserved                      u8  "[precision: 01b]",0
    precision_double                        u8  "53-bit [w/1]",0
    precision_extended                      u8  "64-bit",0
    precision_text                          u8  "precision",0
    underflow_text                          u8  "underflow",0
    overflow_text                           u8  "overflow",0
    divide_by_zero_text                     u8  "divide-by-zero",0
    denormalized_text                       u8  "denormalized",0
    invalid_text                            u8  "invalid operation",0
    error_summary                           u8  "error summary",0
    stack_fault                             u8  "stack fault",0
    busy                                    u8  "busy"
    tag_valid                               u8  "valid",0
    tag_zero                                u8  "zero",0
    tag_special                             u8  "invalid",0
    tag_empty                               u8  "empty",0


                                           // type, number_of_bits
    edit_word                               u8  0, 16               // type=0 indicates hexidecimal editing
    edit_dword                              u8  0, 32               // type=1 indicates binary editing
    edit_binary_32                          u8  1, 32               // number_of_bits indicates how many bits are to be modified
    edit_flags                              u8  1,  1

    instruction_offset                      u32 -1
    instruction_length                      u32 -1
    step_over                               u8  0
    step_offset                             u32 -1
    step_replaced_byte                      u8  0

    break_here_var                          u8  0
    data_segment                            u16 0
    disable_mouse                           u8  0
    disable_kbd                             u8  0
    disable_timer                           u8  0
    debug_levels                            u8  0
    debug_screen_shown                      u8  0
    force_screen_redraw                     u8  0
    debi_ok_to_quit                         u8  0
    object_mode                             u32 0                   // 0-root, 1-a popup, menu or dialogue
    kbd_object                              u32 0
    save_kbd_object                         u32 0
    kbd_focus                               u32 -1
    mouse_objects                           u32 0
    screen_object                           u32 0
    draw_menu                               u32 0
    menu_queue                              u32 0
    last_menu_item                          u8  0ffh
    dragging_something                      u32 0
    dragging_x                              u32 0
    dragging_y                              u32 0
    dragging_height                         u32 0
    dragging_width                          u32 0
    dragging_offset_x                       u32 0
    dragging_offset_y                       u32 0
    dragging_snap_x                         u32 0
    dragging_snap_y                         u32 0
    dragging_last_x                         u32 0
    dragging_last_y                         u32 0
    dragging_skipped                        u32 0
    dragging_esi                            u32 0
    dragging_edi                            u32 0
    dragging_object                         u32 0
    mouse_current_x                         u32 350
    mouse_current_y                         u32 150
    mouse_hovering_x                        u32 -1
    mouse_hovering_y                        u32 -1
    mouse_hovering_count                    u32 -1
    mouse_clicking_count                    u32 -1
    mouse_immediate_count                   u32 -1
    mouse_last_event                        u8  0
    mouse_status                            u32 0                   // Is mouse displayed?  1-Yes, 0-No
    mouse_processing                        u32 0                   // Is this program processing?  1-Yes, 0-No
    mouse_last_buttons                      u32 0                   // Button status from previous packet
    mouse_last_button_left                  u32 0
    mouse_last_button_right                 u32 0
    mouse_button_left                       u32 0
    mouse_button_right                      u32 0
    mouse_left_dragging                     u32 0
    mouse_right_dragging                    u32 0
//    mouse_left_delta_x                      u32 0
//    mouse_left_delta_y                      u32 0
//    mouse_right_delta_x                     u32 0
//    mouse_right_delta_y                     u32 0
    mouse_right_click_x_start               u32 0
    mouse_right_click_y_start               u32 0
    mouse_left_click_x_start                u32 0
    mouse_left_click_y_start                u32 0
    mouse_right_click_x_stop                u32 0
    mouse_right_click_y_stop                u32 0
    mouse_left_click_x_stop                 u32 0
    mouse_left_click_y_stop                 u32 0
    mouse_right_click                       u32 0
    mouse_left_click                        u32 0
    mouse_both_click                        u32 0
    vertical_dragging_threshold             u32 5
    horizontal_dragging_threshold           u32 10
    mouse_allowed                           u8  1                   // Are mouse pointer read/write operations allowed?  1-Yes, 0-No
    mouse_save_area                         u32 16 dup(0)           // 64 bytes
    timer_interface_count                   u32 0
    screen_saver_count                      u32 0
    screen_saver                            u8  0
    cursor_x                                u32 15
    cursor_y                                u32 15
    cursor_count                            u32 0
    cursor                                  u8  0
    force_cursor_off                        u8  1
    force_func_windows                      u8  _NO

    general_menu_esi                        u32 0
    general_menu_edi                        u32 0
    menu_restore_screen_after               u8  _YES

    mem_ul_x                                u32 0                   // Used by the mem.x window algorithms for displaying data
    mem_ul_y                                u32 0
    mem_width                               u32 0
    mem_height                              u32 0
    mem_segment                             u32 0                   // Seg:Offset+Disp to display
    mem_offset                              u32 0
    mem_displacement                        u32 0
    mem_limit                               u32 0                   // Limit for Seg
    mem_temp_x                              u32 0
    mem_max_x                               u32 0

    fpu_esi                                 u32 0                   // esi when this function was called
    fpu_edi                                 u32 0                   // edi
    fpu_x                                   u32 0                   // mouse X coord where right-click happened
    fpu_y                                   u32 0                   // mouse Y coord
    fpu_data                                u32 0                   // miscellaneous data
    fpu_source                              u32 0
    fpu_dest                                u32 0

    exp_esi                                 u32 0
    exp_edi                                 u32 0

  // Textbox related items
    textbox_x                               u32 0
    textbox_y                               u32 0
    textbox_offset                          u32 0
    textbox_sel_start                       u32 0
    textbox_sel_end                         u32 0

  // Checkbox related items
    checkbox_x                              u32 0
    checkbox_y                              u32 0
    checkbox_offset                         u32 0                   // How far from left-side is the actual checkbox?

  // Button related items
    button_x                                u32 0
    button_y                                u32 0
    button_offset                           u32 0                   // How far from left-side is the actual text on the button?

  // Function related items
    function_x                              u32 0
    function_y                              u32 0

    insert_mode                             u32 ON                  // Default to insert mode

    // CFSCA variables
    single_step_history                     u32 -1
    single_step_top                         u32 0
    single_step_end                         u32 0

  // Variables used for FPU conversion
    FPU_fsave_scratch                       u8  104 dup(0)
    trash_string                            u8  91 dup(0)           // Used various places
    trash_dword                             u32 0
    trash_10_bytes                          u32 10 dup(0)
    trash_counter                           u32 0

    FPCtrl                                  u16 0
    FPStat                                  u16 0
    exponent                                u32 0
    signed_digits                           u32 0
    number10                                u32 10
    digit                                   u32 0
    bad_number0                             u8  " ®<unsupported>¯",0
    bad_number1                             u8  " ®<nan>¯",0
    bad_number2                             u8  " ®<-unsupported>¯",0
    bad_number3                             u8  " ®<-nan>¯",0
//   bad_number4                             u8  " ®<+normal>¯",0
    bad_number5                             u8  " ®<+infinity>¯",0
//   bad_number6                             u8  " ®<-normal>¯",0
    bad_number7                             u8  " ®<-infinity>¯",0
//   bad_number8                             u8  " ®<+zero>¯",0
    bad_number9                             u8  " ®<empty>¯",0
//   bad_number10                            u8  " ®<-zero>¯",0
    bad_number11                            u8  " ®<-empty>¯",0
    bad_number12                            u8  " ®<denormals>¯",0
    bad_number13                            u8  " ®<unknown>¯",0
    bad_number14                            u8  " ®<-denormals>¯",0
    number_empty                            u8  " ®<empty>¯",0

    reg_list                                u8  3,"eax", _EAX, _STACK_EAX
                                            u8  3,"ebx", _EBX, _STACK_EBX
                                            u8  3,"ecx", _ECX, _STACK_ECX
                                            u8  3,"edx", _EDX, _STACK_EDX
                                            u8  3,"esi", _ESI, _STACK_ESI
                                            u8  3,"edi", _EDI, _STACK_EDI
                                            u8  3,"ebp", _EBP, _STACK_EBP
                                            u8  3,"esp", _ESP, _STACK_ESP
                                            u8  3,"eip", _EIP, _STACK_EIP
                                            u8  6,"eflags", _EFLAGS, _STACK_EFLAGS
                                            u8  5,"ecode", _ECODE, _STACK_ERROR_CODE
                                            u8  2,"cs", _CS, _STACK_CS
                                            u8  2,"ds", _DS, _STACK_DS
                                            u8  2,"es", _ES, _STACK_ES          // Note, must appear after esi (because of es)
                                            u8  2,"fs", _FS, _STACK_FS
                                            u8  2,"gs", _GS, _STACK_GS
                                            u8  2,"ss", _SS, _STACK_SS
                                            u8  2,"al", _AL, _STACK_AL
                                            u8  2,"bl", _BL, _STACK_BL
                                            u8  2,"cl", _CL, _STACK_CL
                                            u8  2,"dl", _DL, _STACK_DL
                                            u8  2,"ah", _AH, _STACK_AH
                                            u8  2,"bh", _BH, _STACK_BH
                                            u8  2,"ch", _CH, _STACK_CH
                                            u8  2,"dh", _DH, _STACK_DH
                                            u8  2,"ax", _AX, _STACK_AX
                                            u8  2,"bx", _BX, _STACK_BX
                                            u8  2,"cx", _CX, _STACK_CX
                                            u8  2,"dx", _DX, _STACK_DX
                                            u8  2,"si", _SI, _STACK_SI
                                            u8  2,"di", _DI, _STACK_DI
                                            u8  2,"bp", _BP, _STACK_BP
                                            u8  2,"sp", _SP, _STACK_SP
                                            u8  2,"ip", _IP, _STACK_IP
                                            u8  -1

    seg_specified                           u8  _NO
    seg_to_use                              u32 0
    offset_to_use                           u32 0
    last_operator                           u8  _NONE

  // Used for displaying the selector information when the mouse hovers over it
  keyword_listing:      // keyword_listing (the structure) is used by invDEBI_parse_expression().invDEBI_search_keywords()
                                            u8  5
    _sIDT_text                              u8  "_sIDT",0
                                            u16 _sIDT
                                            u8  5
    _sGDT_text                              u8  "_sGDT",0
                                            u16 _sGDT
                                            u8  7
    _sSTACK_text                            u8  "_sSTACK",0
                                            u16 _sSTACK
                                            u8  6
    _sCODE_text                             u8  "_sCODE",0
                                            u16 _sCODE
                                            u8  10
    _sGRAPHICS_text                         u8  "_sGRAPHICS",0
                                            u16 _sGRAPHICS
                                            u8  6
    _sMONO_text                             u8  "_sMONO",0
                                            u16 _sMONO
                                            u8  5
    _sVGA_text                              u8  "_sVGA",0
                                            u16 _sVGA
                                            u8  9
    _sALL_MEM_text                          u8  "_sALL_MEM",0
                                            u16 _sALL_MEM
                                            u8  6
    _sDATA_text                             u8  "_sDATA",0
                                            u16 _sDATA
                                            u8  12
    _sEXODUS_MEM_text                       u8  "_sEXODUS_MEM",0
                                            u16 _sEXODUS_MEM
                                            u8  14
    _sEXODUS_PORTS_text                     u8  "_sEXODUS_PORTS",0
                                            u16 _sEXODUS_PORTS
                                            u8  13
    _sEXODUS_INTS_text                      u8  "_sEXODUS_INTS",0
                                            u16 _sEXODUS_INTS
                                            u8  12
    _sEXODUS_TSS_text                       u8  "_sEXODUS_TSS",0
                                            u16 _sEXODUS_TSS
                                            u8  8
    _sSTACK0_text                           u8  "_sSTACK0",0
                                            u16 _sSTACK0
                                            u8  8
    _sSTACK1_text                           u8  "_sSTACK1",0
                                            u16 _sSTACK1
                                            u8  8
    _sSTACK2_text                           u8  "_sSTACK2",0
                                            u16 _sSTACK2
                                            u8  12
    _sPRIMATIVES_text                       u8  "_sPRIMATIVES",0
                                            u16 _sPRIMATIVES
                                            u8  8
    _sSYSTEM_text                           u8  "_sSYSTEM",0
                                            u16 _sSYSTEM
                                            u8  18
    _sEXODUS_REQUESTOR_text                 u8  "_sEXODUS_REQUESTOR",0
                                            u16 _sEXODUS_REQUESTOR
                                            u8  14
    _sSYSTEM_RING1_text                     u8  "_sSYSTEM_RING1",0
                                            u16 _sSYSTEM_RING1
                                            u8  14
    _sSYSTEM_RING2_text                     u8  "_sSYSTEM_RING2",0
                                            u16 _sSYSTEM_RING2
                                            u8  14
    _sSYSTEM_RING3_text                     u8  "_sSYSTEM_RING3",0
                                            u16 _sSYSTEM_RING3
                                            u8  13
    _sDEBI_screen_text                      u8  "_sDEBI_screen",0
                                            u16 _sDEBI_screen
                                            u8  14
    _sDEBI_memory_text                      u8  "_sDEBI_memory",0
                                            u16 _sDEBI_memory
                                            u8  14
    _sFLOPPY_TRACK_text                     u8  "_sFLOPPY_TRACK",0
                                            u16 _sFLOPPY_TRACK
                                            u8  12
    _sVGA_BACKUP_text                       u8  "_sVGA_BACKUP",0
                                            u16 _sVGA_BACKUP
                                            u8  12
    _sEXODUS_INI_text                       u8  "_sEXODUS_INI",0
                                            u16 _sEXODUS_INI
                                            u8  19
    _sEXODUS_INI_ERRORS_text                u8  "_sEXODUS_INI_ERRORS",0
                                            u16 _sEXODUS_INI_ERRORS
                                            u8  13
    _sTASK_SYSTEM_text                      u8  "_sTASK_SYSTEM",0
                                            u16 _sTASK_SYSTEM
                                            u8  -1
    _sEXODUS_TSS_GATE_text                  u8  "_sEXODUS_TSS_GATE",0
    _sPRIMATIVES_LOAD_INFO_text             u8  "_sPRIMATIVES_LOAD_INFO",0
    _selector_text                          u8  "selector: ",0

    hex_text                                u8  "hex: ",0
    dec_text                                u8  "dec: ",0
    bin_text                                u8  "bin: ",0
  real32_text:
    real4_text                              u8  "r32: ",0
  real64_text:
    real8_text                              u8  "r64: ",0
  real80_text:
    real10_text                             u8  "r80: ",0
    disasm_text                             u8  "disasm: ",0
    rounding_text                           u8  "rounding: ",0
    precision_prefix_text                   u8  "precision: ",0
    exception_prefix_text                   u8  "exception: ",0
    mask_text                               u8  "mask: ",0
    condition_codes_text                    u8  "C3210: ",0
    top_of_stack_text                       u8  "TOS: ",0
    stx_text                                u8  "stx: ",0

    empty_byte_text                         u8  "úú",0
    empty_word_text                         u8  "úúúú",0
    empty_dword_text                        u8  "úúúúúúúú",0
    empty_16_byte_hex_string_text           u8  "úúúúúúúúúúúúúúúúúúúúúúúúúúúúúúúú",0
    empty_16_byte_string_text               u8  "úúúúúúúúúúúúúúúú",0

    menu_area                               u8  3072 dup(0ffh)      // Max of 3K for menu items
    menu_mouse_objects                      u8  60 * 28 dup(0ffh)   // 60 = max # of mouse items active at one time
                                                                    // 28 = width of each mouse object

    _EXODUS_requestor                       u16 0
  primative_call_gates:
    _VID_draw_logo                          u16 0
    _VID_display_string_nr_vga              u16 _sEXODUS_REQUESTOR
    _VID_display_string_mono                u16 0f000h
    _VID_clear_screen_mono                  u16 0f000h
    _VID_g_mono_display_text_mode           u16 0f000h
    _VID_g_mono_display_text                u16 0f000h
    _iKBD_activate_DEBI_intercept           u16 0f000h
    _iKBD_deactivate_DEBI_intercept         u16 0f000h
    _iMOUSE_activate_DEBI_intercept         u16 0f000h
    _iMOUSE_deactivate_DEBI_intercept       u16 0f000h
    _VID_g_mono_mouse_pointer               u16 0f000h
    _VID_g_set_font_8x6                     u16 0f000h
    _VID_g_set_font_8x8                     u16 0f000h
    _VID_g_set_font_8x14                    u16 0f000h
    _VID_g_set_font_16x16                   u16 0f000h
    _iTIMER_activate_DEBI_timer_feed        u16 0f000h
    _iTIMER_deactivate_DEBI_timer_feed      u16 0f000h
    _TASK_release_timeslice                 u16 0f000h
    _VID_g_mono_window_function             u16 0f000h
    _VID_position_cursor_mono               u16 0f000h
    _VID_g_display_radix_in_edx_mono        u16 0f000h
    _VID_g_mono_cursor                      u16 0f000h
    _VID_g_claim_ownership                  u16 0f000h
    _VID_g_release_ownership                u16 0f000h
    _VID_g_mono_enter_graphics_mode         u16 0f000h
    _X86_disassemble                        u16 0f000h
    _X86_simplify_disassembly               u16 0f000h
    _X86_assemble                           u16 0f000h
    _X86_fpu_opcode                         u16 0f000h
    _VID_g_mono_cursor_no_insert            u16 0f000h
    _iMOUSE_bochs_DEBI_intercept            u16 0f000h
                                            u16 0f000h
                                            u16 0f000h

    required_primatives                     u8  13, "VID_draw_logo"
                                            u8  25, "VID_display_string_nr_vga"
                                            u8  23, "VID_display_string_mono"
                                            u8  21, "VID_clear_screen_mono"
                                            u8  28, "VID_g_mono_display_text_mode"
                                            u8  23, "VID_g_mono_display_text"
                                            u8  28, "iKBD_activate_DEBI_intercept"
                                            u8  30, "iKBD_deactivate_DEBI_intercept"
                                            u8  30, "iMOUSE_activate_DEBI_intercept"
                                            u8  32, "iMOUSE_deactivate_DEBI_intercept"
                                            u8  24, "VID_g_mono_mouse_pointer"
                                            u8  18, "VID_g_set_font_8x6"
                                            u8  18, "VID_g_set_font_8x8"
                                            u8  19, "VID_g_set_font_8x14"
                                            u8  20, "VID_g_set_font_16x16"
                                            u8  31, "iTIMER_activate_DEBI_timer_feed"
                                            u8  33, "iTIMER_deactivate_DEBI_timer_feed"
                                            u8  22, "TASK_release_timeslice"
                                            u8  26, "VID_g_mono_window_function"
                                            u8  24, "VID_position_cursor_mono"
                                            u8  31, "VID_g_display_radix_in_edx_mono"
                                            u8  17, "VID_g_mono_cursor"
                                            u8  21, "VID_g_claim_ownership"
                                            u8  23, "VID_g_release_ownership"
                                            u8  30, "VID_g_mono_enter_graphics_mode"
                                            u8  15, "X86_disassemble"
                                            u8  24, "X86_simplify_disassembly"
                                            u8  12, "X86_assemble"
                                            u8  14, "X86_fpu_opcode"
                                            u8  27, "VID_g_mono_cursor_no_insert"
                                            u8  27, "iMOUSE_bochs_DEBI_intercept"
                                            u8  0ffh

    // This logo consists of a three-wide image (the +2 portion (the 2 stands for "an extra 2 18x16 images wide"))
    // It wants a box drawn around it (the +80h portion)
    // And the color we want to use is 8 (dark grey, the "+(8 SHL 3) portion)
    // * Refer to
    debi_boot_logo                          u8  08ah        // * Refer to VGA\INF\VGA.INF for information on this byte's format
                                            u8  10h,10h,10h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,10h,10h,10h
                                            u8  10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h
                                            u8  10h,10h,10h,10h,10h,10h,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,10h,10h,10h
                                            u8  10h,10h,10h,09h,01h,01h,01h,01h,01h,01h,01h,01h,01h,01h,01h,01h,09h,09h,10h,10h
                                            u8  10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h
                                            u8  10h,10h,10h,10h,10h,10h,0fh,02h,02h,02h,02h,02h,02h,02h,0fh,10h,10h,10h
                                            u8  10h,10h,10h,09h,09h,09h,01h,01h,01h,01h,09h,09h,09h,09h,01h,01h,01h,01h,09h,10h
                                            u8  10h,10h,10h,10h,10h,10h,10h,10h,10h,09h,09h,09h,09h,10h,10h,10h,10h,10h,10h,10h
                                            u8  09h,09h,09h,09h,10h,10h,0fh,02h,02h,02h,02h,02h,02h,02h,0fh,10h,10h,10h
                                            u8  10h,10h,10h,10h,10h,09h,01h,01h,01h,01h,09h,10h,10h,10h,09h,09h,01h,01h,01h,09h
                                            u8  10h,10h,10h,10h,10h,10h,10h,10h,09h,01h,01h,01h,01h,09h,10h,10h,10h,10h,10h,09h
                                            u8  01h,01h,01h,01h,09h,10h,0fh,02h,02h,02h,02h,02h,02h,02h,0fh,10h,10h,10h
                                            u8  10h,10h,10h,10h,10h,09h,01h,01h,01h,0eh,09h,0eh,10h,10h,10h,09h,01h,01h,01h,01h
                                            u8  09h,10h,10h,10h,10h,10h,10h,10h,10h,09h,01h,01h,01h,09h,10h,10h,10h,10h,10h,09h
                                            u8  01h,01h,01h,01h,09h,10h,0fh,02h,02h,02h,02h,02h,02h,02h,0fh,10h,10h,10h
                                            u8  10h,10h,10h,10h,10h,09h,0fh,0fh,01h,04h,0ch,0ch,04h,10h,0fh,0fh,0fh,01h,01h,01h
                                            u8  09h,10h,10h,10h,10h,10h,10h,10h,10h,09h,01h,01h,01h,09h,10h,10h,10h,10h,10h,10h
                                            u8  09h,09h,09h,09h,10h,10h,0fh,02h,02h,02h,02h,02h,02h,02h,0fh,10h,10h,10h
                                            u8  10h,10h,10h,10h,10h,0fh,01h,01h,0fh,04h,0ch,0ch,04h,0fh,10h,10h,09h,0fh,01h,01h
                                            u8  09h,10h,10h,09h,09h,09h,09h,09h,09h,09h,01h,01h,01h,09h,10h,10h,10h,10h,10h,10h
                                            u8  10h,10h,10h,10h,10h,10h,0fh,0fh,0fh,0fh,0fh,0fh,0dh,0fh,0fh,10h,10h,10h
                                            u8  10h,10h,10h,10h,10h,09h,01h,01h,01h,0ch,0ch,0ch,0ch,10h,10h,10h,09h,01h,01h,01h
                                            u8  09h,10h,09h,01h,01h,01h,01h,01h,01h,09h,01h,01h,01h,09h,10h,09h,09h,09h,10h,09h
                                            u8  09h,09h,10h,10h,10h,10h,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,10h,10h,10h
                                            u8  10h,10h,10h,10h,10h,09h,01h,0fh,0fh,0ch,0ch,0ch,0ch,0fh,0fh,10h,09h,01h,01h,01h
                                            u8  09h,09h,01h,01h,09h,09h,09h,01h,01h,09h,01h,01h,01h,09h,09h,01h,01h,01h,09h,09h
                                            u8  01h,01h,09h,10h,10h,10h,10h,10h,10h,10h,0eh,10h,10h,10h,10h,10h,10h,10h
                                            u8  10h,10h,10h,10h,10h,09h,0fh,01h,01h,04h,0ch,0ch,04h,10h,10h,0fh,0fh,01h,01h,01h
                                            u8  09h,01h,01h,09h,01h,01h,01h,01h,09h,09h,01h,01h,01h,01h,01h,01h,01h,01h,01h,09h
                                            u8  01h,01h,01h,09h,10h,10h,10h,10h,10h,10h,0eh,10h,10h,10h,10h,10h,10h,10h
                                            u8  10h,10h,10h,10h,10h,0fh,01h,01h,01h,0fh,0ch,0ch,0fh,10h,10h,09h,01h,0fh,01h,01h
                                            u8  09h,01h,01h,01h,01h,01h,09h,09h,10h,09h,01h,01h,01h,01h,01h,09h,01h,01h,01h,09h
                                            u8  01h,01h,01h,01h,09h,10h,10h,10h,10h,10h,0eh,10h,10h,10h,10h,10h,10h,10h
                                            u8  10h,10h,10h,10h,10h,09h,01h,01h,0fh,01h,09h,10h,10h,0fh,10h,09h,01h,01h,01h,01h
                                            u8  09h,01h,01h,01h,09h,09h,10h,10h,10h,09h,01h,01h,01h,01h,01h,01h,09h,01h,01h,09h
                                            u8  01h,01h,01h,01h,09h,10h,10h,10h,10h,10h,0eh,10h,10h,10h,10h,10h,10h,10h
                                            u8  10h,10h,10h,10h,10h,09h,01h,01h,0fh,01h,09h,10h,10h,10h,0fh,09h,01h,01h,01h,09h
                                            u8  09h,01h,01h,01h,09h,09h,09h,09h,09h,09h,01h,01h,01h,01h,01h,01h,09h,01h,01h,09h
                                            u8  01h,01h,01h,01h,09h,10h,0eh,0eh,0eh,0eh,0eh,10h,10h,10h,10h,10h,10h,10h
                                            u8  10h,10h,10h,09h,09h,09h,01h,0fh,01h,01h,09h,09h,09h,09h,0fh,01h,01h,01h,09h,10h
                                            u8  09h,01h,01h,01h,01h,01h,01h,01h,01h,09h,01h,01h,01h,01h,01h,01h,01h,01h,01h,09h
                                            u8  01h,01h,01h,01h,09h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h
                                            u8  10h,10h,10h,09h,01h,01h,01h,0fh,01h,01h,01h,01h,01h,01h,01h,0fh,09h,09h,10h,10h
                                            u8  09h,09h,09h,01h,01h,01h,01h,01h,01h,09h,01h,01h,01h,09h,01h,01h,01h,01h,09h,09h
                                            u8  01h,01h,01h,09h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h
                                            u8  10h,10h,10h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,10h,10h,10h,10h
                                            u8  10h,10h,09h,09h,09h,09h,09h,09h,09h,10h,09h,09h,09h,10h,09h,09h,09h,09h,10h,10h
                                            u8  09h,09h,09h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h
                                            u8  0,0,15h     // A dark shade of blue for the background

    #include "debilogo.asp"

 end_of_required_data:

    driver_primatives                       u8  10, "DEBI_debug"
                                            u32 offset DEBI_debug
                                            u16 0

                                            u8  19,"iDEBI_kbd_interface"
                                            u32 offset iDEBI_kbd_interface
                                            u16 0

                                            u8  21,"iDEBI_mouse_interface"
                                            u32 offset iDEBI_mouse_interface
                                            u16 0

                                            u8  21,"iDEBI_timer_interface"
                                            u32 offset iDEBI_timer_interface
                                            u16 0

                                            u8  15,"iDEBI_open_file"
                                            u32 offset iDEBI_open_file
                                            u16 0

                                            u8  16,"iDEBI_close_file"
                                            u32 offset iDEBI_close_file
                                            u16 0

                                            u8  15,"iDEBI_read_file"
                                            u32 offset iDEBI_read_file
                                            u16 0

                                            u8  16,"iDEBI_write_file"
                                            u32 offset iDEBI_write_file
                                            u16 0

                                            u8  27,"iDEBI_bochs_mouse_interface"
                                            u32 offset iDEBI_bochs_mouse_interface
                                            u16 0

                                            u16 0ffffh              // Teriminator

already_here                                u8  _NO

}
// text32

END
