// cfsca.asp
//
// Low-Level Debi Debugger CFSCA window handler
//
//


source_not_available    u8  "®<Source not available>¯",0
cfsca_buffer1           u8  128 dup(0)
cfsca_buffer2           u8  128 dup(0)



function invDEBI_cfsca_1_window
{
// This routine is called to populate the CFSCA.1 window
//
    mov     u32 ptr [ebp-12],13*FONT_Y
    jmp     invDEBI_cfsca_window_common
}



function invDEBI_cfsca_2_window
{
// This routine is called to populate the CFSCA.2 window
//
    mov     u32 ptr [ebp-12],26*FONT_Y
    jmp     invDEBI_cfsca_window_common
}




function invDEBI_cfsca_3_window
{
// This routine is called to populate the CFSCA.3 window
//
    mov     u32 ptr [ebp-12],39*FONT_Y
    // Note, this next line is not executed because it will flow right into that algorithm
    //jmp     invDEBI_cfsca_window_common
}




function invDEBI_cfsca_window_common
{
// This routine is called to process the cfsca windows
//
// Upon entry:   ds:[esi] - far ptr to this object's screen table info
//               ds:[edi] - far ptr to this object's parameters
//                  [ebp] - pointer to stack frame from debi_debug()
//               [ebp-12] - dword indicating maximum line to reach
//
// Upon exit:    The window is updated with either source code or an assembly listing
//
  // Refer to debi_debug() for these stack references
  // [ebp+56] - cs
  // [ebp+52] - eip
  // [ebp-08] - dword, Current font increment
  // [ebp-12] - dword, maximum line to reach
    push    ds
    push    es
    push    fs
    pushfd
    pushad

  // Save esi use below (as edx)
    mov     edx,esi

  // We need:  ds:[esi] - far ptr to execution code
  //           es:[edi] - far ptr to text string
  //                 fs - current data segment (used below for DEBI_simplify_disassembly)
  //                ebx - used to indicate how far down the screen we are
    mov     es,cs:data_segment
    mov     fs,cs:data_segment
    mov     esi,u32 ptr [ebp+52]
    if (es:single_step_history != 0ffffffffh)
    {
      // They've been single stepping
        if (esi >= es:single_step_top && esi < es:single_step_end)
        {
            mov     esi,es:single_step_top
        }
    }
    mov     es:single_step_history,0
    mov     es:single_step_top,esi

    mov     ebx,u32 ptr [ebp-08]                               // Start at 8 pixels down in window
  //-[loop]---
  @@:
        mov     ds,u32 ptr [ebp+56]
        mov     edi,offset cfsca_buffer1
        call    u48 ptr es:_x86_disassemble
        push    ecx

      // We need:  es:[edi] - far ptr to disassembly cask
      //           fs:[ebx] - far ptr to simplified string
      //                eax - number of spaces in string to use for displaying instruction bytes
      //                ecx - maximum length of string
        push    ebx
        mov     eax,16
        mov     ecx,55                                              // Actually 59-4 (-4 for the "CFSCA" vertical frames)
        mov     ebx,offset cfsca_buffer2
        call    u48 ptr es:_x86_simplify_disassembly
        pop     ebx

        mov     ds,cs:data_segment
        pushfd
        if (esi == u32 ptr [ebp+52])
        {
          // It is the current instruction, we have to display it in reverse color
            mov     ecx,u32 ptr [esp+04]
            mov     ds:instruction_offset,esi
            mov     ds:instruction_length,ecx
          // Draw the text
            push    u32 ptr 0                                     // Write mode (0-overlay)
            push    u32 ptr ds:[edx+_ST_OBJECT_UL_HORIZONTAL]
            add     u32 ptr [esp+00],8*4                       // Move over for the "CFSCA" vertical frames
            mov     ecx,u32 ptr [esp+00]
            mov     ds:cursor_x,ecx
            push    u32 ptr ds:[edx+_ST_OBJECT_UL_VERTICAL]
            add     u32 ptr [esp+00],ebx                       // Move down to whatever line we're currently on
            mov     ecx,u32 ptr [esp+00]
            mov     ds:cursor_y,ecx
            push    u32 ptr 1                                     // Display mode (1-reverse)
            push    u32 ptr offset cfsca_buffer2
            cli
            call    u48 ptr ds:_VID_g_mono_display_text_mode
        
        } else {
          // It's not the current instruction
            push    u32 ptr ds:[edx+_ST_OBJECT_UL_HORIZONTAL]
            add     u32 ptr [esp+00],8*4                       // Move over for the "CFSCA" vertical frames
            push    u32 ptr ds:[edx+_ST_OBJECT_UL_VERTICAL]
            add     u32 ptr [esp+00],ebx                       // Move down to whatever line we're currently on
            push    u32 ptr offset cfsca_buffer2
            cli
            call    u48 ptr ds:_VID_g_mono_display_text
        }
        popfd

      // Move to the next instruction
        pop     ecx
        add     esi,ecx

    add     ebx,u32 ptr [ebp-08]
    cmp     ebx,u32 ptr [ebp-12]
    jb      @B
  //-------
    mov     ds:single_step_end,esi

    popad
    popfd
    pop     fs
    pop     es
    pop     ds
    ret
}




function invDEBI_cfsca_2_click
{
// This routine is called when they click on the cfsca.2 casq
    ret
}




function invDEBI_cfsca_3_click
{
// This routine is called when they click on the cfsca.3 casq
    ret
}




function invDEBI_cfsca_4_click
{
// This routine is called when they click on the cfsca.4 casq
    ret
}
