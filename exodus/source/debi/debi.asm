; debi.asm
;
; ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
; ¥ Debi Debugger ≥
; ¿√√√√√√√√√√√√√√√Ÿ
;
; Exodus native primative debugger, called Debi. :)
;
; -----
;   00000 - Window Supportive Algorithms/Handlers
;   11111 - External interfaces (Timer, Mouse, Kbd)
;   22222 - Screen related functions
;   33333 - MOUSE Events
;   44444 - MENU system
;   55555 - MENUs for screen objects
;   66666 - Actions taken when various menu items are selected
;   77777 - Menu bar events
;   88888 - DRAG and DRAG RELEASE handlers
;   99999 - Keyboard Events
;   AAAAA - INCLUDE files
;


TITLE Debi Debugger

    .MODEL tiny

    .STACK 0h

INCLUDE \exodus\source\common\keylist.asp
INCLUDE \exodus\source\common\equates.asp
INCLUDE \exodus\source\common\macros.asp
INCLUDE debi_mac.asp                                                ; Macros used for DEBI
INCLUDE debi_eq.asp                                                 ; Equates used for DEBI

    .386P

_TEXT32 SEGMENT BYTE 'CODE' USE32
    ASSUME NOTHING

; These are required to be the first 2 dwords in the file
dd  offset main
dd  offset requestor



    requestor   PROC
    ; This routine is called by Exodus.  When this function is called multi-tasking is not installed.  This is a linear function.
    ;
    ; Upon entry:   eax - requested function
    ;                ds - temporary ORG 0h data segment for use with these requestor() functions
    ;
    ; Upon exit:    results vary based on value of eax
    ;
        .IF (eax == 'info')
          ; Program information
            mov     eax,'nati'                              ; Identifying this program as a native primative
            mov     ecx,offset end_of_required_data         ; The maximum number of bytes to retain after loading

            mov     esi,offset driver_primatives            ; Offset to the native primatives structure
            mov     edi,offset driver_name
            mov     ebx,offset version
            mov     edx,offset copyright
            mov     ebp,offset author
            clc
        .ELSEIF (eax == 'prim')
          ; Native primatives this program will use
            mov     ds:data_segment,ds
            mov     esi,offset required_primatives          ; This primative requires these functions
            mov     edi,offset primative_call_gates
            clc
        .ELSEIF (eax == 'id  ')
          ; Display this program's ID on the VGA monitor
            mov     esi,offset driver_name
            call    fword ptr cs:_VID_display_string_nr_vga
            clc
        .ELSEIF (eax == 'note')
            mov     eax,'stop'
            mov     ebx,'load'
            mov     esi,offset driver_name
            call    fword ptr cs:_EXODUS_requestor
        .ELSE
            stc
        .ENDIF
        retf
    requestor   ENDP




    main    PROC
    ; This routine is called once by Exodus once initialization is complete (all calls to requestor() are finished)
    ; It is used by Exodus to allow this driver to properly initialize itself.
    ; When this function is called multi-tasking is not installed.  This is a linear function.
    ;
    ; Upon entry:   Nothing
    ;
    ; Upon exit:    A "continued status of execution" is expected by Exodus.  This indicates whether or not everything
    ;               initialized ok or is available.  If everything is OK the carry? flag is CLEAR.  If there is an error
    ;               and this driver cannot continue then the carry? should be SET.
    ;               carry? - CLEAR=Ok to continue
    ;                          SET=Error initializing
    ;
        mov     ds,cs:data_segment
        mov     ds:bootup,0
        call    initialize_driver
      ; Right now, carry? is SET or CLEAR indicating status of driver
        retf
    main    ENDP




    initialize_driver   PROC
    ; This routine is used to initialize the driver
    ; We trap all interrupts that are generated by the CPU during an error condition
        push    es

      ; Take ownership of the VID_g subsystem in the video driver (DEBI requires monochrome graphics mode)
        call    fword ptr cs:_VID_g_claim_ownership
        call    fword ptr cs:_VID_g_mono_enter_graphics_mode

      ; INT0 - Divide error
        mov     ecx,1                                               ; We only allocate one interrupt at a time (used on all)
        mov     eax,'bint'
        mov     bl,0
        mov     edx,offset invDEBI_int0_handler
        call    fword ptr cs:_EXODUS_requestor
        jc      init_failed

      ; INT1 - Single-step (or debug exception)
        mov     eax,'bint'
        mov     bl,1
        mov     edx,offset invDEBI_int1_handler
        call    fword ptr cs:_EXODUS_requestor
        jc      init_failed

      ; INT2 - No description
        mov     eax,'bint'
        mov     bl,2
        mov     edx,offset invDEBI_int2_handler
        call    fword ptr cs:_EXODUS_requestor
        jc      init_failed

      ; INT3 - Breakpoint exception
        mov     eax,'bint'
        mov     bl,3
        mov     edx,offset invDEBI_int3_handler
        call    fword ptr cs:_EXODUS_requestor
        jc      init_failed

      ; INT4 - Overflow exception
        mov     eax,'bint'
        mov     bl,4
        mov     edx,offset invDEBI_int4_handler
        call    fword ptr cs:_EXODUS_requestor
        jc      init_failed

      ; INT5 - BOUND range exceeded exception
        mov     eax,'bint'
        mov     bl,5
        mov     edx,offset invDEBI_int5_handler
        call    fword ptr cs:_EXODUS_requestor
        jc      init_failed

      ; INT6 - Invalid opcode exception
        mov     eax,'bint'
        mov     bl,6
        mov     edx,offset invDEBI_int6_handler
        call    fword ptr cs:_EXODUS_requestor
        jc      init_failed

      ; INT7 - Device not available exception
        mov     eax,'bint'
        mov     bl,7
        mov     edx,offset invDEBI_int7_handler
        call    fword ptr cs:_EXODUS_requestor
        jc      init_failed

      ; INT8 - Double fault exception
        mov     eax,'bint'
        mov     bl,8
        mov     edx,offset invDEBI_int8_handler
        call    fword ptr cs:_EXODUS_requestor
        jc      init_failed

      ; INT9 - Coprocessor segment overrun
        mov     eax,'bint'
        mov     bl,9
        mov     edx,offset invDEBI_int9_handler
        call    fword ptr cs:_EXODUS_requestor
        jc      init_failed

      ; INT10 - Invalid TSS exception
        mov     eax,'bint'
        mov     bl,10
        mov     edx,offset invDEBI_int10_handler
        call    fword ptr cs:_EXODUS_requestor
        jc      init_failed

      ; INT11 - Segment not present
        mov     eax,'bint'
        mov     bl,11
        mov     edx,offset invDEBI_int11_handler
        call    fword ptr cs:_EXODUS_requestor
        jc      init_failed

      ; INT12 - Stack fault exception
        mov     eax,'bint'
        mov     bl,12
        mov     edx,offset invDEBI_int12_handler
        call    fword ptr cs:_EXODUS_requestor
        jc      init_failed

      ; INT13 - General protection fault
        mov     eax,'bint'
        mov     bl,13
        mov     edx,offset invDEBI_int13_handler
        call    fword ptr cs:_EXODUS_requestor
        jc      init_failed

      ; INT14 - Page fault exception
        mov     eax,'bint'
        mov     bl,14
        mov     edx,offset invDEBI_int14_handler
        call    fword ptr cs:_EXODUS_requestor
        jc      init_failed

      ; INT15 - Because it might be implemented in future Intel cpus
        mov     eax,'bint'
        mov     bl,15
        mov     edx,offset invDEBI_int15_handler
        call    fword ptr cs:_EXODUS_requestor
        jc      init_failed

      ; INT16 - Floating point error
        mov     eax,'bint'
        mov     bl,16
        mov     edx,offset invDEBI_int16_handler
        call    fword ptr cs:_EXODUS_requestor
        jc      init_failed

      ; INT17 - Alignment check exception
        mov     eax,'bint'
        mov     bl,17
        mov     edx,offset invDEBI_int17_handler
        call    fword ptr cs:_EXODUS_requestor
        jc      init_failed

      ; INT18 - Machine check exception
        mov     eax,'bint'
        mov     bl,18
        mov     edx,offset invDEBI_int18_handler
        call    fword ptr cs:_EXODUS_requestor
        jc      init_failed

      ; Initialize the memory area
        mov     eax,_sDEBI_memory
        mov     es,ax
        mov     dword ptr es:[0],4                                  ; Indicate the starting offset for the next data item
        mov     edi,4
        mov     ecx,_sDEBI_memory_limit - 4                         ; Reset everything in the memory area to 0ffh
        mov     al,0ffh
        cld
        rep     stosb

      init_ok:
        mov     esi,offset debi_boot_logo
        call    fword ptr cs:_VID_draw_logo
        clc
        jmp     init_quit

      init_failed:
        stc

      init_quit:
        pop     es
        ret
    initialize_driver   ENDP





    DEBI_debug   PROC
    ; This procedure is called during a fatal error.  The system will be halted.
    ;
    ; Upon entry:   Stack is arranged as below
    ;               eax - ptr to the type of error encountered
    ;
    ; Upon exit:    The errant program continues
    ;
      ; * Note that esp = current value of ebp+60
      ; [ebp+60] - eflags
      ; [ebp+56] - cs
      ; [ebp+52] - eip
      ; [ebp+48] - <error code>
      ; [ebp+44] - eax
      ; [ebp+40] - ebx
      ; [ebp+36] - ecx
      ; [ebp+32] - edx
      ; [ebp+28] - esi
      ; [ebp+24] - edi
      ; [ebp+20] - ds
      ; [ebp+16] - es
      ; [ebp+12] - fs
      ; [ebp+08] - gs
      ; [ebp+04] - ss
      ; [ebp+00] - ebp
      ; [ebp-04] - esp
        push    ebx
        push    ecx
        push    edx
        push    esi
        push    edi
        push    ds
        push    es
        push    fs
        push    gs
        push    ss
        enter   200,0
        mov     dword ptr ss:[ebp-04],ebp
        add     dword ptr ss:[ebp-04],64                            ; Make this value of ESP be what it was originally
      ; [ebp-004] - (see above)
      ; [ebp-008] -  dword,  Current font increment
      ; * Note:  This public stack frame is used by all routines in Debi.
      ;          It cannot be changed without the express written permission of Major League Baseball
      ;------
      ; invDEBI_draw_objects
      ; [ebp-092] -  dword,  Temporary variable used in
      ;------
      ; invDEBI_populate_debug_screen
      ; [ebp-080] - offset into _sDEBI_memory for next item
      ; [ebp-084] - segment of temp far address
      ; [ebp-088] - offset of temp far address
      ; [ebp-092] - (temp) used as a temporary holder for processing
      ;------
      ; [ebp-200] - 108 bytes, FPU save state
        fsave   ss:[ebp-200]
        finit

        mov     ds,cs:data_segment
      ; See if we're in a step-over condition
        .IF (ds:step_over == 1)
          ; We have to replace the byte that was updated
            pushad
            mov     ds:step_over,0
            mov     al,ds:step_replaced_byte
            mov     ebx,ds:step_offset
            push    fs
            mov     edx,_sDEBI_temp
            mov     fs,edx
            mov     byte ptr fs:[ebx],al
            pop     fs
            inc     ebx
            .IF (dword ptr ss:[ebp+52] == ebx)
                dec     dword ptr ss:[ebp+52]
                mov     dword ptr ss:[esp+28],offset step_over_text
            .ENDIF
            popad
        .ENDIF

      ; Right now ds:[eax] - far ptr to the error string (identified by the error trapping functions below)
        mov     esi,eax
        call    invDEBI_update_message
      ; Right now, ds:[edi] - far ptr to the end of the error string in the query window
      ;                 ecx - number of bytes written
      ; Try to find out what procedure caused the problem
        mov     ebx,dword ptr ss:[ebp+52]
        mov     edx,dword ptr ss:[ebp+56]
        mov     ecx,45
        mov     esi,edi
      ; Right now:   edx - code segment
      ;              ebx - instruction pointer
      ;         ds:[esi] - far ptr where to store
      ;              ecx - maximum # of bytes to store
        mov     eax,'find'
        mov     edi,'func'
        call    fword ptr ds:_EXODUS_requestor

      ; Draw the DEBI screen
        call    fword ptr ds:_VID_g_set_font_8x6                    ; Set font at 8x6
        mov     dword ptr ss:[ebp-08],6
        inc     ds:debug_levels
        call    invDEBI_populate_debug_screen
        mov     ds:debug_screen_shown,1
        mov     ds:mouse_status,0                                   ; Indicate that the mouse is not currently being displayed
                                                                    ; Note, it's not displayed until they move or click
      ; Intercept what we need from the keyboard/mouse
        call    fword ptr ds:_iKBD_activate_DEBI_intercept
        call    fword ptr ds:_iMOUSE_activate_DEBI_intercept
        call    fword ptr ds:_iTIMER_activate_DEBI_timer_feed
        call    invDEBI_show_mouse_pointer

      ; Now, we wait.  This is an object oriented system.
      ; When interrupts (mouse or keyboard) are triggered they will be acted on accordingly by the procedures below.
      ; The only thing we have to look for is our exit code when it's available
        mov     ds:debi_ok_to_quit,0
        sti                                                         ; Allow interrupts (they're needed for mouse/keyboard)
      @@:
        hlt
        .IF (ds:debi_ok_to_quit == 1)
          ; They're single stepping
            mov     ds,dword ptr ss:[ebp+56]
            mov     esi,dword ptr ss:[ebp+52]
            mov     al,byte ptr ds:[esi]
            .IF (al == 0eah || al == 09ah)
              ; They're issuing an explicit JMP FAR or CALL FAR
              ; We have to see if it's going to a CALL GATE
                movzx   edx,word ptr ds:[esi+5]
                test    edx,111b
                .IF (zero?)
                    shr     edx,3                                   ; Divide by 8 (to get slot)
                    mov     eax,'get '
                    mov     ebx,'gdt '
                    call    fword ptr cs:_EXODUS_requestor
                    .IF (!carry?)
                      ; Right now, ebx - upper dword
                      ;            edx - lower dword
                        and     bh,11111b
                        .IF (bh == 00101b)
                          ; It is a call gate
                            movzx   edx,word ptr ds:[esi+5]
                            shr     edx,3
                            mov     eax,'get '
                            mov     ebx,'tss '
                            call    fword ptr cs:_EXODUS_requestor
                            mov     eax,_sALL_MEM
                            mov     ds,eax
;                            or      byte ptr ds:[ebx+_TSS_TRAP_BIT],_TSS_TRAP_BIT_MASK
                            or      dword ptr ds:[ebx+_TSS_EFLAGS],100000000b
;mov ds,cs:data_segment
;mov ds:hlt_now,1
                            jmp     bypass_our_eflags
                        .ENDIF
                    .ENDIF
                .ENDIF
            .ENDIF
            or      dword ptr ss:[ebp+60],100000000b
          bypass_our_eflags:
            mov     ds,cs:data_segment
        .ELSEIF (ds:debi_ok_to_quit == 2)
          ; They're continuing on from here
            mov     ds:single_step_history,-1
            jmp     no_single_step
        .ELSEIF (ds:debi_ok_to_quit == 3)
          ; They're stepping over this one
          no_single_step:
            and     dword ptr ss:[ebp+60],not 100000000b
        .ELSE
          ; Nope, we're still waiting... :)
            jmp     @B
        .ENDIF

      ; Note, the code will only get here if they've done something to modify the status of debi_ok_to_quit
      ;       This happens when they press key combinations or click on step/go/etc.
        call    invDEBI_hide_mouse_pointer
        call    fword ptr ds:_iTIMER_deactivate_DEBI_timer_feed
        call    fword ptr ds:_iMOUSE_deactivate_DEBI_intercept
        call    fword ptr ds:_iKBD_deactivate_DEBI_intercept
        mov     ds:force_cursor_off,1
        call    invDEBI_turn_cursor_off
        dec     ds:debug_levels
        frstor  ss:[ebp-200]
        leave
        pop     ss
        pop     gs
        pop     fs
        pop     es
        pop     ds
        pop     edi
        pop     esi
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
        add     esp,4                                               ; Get past the error code
        iretd
    DEBI_debug   ENDP




    invDEBI_null        PROC
    ; This routine does nothing except return to the calling program
        ret
    invDEBI_null        ENDP









;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; 00000 - Window Supportive Algorithms/Handlers
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    invDEBI_update_message      PROC
    ; This routine is used to update the error message on screen (so we can see what error it was/is)
    ;
    ; Upon entry:   ds:[esi] - far ptr to error string
    ;
    ; Upon exit:    ds:[edi] - far ptr to where next bit of information would go on the current line
    ;                    ecx - how many character were copied so far
    ;
        push    es
        mov     es,ds:data_segment

        cld
        push    esi
      ; Scroll line 2 to 3
        mov     edi,offset query_3
        mov     esi,offset query_2
        mov     ecx,sizeof query_2-2
        rep     movsb
      ; Scroll line 1 to 2
        mov     edi,offset query_2
        mov     esi,offset query_1
        mov     ecx,sizeof query_1-2
        rep     movsb
      ; Reset line 1 to spaces
        mov     edi,offset query_1
        mov     al,32
        mov     ecx,sizeof query_1-2
        rep     stosb
      ; Copy the source string to line 1
        pop     esi
        mov     edi,offset query_1
        xor     ecx,ecx
        .WHILE (byte ptr ds:[esi] != 0 && ecx < (sizeof query_1-2))
            lodsb
            stosb
            inc     ecx
        .ENDW

        pop     es
        ret
    invDEBI_update_message      ENDP




    invDEBI_clear_screen_and_redraw_windows     PROC
    ; This routine is called to clear the screen and then redraw all windows
    ;
      ; Clear the whole screen
        push    dword ptr 0
        push    dword ptr 0
        push    dword ptr 720
        push    dword ptr 348
        push    dword ptr 2                                         ; Clear
        push    dword ptr 0                                         ; Not used here, but required for spacer
        call    fword ptr cs:_VID_g_mono_window_function
        ; Note, this line is not executed because program flow will just fall right through
        ;jmp     invDEBI_redraw_windows
    invDEBI_clear_screen_and_redraw_windows     ENDP




    invDEBI_redraw_windows      PROC
    ; This routine forces a redraw of all windows
        push    eax
        movzx   eax,ds:force_screen_redraw
        push    eax

        mov     ds:force_screen_redraw,_YES
        call    invDEBI_populate_debug_screen

        pop     eax
        mov     ds:force_screen_redraw,al
        pop     eax
        ret
    invDEBI_redraw_windows      ENDP




    invDEBI_populate_debug_screen       PROC
    ; This routine is used to put the relevent information on the screen
    ;
    ; Upon entry:   The stack arrangement is provided directly from DEBI_debug()'s stack frame
    ;               * Changes here must be reflected and made compatible with that algorithm
    ;
    ; Upon exit:    The various screens are populated
    ;
      ; [ebp-080] - offset into _sDEBI_memory (memory area) for next item
      ; [ebp-084] - segment of temp far address
      ; [ebp-088] - offset of temp far address
      ; [ebp-092] - (temp) used as a temporary holder for processing
        mov     dword ptr ss:[ebp-080],0                            ; Start at the beginning
        mov     dword ptr ss:[ebp-084],-1                           ; Force an invalid address at the outset
        mov     dword ptr ss:[ebp-088],-1

        mov     esi,offset DEBI_screen_table
        xor     ecx,ecx
        .WHILE (ecx < 15)
            .IF (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _YES)
                push    esi
                push    ecx

              ; After this, ds:[esi] - pointer to this screen table structure
              ;             ds:[edi] - pointer to this item's objects
                mov     edi,dword ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]     ; Get the offset to the objects
                call    invDEBI_draw_objects

                pop     ecx
                pop     esi
            .ENDIF
            inc     ecx
            add     esi,_ST_LENGTH
        .ENDW
        ret
    invDEBI_populate_debug_screen       ENDP




    invDEBI_draw_objects    PROC
    ; This routine is called to update some objects on the screen
    ;
    ; Upon entry:   ds:[esi] - far ptr to screen table structure
    ;               ds:[edi] - far ptr to objects
    ;               ss:[ebp] - space is available indicated in DEBI_debug()
    ;
    ; Upon exit:    The object is drawn/redrawn
    ;
        push    es
        pushad
        mov     eax,_sDEBI_memory                                   ; All DEBI windows store memory here.   Well, at least those
        mov     es,eax                                              ; not handled by _FUNCTION (and even they still might hehehe)
      ; Right now, es:[0] - far ptr to the _sDEBI_memory structure
        .WHILE (byte ptr ds:[edi] != _END)
            mov     al,byte ptr ds:[edi]
            .IF (al == _OBJECT_MEM_SIZE)
              ; They're specifying how big this window's memory size is in the buffer
                .IF (dword ptr ds:[esi+_ST_OBJECT_MEMORY_OFFSET] == -1 && byte ptr ds:[edi+1] != 0)
                  ; It hasn't already been allocated, so let's allocate some memory for this bad boy
                    mov     eax,dword ptr es:[0]
                  ; Right now, eax - offset into temp space where this item will go
                    mov     dword ptr ds:[esi+_ST_OBJECT_MEMORY_OFFSET],eax
                    movzx   ebx,byte ptr ds:[edi+1]                 ; Indicate where the next one will go
                    add     dword ptr es:[0],ebx

                    .WHILE (ebx > 0)                                ; Initialize the memory area to 0ffh's
                        mov     byte ptr es:[eax+ebx-1],0ffh
                        dec     ebx
                    .ENDW
                .ENDIF
              ; Finished, we skip past this fixed 2-byte structure (db _OBJECT_MEM_SIZE, <size>)
                add     edi,2
            .ELSEIF (al == _LOAD_TEMP)
              ; They want to indicate where to load a temporary variable
                mov     al,byte ptr ds:[edi+1]
                .IF (al == _FAR_MEMORY_PTR)
                    mov     eax,dword ptr ds:[esi+_ST_OBJECT_MEMORY_OFFSET]
                    .IF (eax == -1)
                      ; It hasn't yet been initialized, so we can't do anything
                        jmp     next_window
                    .ELSE
                      ; It's valid
                        mov     dl,byte ptr es:[eax]
                        .IF (dl == _RAW_ADDRESS)
                          ; Ok, the raw address they're working with is here
                            mov     edx,dword ptr es:[eax+1]
                            mov     dword ptr ss:[ebp-084],edx
                            mov     edx,dword ptr es:[eax+5]
                            mov     dword ptr ss:[ebp-088],edx
                            add     edi,3
                        .ELSE
                          ; Unsupported option (or invalid data)
                            jmp     next_window
                        .ENDIF
                    .ENDIF
                .ELSE
                  ; Unknown item
                    jmp     next_window
                .ENDIF
            .ELSEIF (al == _DISPLAY)
              ; They want to display something
                mov     al,byte ptr ds:[edi+1]
                .IF (al == _TEMP_RELATIVE)
                  ; They're specifying an address relative to the previously loaded temporary address
                    add     edi,16
                    jmp     next_object

                .ELSEIF (al == _EBP_RELATIVE)
                  ; They're specifying that it's EBP relative (our EBP, not theirs)
                    movsx   ebx,word ptr ds:[edi+3]
                    mov     edx,dword ptr ss:[ebp+ebx]
                    mov     al,byte ptr ds:[edi+2]
                    .IF (al == _UPPER_NIBBLE)
                        and     edx,0f0h
                        shr     edx,4
                        mov     ebx,2
                        mov     ecx,4
                    .ELSEIF (al == _LOWER_NIBBLE)
                        and     edx,00fh
                        mov     ebx,2
                        mov     ecx,4
                    .ELSEIF (al == _8)
                        and     edx,0ffh
                        mov     ebx,16
                        mov     ecx,2
                    .ELSEIF (al == _16)
                        and     edx,0ffffh
                        mov     ebx,16
                        mov     ecx,4
                    .ELSEIF (al == _FPU_OPCODE)
                        and     edx,0000011111111111b
                        or      edx,1101100000000000b
                        mov     ebx,16
                        mov     ecx,4
                    .ELSEIF (al == _32)
                        mov     ecx,8
                        mov     ebx,16
                    .ELSEIF (al == _LOWER_NIBBLE3)
                        and     edx,7
                        mov     ebx,2
                        mov     ecx,3
                    .ELSEIF (al == _BINARY8)
                        mov     ebx,2
                        mov     ecx,8
                    .ELSEIF (al == _BINARY11)
                        mov     ebx,2
                        mov     ecx,11
                    .ELSEIF (al == _BINARY16)
                        mov     ebx,2
                        mov     ecx,16
                    .ELSEIF (al == _BINARY32)
                        mov     ebx,2
                        mov     ecx,32
                    .ELSE
                      ; These are handled as text operations
                        .IF (al == _TBYTE || al == _IEEE_80)
                          ; It is a floating point real to be displayed in hex format
                            mov     edx,offset trash_string
                            mov     ecx,10
                            .WHILE (ecx > 0)
                                mov     al,byte ptr ss:[ebp+ebx]
                                mov     ah,al
                                and     al,0fh
                                .IF (al > 9)
                                  ; It gets a letter
                                    add     al,'a'-10
                                .ELSE
                                  ; It gets a number
                                    add     al,'0'
                                .ENDIF
                                mov     byte ptr ds:[edx],al
                                inc     edx
                                and     ah,0fh
                                .IF (ah > 9)
                                  ; It gets a letter
                                    add     ah,'a'-10
                                .ELSE
                                  ; It gets a number
                                    add     ah,'0'
                                .ENDIF
                                mov     byte ptr ds:[edx],al
                                inc     edx
                                dec     ecx
                                inc     ebx
                            .ENDW
                            mov     byte ptr ds:[edx],0
                          ; Right now the string is created and null-terminated

                        .ELSEIF (al == _ADJ_FLOAT14)
                          ; This is an abbreviated version of the floating point data, only 14 chars wide total
                            push    edi
                            mov     ecx,14
                            mov     edi,offset trash_string
                            call    invDEBI_check_stx_from_fpu_save_state
                            .IF (!carry?)
                                finit
                                call    invDEBI_load_stx_from_ebx
                              ; Right now, st(0) - the value we need to display
                                call    invDEBI_convert_st0_to_string
                                call    invDEBI_align_floating_point_string
                            .ENDIF
                            pop     edi
                        .ELSEIF (al == _ADJ_FLOAT20)
                          ; This is a full width floating point data
                            push    edi
                            mov     ecx,20
                            mov     edi,offset trash_string
                            call    invDEBI_check_stx_from_fpu_save_state
                            .IF (!carry?)
                                finit
                                call    invDEBI_load_stx_from_ebx
                              ; Right now, st(0) - the value we need to display
                                call    invDEBI_convert_st0_to_string
                                call    invDEBI_align_floating_point_string
                            .ENDIF
                            pop     edi
                        .ELSEIF (al == _ADJ_FLOAT21)
                          ; This is a full width floating point data
                            push    edi
                            mov     ecx,21
                            mov     edi,offset trash_string
                            call    invDEBI_check_stx_from_fpu_save_state
                            .IF (!carry?)
                                finit
                                call    invDEBI_load_stx_from_ebx
                              ; Right now, st(0) - the value we need to display
                                call    invDEBI_convert_st0_to_string
                                call    invDEBI_align_floating_point_string
                            .ENDIF
                            pop     edi
                        .ELSE
                          ; Unknown type
                            jmp     next_window
                        .ENDIF
                        pushfd
                        push    0                           ; write operation (0-overlay)
                        mov     eax,dword ptr ds:[edi+6]
                        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                        push    eax
                      ; Y coordinate
                        mov     eax,dword ptr ds:[edi+10]
                        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                        push    eax
                        push    0                           ; display mode (0-normal)
                        push    dword ptr offset trash_string
                        cli
                        call    fword ptr ds:_VID_g_mono_display_text_mode
                        popfd
                        add     edi,16
                        jmp     next_object
                    .ENDIF
                  ; Right now, edx - lower nibble contains the upper nibble specified
                  ;            ebx - 2 (base-2 number, it will be displayed in binary)
                  ;            ecx - number of digits to display
                  ; X coordinate
                    pushfd
                    mov     eax,dword ptr ds:[edi+6]
                    add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                    push    eax
                  ; Y coordinate
                    mov     eax,dword ptr ds:[edi+10]
                    add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                    push    eax
                  just_display1:
                    cli
                    call    fword ptr ds:_VID_g_display_radix_in_edx_mono
                    popfd
                  skip1:
                    add     edi,16
                    jmp     next_object

                .ELSEIF (al == _EBP_RELATIVE_EFLAG)
                  ; They're specifying that it's EBP relative flag (our EBP, not theirs)
                    movsx   ebx,word ptr ds:[edi+2]             ; Offset in our stack frame
                    mov     edx,dword ptr ss:[ebp+ebx]          ; Value stored there
                    mov     ecx,dword ptr ds:[edi+5]            ; bit mask to use for flag
                    and     edx,ecx                             ; mask off the value (used below)
                    mov     ebx,edi                             ; Get a pointer to the text string to display
                    add     ebx,18
                    movzx   ecx,byte ptr ds:[ebx-1]             ; Length of this string
                    .IF (edx == 0)
                      ; FLAG is down
                        mov     byte ptr ds:[ebx+ecx-1],''
                    .ELSE
                      ; FLAG is up
                        mov     byte ptr ds:[ebx+ecx-1],''
                    .ENDIF
                  ; X coordinate
                    pushfd
                    push    ecx
                    mov     eax,dword ptr ds:[edi+9]
                    add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                    push    eax
                  ; Y coordinate
                    mov     eax,dword ptr ds:[edi+13]
                    add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                    push    eax
                    push    ebx                                 ; offset to string
                    cli
                    call    fword ptr ds:_VID_g_mono_display_text
                    pop     ecx
                    popfd
                    add     ebx,ecx                             ; move past the string
                    inc     ebx                                 ; for the trailing null
                    mov     edi,ebx
                    jmp     next_object

                .ELSEIF (al == _EBP_THROUGH_EBP_RELATIVE)
                  ; Something in the user's local variables
                    mov     edx,dword ptr ss:[ebp]              ; Get their original EBP value
                    movsx   ebx,word ptr ds:[edi+3]             ; Offset in their stack frame
                    add     edx,ebx
                    test    dword ptr ss:[ebp+56],111b
                    .IF (zero?)
                      ; This is an Exodus core algorithm that's being debugged
                        mov     ebx,08000h
                    .ELSE
                      ; It's a user application, we need to find out exactly how big the stack is
                      ;; REMEMBER, hard-wired stack reference of 8000h ... needs to be dynamic
                        mov     ebx,08000h
                    .ENDIF
                    .IF (edx < ebx && edx >= dword ptr ss:[ebp-04])
                      ; The value of EBP is within the first 32k and it's greater than their value of ESP
                        mov     edx,dword ptr ss:[edx]          ; Value stored there
                        mov     ebx,16
                        mov     ecx,-8                          ; The negative sign indicates leading 0's should be ˙'s
                      ; Right now, edx - lower nibble contains the upper nibble specified
                      ;            ebx - 16 (base-16 number, it will be displayed in hex)
                      ;            ecx - number of digits to display
                      ; X coordinate
                        pushfd
                        mov     eax,dword ptr ds:[edi+6]
                        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                        push    eax
                      ; Y coordinate
                        mov     eax,dword ptr ds:[edi+10]
                        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                        push    eax
                        cli
                        call    fword ptr ds:_VID_g_display_radix_in_edx_mono
                        popfd
                    .ELSE
                      ; Just display the empty string notation
                        pushfd
                        mov     eax,dword ptr ds:[edi+6]
                        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                        push    eax
                      ; Y coordinate
                        mov     eax,dword ptr ds:[edi+10]
                        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                        push    eax
                        push    dword ptr offset empty_dword_text
                        cli
                        call    fword ptr ds:_VID_g_mono_display_text
                        popfd
                    .ENDIF
                    add     edi,16
                    jmp     next_object

                .ELSEIF (al == _ESP_THROUGH_EBP_RELATIVE)
                  ; Something in the user's local variables
                    mov     edx,dword ptr ss:[ebp-04]           ; Get their original ESP value
                    movsx   ebx,word ptr ds:[edi+3]             ; Offset in their stack
                    add     edx,ebx
                    test    dword ptr ss:[ebp+56],111b
                    .IF (zero?)
                      ; This is an Exodus core algorithm that's being debugged
                        mov     ebx,08000h
                    .ELSE
                      ; It's a user application, we need to find out exactly how big the stack is
                      ;; REMEMBER, hard-wired stack reference of 8000h ... needs to be dynamic
                        mov     ebx,08000h
                    .ENDIF
                    .IF (edx < ebx)
                      ; The value of EBP is within the first 32k and it's greater than their value of ESP
                        mov     edx,dword ptr ss:[edx]          ; Value stored there
                        mov     ebx,16
                        mov     ecx,-8                          ; The -8 indicates leading ˙'s and not 0's
                      ; Right now, edx - lower nibble contains the upper nibble specified
                      ;            ebx - 16 (base-16 number, it will be displayed in hex)
                      ;            ecx - number of digits to display
                      ; X coordinate
                        pushfd
                        mov     eax,dword ptr ds:[edi+6]
                        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                        push    eax
                      ; Y coordinate
                        mov     eax,dword ptr ds:[edi+10]
                        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                        push    eax
                        cli
                        call    fword ptr ds:_VID_g_display_radix_in_edx_mono
                        popfd
                    .ELSE
                      ; Just display the empty string notation
                        pushfd
                        mov     eax,dword ptr ds:[edi+6]
                        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                        push    eax
                      ; Y coordinate
                        mov     eax,dword ptr ds:[edi+10]
                        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                        push    eax
                        push    dword ptr offset empty_dword_text
                        cli
                        call    fword ptr ds:_VID_g_mono_display_text
                        popfd
                    .ENDIF
                    add     edi,16
                    jmp     next_object

                .ELSE
                  ; Unsupported option (or invalid data)
                    jmp     next_window
                .ENDIF

            .ELSEIF (al == _INPUT)
                jmp     next_window
            .ELSEIF (al == _POST_DISPLAY)
                add     edi,10
                movzx   ecx,byte ptr ds:[edi]
                add     edi,ecx
                inc     edi
            .ELSEIF (al == _POST_OBJECT)
                jmp     next_window
            .ELSEIF (al == _FUNCTION)
              ; They've specified that a function will handle this item
                mov     ebx,dword ptr ds:[edi+1]
                pushad
                pushfd
                push    ds
                push    es
                push    fs
                push    gs

                call    ebx

                pop     gs
                pop     fs
                pop     es
                pop     ds
                popfd
                popad
                add     edi,5
            .ELSEIF (al == _DRAW_WINDOW_ALWAYS)
              ; Draw a DEBI window, regardless of whether or not the screen is shown
                jmp     force_draw_window
            .ELSEIF (al == _DRAW_WINDOW)
              ; Draw a DEBI window
                .IF (ds:debug_screen_shown == 0 || ds:force_screen_redraw != 0)
                  force_draw_window:
                    pushad
                    mov     ebx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                    mov     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                    mov     edi,dword ptr ds:[edi+1]
                  ; Right now, ebx - horizontal starting pixel
                  ;            eax - vertical starting pixel
                  ;       ds:[edi] - far ptr to screen info
                    call    invDEBI_draw_window
                    popad
                .ENDIF
                add     edi,5
            .ELSE
              ; What is it?  Dunno.  Why not?  'Cause I'm stupid.  Oh yeah. :)
                jmp     next_window
            .ENDIF
          next_object:
        .ENDW
      next_window:
        popad
        pop     es
        ret
    invDEBI_draw_objects    ENDP




    invDEBI_draw_window     PROC
    ; This routine is used draw the contents of a window
    ;
    ; Upon entry:   ebx - horizontal starting pixel
    ;               eax - vertical starting pixel
    ;             [edi] - far ptr to screen info in current data segment
    ;                ds - current data segment
    ;
    ; Upon exit:    The window is drawn
    ;
        .WHILE (byte ptr ds:[edi] != 255)
            push    ebx                                             ; horizontal
            push    eax                                             ; vertical
            push    edi                                             ; start of window item
            call    fword ptr ds:_VID_g_mono_display_text           ;

            add     edi,ecx
            add     eax,dword ptr ss:[ebp-08]                       ; Move down to next line

            .IF (byte ptr ds:[edi] == 254)
              ; They are specifying that this last line has to repeat a fixed number of times
                mov     edx,ecx
                xor     ecx,ecx
                mov     cl,byte ptr ds:[edi+1]                      ; Get the count
                sub     edi,edx
                .REPEAT
                    push    ecx
                    push    ebx
                    push    eax
                    push    edi
                    call    fword ptr ds:_VID_g_mono_display_text
                    add     eax,dword ptr ss:[ebp-08]               ; Next line
                    pop     ecx
                .UNTILCXZ
                jmp     done_with_window
            .ENDIF
        .ENDW
      done_with_window:
        ret
    invDEBI_draw_window     ENDP




    invDEBI_load_stx_from_ebx       PROC
    ; This routine is used to load a particular ST(x) value from the FPU Save State on the stack
    ;
    ; Upon entry:   ss:[ebp-200] - start of FPU save state on the stack
    ;                        ebx - st(0) value on the FPU save state stack to load
    ;
    ; Upon exit:    st(0) is loaded with the value specified (or 0 if ebx is invalid)
    ;
        .IF (ebx == 0)
            mov     ebx,-200+28
        .ELSEIF (ebx == 1)
            mov     ebx,-200+38
        .ELSEIF (ebx == 2)
            mov     ebx,-200+48
        .ELSEIF (ebx == 3)
            mov     ebx,-200+58
        .ELSEIF (ebx == 4)
            mov     ebx,-200+68
        .ELSEIF (ebx == 5)
            mov     ebx,-200+78
        .ELSEIF (ebx == 6)
            mov     ebx,-200+88
        .ELSEIF (ebx == 7)
            mov     ebx,-200+98
        .ELSE
          ; It's invalid, load 0
            fldz
            jmp     quit
        .ENDIF
        fld     tbyte ptr ss:[ebp+ebx]
      quit:
        ret
    invDEBI_load_stx_from_ebx       ENDP




    invDEBI_check_stx_from_fpu_save_state   PROC
    ; This routine is used as a precursor to invDEBI_convert_st0_to_string().  It determines whether or not a particular
    ; st(x) value stored in the FPU Save State on the stack is valid or not (based on the TAG word).  If it is valid then it
    ; does nothing.  If it is invalid then it populates the ds:[edi] string with the appropriate text.
    ;
    ; Upon entry:   ebx - st(x) value (0-7)
    ;               ecx - maximum string width
    ;          ds:[edi] - Where to store the string (if generated)
    ;
    ; Upon exit:    ds:[edi] - may be updated with the generated string
    ;               carry? - CLEAR if not updated, SET if updated
    ;
        pushad
        movzx   eax,word ptr ss:[ebp-200+8]                         ; Load TAG word
        movzx   edx,word ptr ss:[ebp-200+4]                         ; Load STATUS word
        call    invDEBI_adjust_for_fpu_tos                          ; Adjust the current TAG word for top-of-stack
        cmp     ebx,0                                               ; They want us to examine st(0)
        jz      next_part
        shr     eax,2
        cmp     ebx,1                                               ; st(1)
        jz      next_part
        shr     eax,2
        cmp     ebx,2                                               ; st(2)
        jz      next_part
        shr     eax,2
        cmp     ebx,3                                               ; st(3)
        jz      next_part
        shr     eax,2
        cmp     ebx,4                                               ; st(4)
        jz      next_part
        shr     eax,2
        cmp     ebx,5                                               ; st(5)
        jz      next_part
        shr     eax,2
        cmp     ebx,6                                               ; st(6)
        jz      next_part
        shr     eax,2
        cmp     ebx,7                                               ; st(7)
        jz      next_part
      ; If we're here it wasn't found
      ; It's an error so we go ahead and display the value numerically (which will catch NaN's and the like)
        clc
        jmp     quit

      next_part:
        and     eax,11b
        .IF (eax != 11b)
          ; It's something that needs to be represented numerically
            clc                                                     ; Clear the flag (we didn't copy anything)
            jmp     quit
        .ENDIF

      ; It's empty, so we copy the string
        mov     esi,offset number_empty
        mov     ebx,ecx
        xor     ecx,ecx
        .WHILE (byte ptr ds:[esi+ecx] != 0 && ebx > 0)
            mov     al,byte ptr ds:[esi+ecx]
            mov     byte ptr ds:[edi+ecx],al
            inc     ecx
            .IF (al != 'Æ' && al != 'Ø')
                dec     ebx
            .ENDIF
        .ENDW
        .WHILE (ebx > 0)
            mov     byte ptr ds:[edi+ecx],' '
            inc     ecx
            dec     ebx
        .ENDW
        mov     byte ptr ds:[edi+ecx],0
        stc                                                         ; Set the flag (indicating we copied something)

      quit:
        popad
        ret
    invDEBI_check_stx_from_fpu_save_state   ENDP




    invDEBI_adjust_for_fpu_tos      PROC
    ; This algorithm is used to adjust the currently requested
    ;
    ; Upon entry:  eax - TAG word
    ;              ebx - st(x) value they're desiring
    ;              edx - STATUS word
    ;
    ; Upon exit:   eax - adjusted properly for current TOS pointer
    ;
        shr     edx,11                                              ; Shift it over 11 bits (to get TOS down to the lower 3 bits)
        cmp     edx,00
        jz      quit                                                ; if branch we're good to go (TOS is already at 0)
        rol     ax,2
        cmp     edx,7
        jz      quit                                                ; in branch it was at 7
        rol     ax,2
        cmp     edx,6
        jz      quit                                                ; in branch it was at 6
        rol     ax,2
        cmp     edx,5
        jz      quit                                                ; in branch it was at 5
        rol     ax,2
        cmp     edx,4
        jz      quit                                                ; in branch it was at 4
        rol     ax,2
        cmp     edx,3
        jz      quit                                                ; in branch it was at 3
        rol     ax,2
        cmp     edx,2
        jz      quit                                                ; in branch it was at 2
        rol     ax,2
      ; If we get all the way to here then it was 1

      quit:
        ret
    invDEBI_adjust_for_fpu_tos      ENDP




    invDEBI_convert_st0_to_string       PROC
    ; This routine is used to convert the value currently stored in ST0 to it's standard numeric equivalent
    ;
    ; Upon entry:   st0 - IEEE 80-bit to convert to string
    ;               ecx - maximum string width
    ;          ds:[edi] - where to store the trash string
    ;
    ; Upon exit:    ds:[edi] is updated with the string to display
    ;
        pushad
        push    es
        mov     es,cs:data_segment

        mov     es:exponent,0
        fxam                                                        ; Examine the # for weird values
        fstsw   es:FPStat
        mov     bx,es:FPStat

      ; Copy high bits to low.
        mov     bl,bh
        shr     bh,3
        and     bh,008h
        and     bl,007h
        or      bl,bh
      ; bl now has C3, C2, C1 and C0 in low 4 bits

        .IF (bl != 4 && bl != 6)
            .IF (bl == 0)
                mov     esi,offset bad_number0
            .ELSEIF (bl == 1)
                mov     esi,offset bad_number1
            .ELSEIF (bl == 2)
                mov     esi,offset bad_number2
            .ELSEIF (bl == 3)
                mov     esi,offset bad_number3
            .ELSEIF (bl == 5)
                mov     esi,offset bad_number5
            .ELSEIF (bl == 7)
                mov     esi,offset bad_number7
            .ELSEIF (bl == 8)
                mov     al,'+'
                jmp     skip_alignment
            .ELSEIF (bl == 9)
                mov     esi,offset bad_number9
            .ELSEIF (bl == 10)
                mov     al,'-'
                fchs
                jmp     skip_alignment
            .ELSEIF (bl == 11)
                mov     esi,offset bad_number11
            .ELSEIF (bl == 12)
                mov     esi,offset bad_number12
            .ELSEIF (bl == 13)
                mov     esi,offset bad_number13
            .ELSEIF (bl == 14)
                mov     esi,offset bad_number14
            .ELSEIF (bl == 15)
                mov     esi,offset bad_number13
            .ELSE
                jmp     do_the_number
            .ENDIF

          ; Note, this bit of code is duplicated in the invDEBI_check_stx() algorithm
            mov     ebx,ecx
            xor     ecx,ecx
            .WHILE (byte ptr es:[esi+ecx] != 0 && ebx > 0)
                mov     al,byte ptr es:[esi+ecx]
                mov     byte ptr ds:[edi+ecx],al
                inc     ecx
                dec     ebx
            .ENDW

            inc     ebx
            .WHILE (ebx > 0)
                mov     byte ptr ds:[edi+ecx],' '
                inc     ecx
                dec     ebx
            .ENDW
            mov     byte ptr ds:[edi+ecx],0
            jmp     quit
        .ENDIF

      do_the_number:
      ; Is it greater than zero?
        ftst
        fstsw   ax
        mov     es:FPStat,ax
        sahf
        .IF (carry?)
          ; It is < than zero...Put a minus sign
            mov     al,"-"
            fchs
        .ELSE
          ; It is > than zero...Put a plus sign
            mov     al,"+"
        .ENDIF

      ; While the number is less than 1 multiply by 10 and decrement exponent
        push    eax
      @@:
        fld1
        fcomp
        fstsw   ax
        sahf
        jc      @F
        dec     es:exponent
        fild    es:number10
        fmul
        jmp     @B
      @@:

      ; While the number is greater than or equal to 10, divide it by 10 and increment the exponent
      @@:
        ficom   es:number10
        fstsw   ax
        sahf
        jc      @F
        inc     es:exponent
        fild    es:number10
        fdivp   st(1),st
        jmp     @B
      @@:
      ; The value is now a number in the range of 1.0<=Number<10
        pop     eax

      skip_alignment:
        mov     byte ptr ds:[edi],al
        inc     edi
      ; Now set up rounding by chopping
        fstcw   es:FPCtrl
        movzx   eax,es:FPCtrl
        and     eax,0f3ffh
        or      eax,0c00h
        mov     es:FPCtrl,ax
        fldcw   es:FPCtrl

        call    invDEBI_extract_digit
        mov     byte ptr ds:[edi],al
        inc     edi
        mov     al,"."
        mov     byte ptr ds:[edi],al
        inc     edi

      ; Now get 18 decimals
        mov     ecx,18
        .REPEAT
            call    invDEBI_extract_digit
            mov     byte ptr ds:[edi],al
            inc     edi
        .UNTILCXZ

      ; Now write the exponent
        mov     byte ptr ds:[edi],'e'
        inc     edi
        mov     edx,es:exponent
        call    invDEBI_signed_convert_dword_to_decimal         ; Store the exponent as signed text

      quit:
        fistp   es:trash_dword
        pop     es
        popad
        ret
    invDEBI_convert_st0_to_string       ENDP




    invDEBI_extract_digit   PROC    NEAR
    ; This routine is called to extract the left-most digit from a number in the format of #.######
    ;
    ; Upon entry:   the value is in st(0)
    ;
    ; Upon exit:    al - extracted digit
    ;
        fld     st(0)                                               ; Duplicate st(0)
        frndint                                                     ; Convert this value to an int
        fsub    st(1),st(0)                                         ; Get the "remainder" portion
        fistp   es:digit                                            ; Store it
        fild    es:number10                                         ; Now update our the value by our multiplier
        fmulp   st(1),st(0)

      ; Get the digit and convert it and write it
        mov     eax,es:digit
        add     al,"0"
        ret
    invDEBI_extract_digit   ENDP




    invDEBI_signed_convert_dword_to_decimal     PROC
    ; This routine takes the value in edx and outputs it to ds:[edi]
    ;
    ; Upon entry:   edx - value to convert
    ;          ds:[edi] - where to store the signed quantity
    ;
    ; Upon exit:    The value is converted
    ;               edi - pointer to end of string
    ;
        enter   10,0
        pushad
        mov     esi,ebp
        sub     esi,10
      ; Right now, ss:[esi] - far ptr to string to build
        mov     byte ptr ss:[esi],0
        inc     esi

        .IF (edx > 7fffffffh)
            mov     al,"-"
            neg     edx
        .ELSE
            mov     al,"+"
        .ENDIF
        stosb

        mov     eax,edx
        mov     ebx,10
      @@:
        xor     edx,edx
        div     ebx
        add     dl,'0'
        mov     byte ptr ss:[esi],dl
        inc     esi
        cmp     eax,0
        jnz     @B

      ; Right now we've extracted all of the values
        mov     ecx,2                                               ; Default to 2, one for +/- above, one for trailing NULL
        dec     esi
        .WHILE (byte ptr ss:[esi] != 0)
            mov     dl,byte ptr ss:[esi]
            mov     byte ptr ds:[edi],dl
            inc     edi
            dec     esi
            inc     ecx
        .ENDW
        mov     byte ptr ds:[edi],0                                 ; NULL terminate

        mov     es:signed_digits,ecx                                ; Indicate how many digits were written in the exponent
        add     dword ptr ss:[esp+00],ecx                           ; Update edi on the stack

        popad
        leave
        ret
    invDEBI_signed_convert_dword_to_decimal     ENDP




    invDEBI_align_floating_point_string     PROC
    ; This routine is used to adjust a floating pointer string that was just created
    ;
    ; Upon entry:   cs:exponent - # of digits in the exponent portion
    ;               ds:[edi] - far ptr to string to adjust
    ;                    ecx - maximum width for value
    ;
    ; Upon exit:    String at ds:[edi] is adjusted (if possible) to represent it in the number of digits specified in ecx
    ;               * Note:  If the string cannot be represented in the specified length then it will appear in +1.234e+289 form
    ;
        enter   4,0
      ; [ebp-04] - dword, used to hold the NEG exponent value for a negative exponent (this gives it the positive appearance)
        pushad
        push    es
        mov     es,cs:data_segment
        .IF (es:exponent == 0)
          ; The number is already adjusted properly for decimal alignment
          ; All we have to worry about is the width
          truncate_as_necessary:
            xor     ebx,ebx
            .WHILE (ebx < ecx && byte ptr ds:[edi+ebx] != 'e' && byte ptr ds:[edi+ebx] != '<')
                .IF (byte ptr ds:[edi+ebx] == 'Æ' || byte ptr ds:[edi+ebx] == 'Ø')
                    inc     ecx
                .ENDIF
                inc     ebx
            .ENDW
            .IF (byte ptr ds:[edi+ebx] == '<')
              ; This is one of the conditions, it's not a number
                .WHILE (ebx < ecx)
                    .IF (byte ptr ds:[edi+ebx] == 'Æ' || byte ptr ds:[edi+ebx] == 'Ø')
                        inc     ecx
                    .ENDIF
                    .IF (byte ptr ds:[edi+ebx] == 0)
                        mov     byte ptr ds:[edi+ebx],32
                    .ENDIF
                    inc     ebx
                .ENDW
            .ELSE
                .IF (ebx < ecx)
                  ; We need to pad with spaces
                    .WHILE (ebx < ecx)
                        .IF (byte ptr ds:[edi+ebx] == 'Æ' || byte ptr ds:[edi+ebx] == 'Ø')
                            inc     ecx
                        .ENDIF
                        mov     byte ptr ds:[edi+ebx],' '
                        inc     ebx
                    .ENDW
                .ENDIF
            .ENDIF
            mov     byte ptr ds:[edi+ebx],0
        .ELSEIF (es:exponent > 80000000h)
          ; It's negative
            mov     ebx,es:exponent
            neg     ebx
            mov     dword ptr ss:[ebp-04],ebx
            .IF (ebx < ecx)
              ; We an adjust it
              ; Exchange the first digit and its decimal point
                mov     al,byte ptr ds:[edi+1]
                xchg    al,byte ptr ds:[edi+2]
                mov     byte ptr ds:[edi+1],al
                mov     edx,20
                sub     edx,ebx
                mov     esi,edi
                push    ebx
                .WHILE (edx > 1)
                    mov     al,byte ptr ds:[edi+edx]
                    mov     byte ptr ds:[esi+20],al
                    dec     esi
                    dec     edx
                .ENDW
                pop     ebx
                mov     ebx,dword ptr ss:[ebp-04]
                .WHILE (ebx > 1)
                    mov     byte ptr ds:[esi+20],'0'
                    dec     esi
                    dec     ebx
                .ENDW
              ; Now, put the first 2 characters back where they're supposed to be
                mov     word ptr ds:[edi+1],'.0'
                mov     dword ptr ds:[edi+21],' 0+e'                ; Note, there's a NULL embedded on this line '<null>0+e'
                jmp     truncate_as_necessary
            .ENDIF
        .ELSE
          ; It's positive
            .IF (es:exponent < ecx)
              ; We can adjust it
                mov     ebx,es:exponent
                mov     esi,edi
                .WHILE (ebx > 0)
                    mov     al,byte ptr ds:[esi+3]                  ; Move to the "1" in "+2.1234567890"
                    mov     byte ptr ds:[esi+2],al                  ; Move to the "." in same
                    inc     esi
                    dec     bx
                .ENDW
                mov     byte ptr ds:[esi+2],'.'
                jmp     truncate_as_necessary
            .ENDIF
        .ENDIF

      quit:
        pop     es
        popad
        leave
        ret
    invDEBI_align_floating_point_string     ENDP




    invDEBI_quick_watch_add_item    PROC
    ; This routine is used to add a line item to the quick watch window
    ;
    ; Upon entry:   ds:[esi] - ptr to item to add
    ;               cs:[edi] - ptr to text to preceed item to add
    ;                          * Note:  If edi = -1, then only ds:[esi] is used
    ;
    ; Upon exit:    Item is added and the quick watch window is updated
    ;
        pushfd
        push    es
        push    ds
        pushad

        mov     es,cs:data_segment
        .IF (edi == -1)
            jmp     doing_ds_esi_only
        .ENDIF
      do_again_cs_edi:
        call    invDEBI_quick_watch_scroll_data
        mov     ebx,offset quick_1
        mov     ecx,sizeof quick_1 - 2
        .WHILE (ecx > 0 && byte ptr es:[edi] != 0)
            mov     al,byte ptr es:[edi]
            inc     edi
            mov     byte ptr es:[ebx],al
            inc     ebx
            dec     ecx
        .ENDW
        .IF (byte ptr es:[edi] != 0)
          ; Still more to do
            jmp     do_again_cs_edi
        .ENDIF

      do_again_ds_esi:
        .WHILE (byte ptr ds:[esi] != 0 && ecx > 0)
            lodsb
            mov     byte ptr es:[ebx],al
            inc     ebx
            dec     ecx
        .ENDW
        .IF (byte ptr ds:[esi] != 0)
          ; Still more to do
          doing_ds_esi_only:
            call    invDEBI_quick_watch_scroll_data
            mov     ebx,offset quick_1
            mov     ecx,sizeof quick_1 - 2
            jmp     do_again_ds_esi
        .ENDIF
        call    invDEBI_quick_watch_refresh_window

        popad
        pop     ds
        pop     es
        popfd
        ret
    invDEBI_quick_watch_add_item    ENDP




    invDEBI_quick_watch_add_item_ecx        PROC
    ; This routine is used to add a line item to the quick watch window
    ;
    ; Upon entry:   ds:[esi] - ptr to item to add
    ;               cs:[edi] - ptr to text to preceed item to add
    ;
    ; Upon exit:    Item is added and the quick watch window is updated
    ;
        pushfd
        push    es
        push    ds
        pushad

        mov     es,cs:data_segment
        .IF (edi == -1)
            jmp     doing_ds_esi_only
        .ENDIF
      do_again_cs_edi:
        call    invDEBI_quick_watch_scroll_data
        mov     ebx,offset quick_1
        mov     edx,sizeof quick_1 - 2
        .WHILE (byte ptr es:[edi] != 0 && edx > 0)
            mov     al,byte ptr es:[edi]
            inc     edi
            mov     byte ptr es:[ebx],al
            inc     ebx
            dec     edx
        .ENDW
        .IF (byte ptr es:[edi] != 0)
          ; Still more to do
            jmp     do_again_cs_edi
        .ENDIF

      do_again_ds_esi:
        .WHILE (byte ptr ds:[esi] != 0 && ecx > 0)
            lodsb
            mov     byte ptr es:[ebx],al
            inc     ebx
            dec     ecx
        .ENDW
        .IF (byte ptr ds:[esi] != 0)
          ; Still more to do
          doing_ds_esi_only:
            call    invDEBI_quick_watch_scroll_data
            mov     ebx,offset quick_1
            mov     ecx,sizeof quick_1 - 2
            jmp     do_again_ds_esi
        .ENDIF
        call    invDEBI_quick_watch_refresh_window

        popad
        pop     ds
        pop     es
        popfd
        ret
    invDEBI_quick_watch_add_item_ecx        ENDP




    invDEBI_quick_watch_refresh_window      PROC
    ; This routine physically redraws the quick watch window
    ;
    ; Upon entry:   Nothing
    ;
    ; Upon exit:    The window is redrawn
    ;
        pushfd
        pushad
        push    ds

      ; Now, physically draw the window (update it)
        mov     ds,cs:data_segment
        mov     esi,offset quick_watch_screen_object
        mov     ebx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        mov     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        mov     edi,offset DEBI_j_window

      ; Right now, ebx - horizontal starting pixel
      ;            eax - vertical starting pixel
      ;       ds:[edi] - far ptr to screen info
        cli
        call    invDEBI_hide_mouse_pointer
        call    invDEBI_turn_cursor_off
        call    invDEBI_draw_window
        call    invDEBI_show_mouse_pointer

        pop     ds
        popad
        popfd
        ret
    invDEBI_quick_watch_refresh_window      ENDP




    invDEBI_quick_watch_add_radix_in_edx        PROC
    ; This routine is used to display the value in edx in a radix in ebx
    ;
    ; Upon entry:   edx - value to display
    ;               ebx - radix to display in
    ;               edi - ptr to text to add, or -1 if none
    ;
    ; Upon exit:    The value is displayed
    ;
        push    ds
        pushad
        sub     esp,36                                                  ; Assume a maximum length of 32 chars (4 extra for boundary)
        mov     ebp,esp

        mov     byte ptr [ebp+32],0                                     ; NULL terminate the string we're building
        mov     esi,ebp
        add     esi,31
        mov     eax,edx
        and     ebx,0ffffh
        .IF (ebx <= 1)
          ; They've forgotten to set the value, so we correct their little blunder
            mov     ebx,16
        .ENDIF
      @@:
        xor     edx,edx
        div     ebx
        .IF (dl > 9)
            add     dl,'a'-10                                           ; Make it a letter if it's above 9 (10+ cannot be represented in 1 digit)
        .ELSE
            add     dl,'0'                                              ; Make it a number
        .ENDIF
        mov     byte ptr ss:[esi],dl
        dec     esi                                                     ; Decrement (move to next position to store data)
        cmp     esi,ebp
        jz      @F
        cmp     eax,0
        jnz     @B
      @@:
        push    ss
        pop     ds
        inc     esi                                                     ; Add back for the one we decremented above
      ; Right now, ds:[esi] - ptr to the value to display
      ;            cs:[edi] - ptr to text to preceed this item
        mov     ebp,dword ptr ss:[esp+08+36]
        call    invDEBI_quick_watch_add_item

        add     esp,36
        popad
        pop     ds
        ret
    invDEBI_quick_watch_add_radix_in_edx        ENDP




    invDEBI_quick_watch_add_real4_in_edx        PROC
    ; This routine is used to display the value in edx in a radix in ebx
    ;
    ; Upon entry:   edx - REAL4 value to display
    ;               edi - ptr to text to add, or -1 if none
    ;
    ; Upon exit:    The value is displayed
    ;
        pushad
        push    ds
        sub     esp,44                                                  ; Allow for plenty of space

        push    ss
        pop     ds
        mov     dword ptr ss:[esp],edi
        mov     edi,esp
        add     edi,4
        mov     esi,edi
        mov     ecx,18
      ; Right now, ds:[esi] - ptr to the value to display
      ;            cs:[edi] - ptr to text to preceed this item
        mov     dword ptr ds:[edi],edx
        fld     real4 ptr ds:[edi]
        call    invDEBI_convert_st0_to_string
        mov     edi,dword ptr ss:[esp]
        call    invDEBI_quick_watch_add_item

        add     esp,44
        pop     ds
        popad
        ret
    invDEBI_quick_watch_add_real4_in_edx        ENDP




    invDEBI_quick_watch_add_divider     PROC
    ; This routine is called to put a divider up between items in the quickwatch window
    ;
    ; Upon entry:   Nothing
    ;
    ; Upon exit:    The divider bar is displayed
    ;
        push    ds
        push    esi
        push    edi

        mov     ds,cs:data_segment
        mov     esi,offset quick_watch_divider
        mov     edi,-1
        call    invDEBI_quick_watch_add_item

        pop     edi
        pop     esi
        pop     ds
        ret
    invDEBI_quick_watch_add_divider     ENDP




    invDEBI_quick_watch_scroll_data     PROC
    ; This routine physically copies the data in the watch window up one line
    ;
    ; Upon entry:   Nothing
    ;
    ; Upon exit:    Data is scrolled
    ;
        pushfd
        push    ds
        push    es
        push    esi
        push    edi
        push    ecx
        push    eax

        mov     ds,cs:data_segment
        mov     es,cs:data_segment

        cld
        mov     esi,offset quick_11
        mov     edi,offset quick_12
        mov     ecx,sizeof quick_12 - 2
        rep     movsb
        mov     esi,offset quick_10
        mov     edi,offset quick_11
        mov     ecx,sizeof quick_11 - 2
        rep     movsb
        mov     esi,offset quick_9
        mov     edi,offset quick_10
        mov     ecx,sizeof quick_10 - 2
        rep     movsb
        mov     esi,offset quick_8
        mov     edi,offset quick_9
        mov     ecx,sizeof quick_9 - 2
        rep     movsb
        mov     esi,offset quick_7
        mov     edi,offset quick_8
        mov     ecx,sizeof quick_8 - 2
        rep     movsb
        mov     esi,offset quick_6
        mov     edi,offset quick_7
        mov     ecx,sizeof quick_7 - 2
        rep     movsb
        mov     esi,offset quick_5
        mov     edi,offset quick_6
        mov     ecx,sizeof quick_6 - 2
        rep     movsb
        mov     esi,offset quick_4
        mov     edi,offset quick_5
        mov     ecx,sizeof quick_5 - 2
        rep     movsb
        mov     esi,offset quick_3
        mov     edi,offset quick_4
        mov     ecx,sizeof quick_4 - 2
        rep     movsb
        mov     esi,offset quick_2
        mov     edi,offset quick_3
        mov     ecx,sizeof quick_3 - 2
        rep     movsb
        mov     esi,offset quick_1
        mov     edi,offset quick_2
        mov     ecx,sizeof quick_2 - 2
        rep     movsb
      ; Reset the bottom line to spaces
        mov     edi,offset quick_1
        mov     ecx,sizeof quick_1 - 2
        mov     al,32
        rep     stosb

        pop     eax
        pop     ecx
        pop     edi
        pop     esi
        pop     es
        pop     ds
        popfd
        ret
    invDEBI_quick_watch_scroll_data     ENDP




    invDEBI_query_window            PROC
    ; This routine is called when updating the screen (it handles query window objects)
    ;
    ; Upon entry:   The stack is arranged as below
    ;               ds:[esi] - ptr to screen table structure
    ;               ds:[edi] - ptr to this item's objects
    ;
    ; Upon exit:    The window is populated or not
    ;
      ; [ebp-080] - offset into _sDEBI_memory for next item
      ; [ebp-084] - segment of temp far address
      ; [ebp-088] - offset of temp far address
      ; [ebp-092] - (temp) used as a temporary holder for processing
        ret
    invDEBI_query_window            ENDP
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; END - 00000 - Window Supportive Algorithms/Handlers
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; 11111 - External interfaces (Timer, Mouse, Kbd)
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    iDEBI_kbd_interface     PROC
    ; This routine is called when the user presses a key after iKBD_activate_DEBI_intercept() has been called
    ;
    ; Upon entry:   eax - key
    ;               ebx - keyboard flags
    ;
    ; Upon exit:    Nothing
    ;
        .IF (cs:disable_kbd == 1)
            retf
        .ENDIF

      ; Cancel the screen saver (if it's activated)
        push    ds
        mov     ds,cs:data_segment
        call    invDEBI_cancel_screen_saver
        mov     ds:screen_saver_count,0

      ; Process the key with whatever routine is receiving keyboard input
        .IF (cs:kbd_focus == -1)
          ; No handler is seutp, use DEBI generic
            call    invDEBI_kbd_handler
        .ELSE
            push    es
            push    fs
            push    gs
            pushad

            mov     edx,ds:kbd_focus
            call    edx

            popad
            pop     gs
            pop     fs
            pop     es
        .ENDIF

        pop     ds
        retf
    iDEBI_kbd_interface     ENDP




    iDEBI_mouse_interface       PROC
    ; This routine is called when the mouse status changes after iMOUSE_activate_DEBI_intercept() has been called
    ;
    ; Upon entry:   eax - X delta
    ;               edx - Y delta
    ;               ebx - button status
    ;
    ; Upon exit:    Nothing
    ;
        .IF (cs:disable_mouse == 1)
            retf
        .ENDIF
        push    ds
        pushad
        mov     ds,cs:data_segment

      ;; Cancel screen saver if it's active
        call    invDEBI_cancel_screen_saver
        mov     ds:screen_saver_count,0

      ;; Remove the mouse pointer that's already displayed
        .IF (ds:mouse_processing == 0 && ds:mouse_status == 1)
            call    invDEBI_hide_mouse_pointer
        .ENDIF

      ;; Update the coordinates based on the signed displacement information sent to us from the mouse driver
        call    invDEBI_update_mouse_coordinates

      ;; Process the mouse
        .IF (ds:mouse_processing == 0)
          ; No button status, just moving the mouse around. :)
            mov     ds:mouse_processing,1
            .IF (ds:dragging_something != 0)
                pushad
                pushfd
                push    ds

              ; Put the image back on the screen where it was
                cli
                .IF (ds:dragging_something != 1)
                    push    dword ptr ds:dragging_x
                    mov     edx,ds:dragging_offset_x
                    sub     dword ptr ss:[esp],edx
                    call    invDEBI_dragging_snap_x

                    push    dword ptr ds:dragging_y
                    mov     edx,ds:dragging_offset_y
                    sub     dword ptr ss:[esp],edx
                    call    invDEBI_dragging_snap_y

                    mov     edx,ds:dragging_last_x
                    mov     ebx,ds:dragging_last_y
                    .IF (dword ptr ss:[esp+4] == edx && dword ptr ss:[esp] == ebx)
                      ; This will only be the case if they're using a dragging_snap_x and/or dragging_snap_y value
                        mov     ds:dragging_skipped,1
                        add     esp,8
                        jmp     skip_dragging_redraw
                    .ELSE
                        mov     edx,dword ptr ss:[esp+4]
                        mov     ebx,dword ptr ss:[esp+0]
                        .IF (ds:dragging_skipped != 0)
                            mov     ds:dragging_skipped,0
                            mov     edx,ds:dragging_last_x
                            mov     ebx,ds:dragging_last_y
                            mov     dword ptr ss:[esp+4],edx
                            mov     dword ptr ss:[esp+0],ebx
                        .ELSE
                            mov     ds:dragging_last_x,edx
                            mov     ds:dragging_last_y,ebx
                        .ENDIF
                    .ENDIF

                    push    dword ptr ss:[esp+4]
                    mov     edx,ds:dragging_width
                    add     dword ptr ss:[esp],edx

                    push    dword ptr ss:[esp+4]
                    mov     edx,ds:dragging_height
                    add     dword ptr ss:[esp],edx

                    push    0
                    push    0
                    mov     eax,_sDEBI_screen
                    mov     ds,ax
                    call    fword ptr cs:_VID_g_mono_window_function
                .ELSE
                    inc     ds:dragging_something
                    mov     eax,_sDEBI_screen
                    mov     ds,ax
                .ENDIF

              ; Get the image at the new location
                push    dword ptr cs:mouse_current_x
                mov     edx,cs:dragging_offset_x
                sub     dword ptr ss:[esp],edx
                call    invDEBI_dragging_snap_x

                push    dword ptr cs:mouse_current_y
                mov     edx,cs:dragging_offset_y
                sub     dword ptr ss:[esp],edx
                call    invDEBI_dragging_snap_y

                push    dword ptr ss:[esp+4]
                mov     edx,cs:dragging_width
                add     dword ptr ss:[esp],edx

                push    dword ptr ss:[esp+4]
                mov     edx,cs:dragging_height
                add     dword ptr ss:[esp],edx

                push    1
                push    0
                call    fword ptr cs:_VID_g_mono_window_function

              ; Draw it at its new location
                push    dword ptr cs:mouse_current_x
                mov     edx,cs:dragging_offset_x
                sub     dword ptr ss:[esp],edx
                call    invDEBI_dragging_snap_x

                push    dword ptr cs:mouse_current_y
                mov     edx,cs:dragging_offset_y
                sub     dword ptr ss:[esp],edx
                call    invDEBI_dragging_snap_y

                push    dword ptr ss:[esp+4]
                mov     edx,cs:dragging_width
                add     dword ptr ss:[esp],edx

                push    dword ptr ss:[esp+4]
                mov     edx,cs:dragging_height
                add     dword ptr ss:[esp],edx

                push    0
                push    dword ptr 4000h
                call    fword ptr cs:_VID_g_mono_window_function

              ; Update the dragging_coordinates
              skip_dragging_redraw:
                pop     ds
                popfd
                mov     edx,ds:mouse_current_x
                mov     ds:dragging_x,edx
                mov     edx,ds:mouse_current_y
                mov     ds:dragging_y,edx
                popad
            .ENDIF
            .IF (ebx != 0 || ebx != ds:mouse_last_buttons)
              ; There is button activity
              ; This process might take a bit of time to complete so we indicate we're processing thereby removing
              ; the possibility of attempted processing in the future until such time as all the processing we're about
              ; to start gets completed.
                call    invDEBI_mouse_button_activity
            .ELSE
              ; No button activity
              ; We still have to see if we're over anything that needs to be updated because we also display information about
              ; certain things in the Quick Watch window.  Isn't it great? :)
                mov     edx,ds:mouse_current_x
                mov     ds:mouse_hovering_x,edx
                mov     edx,ds:mouse_current_y
                mov     ds:mouse_hovering_y,edx
                mov     ds:mouse_hovering_count,91
                mov     ds:mouse_last_event,_HOVER
                mov     ds:mouse_immediate_count,_IMMEDIATE_COUNT
                call    invDEBI_show_mouse_pointer
            .ENDIF
            mov     ds:mouse_processing,0
        .ENDIF

        popad
        pop     ds
        retf
    iDEBI_mouse_interface       ENDP




;; Bochs hack
    iDEBI_bochs_mouse_interface     PROC
    ; Called from the mouse handler, simulates mouse input as though it came from a real mouse.
    ; When working with Bochs, the MoMo maintains mouse pointer position, which is fed here.
    ;
    ; Upon entry:   eax - X delta
    ;               ebx - Y delta
    ;               ecx - button status
    ;
    ; Upon exit:    Nothing
    ;
        push    ds
        pushad
        mov     ds,cs:data_segment

        ; See if anything's changed
        .IF (eax != ds:mouse_current_x && ebx != ds:mouse_current_y)
            ; It has
            mov     edx,ebx         ; Update Y coord for iDEBI_mouse_interface
            mov     ebx,ecx         ; Update button for iDEBI_mouse_interface
            push    cs
            call    iDEBI_mouse_interface
        .ENDIF

        popad
        pop     ds
        retf
    iDEBI_bochs_mouse_interface     ENDP
;; Bochs hack




    invDEBI_dragging_snap_x         PROC
    ; This routine is called to adjust the snap-to coordinates of the mouse movement
    ;
    ; Upon entry:   ss:[esp+4] - value to snap
    ;               ds:dragging_snap_x - value to snap to
    ;
    ; Upon exit:    Value on stack is updated to upper-most region
    ;
      ; [esp+8] - X coord to snap
      ; [esp+4] - calling EIP
      ; [esp+0] - ds
        .IF (cs:dragging_snap_x != 0)
            push    ds
            mov     ds,cs:data_segment
            mov     eax,dword ptr ss:[esp+8]
            mov     ebx,ds:dragging_snap_x
            xor     edx,edx
            div     ebx
            mul     ebx
            mov     dword ptr ss:[esp+8],eax
            pop     ds
        .ENDIF
        ret
    invDEBI_dragging_snap_x         ENDP




    invDEBI_dragging_snap_y         PROC
    ; This routine is called to adjust the snap-to coordinates of the mouse movement
    ;
    ; Upon entry:   ss:[esp+4] - value to snap
    ;               ds:dragging_snap_y - value to snap to
    ;
    ; Upon exit:    Value on stack is updated to left-most region
    ;
      ; [esp+8] - Y coord to snap
      ; [esp+4] - calling EIP
      ; [esp+0] - ds
        .IF (cs:dragging_snap_y != 0)
            push    ds
            mov     ds,cs:data_segment
            mov     eax,dword ptr ss:[esp+8]
            mov     ebx,ds:dragging_snap_y
            xor     edx,edx
            div     ebx
            mul     ebx
            mov     dword ptr ss:[esp+8],eax
            pop     ds
        .ENDIF
        ret
    invDEBI_dragging_snap_y         ENDP




    invDEBI_update_mouse_coordinates    PROC
    ; This routine is used to update the mouse coordinates
    ;
    ; Upon entry:   eax - change in X
    ;               edx - change in Y
    ;
    ; Upon exit:    values are updated
    ;
;; Bochs hack
;;        shl     eax,1                                               ; We multiply the X-coordinate by 2 because the
;;                                                                    ; monochrome display is 720x348 (x is twice as big)
;;        add     ds:mouse_current_x,eax
;;        add     ds:mouse_current_y,edx
        mov     ds:mouse_current_x,eax
        mov     ds:mouse_current_y,edx
;; Bochs hack
        .IF (ds:dragging_something == 0)
          ; Verify X
            .IF (ds:mouse_current_x > 7fffffffh || ds:mouse_current_x == 0)
              ; It's negative (it's off the left of the screen or it's at the very left of the screen)
                mov     ds:mouse_current_x,1
            .ELSEIF (ds:mouse_current_x > 718)
              ; It's heading off the right side of the screen
                mov     ds:mouse_current_x,718
            .ENDIF

          ; Verify Y
            .IF (ds:mouse_current_y > 7fffffffh || ds:mouse_current_y == 0)
              ; It's negative (it's above the top of the screen or it's at the very top of the screen)
                mov     ds:mouse_current_y,1
            .ELSEIF (ds:mouse_current_y > 346)
              ; It's heading off the bottom of the screen
                mov     ds:mouse_current_y,346
            .ENDIF
        .ELSE
          ; The mouse is only allowed to move in certain areas when something is being dragged
          ; This logic is a little more complex than the above no-drag logic

          ; Make sure they're not negative
            .IF (ds:mouse_current_x > 7fffffffh)
                neg     ds:mouse_current_x
            .ENDIF
            .IF (ds:mouse_current_y > 7fffffffh)
                neg     ds:mouse_current_y
            .ENDIF

          ; Verify X
            push    ebx
            mov     ebx,ds:mouse_current_x
            sub     ebx,ds:dragging_offset_x
            .IF (carry?)
              ; We're less than zero
                neg     ebx
                add     ds:mouse_current_x,ebx
            .ELSE
              ; We're good on the left-side.  Now, how about the right?
                mov     ebx,ds:mouse_current_x
                sub     ebx,ds:dragging_offset_x
                add     ebx,ds:dragging_width
                .IF (ebx > 720)
                  ; We're to far
                    sub     ebx,720
                    sub     ds:mouse_current_x,ebx
                .ENDIF
            .ENDIF

          ; Verify Y
            mov     ebx,ds:mouse_current_y
            sub     ebx,ds:dragging_offset_y
            .IF (carry?)
              ; We're less than zero
                neg     ebx
                add     ds:mouse_current_y,ebx
            .ELSE
              ; We're good on the top.  Now, how about the bottom?
                mov     ebx,ds:mouse_current_y
                sub     ebx,ds:dragging_offset_y
                add     ebx,ds:dragging_height
                .IF (ebx > 348)
                  ; We're to far
                    sub     ebx,348
                    sub     ds:mouse_current_y,ebx
                .ENDIF
            .ENDIF
            pop     ebx
        .ENDIF
        ret
    invDEBI_update_mouse_coordinates    ENDP




    iDEBI_timer_interface       PROC
    ; This routine is called 182 times per second from the timer handler.  It is used to determine how long objects
    ; have been displayed, how long a mouse has been hovering over an object prior to display, etc.  It's very handy. :)
    ;
    ; Upon entry:   Nothing
    ;
    ; Upon exit:    Nothing
    ;
        .IF (cs:disable_timer == 1)
            retf
        .ENDIF
        push    ds
        mov     ds,cs:data_segment
        inc     ds:timer_interface_count
        inc     ds:screen_saver_count
        .IF (ds:screen_saver_count > 18200 && ds:screen_saver == 0)
          ; This is 100 seconds
            ;call    invDEBI_activate_screen_saver
        .ENDIF

;; Bochs hack
        .IF (ds:screen_saver_count > 10)
            mov     ds:screen_saver_count,0
            call    fword ptr ds:_iMOUSE_bochs_DEBI_intercept
        .ENDIF
;; Bochs hack


        inc     ds:cursor_count
        .IF (ds:force_cursor_off == 0 && ds:cursor_count > 60 && ds:screen_saver == 0)
          ; About every 182/60 second the cursor toggles
            call    invDEBI_toggle_cursor
        .ENDIF

        .IF (ds:draw_menu != 0)
          ;; Draw the menu
            mov     ds:draw_menu,0
            pushad
            pushfd
            cli
            call    invDEBI_hide_mouse_pointer
            call    invDEBI_turn_cursor_off
            call    invDEBI_save_screen2
            popfd
            popad
            call    invDEBI_menu_refresh
        .ENDIF

        sub     ds:mouse_immediate_count,1
        .IF (carry?)
            push    edx
            mov     dl,ds:mouse_last_event
            call    invDEBI_check_immediate
            pop     edx
        .ENDIF

        sub     ds:mouse_hovering_count,1
        .IF (carry?)
          ; We've rolled over (which means our countdown has completed)
            call    invDEBI_check_hovering
        .ENDIF

        sub     ds:mouse_clicking_count,1
        .IF (carry?)
          ; We've rolled over (which means our countdown has completed)
            call    invDEBI_check_objects_click
        .ENDIF
        pop     ds
        retf
    iDEBI_timer_interface       ENDP
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; END - 11111 - External interfaces (Timer, Mouse, Kbd)
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; 22222 - Screen related functions
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    invDEBI_hide_mouse_pointer      PROC
    ; This routine is used to hide the mouse pointer
    ;
    ; Upon entry:   ds:mouse_current_x - current x coord
    ;               ds:mouse_current_y - current y coord
    ;
    ; Upon exit:    The mouse pointer is hidden
    ;
        .IF (cs:mouse_status == 1 && cs:mouse_allowed == 1)
            push    ds
            pushfd
;            cli
            mov     ds,cs:data_segment
;            push    dword ptr ds:mouse_current_x
;            sub     dword ptr ss:[esp],1                            ; hot-spot on mouse is at 1,1
;            push    dword ptr ds:mouse_current_y
;            sub     dword ptr ss:[esp],1
;            push    dword ptr 0                                     ; Hide the mouse
;            push    dword ptr offset mouse_save_area
;            call    fword ptr ds:_VID_g_mono_mouse_pointer
            mov     ds:mouse_status,0
            popfd
            pop     ds
        .ENDIF
        ret
    invDEBI_hide_mouse_pointer      ENDP




    invDEBI_show_mouse_pointer      PROC
    ; This routine is used to display the mouse pointer
    ;
    ; Upon entry:   ds:mouse_current_x - current x coord
    ;               ds:mouse_current_y - current y coord
    ;
    ; Upon exit:    The mouse pointer is displayed
    ;
        .IF (cs:mouse_status == 0 && cs:mouse_allowed == 1)
            push    ds
            pushfd
;            cli
            mov     ds,cs:data_segment
;            push    dword ptr ds:mouse_current_x
;            sub     dword ptr ss:[esp],1                            ; hot-spot on mouse is at 1,1
;            push    dword ptr ds:mouse_current_y
;            sub     dword ptr ss:[esp],1
;            push    dword ptr 1                                     ; Show the mouse
;            push    dword ptr offset mouse_save_area
;            call    fword ptr ds:_VID_g_mono_mouse_pointer
            mov     ds:mouse_status,1
            popfd
            pop     ds
        .ENDIF
        ret
    invDEBI_show_mouse_pointer      ENDP




    invDEBI_activate_screen_saver       PROC
    ; This routine is used to activate the screen saver.  It copies the screen buffer to a save area and then clear it off
    ;
    ; Upon entry:   ds - DEBI's data segment
    ;
    ; Upon exit:    The screen is blanked and the screen_saver variable is set to 1
    ;
        .IF (ds:screen_saver == 0)
            pushfd
            cli
            pushad
            push    ds
            push    es

            mov     ds:screen_saver,1                               ; Turn on screen saver indicator
            call    invDEBI_hide_mouse_pointer
            call    invDEBI_turn_cursor_off
            mov     ds:mouse_allowed,0                              ; Indicate the mouse cannot be drawn

          ; Copy the screen to the save buffer
            mov     eax,_sDEBI_screen                               ; Copy from the MONO screen to the _sDEBI_screen buffer
            mov     es,ax
            xor     edi,edi
            mov     eax,_sMONO
            mov     ds,ax
            xor     esi,esi
            mov     ecx,7fffh                                       ; Copy 32k
            cld
            rep     movsb
          ; Clear off the screen
            mov     eax,_sMONO
            mov     es,ax
            xor     edi,edi
            mov     al,0
            mov     ecx,7fffh
            rep     stosb

            pop     es
            pop     ds
            popad
            popfd
        .ENDIF
        ret
    invDEBI_activate_screen_saver       ENDP




    invDEBI_save_screen2    PROC
    ; This routine is used to save the current screen contents to a save area during a popup dialogue, menu or other item
    ;
    ; Upon entry:   Nothing
    ;
    ; Upon exit:    The screen is saved
    ;
        pushad
        push    ds
        push    es

      ; Copy the screen to the save buffer
        mov     eax,_sDEBI_screen2                                  ; Copy from the MONO screen to the _sDEBI_screen2 buffer
        mov     es,ax
        xor     edi,edi
        mov     eax,_sMONO
        mov     ds,ax
        xor     esi,esi
        mov     ecx,7fffh                                           ; Copy 32k
        cld
        rep     movsb

        pop     es
        pop     ds
        popad
        ret
    invDEBI_save_screen2    ENDP




    invDEBI_restore_screen2     PROC
    ; This routine is used to save the current screen contents to a save area during a popup dialogue, menu or other item
    ;
    ; Upon entry:   Nothing
    ;
    ; Upon exit:    The screen is saved
    ;
        pushad
        push    ds
        push    es

      ; Copy the screen to the save buffer
        mov     eax,_sDEBI_screen2                                  ; Copy from the _sDEBI_screen buffer to the MONO screen
        mov     ds,ax
        xor     esi,esi
        mov     eax,_sMONO
        mov     es,ax
        xor     edi,edi
        mov     ecx,7fffh                                           ; Copy 32k
        cld
        rep     movsb

        pop     es
        pop     ds
        popad
        ret
    invDEBI_restore_screen2     ENDP




    invDEBI_toggle_cursor   PROC
    ; This routine is used to toggle the cursor
    ;
    ; Upon entry:   ds - DEBI's data segment
    ;
    ; Upon exit:    The cursor may be updated
    ;
        .IF (cs:force_cursor_off == 0)
          ; We need to toggle the cursor
            push    ds
            pushad
            pushfd
            cli
            mov     ds,cs:data_segment
            mov     eax,ds:mouse_status
            call    invDEBI_hide_mouse_pointer
            push    dword ptr ds:cursor_x
            push    dword ptr ds:cursor_y
            .IF (ds:insert_mode == ON)
                call    fword ptr ds:_VID_g_mono_cursor
            .ELSE
                call    fword ptr ds:_VID_g_mono_cursor_no_insert
            .ENDIF
            not     ds:cursor
            .IF (eax != 0)
                call    invDEBI_show_mouse_pointer
            .ENDIF
            mov     ds:cursor_count,0
            popfd
            popad
            pop     ds
        .ENDIF
        ret
    invDEBI_toggle_cursor   ENDP




    invDEBI_turn_cursor_off     PROC
    ; This routine is used to toggle the cursor
    ;
    ; Upon entry:   ds - DEBI's data segment
    ;
    ; Upon exit:    The cursor may be updated
    ;
        .IF (cs:force_cursor_off == 0 && cs:cursor != 0)
          ; We need to turn the cursor off
            push    ds
            push    eax
            mov     ds,cs:data_segment
            mov     eax,ds:cursor_count
            call    invDEBI_toggle_cursor
            mov     ds:cursor_count,eax
            pop     eax
            pop     ds
        .ENDIF
        ret
    invDEBI_turn_cursor_off     ENDP




    invDEBI_turn_cursor_on      PROC
    ; This routine is used to toggle the cursor
    ;
    ; Upon entry:   ds - DEBI's data segment
    ;
    ; Upon exit:    The cursor may be updated
    ;
        .IF (cs:force_cursor_off == 0 && cs:cursor == 0)
          ; We need to turn the cursor on
            push    ds
            push    eax
            mov     ds,cs:data_segment
            mov     eax,ds:cursor_count
            call    invDEBI_toggle_cursor
            mov     ds:cursor_count,eax
            pop     eax
            pop     ds
        .ENDIF
        ret
    invDEBI_turn_cursor_on      ENDP




    invDEBI_cancel_screen_saver     PROC
    ; This routine is used to cancel a previous screen saver.  It restores the screen from the previously saved buffer
    ;
    ; Upon entry:   ds - DEBI's data segment
    ;
    ; Upon exit:    The screen is blanked and the screen_saver variable is set to 1
    ;
        .IF (cs:screen_saver == 1)
            pushfd
            pushad
            push    ds
            push    es

            cli
            mov     ds,cs:data_segment
            mov     ds:screen_saver,0                               ; Turn off screen saver indicator
            mov     ds:screen_saver_count,0
            mov     ds:mouse_allowed,1                              ; Indicate the mouse can once again be drawn

            mov     eax,_sDEBI_screen                               ; Copy from the _sDEBI_screen buffer to the MONO screen
            mov     ds,ax
            xor     esi,esi
            mov     eax,_sMONO
            mov     es,ax
            xor     edi,edi
            mov     ecx,7fffh                                       ; Copy 32k
            cld
            rep     movsb

            pop     es
            pop     ds
            popad
            popfd
        .ENDIF
        ret
    invDEBI_cancel_screen_saver     ENDP
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; END - 22222 - Screen related functions
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; 33333 - MOUSE Events
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    invDEBI_mouse_button_activity       PROC
    ; This routine is used to check for objects the mouse is currently hovering over (without anything being clicked)
    ;
    ; Upon entry:   ds:mouse_current_x - current x coord
    ;               ds:mouse_current_y - current y coord
    ;            ds:mouse_last_buttons - previous button status
    ;                              ebx - new button status (from mouse driver)
    ;                                    * Note:  Bits 2,1,0 are set depending on button status (2-middle, 1-right, 0-left)
    ;
    ; Upon exit:    Some items may be deselected or selected for display
    ;
        pushad
        .IF (ds:mouse_last_button_left == 0)
          ; The left mouse button was previously UP (not pressed)
            test    ebx,01b
            .IF (!zero?)
              ; The left button has changed
                inc     ds:mouse_button_left
                mov     ds:mouse_clicking_count,-1
                mov     ds:mouse_last_button_left,1
                mov     edx,ds:mouse_current_x
                mov     ds:mouse_left_click_x_start,edx
                mov     edx,ds:mouse_current_y
                mov     ds:mouse_left_click_y_start,edx
                mov     ds:mouse_hovering_count,-1
            .ENDIF
        .ELSE
          ; The left mouse button was previously DOWN (pressed)
            test    ebx,01b
            .IF (zero?)
              ; The left buton has changed
                test    ebx,10b
                .IF (zero?)
                  ; The other button isn't down, so we're good to go
                    mov     ds:mouse_clicking_count,30
                    mov     ds:mouse_immediate_count,_IMMEDIATE_COUNT
                    mov     ds:mouse_last_event,_LEFT_SINGLE_CLICK
                .ENDIF
                mov     ds:mouse_last_button_left,0
                mov     edx,ds:mouse_current_x
                mov     ds:mouse_left_click_x_stop,edx
                mov     edx,ds:mouse_current_y
                mov     ds:mouse_left_click_y_stop,edx
                .IF (ds:mouse_left_dragging != 0)
                    call    invDEBI_check_drag_stop
                    mov     ds:mouse_left_dragging,0
                    mov     ds:mouse_button_left,0
                    mov     ds:mouse_clicking_count,-1
                .ENDIF
            .ELSEIF (ds:mouse_left_dragging == 0)
              ; We need to check to see if the delta-x and delta-y are far enough that something is being dragged
                test    ebx,10b
                .IF (zero?)
                  ; The other button isn't down, so we're good to go
                    mov     edx,ds:mouse_current_x
                    sub     edx,ds:mouse_left_click_x_start
                    call    invDEBI_absolute_edx
                    mov     eax,edx
                    mov     edx,ds:mouse_current_y
                    sub     edx,ds:mouse_left_click_y_start
                    call    invDEBI_absolute_edx
                    .IF (edx > ds:vertical_dragging_threshold || eax > ds:horizontal_dragging_threshold)
                      ; They're dragging
                        mov     ds:mouse_left_dragging,1
                        call    invDEBI_check_drag_start
                    .ENDIF
                .ENDIF
            .ELSEIF (ds:mouse_left_dragging != 0)
              ; A button is down, so they're dragging something
                mov     ds:mouse_hovering_x,-1
                mov     ds:mouse_hovering_y,-1
                mov     ds:mouse_hovering_count,-1
                call    invDEBI_check_drag_start
            .ENDIF
        .ENDIF

        .IF (ds:mouse_last_button_right == 0)
          ; The right mouse button was previously UP
            test    ebx,10b
            .IF (!zero?)
              ; The right buton has changed
                inc     ds:mouse_button_right
                mov     ds:mouse_clicking_count,-1
                mov     ds:mouse_last_button_right,1
                mov     edx,ds:mouse_current_x
                mov     ds:mouse_right_click_x_start,edx
                mov     edx,ds:mouse_current_y
                mov     ds:mouse_right_click_y_start,edx
                mov     ds:mouse_hovering_count,-1
            .ENDIF
        .ELSE
          ; The right mouse button was previously DOWN
            test    ebx,10b
            .IF (zero?)
              ; The right buton has changed
                test    ebx,01b
                .IF (zero?)
                  ; The other button isn't down, so we're good to go
                    mov     ds:mouse_clicking_count,30
                    mov     ds:mouse_immediate_count,_IMMEDIATE_COUNT
                    mov     ds:mouse_last_event,_RIGHT_SINGLE_CLICK
                .ENDIF
                mov     ds:mouse_last_button_right,0
                mov     edx,ds:mouse_current_x
                mov     ds:mouse_right_click_x_stop,edx
                mov     edx,ds:mouse_current_y
                mov     ds:mouse_right_click_y_stop,edx
                .IF (ds:mouse_right_dragging != 0)
                    call    invDEBI_check_drag_stop
                    mov     ds:mouse_right_dragging,0
                    mov     ds:mouse_button_right,0
                    mov     ds:mouse_clicking_count,-1
                .ENDIF
            .ELSEIF (ds:mouse_right_dragging == 0)
              ; We need to check to see if the delta-x and delta-y are far enough that something is being dragged
                test    ebx,01b
                .IF (zero?)
                  ; The other button isn't down, so we're good to go
                    mov     edx,ds:mouse_current_x
                    sub     edx,ds:mouse_right_click_x_start
                    call    invDEBI_absolute_edx
                    mov     eax,edx
                    mov     edx,ds:mouse_current_y
                    sub     edx,ds:mouse_right_click_y_start
                    call    invDEBI_absolute_edx
                    .IF (edx > ds:vertical_dragging_threshold || eax > ds:horizontal_dragging_threshold)
                      ; They're dragging
                        mov     ds:mouse_right_dragging,1
                        call    invDEBI_check_drag_start
                    .ENDIF
                .ENDIF
            .ELSEIF (ds:mouse_right_dragging != 0)
              ; A button is down, so they're dragging something
                mov     ds:mouse_hovering_x,-1
                mov     ds:mouse_hovering_y,-1
                mov     ds:mouse_hovering_count,-1
                call    invDEBI_check_drag_start
            .ENDIF
        .ENDIF
        mov     ds:mouse_last_buttons,ebx

      quit:
        popad
        ret
    invDEBI_mouse_button_activity       ENDP




    invDEBI_absolute_edx        PROC
    ; This routine is used to compute the absolute value of the value in edx
    ;
    ; Upon entry:   edx - value to compute absolute value
    ;
    ; Upon exit:    edx - abs(edx)
    ;
        .IF (edx > 7fffffffh)
          ; It's negative
            neg     edx
        .ENDIF
        ret
    invDEBI_absolute_edx        ENDP




    invDEBI_check_drag_start        PROC
    ; This routine is used to check to see what object they're trying to drag
    ;
    ; Upon enry:    ds:mouse_current_x - current mouse X coordinate
    ;               ds:mouse_current_y - current mouse Y coordinate
    ;               ds:mouse_right_click_x_start - starting mouse X coordinate if right dragging
    ;               ds:mouse_right_click_y_start - starting mouse Y coordinate if right dragging
    ;               ds:mouse_left_click_x_start - starting mouse X coordinate if left dragging
    ;               ds:mouse_left_click_y_start - starting mouse Y coordinate if left dragging
    ;
    ; Upon exit:    If dragging some object, it is currently underway
    ;
        .IF (ds:mouse_left_dragging == 1)
            inc     ds:mouse_left_dragging
            mov     ds:mouse_last_event,_LEFT_DRAG_START
            mov     dl,_LEFT_DRAG_START
            call    invDEBI_check_mouse_event
        .ENDIF
        .IF (ds:mouse_right_dragging == 1)
            inc     ds:mouse_right_dragging
            mov     ds:mouse_last_event,_RIGHT_DRAG_START
            mov     dl,_RIGHT_DRAG_START
            call    invDEBI_check_mouse_event
        .ENDIF

        ret
    invDEBI_check_drag_start        ENDP




    invDEBI_check_drag_stop     PROC
    ; This routine is called when an object being dragged is released
    ;
    ; Upon entry:
    ;
    ; Upon exit:    The object is released
    ;
        .IF (ds:mouse_left_dragging != 0)
            mov     ds:mouse_last_event,_LEFT_DRAG_STOP
            mov     dl,_LEFT_DRAG_STOP
            call    invDEBI_check_mouse_event
        .ENDIF
        .IF (ds:mouse_right_dragging != 0)
            mov     ds:mouse_last_event,_RIGHT_DRAG_STOP
            mov     dl,_RIGHT_DRAG_STOP
            call    invDEBI_check_mouse_event
        .ENDIF
        .IF (ds:dragging_something != 0)
          ; No event was at the release point, so we just call the default handler to cancel the drag
            call    invDEBI_drag_stop
        .ENDIF
        mov     ds:mouse_last_event,_HOVER

        ret
    invDEBI_check_drag_stop     ENDP




    invDEBI_check_hovering      PROC
    ; This routine is used to check for objects the mouse is currently hovering over (without anything being clicked)
    ;
    ; Upon entry:   ds:mouse_hovering_x - current x coord
    ;               ds:mouse_hovering_y - current y coord
    ;
    ; Upon exit:    The quick watch window may be updated
    ;
        pushad

        .IF (ds:object_mode == 0)
          ; We're in root object mode (meaning they're the default Debi objects, not a pop-up or dialogue box)
            mov     esi,offset DEBI_screen_table_end - _ST_LENGTH
            xor     ecx,ecx
            .WHILE (ecx < 15)
                .IF (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _YES)
                    mov     edi,dword ptr ds:[esi+_ST_OBJECT_MOUSE_OFFSET]
                    .IF (edi != -1)
                        .WHILE (byte ptr ds:[edi] != _END)
                            mov     al,byte ptr ds:[edi]
                            .IF (al == _ABANDON_IF_NOT)
                              ; We are to abandon this item if the mouse isn't within its data area
                                call    invDEBI_check_mouse_object_coordinate
                                jc      next_screen_object
                            .ELSEIF (al == _HOVER)
                              ; This is a hover item, we need to check the coordinates to see if it's the one!
                                call    invDEBI_check_mouse_object_coordinate
                                jc      next_mouse_object1

                              ; This is a match
                                mov     ebx,dword ptr ds:[edi+_MO_FUNC]
                                pushad
                                pushfd
                                push    ds
                                push    es
                                push    fs
                                push    gs

                                call    ebx

                                pop     gs
                                pop     fs
                                pop     es
                                pop     ds
                                popfd
                                popad
                                jc      quit
                            .ENDIF

                          next_mouse_object1:
                            add     edi,_MO_LENGTH
                        .ENDW
                    .ENDIF
                .ENDIF

              next_screen_object:
                sub     esi,_ST_LENGTH
                inc     ecx
            .ENDW
        .ELSE
          ; We're currently on one of the pop-up objects
            mov     edi,ds:mouse_objects
            mov     esi,ds:screen_object
            .WHILE (byte ptr ds:[edi] != _END)
                mov     al,byte ptr ds:[edi]
                .IF (al == _ABANDON_IF_NOT)
                  ; We are to abandon this item if the mouse isn't within its data area
                    call    invDEBI_check_mouse_object_coordinate
                    jc      quit
                .ELSEIF (al == _HOVER)
                  ; This is the correct thing, we need to check the coordinates to see if it's the one!
                    call    invDEBI_check_mouse_object_coordinate
                    jc      next_mouse_object2

                  ; This is a match
                    mov     ebx,dword ptr ds:[edi+_MO_FUNC]
                    pushad
                    pushfd
                    push    ds
                    push    es
                    push    fs
                    push    gs

                    call    ebx

                    pop     gs
                    pop     fs
                    pop     es
                    pop     ds
                    popfd
                    popad
                    jc      quit
                .ENDIF

              next_mouse_object2:
                add     edi,_MO_LENGTH
            .ENDW
        .ENDIF

      quit:
        popad
        ret
    invDEBI_check_hovering      ENDP




    invDEBI_check_mouse_event       PROC
    ; This routine is used to check for objects the mouse has done something on/near
    ;
    ; Upon entry:   ds:mouse_current_x - current x coord
    ;               ds:mouse_current_y - current y coord
    ;                               dl - mouse activity to search for
    ;
    ; Upon exit:    The quick watch window may be updated
    ;
        pushad

        .IF (ds:object_mode == 0)
          ; We're in root object mode (meaning they're the default Debi objects, not a pop-up or dialogue box)
            mov     esi,offset DEBI_screen_table_end - _ST_LENGTH
            xor     ecx,ecx
            .WHILE (ecx < 15)
                .IF (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _YES)
                    mov     edi,dword ptr ds:[esi+_ST_OBJECT_MOUSE_OFFSET]
                    .IF (edi != -1)
                        .WHILE (byte ptr ds:[edi] != _END)
                            mov     al,byte ptr ds:[edi]
                            .IF (al == _ABANDON_IF_NOT)
                              ; We are to abandon this item if the mouse isn't within its data area
                                call    invDEBI_check_mouse_object_coordinate
                                jc      next_screen_object

                            .ELSEIF (al == dl || al == _ANY_CLICK)
                              ; This is the correct thing, we need to check the coordinates to see if it's the one!
                                .IF (dl == _LEFT_DRAG_START || dl == _RIGHT_DRAG_START)
                                    call    invDEBI_check_mouse_object_coordinate_drag_start
                                .ELSEIF (dl == _LEFT_DRAG_STOP || dl == _RIGHT_DRAG_STOP)
                                    call    invDEBI_check_mouse_object_coordinate_drag_stop
                                .ELSE
                                    call    invDEBI_check_mouse_object_coordinate
                                .ENDIF
                                jc      next_mouse_object1

                              ; This is a match
                                mov     ebx,dword ptr ds:[edi+_MO_FUNC]
                                pushad
                                pushfd
                                push    ds
                                push    es
                                push    fs
                                push    gs

                                call    ebx

                                pop     gs
                                pop     fs
                                pop     es
                                pop     ds
                                popfd
                                popad
                                jc      quit

                            .ELSEIF (dl == _LEFT_SINGLE_CLICK && al == _EDIT)
                              ; This is an edit item, they might be wanting to edit something possibly?
                                call    invDEBI_check_mouse_object_coordinate
                                jc      next_mouse_object1

                              ; This is a match
                                call    invDEBI_edit_variable
                            .ENDIF

                          next_mouse_object1:
                            add     edi,_MO_LENGTH
                        .ENDW
                    .ENDIF
                .ENDIF

              next_screen_object:
                sub     esi,_ST_LENGTH
                inc     ecx
            .ENDW
        .ELSE
          ; We're currently on one of the pop-up objects
            mov     edi,ds:mouse_objects
            mov     esi,ds:screen_object
            .WHILE (byte ptr ds:[edi] != _END)
                mov     al,byte ptr ds:[edi]
                .IF (al == _ABANDON_IF_NOT)
                  ; We are to abandon this item if the mouse isn't within its data area
                    call    invDEBI_check_mouse_object_coordinate
                    jc      quit

                .ELSEIF (al == dl || al == _ANY_CLICK)
                  ; This is the correct thing, we need to check the coordinates to see if it's the one!
                    call    invDEBI_check_mouse_object_coordinate
                    jc      next_mouse_object2                      ; If branch, the mouse isn't over this item

                  ; This is a match
                    mov     ebx,dword ptr ds:[edi+_MO_FUNC]
                    pushad
                    pushfd
                    push    ds
                    push    es
                    push    fs
                    push    gs

                    call    ebx

                    pop     gs
                    pop     fs
                    pop     es
                    pop     ds
                    popfd
                    popad
                    jc      quit

                .ELSEIF (dl == _LEFT_SINGLE_CLICK && al == _EDIT)
                  ; This is an edit item, they might be wanting to edit something possibly?
                    call    invDEBI_check_mouse_object_coordinate
                    jc      next_mouse_object2

                  ; This is a match
                    call    invDEBI_edit_variable
                .ENDIF

              next_mouse_object2:
                add     edi,_MO_LENGTH
            .ENDW
        .ENDIF

      quit:
        popad
        ret
    invDEBI_check_mouse_event       ENDP




    invDEBI_check_immediate     PROC
    ; This routine is used to check for objects the mouse has done something on/near
    ;
    ; Upon entry:   ds:mouse_current_x - current x coord
    ;               ds:mouse_current_y - current y coord
    ;                               dl - mouse activity to search for
    ;
    ; Upon exit:    The quick watch window may be updated
    ;
        pushad

        .IF (ds:object_mode == 0)
          ; We're in root object mode (meaning they're the default Debi objects, not a pop-up or dialogue box)
            mov     esi,offset DEBI_screen_table_end - _ST_LENGTH
            xor     ecx,ecx
            .WHILE (ecx < 15)
                .IF (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _YES)
                    mov     edi,dword ptr ds:[esi+_ST_OBJECT_MOUSE_OFFSET]
                    .IF (edi != -1)
                        .WHILE (byte ptr ds:[edi] != _END)
                            mov     al,byte ptr ds:[edi]
                            .IF (al == _IMMEDIATE)
                              ; We know now that there are immediates, so we will setup the count for continued use
                                .IF (byte ptr ds:[edi+_MO_TYPE] == dl)
                                  ; This is the correct thing, we need to check the coordinates to see if it's the one!
                                    call    invDEBI_check_mouse_object_coordinate
                                    jc      next_mouse_object1

                                  ; This is a match
                                    mov     ebx,dword ptr ds:[edi+_MO_FUNC]
                                    pushad
                                    pushfd
                                    push    ds
                                    push    es
                                    push    fs
                                    push    gs

                                    call    ebx

                                    pop     gs
                                    pop     fs
                                    pop     es
                                    pop     ds
                                    popfd
                                    popad
                                    jc      quit
                                .ENDIF
                            .ELSE
                                jmp     next_screen_object
                            .ENDIF

                          next_mouse_object1:
                            add     edi,_MO_LENGTH
                        .ENDW
                    .ENDIF
                .ENDIF

              next_screen_object:
                sub     esi,_ST_LENGTH
                inc     ecx
            .ENDW
        .ELSE
          ; We're currently on one of the pop-up objects
            mov     edi,ds:mouse_objects
            mov     esi,ds:screen_object
            .WHILE (byte ptr ds:[edi] != _END)
                mov     al,byte ptr ds:[edi]
                .IF (al == _IMMEDIATE)
                  ; We know now that there are immediates, so we will setup the count for continued use
                    .IF (byte ptr ds:[edi+_MO_TYPE] == dl)
                      ; This is the correct thing, we need to check the coordinates to see if it's the one!
                        call    invDEBI_check_mouse_object_coordinate
                        jc      next_mouse_object2

                      ; This is a match
                        mov     ebx,dword ptr ds:[edi+_MO_FUNC]
                        pushad
                        pushfd
                        push    ds
                        push    es
                        push    fs
                        push    gs

                        call    ebx

                        pop     gs
                        pop     fs
                        pop     es
                        pop     ds
                        popfd
                        popad
                        jc      quit
                    .ENDIF
                .ELSE
                    jmp     quit
                .ENDIF

              next_mouse_object2:
                add     edi,_MO_LENGTH
            .ENDW
        .ENDIF

      quit:
        popad
        ret
    invDEBI_check_immediate     ENDP




    invDEBI_check_mouse_object_coordinate       PROC
    ; This routine is used to check the current mouse coordinate against the screen object coordinate plus the mouse object
    ; relative displacement
    ;
    ; Upon entry:   ds:[esi] - far ptr to screen object
    ;               ds:[edi] - far ptr to mouse object
    ;
    ; Upon exit:    carry? - SET if mouse not in this object's coordinates, CLEAR if it is within
    ;
        push    edx

        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        add     edx,dword ptr ds:[edi+_MO_X1]
        cmp     ds:mouse_current_x,edx
        jb      fail
      ; We're >= the left-most X coordinate

        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        add     edx,dword ptr ds:[edi+_MO_X2]
        cmp     ds:mouse_current_x,edx
        ja      fail
      ; We're <= the right-most X coordinate

        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        add     edx,dword ptr ds:[edi+_MO_Y1]
        cmp     ds:mouse_current_y,edx
        jb      fail
      ; We're >= the top-most Y coordinate

        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        add     edx,dword ptr ds:[edi+_MO_Y2]
        cmp     ds:mouse_current_y,edx
        ja      fail
      ; We're <= the bottom-most Y coordinate

      ; This is it!
        clc
        jmp     quit

      fail:
        stc

      quit:
        pop     edx
        ret
    invDEBI_check_mouse_object_coordinate       ENDP




    invDEBI_check_mouse_object_coordinate_drag_start        PROC
    ; This routine is used to check the current mouse coordinate against the starting object coordinate plus the mouse object
    ; relative displacement
    ;
    ; Upon entry:   ds:[esi] - far ptr to screen object
    ;               ds:[edi] - far ptr to mouse object
    ;                     dl - drag start type
    ;
    ; Upon exit:    carry? - SET if mouse not in this object's coordinates, CLEAR if it is within
    ;
        push    edx

        .IF (dl == _LEFT_DRAG_START)
          ; It's a left-drag start
            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            add     edx,dword ptr ds:[edi+_MO_X1]
            cmp     ds:mouse_left_click_x_start,edx
            jb      fail
          ; We're >= the left-most X coordinate

            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            add     edx,dword ptr ds:[edi+_MO_X2]
            cmp     ds:mouse_left_click_x_start,edx
            ja      fail
          ; We're <= the right-most X coordinate

            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            add     edx,dword ptr ds:[edi+_MO_Y1]
            cmp     ds:mouse_left_click_y_start,edx
            jb      fail
          ; We're >= the top-most Y coordinate

            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            add     edx,dword ptr ds:[edi+_MO_Y2]
            cmp     ds:mouse_left_click_y_start,edx
            ja      fail
          ; We're <= the bottom-most Y coordinate
        .ELSE
          ; It's a right-drag start
            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            add     edx,dword ptr ds:[edi+_MO_X1]
            cmp     ds:mouse_right_click_x_start,edx
            jb      fail
          ; We're >= the left-most X coordinate

            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            add     edx,dword ptr ds:[edi+_MO_X2]
            cmp     ds:mouse_right_click_x_start,edx
            ja      fail
          ; We're <= the right-most X coordinate

            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            add     edx,dword ptr ds:[edi+_MO_Y1]
            cmp     ds:mouse_right_click_y_start,edx
            jb      fail
          ; We're >= the top-most Y coordinate

            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            add     edx,dword ptr ds:[edi+_MO_Y2]
            cmp     ds:mouse_right_click_y_start,edx
            ja      fail
        .ENDIF

      ; This is it!
        clc
        jmp     quit

      fail:
        stc

      quit:
        pop     edx
        ret
    invDEBI_check_mouse_object_coordinate_drag_start        ENDP




    invDEBI_check_mouse_object_coordinate_drag_stop         PROC
    ; This routine is used to check the current mouse coordinate against the starting object coordinate plus the mouse object
    ; relative displacement
    ;
    ; Upon entry:   ds:[esi] - far ptr to screen object
    ;               ds:[edi] - far ptr to mouse object
    ;                     dl - drag start type
    ;
    ; Upon exit:    carry? - SET if mouse not in this object's coordinates, CLEAR if it is within
    ;
        push    edx

        .IF (dl == _LEFT_DRAG_STOP)
          ; It's a left-drag start
            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            add     edx,dword ptr ds:[edi+_MO_X1]
            cmp     ds:mouse_left_click_x_stop,edx
            jb      fail
          ; We're >= the left-most X coordinate

            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            add     edx,dword ptr ds:[edi+_MO_X2]
            cmp     ds:mouse_left_click_x_stop,edx
            ja      fail
          ; We're <= the right-most X coordinate

            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            add     edx,dword ptr ds:[edi+_MO_Y1]
            cmp     ds:mouse_left_click_y_stop,edx
            jb      fail
          ; We're >= the top-most Y coordinate

            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            add     edx,dword ptr ds:[edi+_MO_Y2]
            cmp     ds:mouse_left_click_y_stop,edx
            ja      fail
          ; We're <= the bottom-most Y coordinate
        .ELSE
          ; It's a right-drag start
            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            add     edx,dword ptr ds:[edi+_MO_X1]
            cmp     ds:mouse_right_click_x_stop,edx
            jb      fail
          ; We're >= the left-most X coordinate

            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            add     edx,dword ptr ds:[edi+_MO_X2]
            cmp     ds:mouse_right_click_x_stop,edx
            ja      fail
          ; We're <= the right-most X coordinate

            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            add     edx,dword ptr ds:[edi+_MO_Y1]
            cmp     ds:mouse_right_click_y_stop,edx
            jb      fail
          ; We're >= the top-most Y coordinate

            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            add     edx,dword ptr ds:[edi+_MO_Y2]
            cmp     ds:mouse_right_click_y_stop,edx
            ja      fail
        .ENDIF

      ; This is it!
        clc
        jmp     quit

      fail:
        stc

      quit:
        pop     edx
        ret
    invDEBI_check_mouse_object_coordinate_drag_stop         ENDP




    invDEBI_check_objects_click     PROC
    ; This routine is used to check for objects the mouse is currently hovering over (without anything being clicked)
    ;
    ; Upon entry:   ds:mouse_hovering_x - current x coord
    ;               ds:mouse_hovering_y - current y coord
    ;
    ; Upon exit:    Some items may be deselected or selected for display
    ;
        pushad

      ; See what the left button has done
        mov     ds:mouse_left_click,0
        .IF (ds:mouse_button_left == 1)
          ; Single click
            mov     ds:mouse_left_click,1
        .ELSEIF (ds:mouse_button_left == 2)
          ; Double-click
            mov     ds:mouse_left_click,2
        .ENDIF
        mov     ds:mouse_button_left,0

      ; See what the right button has done
        mov     ds:mouse_right_click,0
        .IF (ds:mouse_button_right == 1)
          ; Single click
            mov     ds:mouse_right_click,1
        .ELSEIF (ds:mouse_button_right == 2)
          ; Double-click
            mov     ds:mouse_right_click,2
        .ENDIF
        mov     ds:mouse_button_right,0

      ; If no activity, quit
        .IF (ds:mouse_left_click == 0 && ds:mouse_right_click == 0)
            jmp     quit
        .ENDIF

      ; See if it was a both-button action
        mov     edx,ds:mouse_left_click
        .IF (ds:mouse_right_click == edx)
          ; Both buttons were pressed the same number of times
            .IF (edx == 1)
              ; It's a both_single_click
                mov     ds:mouse_both_click,1
            .ELSE
              ; It's a both_double_click
                mov     ds:mouse_both_click,2
            .ENDIF
            mov     ds:mouse_left_click,0
            mov     ds:mouse_right_click,0
        .ENDIF

      ; Now, call the invDEBI_check_mouse_event with the appropriate activity to search for
        .IF (ds:mouse_both_click != 0)
            .IF (ds:mouse_both_click == 1)
                mov     dl,_BOTH_SINGLE_CLICK
            .ELSE
                mov     dl,_BOTH_DOUBLE_CLICK
            .ENDIF
            call    invDEBI_check_mouse_event
        .ENDIF

        .IF (ds:mouse_left_click != 0)
            .IF (ds:mouse_left_click == 1)
                mov     dl,_LEFT_SINGLE_CLICK
            .ELSE
                mov     dl,_LEFT_DOUBLE_CLICK
            .ENDIF
            call    invDEBI_check_mouse_event
        .ENDIF

        .IF (ds:mouse_right_click != 0)
            .IF (ds:mouse_right_click == 1)
                mov     dl,_RIGHT_SINGLE_CLICK
            .ELSE
                mov     dl,_RIGHT_DOUBLE_CLICK
            .ENDIF
            call    invDEBI_check_mouse_event
        .ENDIF

      ; Now, reset the mouse variables
        mov     ds:mouse_left_click,0
        mov     ds:mouse_right_click,0
      quit:
        mov     ds:mouse_both_click,0
        mov     ds:mouse_last_event,_HOVER

        popad
        ret
    invDEBI_check_objects_click     ENDP
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; END - 33333 - MOUSE Events
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; 44444 - MENU system
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    invDEBI_menu    PROC
    ; This function is called when a menu needs to be displayed
    ;
    ; Upon entry:   ds:[esi] - far ptr to the screen object
    ;               ds:[edi] - far ptr to the mouse object
    ;               ds:[ebx] - far ptr to the start of the menu objects
    ;
    ; Upon exit:    The menu is displayed and internal variables are setup for mouse menu processing
    ;
        enter   40,0
        pushad
        pushfd
        push    es
      ; [ebp-04] - [ebx]
      ; [ebp-08] - [edi]
      ; [ebp-12] - [esi]
      ; [ebp-16] - widest item
      ; [ebp-20] - number of items
      ; [ebp-24] - Y distance
      ; [ebp-28] - temp storage
      ; [ebp-32] - temp storage
      ; [ebp-36] - build mouse listing Y
      ; [ebp-40] - Maximum size of menu area
        mov     dword ptr ss:[ebp-04],ebx
        mov     dword ptr ss:[ebp-08],edi
        mov     dword ptr ss:[ebp-12],esi
        mov     dword ptr ss:[ebp-16],0
        mov     dword ptr ss:[ebp-20],0
        mov     dword ptr ss:[ebp-24],16                            ; For top and bottom parts
        mov     dword ptr ss:[ebp-32],0
        mov     es,ds:data_segment
        mov     ds:menu_restore_screen_after,_YES


      ;; Perform a preliminary pass to determine the longest menu items
        mov     esi,ebx
        .WHILE (byte ptr ds:[esi] != _END)
            mov     al,byte ptr ds:[esi]
            .IF (al == _MENU_ITEM)
              ; Find out how long this item is
                movzx   ecx,byte ptr ds:[esi+1]
                .IF (ecx > dword ptr ss:[ebp-16])
                    mov     dword ptr ss:[ebp-16],ecx
                .ENDIF
                add     esi,ecx
                add     esi,2
                inc     dword ptr ss:[ebp-20]
                add     dword ptr ss:[ebp-24],8
            .ELSEIF (al == _MENU_ITEM_EVENT)
                add     esi,6
            .ELSEIF (al == _MENU_BAR)
                inc     esi
            .ELSE
              ; unknown option, we can't process this menu
                jmp     quit
            .ENDIF
        .ENDW
      ; Right now, [ebp-16] - widest item
      ;            [ebp-20] - number of items
        add     dword ptr ss:[ebp-16],2
        mov     ecx,dword ptr ss:[ebp-16]
        .IF (ecx == 0 || ecx > 74 || dword ptr ss:[ebp-20] > 60)
            jmp     quit
        .ENDIF


      ;; Initialize our menu area
        mov     edi,offset menu_area
        mov     ecx,sizeof menu_area / 4
        cld
        mov     eax,-1
        rep     stosd

      ;; Initialize our mouse object area
        mov     edi,offset menu_mouse_objects
        mov     ecx,sizeof menu_mouse_objects / 4
        cld
        mov     eax,-1
        rep     stosd


      ;; Initialize the top line
        mov     edi,offset menu_area
        mov     dword ptr ss:[ebp-40],edi
        add     dword ptr ss:[ebp-40],sizeof menu_area
        mov     ecx,dword ptr ss:[ebp-16]
        mov     al,'Ù'
        stosb
        mov     al,'⁄'                                              ; UL corner char
        stosb
        mov     al,'Ù'
        stosb
        mov     al,'ƒ'                                              ; top char
        rep     stosb
        mov     al,'Ù'
        stosb
        mov     al,'ø'                                              ; UR corner
        stosb
        xor     al,al
        stosb


      ;; Build the menu text and mouse objects
        mov     esi,dword ptr ss:[ebp-04]
        xor     edx,edx
        mov     ebx,offset menu_mouse_objects + _ST_LENGTH + _MO_LENGTH
        mov     dword ptr ss:[ebp-36],0
        .WHILE (byte ptr ds:[esi] != _END && edi < dword ptr ss:[ebp-40])
            mov     al,byte ptr ds:[esi]
            .IF (al == _MENU_ITEM)
                add     dword ptr ss:[ebp-36],FONT_Y
                mov     dword ptr ss:[ebp-28],edi
                mov     ecx,dword ptr ss:[ebp-16]
                mov     al,'Ù'
                stosb
                mov     al,'¥'                                      ; left side char
                stosb
                mov     al,'Ù'
                stosb
                mov     al,' '
                rep     stosb
                mov     al,'Ù'
                stosb
                mov     al,'≥'                                      ; right side char
                stosb
                xor     al,al
                stosb

                mov     edi,dword ptr ss:[ebp-28]
                add     edi,4
                movzx   ecx,byte ptr ds:[esi+1]
                add     esi,2
                rep     movsb

                mov     edi,dword ptr ss:[ebp-28]
                add     edi,dword ptr ss:[ebp-16]
                add     edi,6                                       ; move past all the extra characters
            .ELSEIF (al == _MENU_ITEM_EVENT)
              ; Build the activity for this item
                call    invDEBI_menu_write_common_header
                mov     al,byte ptr ds:[esi+1]
                mov     byte ptr ds:[ebx+_MO_OBJECT_TYPE],al
                mov     eax,dword ptr ds:[esi+2]
                mov     dword ptr ds:[ebx+_MO_FUNC],eax

                add     ebx,_MO_LENGTH
                add     esi,6
            .ELSEIF (al == _MENU_BAR)
                add     dword ptr ss:[ebp-36],FONT_Y
                mov     dword ptr ss:[ebp-28],edi
                mov     ecx,dword ptr ss:[ebp-16]
                mov     al,'Ù'
                stosb
                mov     al,'¥'                                      ; left side char
                stosb
                mov     al,'Ù'
                stosb
                mov     al,'ƒ'
                rep     stosb
                mov     al,'Ù'
                stosb
                mov     al,'≥'                                      ; right side char
                stosb
                xor     al,al
                stosb

                mov     edi,dword ptr ss:[ebp-28]
                add     edi,dword ptr ss:[ebp-16]
                add     edi,6                                       ; move past all the extra characters
                inc     esi                                         ; move past the _MENU_BAR character
            .ELSE
              ; unknown option, we can't process this menu
                jmp     quit
            .ENDIF
            inc     edx
        .ENDW
      ; Note, this space is reserved for a final entry that will terminate the menu if they click anywhere on the screen
        mov     dword ptr ss:[ebp-28],ebx
        add     ebx,_MO_LENGTH
        mov     byte ptr ds:[ebx],_END


      ;; Initialize the bottom line
        mov     ecx,dword ptr ss:[ebp-16]
        mov     al,'Ù'
        stosb
        mov     al,'¿'                                              ; bottom left char
        stosb
        mov     al,'Ù'
        stosb
        mov     al,'√'                                              ; bottom char
        rep     stosb
        mov     al,'Ù'
        stosb
        mov     al,'Ÿ'                                              ; bottom right char
        stosb
        xor     al,al
        stosb
      ;; Terminate the window
        not     al
        stosb


      ;; Determine the maximum height and width of the window (in pixels)
        add     dword ptr ss:[ebp-16],2                             ; for border characters
        mov     eax,dword ptr ss:[ebp-16]
        mov     ebx,FONT_X
        mul     ebx
        mov     dword ptr ss:[ebp-16],eax                           ; width - multiply by FONT_X
        add     dword ptr ss:[ebp-20],2                             ; for top and bottom
        mov     eax,dword ptr ss:[ebp-20]
        mov     ebx,FONT_Y
        mul     ebx
        mov     dword ptr ss:[ebp-20],eax                           ; height - multiply by FONT_Y

      ;; Right now, ss:[ebp-32] - free

      ;; Determine the position of the menu
        mov     edx,dword ptr ss:[ebp-16]
        mov     dword ptr ss:[ebp-32],edx                           ; Save for below
        mov     edx,ds:mouse_current_x
        add     edx,dword ptr ss:[ebp-16]
        .IF (edx < 720)
            mov     ebx,ds:mouse_current_x
        .ELSE
            mov     ebx,720
            sub     ebx,dword ptr ss:[ebp-16]
        .ENDIF
      ; Now, see if we can position the menu 1/2 way left from the current mouse coordinate
        shr     dword ptr ss:[ebp-16],1
        mov     ecx,ds:mouse_current_x
        sub     ecx,dword ptr ss:[ebp-16]
        .IF (carry?)
            xor     ebx,ebx
        .ELSE
            sub     ebx,dword ptr ss:[ebp-16]
        .ENDIF

        mov     edx,ds:mouse_current_y
        add     edx,dword ptr ss:[ebp-36]
        add     edx,FONT_Y * 2
        .IF (edx < 348)
            mov     eax,ds:mouse_current_y
        .ELSE
            mov     eax,348
            sub     eax,dword ptr ss:[ebp-36]
            sub     eax,FONT_Y * 2
            jmp     skip_height_adjustment
        .ENDIF
      ; Now, see if we can position the menu 1/2 way up from the current mouse coordinate
        shr     dword ptr ss:[ebp-20],1
        mov     ecx,ds:mouse_current_y
        sub     ecx,dword ptr ss:[ebp-20]
        .IF (carry?)
            xor     eax,eax
        .ELSE
          ; we can
            sub     eax,dword ptr ss:[ebp-20]
        .ENDIF

      skip_height_adjustment:
      ; Right now, eax - vertical
      ;            ebx - horizontal
        mov     edx,offset menu_mouse_objects
        mov     byte  ptr ds:[edx+_ST_OBJECT_ALTERABLE],0
        mov     dword ptr ds:[edx+_ST_OBJECT_UL_HORIZONTAL],ebx
        mov     dword ptr ds:[edx+_ST_OBJECT_UL_VERTICAL],eax
        mov     ecx,dword ptr ss:[ebp-32]
        mov     dword ptr ds:[edx+_ST_OBJECT_WIDTH],ecx
        mov     ecx,dword ptr ss:[ebp-36]
        add     ecx,FONT_Y * 2                                      ; for top and bottom bars around menu
        mov     dword ptr ds:[edx+_ST_OBJECT_HEIGHT],ecx
        mov     dword ptr ds:[edx+_ST_OBJECT_MOUSE_OFFSET],offset menu_mouse_objects + _ST_LENGTH
        mov     dword ptr ds:[edx+_ST_OBJECT_SCREEN_OFFSET],offset menu_area
        mov     ds:draw_menu,1
        inc     ds:menu_queue
        mov     ds:last_menu_item,0ffh

      ;; Now, add the _ANY_CLICK option that will work outside the range of the mouse window
      ;; This will call the invDEBI_menu_cancel algorithm if they click anywhere outside the menu
      ;; And finally, build the mouse-movement activity for this item
        mov     edx,dword ptr ss:[ebp-28]
        mov     ecx,offset menu_mouse_objects + _ST_LENGTH
      ; Right now, edx - far ptr to _ANY_CLICK item
      ;            ecx - far ptr to _IMMEDIATE/_HOVER item
        mov     byte ptr ds:[edx+_MO_OBJECT_TYPE],_ANY_CLICK
        neg     eax
        neg     ebx
        mov     dword ptr ds:[edx+_MO_X1],ebx
        mov     dword ptr ds:[edx+_MO_Y1],eax
        mov     dword ptr ds:[ecx+_MO_X1],ebx
        mov     dword ptr ds:[ecx+_MO_Y1],eax

        add     ebx,720
        add     eax,348
        mov     dword ptr ds:[edx+_MO_X2],ebx
        mov     dword ptr ds:[edx+_MO_Y2],eax
        mov     dword ptr ds:[edx+_MO_FUNC],offset invDEBI_menu_cancel

        mov     dword ptr ds:[ecx+_MO_X2],ebx
        mov     dword ptr ds:[ecx+_MO_Y2],eax
        mov     byte  ptr ds:[ecx+_MO_OBJECT_TYPE],_IMMEDIATE
        mov     dword ptr ds:[ecx+_MO_FUNC],offset invDEBI_menu_change
        mov     byte  ptr ds:[ecx+_MO_TYPE],_HOVER

      quit:
        pop     es
        popfd
        popad
        leave
        ret
    invDEBI_menu    ENDP




    invDEBI_menu_write_common_header    PROC
    ; This routine writes common information for the mouse object headers
        mov     dword ptr ds:[ebx+_MO_X1],FONT_X
        mov     eax,dword ptr ss:[ebp-36]
        mov     dword ptr ds:[ebx+_MO_Y1],eax
        add     eax,FONT_Y - 1
        mov     dword ptr ds:[ebx+_MO_Y2],eax

        push    ebx
        push    edx
        mov     eax,dword ptr ss:[ebp-16]
        mov     ebx,FONT_X
        mul     ebx
        pop     edx
        pop     ebx
        add     eax,FONT_X - 1                                      ; To encompass all of the last character)
        mov     dword ptr ds:[ebx+_MO_X2],eax
        ret
    invDEBI_menu_write_common_header    ENDP




    invDEBI_menu_cancel     PROC
    ; This routine is called from the menu itself when the user clicks anywhere except on one of the options
    ;
    ; Upon entry:   ds:[esi] - far ptr to screen objects
    ;               ds:[edi] - far ptr to this mouse object
    ;
    ; Upon exit:    The menu is cancelled and the screen is restored
    ;
        .IF (ds:menu_queue != 0)
            dec     ds:menu_queue
            mov     ds:object_mode,0
            .IF (ds:menu_restore_screen_after == _YES)
                pushad
                pushfd
                cli
                call    invDEBI_hide_mouse_pointer
                call    invDEBI_turn_cursor_off
                call    invDEBI_restore_screen2
                popfd
                popad
            .ENDIF
        .ENDIF
        ret
    invDEBI_menu_cancel     ENDP




    invDEBI_menu_change     PROC
    ; This routine is called repeatedly whenever a mouse moves over a menu.  It constantly updates the menu item that's being
    ; selected based on the location of the mouse pointer
    ;
    ; Upon entry:   ds:[esi] - far ptr to screen objects
    ;               ds:[edi] - far ptr to this mouse object
    ;               ds:mouse_current_x - X coordinate for mouse
    ;               ds:mouse_current_y - Y coordinate for mouse
    ;
    ; Upon entry:   If the mouse has moved away from the previously displayed item in the menu then the menu is updated
    ;               Otherwise, nothing happens
    ;
        .IF (ds:menu_queue != 0)
          ; See which item needs to be updated
            pushad
            mov     ebx,ds:mouse_current_x
            mov     eax,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            .IF (ebx < eax)
                mov     al,0ffh
                jmp     continue_updating_menu
            .ENDIF
          ; We might be on the menu, we could be past the right-side
            add     eax,dword ptr ds:[esi+_ST_OBJECT_WIDTH]
            .IF (ebx > eax)
              ; We are not on the menu
                mov     al,0ffh
                jmp     continue_updating_menu
            .ENDIF
          ; We are horizontally on the menu
          ; See if we're vertically on the menu
            mov     eax,ds:mouse_current_y
            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            .IF (eax < edx)
              ; We're above the menu
                mov     al,0ffh
                jmp     continue_updating_menu
            .ENDIF
            add     edx,dword ptr ds:[esi+_ST_OBJECT_HEIGHT]
            .IF (eax > edx)
              ; We're below the menu
                mov     al,0ffh
                jmp     continue_updating_menu
            .ENDIF

          ;; Ok, we know for a fact that the mouse poniter is somewhere on the menu
            mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            sub     eax,edx
            mov     edx,dword ptr ds:[esi+_ST_OBJECT_HEIGHT]
            sub     edx,FONT_Y
            .IF (eax >= edx && eax <= ds:[esi+_ST_OBJECT_HEIGHT])
              ; It's on the bottom-most line (which is actually the border)
                mov     al,0ffh
                jmp     continue_updating_menu
            .ENDIF
            mov     ebx,FONT_Y
            xor     edx,edx
            div     ebx
            .IF (al == 0)
              ; It's on the top most line (which is actually the border)
                mov     al,0ffh
                jmp     continue_updating_menu
            .ENDIF

          continue_updating_menu:
            .IF (al != ds:last_menu_item)
              ;; Right now, eax - contains the item number we're on
                mov     ds:last_menu_item,al
                xor     ecx,ecx
                mov     esi,dword ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]
                .WHILE (byte ptr ds:[esi] != 255)
                    xor     edx,edx
                    .WHILE (byte ptr ds:[esi] != 0)
                        mov     bl,byte ptr ds:[esi]
                        .IF (bl == 'Ù' || bl == 'ı')
                            .IF (edx == 1)
                                .IF (eax == ecx && byte ptr ds:[esi+1] != 'ƒ')
                                  ; This is the one they're on (and it's not a menu bar)
                                    mov     byte ptr ds:[esi],'ı'
                                .ELSE
                                  ; They're not on this one
                                    mov     byte ptr ds:[esi],'Ù'
                                .ENDIF
                            .ENDIF
                            inc     edx
                        .ENDIF
                        inc     esi
                    .ENDW
                    inc     ecx
                    inc     esi
                .ENDW

              ;; Right now, the menu has been updated
                call    invDEBI_menu_refresh
            .ENDIF

            popad
        .ENDIF
        ret
    invDEBI_menu_change     ENDP




    invDEBI_menu_refresh        PROC
    ; This routine is used to refresh the menu
    ;
    ; Upon entry:   Nothing
    ;
    ; Upon exit:    The menu is drawn on the screen
    ;
        .IF (ds:draw_menu == 0)
            pushad
            pushfd
            mov     edi,offset menu_area
            mov     esi,offset menu_mouse_objects
            mov     ebx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            mov     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
            cli
            call    invDEBI_hide_mouse_pointer
            call    invDEBI_turn_cursor_off
            call    invDEBI_draw_window
            call    invDEBI_show_mouse_pointer
            mov     ds:object_mode,1
            mov     ds:mouse_objects,offset menu_mouse_objects + _ST_LENGTH
            mov     ds:screen_object,offset menu_mouse_objects
            mov     ds:draw_menu,0
            mov     ds:mouse_immediate_count,0                      ; This will force it to fire immediately (because 0-1 = carry?)
            popfd
            popad
        .ENDIF
        ret
    invDEBI_menu_refresh        ENDP
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; END - 44444 - MENU system
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; 55555 - MENUs for screen objects
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
; Upon entry:   ds:[esi] - far ptr to this object's screen table entry
;               es:[edi] - far ptr to this object's mouse object information
;
    invDEBI_general_menu        PROC
        mov     ds:general_menu_esi,esi
        mov     ds:general_menu_edi,edi
        mov     ebx,offset DEBI_general_menu
        call    invDEBI_menu
        ret
    invDEBI_general_menu        ENDP




    invDEBI_cfsca_menu      PROC
        mov     ebx,offset DEBI_cfsca_menu
        call    invDEBI_menu
        ret
    invDEBI_cfsca_menu      ENDP




    invDEBI_fpu_menu        PROC
    ; This routine is called when a right-click is recognized on one of the stx fields
    ;
    ; Upon entry:   ds:[esi] - far ptr to screen object
    ;               ds:[edi] - far ptr to mouse object
    ;               ds:mouse_right_click_x_start - X coord where right-click happened
    ;               ds:mouse_right_click_y_start - Y coord
    ;
    ; Upon exit:    The FPU menu is displayed, temporary variables are stored
    ;
        mov     ds:fpu_esi,esi
        mov     ds:fpu_edi,edi
        mov     eax,ds:mouse_right_click_x_start
        mov     ds:fpu_x,eax
        mov     eax,ds:mouse_right_click_y_start
        mov     ds:fpu_y,eax
        mov     ebx,offset DEBI_fpu_menu
        call    invDEBI_menu
        ret
    invDEBI_fpu_menu        ENDP




    invDEBI_mmx_menu        PROC
    ; This routine is called when a right-click is recognized on one of the stx fields
    ;
    ; Upon entry:   ds:[esi] - far ptr to screen object
    ;               ds:[edi] - far ptr to mouse object
    ;               ds:mouse_right_click_x_start - X coord where right-click happened
    ;               ds:mouse_right_click_y_start - Y coord
    ;
    ; Upon exit:    The FPU menu is displayed, temporary variables are stored
    ;
        mov     ds:fpu_esi,esi
        mov     ds:fpu_edi,edi
        mov     eax,ds:mouse_right_click_x_start
        mov     ds:fpu_x,eax
        mov     eax,ds:mouse_right_click_y_start
        mov     ds:fpu_y,eax
        call    invDEBI_determine_mmx_variable
        mov     ds:fpu_data,edx
        .IF (edx != -1)
            mov     ebx,offset DEBI_mmx_menu
            call    invDEBI_menu
        .ENDIF
        ret
    invDEBI_mmx_menu        ENDP
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; END - 55555 - MENUs for screen objects
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; 66666 - Actions taken when various menu items are selected
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    invDEBI_fpu_finit       PROC
        call    invDEBI_menu_cancel
        finit
        fsave   ss:[ebp-200]
        call    invDEBI_FPU_update_display
    invDEBI_fpu_finit       ENDP




    invDEBI_FPU_update_display      PROC
        push    ebx

      ; These are all FPU windows
        mov     ebx,offset DEBI_e_screen_objects
        call    invDEBI_update_all_windows_of_type
        mov     ebx,offset DEBI_f_screen_objects
        call    invDEBI_update_all_windows_of_type
        mov     ebx,offset DEBI_q_screen_objects
        call    invDEBI_update_all_windows_of_type
        mov     ebx,offset DEBI_r_screen_objects
        call    invDEBI_update_all_windows_of_type

      ; This is an MMX window (but it is also affected)
        mov     ebx,offset DEBI_s_screen_objects
        call    invDEBI_update_all_windows_of_type

        pop     ebx
        ret
    invDEBI_FPU_update_display      ENDP




    invDEBI_update_all_windows_of_type      PROC
    ; This routine is used to update all windows of a particular flavor
    ;
    ; Upon entry:   ebx - offset of screen_objects variable (such as DEBI_a_screen_objects:) to update
    ;
    ; Upon exit:    Those window(s) are updated (if any)
    ;
        pushad
        pushfd

      ; Remove any impediments to this process
        cli
        call    invDEBI_hide_mouse_pointer
        call    invDEBI_turn_cursor_off

      ; And execute the process
        mov     esi,offset DEBI_screen_table
        xor     ecx,ecx
        .WHILE (ecx < 15)
            .IF (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _YES)
                mov     edi,dword ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]     ; Get the offset to the objects
              ; Right now, ds:[esi] - pointer to this screen table structure
              ;            ds:[edi] - pointer to this item's objects
              ; Now, parse the objects and act accordingly
                .IF (edi == ebx)
                    pushad
                    call    invDEBI_draw_objects
                    popad
                .ENDIF
            .ENDIF

            add     esi,_ST_LENGTH
            inc     ecx
        .ENDW

        popfd
        popad
        ret
    invDEBI_update_all_windows_of_type      ENDP




    invDEBI_fpu_force_0     PROC
        call    invDEBI_menu_cancel
        finit
        fldz
        jmp     invDEBI_stx_store_st0
    invDEBI_fpu_force_0     ENDP




    invDEBI_fpu_force_1     PROC
        call    invDEBI_menu_cancel
        finit
        fld1
        jmp     invDEBI_stx_store_st0
    invDEBI_fpu_force_1     ENDP




    invDEBI_fpu_force_10    PROC
        call    invDEBI_menu_cancel
        finit
        push    dword ptr 10
        fild    dword ptr ss:[esp]
        add     esp,4
        jmp     invDEBI_stx_store_st0
    invDEBI_fpu_force_10    ENDP




    invDEBI_fpu_force_pi        PROC
        call    invDEBI_menu_cancel
        finit
        fldpi
        jmp     invDEBI_stx_store_st0
    invDEBI_fpu_force_pi        ENDP




    invDEBI_stx_store_st0       PROC
    ; This routine is used to store the current value in st0 to the location specified when they right-clicked
    ;
    ; Upon entry:   ds:[fpu_esi] - far ptr to screen object
    ;               ds:[fpu_edi] - far ptr to mouse object
    ;                   ds:fpu_x - X coordinate where mouse was clicked
    ;                   ds:fpu_y - Y coordinate where mouse was clicked
    ;                        st0 - value to store there
    ;
    ; Upon exit:    The particular stx value right-clicked on is updated
    ;
        pushad
        call    invDEBI_fpu_get_stx_offset_in_ebx
        fstp    tbyte ptr ss:[ebp+ebx]
        call    invDEBI_FPU_update_display
        popad
        ret
    invDEBI_stx_store_st0       ENDP




    invDEBI_fpu_swap_sign       PROC
        call    invDEBI_menu_cancel
        pushad
        call    invDEBI_fpu_get_stx_offset_in_ebx
        finit
        fld     tbyte ptr ss:[ebp+ebx]
        fchs
        fstp    tbyte ptr ss:[ebp+ebx]
        call    invDEBI_FPU_update_display
        popad
        ret
    invDEBI_fpu_swap_sign       ENDP




    invDEBI_fpu_fld_0       PROC
        call    invDEBI_menu_cancel
        frstor  ss:[ebp-200]
        fldz
        fsave   ss:[ebp-200]
        call    invDEBI_FPU_update_display
        ret
    invDEBI_fpu_fld_0       ENDP




    invDEBI_fpu_fld_1       PROC
        call    invDEBI_menu_cancel
        frstor  ss:[ebp-200]
        fld1
        fsave   ss:[ebp-200]
        call    invDEBI_FPU_update_display
        ret
    invDEBI_fpu_fld_1       ENDP




    invDEBI_fpu_fld_10      PROC
        call    invDEBI_menu_cancel
        frstor  ss:[ebp-200]
        push    dword ptr 10
        fild    dword ptr ss:[esp]
        add     esp,4
        fsave   ss:[ebp-200]
        call    invDEBI_FPU_update_display
        ret
    invDEBI_fpu_fld_10      ENDP




    invDEBI_fpu_fld_pi      PROC
        call    invDEBI_menu_cancel
        frstor  ss:[ebp-200]
        fldpi
        fsave   ss:[ebp-200]
        call    invDEBI_FPU_update_display
        ret
    invDEBI_fpu_fld_pi      ENDP




    invDEBI_fpu_ffree       PROC
        call    invDEBI_menu_cancel
        frstor  ss:[ebp-200]
        fistp   ds:trash_dword
        fsave   ss:[ebp-200]
        call    invDEBI_FPU_update_display
        ret
    invDEBI_fpu_ffree       ENDP




    invDEBI_fpu_fmulp       PROC
        call    invDEBI_menu_cancel
        frstor  ss:[ebp-200]
        fmulp   st(1),st(0)
        fsave   ss:[ebp-200]
        call    invDEBI_FPU_update_display
        ret
    invDEBI_fpu_fmulp       ENDP




    invDEBI_fpu_fdivp       PROC
        call    invDEBI_menu_cancel
        frstor  ss:[ebp-200]
        fdivp   st(1),st(0)
        fsave   ss:[ebp-200]
        call    invDEBI_FPU_update_display
        ret
    invDEBI_fpu_fdivp       ENDP




    invDEBI_fpu_fdivrp      PROC
        call    invDEBI_menu_cancel
        frstor  ss:[ebp-200]
        fdivrp  st(1),st(0)
        fsave   ss:[ebp-200]
        call    invDEBI_FPU_update_display
        ret
    invDEBI_fpu_fdivrp      ENDP




    invDEBI_fpu_save        PROC
        call    invDEBI_menu_cancel
        frstor  ss:[ebp-200]
        fsave   ds:FPU_fsave_scratch
        ret
    invDEBI_fpu_save        ENDP




    invDEBI_fpu_restore     PROC
        call    invDEBI_menu_cancel
        frstor  ds:FPU_fsave_scratch
        fsave   ss:[ebp-200]
        call    invDEBI_FPU_update_display
        ret
    invDEBI_fpu_restore     ENDP




    invDEBI_fpu_get_stx_offset_in_ebx       PROC
        push    edi
        push    esi
        push    edx
        push    eax

        mov     esi,ds:fpu_esi
        mov     edi,ds:fpu_edi
        mov     eax,ds:fpu_y
        sub     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        sub     eax,dword ptr ds:[edi+_MO_Y1]
        xor     edx,edx
        mov     ebx,FONT_Y
        div     ebx
      ; Find out which slot to store it in
        .IF (al == 0)
          ; st7
            mov     ebx,-200+98
        .ELSEIF (al == 1)
          ; st6
            mov     ebx,-200+88
        .ELSEIF (al == 2)
          ; st5
            mov     ebx,-200+78
        .ELSEIF (al == 3)
          ; st4
            mov     ebx,-200+68
        .ELSEIF (al == 4)
          ; st3
            mov     ebx,-200+58
        .ELSEIF (al == 5)
          ; st2
            mov     ebx,-200+48
        .ELSEIF (al == 6)
          ; st1
            mov     ebx,-200+38
        .ELSE
          ; st0
            mov     ebx,-200+28
        .ENDIF

        pop     eax
        pop     edx
        pop     esi
        pop     edi
        ret
    invDEBI_fpu_get_stx_offset_in_ebx       ENDP




    invDEBI_mmx_emms        PROC
        call    invDEBI_menu_cancel
        db  0fh, 77h    ; emms
        finit
        fsave   ss:[ebp-200]
        call    invDEBI_FPU_update_display
        ret
    invDEBI_mmx_emms        ENDP




    invDEBI_mmx_emms_zero       PROC
        call    invDEBI_menu_cancel
        db  0fh, 77h    ; emms
        finit
        fsave   ss:[ebp-200]
        finit
        fldz
        fistp   qword ptr ss:[ebp-200+28]
        fldz
        fistp   qword ptr ss:[ebp-200+38]
        fldz
        fistp   qword ptr ss:[ebp-200+48]
        fldz
        fistp   qword ptr ss:[ebp-200+58]
        fldz
        fistp   qword ptr ss:[ebp-200+68]
        fldz
        fistp   qword ptr ss:[ebp-200+78]
        fldz
        fistp   qword ptr ss:[ebp-200+88]
        fldz
        fistp   qword ptr ss:[ebp-200+98]
        call    invDEBI_FPU_update_display
        ret
    invDEBI_mmx_emms_zero       ENDP




    invDEBI_mmx_pnot        PROC
        call    invDEBI_menu_cancel
        mov     edx,ds:fpu_data
        not     dword ptr ss:[ebp+edx+4]
        not     dword ptr ss:[ebp+edx+0]
        call    invDEBI_FPU_update_display
        ret
    invDEBI_mmx_pnot        ENDP




    invDEBI_mmx_pror_mmx_32     PROC
        call    invDEBI_menu_cancel
        mov     edx,ds:fpu_data
        mov     eax,dword ptr ss:[ebp+edx]
        mov     ebx,dword ptr ss:[ebp+edx+4]
        mov     dword ptr ss:[ebp+edx+4],eax
        mov     dword ptr ss:[ebp+edx],ebx
        call    invDEBI_FPU_update_display
        ret
    invDEBI_mmx_pror_mmx_32     ENDP




    invDEBI_mmx_pror_mmx_16     PROC
        call    invDEBI_menu_cancel
        mov     edx,ds:fpu_data
        mov     ax,word ptr ss:[ebp+edx]

        mov     bx,word ptr ss:[ebp+edx+2]
        mov     word ptr ss:[ebp+edx],bx

        mov     bx,word ptr ss:[ebp+edx+4]
        mov     word ptr ss:[ebp+edx+2],bx

        mov     bx,word ptr ss:[ebp+edx+6]
        mov     word ptr ss:[ebp+edx+4],bx

        mov     word ptr ss:[ebp+edx+6],ax
        call    invDEBI_FPU_update_display
        ret
    invDEBI_mmx_pror_mmx_16     ENDP




    invDEBI_mmx_pror_mmx_8      PROC
        call    invDEBI_menu_cancel
        mov     edx,ds:fpu_data
        mov     al,byte ptr ss:[ebp+edx]
        mov     bl,byte ptr ss:[ebp+edx+1]
        mov     byte ptr ss:[ebp+edx],bl

        mov     bl,byte ptr ss:[ebp+edx+2]
        mov     byte ptr ss:[ebp+edx+1],bl

        mov     bl,byte ptr ss:[ebp+edx+3]
        mov     byte ptr ss:[ebp+edx+2],bl

        mov     bl,byte ptr ss:[ebp+edx+4]
        mov     byte ptr ss:[ebp+edx+3],bl

        mov     bl,byte ptr ss:[ebp+edx+5]
        mov     byte ptr ss:[ebp+edx+4],bl

        mov     bl,byte ptr ss:[ebp+edx+6]
        mov     byte ptr ss:[ebp+edx+5],bl

        mov     bl,byte ptr ss:[ebp+edx+7]
        mov     byte ptr ss:[ebp+edx+6],bl

        mov     byte ptr ss:[ebp+edx+7],al
        call    invDEBI_FPU_update_display
        ret
    invDEBI_mmx_pror_mmx_8      ENDP




    invDEBI_mmx_pror_mmx_1      PROC
        call    invDEBI_menu_cancel
        mov     edx,ds:fpu_data
        mov     eax,dword ptr ss:[ebp+edx+0]
        shr     eax,1
        rcr     dword ptr ss:[ebp+edx+4],1
        rcr     dword ptr ss:[ebp+edx+0],1
        call    invDEBI_FPU_update_display
        ret
    invDEBI_mmx_pror_mmx_1      ENDP




    invDEBI_mmx_pshr_mmx_1      PROC
        call    invDEBI_menu_cancel
        mov     edx,ds:fpu_data
        shr     dword ptr ss:[ebp+edx+4],1
        rcr     dword ptr ss:[ebp+edx+0],1
        call    invDEBI_FPU_update_display
        ret
    invDEBI_mmx_pshr_mmx_1      ENDP




    invDEBI_mmx_prol_mmx_16     PROC
        call    invDEBI_menu_cancel
        mov     edx,ds:fpu_data
        mov     ax,word ptr ss:[ebp+edx+6]

        mov     bx,word ptr ss:[ebp+edx+4]
        mov     word ptr ss:[ebp+edx+6],bx

        mov     bx,word ptr ss:[ebp+edx+2]
        mov     word ptr ss:[ebp+edx+4],bx

        mov     bx,word ptr ss:[ebp+edx+0]
        mov     word ptr ss:[ebp+edx+2],bx

        mov     word ptr ss:[ebp+edx+0],ax
        call    invDEBI_FPU_update_display
        ret
    invDEBI_mmx_prol_mmx_16     ENDP




    invDEBI_mmx_prol_mmx_8      PROC
        call    invDEBI_menu_cancel
        mov     edx,ds:fpu_data
        mov     al,byte ptr ss:[ebp+edx+7]
        mov     bl,byte ptr ss:[ebp+edx+6]
        mov     byte ptr ss:[ebp+edx+7],bl

        mov     bl,byte ptr ss:[ebp+edx+5]
        mov     byte ptr ss:[ebp+edx+6],bl

        mov     bl,byte ptr ss:[ebp+edx+4]
        mov     byte ptr ss:[ebp+edx+5],bl

        mov     bl,byte ptr ss:[ebp+edx+3]
        mov     byte ptr ss:[ebp+edx+4],bl

        mov     bl,byte ptr ss:[ebp+edx+2]
        mov     byte ptr ss:[ebp+edx+3],bl

        mov     bl,byte ptr ss:[ebp+edx+1]
        mov     byte ptr ss:[ebp+edx+2],bl

        mov     bl,byte ptr ss:[ebp+edx+0]
        mov     byte ptr ss:[ebp+edx+1],bl

        mov     byte ptr ss:[ebp+edx+0],al
        call    invDEBI_FPU_update_display
        ret
    invDEBI_mmx_prol_mmx_8      ENDP




    invDEBI_mmx_prol_mmx_1      PROC
        call    invDEBI_menu_cancel
        mov     edx,ds:fpu_data
        mov     eax,dword ptr ss:[ebp+edx+4]
        shl     eax,1
        rcl     dword ptr ss:[ebp+edx+0],1
        rcl     dword ptr ss:[ebp+edx+4],1
        call    invDEBI_FPU_update_display
        ret
    invDEBI_mmx_prol_mmx_1      ENDP




    invDEBI_mmx_pshl_mmx_1      PROC
        call    invDEBI_menu_cancel
        mov     edx,ds:fpu_data
        shl     dword ptr ss:[ebp+edx+0],1
        rcl     dword ptr ss:[ebp+edx+4],1
        call    invDEBI_FPU_update_display
        ret
    invDEBI_mmx_pshl_mmx_1      ENDP




    invDEBI_mmx_movq_ffff_ffff_ffff_ffff     PROC
        push    dword ptr 0ffffffffh
        push    dword ptr 0ffffffffh
        jmp     invDEBI_mmx_movq
    invDEBI_mmx_movq_ffff_ffff_ffff_ffff     ENDP




    invDEBI_mmx_movq_0000_ffff_ffff_ffff     PROC
        push    dword ptr 00000ffffh
        push    dword ptr 0ffffffffh
        jmp     invDEBI_mmx_movq
    invDEBI_mmx_movq_0000_ffff_ffff_ffff     ENDP




    invDEBI_mmx_movq_0000_0000_ffff_ffff     PROC
        push    dword ptr 000000000h
        push    dword ptr 0ffffffffh
        jmp     invDEBI_mmx_movq
    invDEBI_mmx_movq_0000_0000_ffff_ffff     ENDP




    invDEBI_mmx_movq_0000_0000_0000_ffff     PROC
        push    dword ptr 000000000h
        push    dword ptr 00000ffffh
        jmp     invDEBI_mmx_movq
    invDEBI_mmx_movq_0000_0000_0000_ffff     ENDP




    invDEBI_mmx_movq_0000_0000_0000_0fff     PROC
        push    dword ptr 000000000h
        push    dword ptr 000000fffh
        jmp     invDEBI_mmx_movq
    invDEBI_mmx_movq_0000_0000_0000_0fff     ENDP




    invDEBI_mmx_movq_0000_0000_0000_00ff     PROC
        push    dword ptr 000000000h
        push    dword ptr 0000000ffh
        jmp     invDEBI_mmx_movq
    invDEBI_mmx_movq_0000_0000_0000_00ff     ENDP




    invDEBI_mmx_movq_0000_0000_0000_000f     PROC
        push    dword ptr 000000000h
        push    dword ptr 00000000fh
        jmp     invDEBI_mmx_movq
    invDEBI_mmx_movq_0000_0000_0000_000f     ENDP




    invDEBI_mmx_movq_0000_0000_0000_0000     PROC
        push    dword ptr 000000000h
        push    dword ptr 000000000h
        jmp     invDEBI_mmx_movq
    invDEBI_mmx_movq_0000_0000_0000_0000    ENDP




    invDEBI_mmx_pand_ffff_0000_0000_0000        PROC
        push    dword ptr 0ffff0000h
        push    dword ptr 000000000h
        jmp     invDEBI_mmx_pand
    invDEBI_mmx_pand_ffff_0000_0000_0000        ENDP




    invDEBI_mmx_pand_0000_ffff_0000_0000        PROC
        push    dword ptr 00000ffffh
        push    dword ptr 000000000h
        jmp     invDEBI_mmx_pand
    invDEBI_mmx_pand_0000_ffff_0000_0000        ENDP




    invDEBI_mmx_pand_0000_0000_ffff_0000        PROC
        push    dword ptr 000000000h
        push    dword ptr 0ffff0000h
        jmp     invDEBI_mmx_pand
    invDEBI_mmx_pand_0000_0000_ffff_0000        ENDP




    invDEBI_mmx_pand_0000_0000_0000_ffff        PROC
        push    dword ptr 000000000h
        push    dword ptr 00000ffffh
        jmp     invDEBI_mmx_pand
    invDEBI_mmx_pand_0000_0000_0000_ffff        ENDP




    invDEBI_mmx_pand_0000_0000_0000_0fff        PROC
        push    dword ptr 000000000h
        push    dword ptr 000000fffh
        jmp     invDEBI_mmx_pand
    invDEBI_mmx_pand_0000_0000_0000_0fff        ENDP




    invDEBI_mmx_pand_0000_0000_0000_00ff        PROC
        push    dword ptr 000000000h
        push    dword ptr 0000000ffh
        jmp     invDEBI_mmx_pand
    invDEBI_mmx_pand_0000_0000_0000_00ff        ENDP




    invDEBI_mmx_pand_0000_0000_0000_000f        PROC
        push    dword ptr 000000000h
        push    dword ptr 00000000fh
        jmp     invDEBI_mmx_pand
    invDEBI_mmx_pand_0000_0000_0000_000f        ENDP




    invDEBI_mmx_pand_ffff_ffff_0000_0000        PROC
        push    dword ptr 0ffffffffh
        push    dword ptr 000000000h
        jmp     invDEBI_mmx_pand
    invDEBI_mmx_pand_ffff_ffff_0000_0000        ENDP




    invDEBI_mmx_pand_0000_0000_ffff_ffff        PROC
        push    dword ptr 000000000h
        push    dword ptr 0ffffffffh
        jmp     invDEBI_mmx_pand
    invDEBI_mmx_pand_0000_0000_ffff_ffff        ENDP




    invDEBI_mmx_pand_ffff_0000_ffff_0000        PROC
        push    dword ptr 0ffff0000h
        push    dword ptr 0ffff0000h
        jmp     invDEBI_mmx_pand
    invDEBI_mmx_pand_ffff_0000_ffff_0000        ENDP




    invDEBI_mmx_pand_0000_ffff_0000_ffff        PROC
        push    dword ptr 00000ffffh
        push    dword ptr 00000ffffh
        jmp     invDEBI_mmx_pand
    invDEBI_mmx_pand_0000_ffff_0000_ffff        ENDP




    invDEBI_mmx_por_ffff_0000_0000_0000         PROC
        push    dword ptr 0ffff0000h
        push    dword ptr 000000000h
        jmp     invDEBI_mmx_por
    invDEBI_mmx_por_ffff_0000_0000_0000         ENDP




    invDEBI_mmx_por_0000_ffff_0000_0000         PROC
        push    dword ptr 00000ffffh
        push    dword ptr 000000000h
        jmp     invDEBI_mmx_por
    invDEBI_mmx_por_0000_ffff_0000_0000         ENDP




    invDEBI_mmx_por_0000_0000_ffff_0000         PROC
        push    dword ptr 000000000h
        push    dword ptr 0ffff0000h
        jmp     invDEBI_mmx_por
    invDEBI_mmx_por_0000_0000_ffff_0000         ENDP




    invDEBI_mmx_por_0000_0000_0000_ffff         PROC
        push    dword ptr 000000000h
        push    dword ptr 00000ffffh
        jmp     invDEBI_mmx_por
    invDEBI_mmx_por_0000_0000_0000_ffff         ENDP




    invDEBI_mmx_por_0000_0000_0000_0fff         PROC
        push    dword ptr 000000000h
        push    dword ptr 000000fffh
        jmp     invDEBI_mmx_por
    invDEBI_mmx_por_0000_0000_0000_0fff         ENDP




    invDEBI_mmx_por_0000_0000_0000_00ff         PROC
        push    dword ptr 000000000h
        push    dword ptr 0000000ffh
        jmp     invDEBI_mmx_por
    invDEBI_mmx_por_0000_0000_0000_00ff         ENDP




    invDEBI_mmx_por_0000_0000_0000_000f         PROC
        push    dword ptr 000000000h
        push    dword ptr 00000000fh
        jmp     invDEBI_mmx_por
    invDEBI_mmx_por_0000_0000_0000_000f         ENDP




    invDEBI_mmx_por_ffff_ffff_0000_0000         PROC
        push    dword ptr 0ffffffffh
        push    dword ptr 000000000h
        jmp     invDEBI_mmx_por
    invDEBI_mmx_por_ffff_ffff_0000_0000         ENDP




    invDEBI_mmx_por_0000_0000_ffff_ffff         PROC
        push    dword ptr 000000000h
        push    dword ptr 0ffffffffh
        jmp     invDEBI_mmx_por
    invDEBI_mmx_por_0000_0000_ffff_ffff         ENDP




    invDEBI_mmx_por_ffff_0000_ffff_0000         PROC
        push    dword ptr 0ffff0000h
        push    dword ptr 0ffff0000h
        jmp     invDEBI_mmx_por
    invDEBI_mmx_por_ffff_0000_ffff_0000         ENDP




    invDEBI_mmx_por_0000_ffff_0000_ffff         PROC
        push    dword ptr 00000ffffh
        push    dword ptr 00000ffffh
        jmp     invDEBI_mmx_por
    invDEBI_mmx_por_0000_ffff_0000_ffff         ENDP




    invDEBI_mmx_pandn_ffff_0000_0000_0000       PROC
        push    dword ptr 0ffff0000h
        push    dword ptr 000000000h
        jmp     invDEBI_mmx_pandn
    invDEBI_mmx_pandn_ffff_0000_0000_0000       ENDP




    invDEBI_mmx_pandn_0000_ffff_0000_0000       PROC
        push    dword ptr 00000ffffh
        push    dword ptr 000000000h
        jmp     invDEBI_mmx_pandn
    invDEBI_mmx_pandn_0000_ffff_0000_0000       ENDP




    invDEBI_mmx_pandn_0000_0000_ffff_0000       PROC
        push    dword ptr 000000000h
        push    dword ptr 0ffff0000h
        jmp     invDEBI_mmx_pandn
    invDEBI_mmx_pandn_0000_0000_ffff_0000       ENDP




    invDEBI_mmx_pandn_0000_0000_0000_ffff       PROC
        push    dword ptr 000000000h
        push    dword ptr 00000ffffh
        jmp     invDEBI_mmx_pandn
    invDEBI_mmx_pandn_0000_0000_0000_ffff       ENDP




    invDEBI_mmx_pandn_0000_0000_0000_0fff       PROC
        push    dword ptr 000000000h
        push    dword ptr 000000fffh
        jmp     invDEBI_mmx_pandn
    invDEBI_mmx_pandn_0000_0000_0000_0fff       ENDP




    invDEBI_mmx_pandn_0000_0000_0000_00ff       PROC
        push    dword ptr 000000000h
        push    dword ptr 0000000ffh
        jmp     invDEBI_mmx_pandn
    invDEBI_mmx_pandn_0000_0000_0000_00ff       ENDP




    invDEBI_mmx_pandn_0000_0000_0000_000f       PROC
        push    dword ptr 000000000h
        push    dword ptr 00000000fh
        jmp     invDEBI_mmx_pandn
    invDEBI_mmx_pandn_0000_0000_0000_000f       ENDP




    invDEBI_mmx_pandn_ffff_ffff_0000_0000       PROC
        push    dword ptr 0ffffffffh
        push    dword ptr 000000000h
        jmp     invDEBI_mmx_pandn
    invDEBI_mmx_pandn_ffff_ffff_0000_0000       ENDP




    invDEBI_mmx_pandn_0000_0000_ffff_ffff       PROC
        push    dword ptr 000000000h
        push    dword ptr 0ffffffffh
        jmp     invDEBI_mmx_pandn
    invDEBI_mmx_pandn_0000_0000_ffff_ffff       ENDP




    invDEBI_mmx_pandn_ffff_0000_ffff_0000       PROC
        push    dword ptr 0ffff0000h
        push    dword ptr 0ffff0000h
        jmp     invDEBI_mmx_pandn
    invDEBI_mmx_pandn_ffff_0000_ffff_0000       ENDP




    invDEBI_mmx_pandn_0000_ffff_0000_ffff       PROC
        push    dword ptr 00000ffffh
        push    dword ptr 00000ffffh
        jmp     invDEBI_mmx_pandn
    invDEBI_mmx_pandn_0000_ffff_0000_ffff       ENDP




    invDEBI_mmx_movq        PROC
        mov     edx,ds:fpu_data
        call    invDEBI_menu_cancel

        mov     ebx,dword ptr ss:[esp+4]
        mov     dword ptr ss:[ebp+edx+4],ebx

        mov     ebx,dword ptr ss:[esp+0]
        mov     dword ptr ss:[ebp+edx+0],ebx
        call    invDEBI_FPU_update_display
        add     esp,8
        ret
    invDEBI_mmx_movq        ENDP




    invDEBI_mmx_pand        PROC
        mov     edx,ds:fpu_data
        call    invDEBI_menu_cancel

        mov     ebx,dword ptr ss:[esp+4]
        and     dword ptr ss:[ebp+edx+4],ebx

        mov     ebx,dword ptr ss:[esp+0]
        and     dword ptr ss:[ebp+edx+0],ebx
        call    invDEBI_FPU_update_display
        add     esp,8
        ret
    invDEBI_mmx_pand        ENDP




    invDEBI_mmx_por         PROC
        mov     edx,ds:fpu_data
        call    invDEBI_menu_cancel

        mov     ebx,dword ptr ss:[esp+4]
        or      dword ptr ss:[ebp+edx+4],ebx

        mov     ebx,dword ptr ss:[esp+0]
        or      dword ptr ss:[ebp+edx+0],ebx
        call    invDEBI_FPU_update_display
        add     esp,8
        ret
    invDEBI_mmx_por         ENDP




    invDEBI_mmx_pandn       PROC
        mov     edx,ds:fpu_data
        call    invDEBI_menu_cancel

        mov     ebx,dword ptr ss:[esp+4]
        not     ebx
        and     dword ptr ss:[ebp+edx+4],ebx

        mov     ebx,dword ptr ss:[esp+0]
        not     ebx
        and     dword ptr ss:[ebp+edx+0],ebx
        call    invDEBI_FPU_update_display
        add     esp,8
        ret
    invDEBI_mmx_pandn       ENDP




    invDEBI_quick_watch_show_EBP_relative_selector      PROC
        call    invDEBI_quick_watch_add_divider
        movsx   ebx,word ptr ds:[edi+_MO_DATA]
        mov     edx,dword ptr ss:[ebp+ebx]
        mov     ebx,16
        mov     edi,offset hex_text
        call    invDEBI_quick_watch_add_radix_in_edx
        mov     ebx,10
        mov     edi,offset dec_text
        call    invDEBI_quick_watch_add_radix_in_edx
        mov     ebx,2
        mov     edi,offset bin_text
        call    invDEBI_quick_watch_add_radix_in_edx
        .IF (edx == 08h)
            mov     esi,offset _sIDT_text
        .ELSEIF (edx == 010h)
            mov     esi,offset _sGDT_text
        .ELSEIF (edx == 018h)
            mov     esi,offset _sSTACK_text
        .ELSEIF (edx == 020h)
            mov     esi,offset _sCODE_text
        .ELSEIF (edx == 028h)
            mov     esi,offset _sGRAPHICS_text
        .ELSEIF (edx == 030h)
            mov     esi,offset _sMONO_text
        .ELSEIF (edx == 038h)
            mov     esi,offset _sVGA_text
        .ELSEIF (edx == 040h)
            mov     esi,offset _sALL_MEM_text
        .ELSEIF (edx == 048h)
            mov     esi,offset _sDATA_text
        .ELSEIF (edx == 050h)
            mov     esi,offset _sEXODUS_MEM_text
        .ELSEIF (edx == 058h)
            mov     esi,offset _sEXODUS_PORTS_text
        .ELSEIF (edx == 060h)
            mov     esi,offset _sEXODUS_INTS_text
;        .ELSEIF (edx == 068h)
;          ; Not used, this is slot 13.  13 is bad luck. :)
        .ELSEIF (edx == 070h)
            mov     esi,offset _sEXODUS_TSS_text
        .ELSEIF (edx == 078h)
            mov     esi,offset _sEXODUS_TSS_GATE_text
        .ELSEIF (edx == 080h)
            mov     esi,offset _sSTACK0_text
        .ELSEIF (edx == 088h)
            mov     esi,offset _sSTACK1_text
        .ELSEIF (edx == 090h)
            mov     esi,offset _sSTACK2_text
        .ELSEIF (edx == 098h)
            mov     esi,offset _sPRIMATIVES_text
        .ELSEIF (edx == 0a0h)
            mov     esi,offset _sPRIMATIVES_LOAD_INFO_text
        .ELSEIF (edx == 0a8h)
            mov     esi,offset _sSYSTEM_text
        .ELSEIF (edx == 0b0h)
            mov     esi,offset _sEXODUS_REQUESTOR_text
        .ELSEIF (edx == 0b8h)
            mov     esi,offset _sSYSTEM_RING1_text
        .ELSEIF (edx == 0c0h)
            mov     esi,offset _sSYSTEM_RING2_text
        .ELSEIF (edx == 0c8h)
            mov     esi,offset _sSYSTEM_RING3_text
        .ELSEIF (edx == 0d0h)
            mov     esi,offset _sDEBI_screen_text
        .ELSEIF (edx == 0d8h)
            mov     esi,offset _sDEBI_memory_text
        .ELSEIF (edx == 0e0h)
            mov     esi,offset _sFLOPPY_TRACK_text
        .ELSEIF (edx == 0e8h)
            mov     esi,offset _sVGA_BACKUP_text
        .ELSEIF (edx == 0190h)
            mov     esi,offset _sEXODUS_INI_text
        .ELSEIF (edx == 0198h)
            mov     esi,offset _sEXODUS_INI_ERRORS_text
        .ELSEIF (edx == 01a0h)
            mov     esi,offset _sTASK_SYSTEM_text
        .ELSE
            jmp     @F
        .ENDIF
        mov     edi,offset _selector_text
        call    invDEBI_quick_watch_add_item
      @@:
        ret
    invDEBI_quick_watch_show_EBP_relative_selector      ENDP




    invDEBI_quick_watch_show_EBP_relative_32        PROC
    ; This routine displays a 32-bit value that's in the data Debi saved when it was called
        movsx   ebx,word ptr ds:[edi+_MO_DATA]
        mov     edx,dword ptr ss:[ebp+ebx]
        call    invDEBI_quick_watch_common_32
        ret
    invDEBI_quick_watch_show_EBP_relative_32        ENDP




    invDEBI_quick_watch_common_32       PROC
    ; This routine displays the value in edx in three different formats
    ;
    ; Upon entry:   edx - value to display
    ;
    ; Upon exit:    It is displayed in hex, decimal and binary
    ;
        call    invDEBI_quick_watch_add_divider
        mov     ebx,16
        mov     edi,offset hex_text
        call    invDEBI_quick_watch_add_radix_in_edx
        mov     ebx,10
        mov     edi,offset dec_text
        call    invDEBI_quick_watch_add_radix_in_edx
        mov     ebx,2
        mov     edi,offset bin_text
        call    invDEBI_quick_watch_add_radix_in_edx
        mov     edi,offset real4_text
        call    invDEBI_quick_watch_add_real4_in_edx
        ret
    invDEBI_quick_watch_common_32       ENDP




    invDEBI_quick_watch_show_fpu_cw     PROC
        movsx   ebx,word ptr ds:[edi+_MO_DATA]
        movzx   edx,word ptr ss:[ebp+ebx]

      ; Show the value in binary
        call    invDEBI_quick_watch_add_divider
        mov     ebx,16
        mov     edi,offset hex_text
        call    invDEBI_quick_watch_add_radix_in_edx
        mov     ebx,2
        mov     edi,offset bin_text
        call    invDEBI_quick_watch_add_radix_in_edx

        mov     ebx,edx
        and     ebx,_CW_ROUNDING
        .IF (ebx == _CW_ROUNDING_00)
          ; Round to nearest
            mov     esi,offset round_to_nearest
        .ELSEIF (ebx == _CW_ROUNDING_01)
          ; Round down
            mov     esi,offset round_down
        .ELSEIF (ebx == _CW_ROUNDING_10)
          ; Round up
            mov     esi,offset round_up
        .ELSE
          ; Truncate
            mov     esi,offset round_truncate
        .ENDIF
        mov     edi,offset rounding_text
        call    invDEBI_quick_watch_add_item

        mov     ebx,edx
        and     ebx,_CW_PRECISION
        .IF (ebx == _CW_PRECISION_00)
          ; Single (23 bit w/1)
            mov     esi,offset precision_single
        .ELSEIF (ebx == _CW_PRECISION_01)
          ; Reserved
            mov     esi,offset precision_reserved
        .ELSEIF (ebx == _CW_PRECISION_10)
          ; Double (53 bit w/1)
            mov     esi,offset precision_double
        .ELSE
          ; Extended (64 bit w/1)
            mov     esi,offset precision_extended
        .ENDIF
        mov     edi,offset precision_prefix_text
        call    invDEBI_quick_watch_add_item

        mov     edi,offset mask_text
        test    edx,_CW_PM
        .IF (!zero?)
            mov     esi,offset precision_text
            call    invDEBI_quick_watch_add_item
        .ENDIF

        test    edx,_CW_UM
        .IF (!zero?)
            mov     esi,offset underflow_text
            call    invDEBI_quick_watch_add_item
        .ENDIF

        test    edx,_CW_OM
        .IF (!zero?)
            mov     esi,offset overflow_text
            call    invDEBI_quick_watch_add_item
        .ENDIF

        test    edx,_CW_ZM
        .IF (!zero?)
            mov     esi,offset divide_by_zero_text
            call    invDEBI_quick_watch_add_item
        .ENDIF

        test    edx,_CW_DM
        .IF (!zero?)
            mov     esi,offset denormalized_text
            call    invDEBI_quick_watch_add_item
        .ENDIF

        test    edx,_CW_IM
        .IF (!zero?)
            mov     esi,offset invalid_text
            call    invDEBI_quick_watch_add_item
        .ENDIF

        ret
    invDEBI_quick_watch_show_fpu_cw     ENDP




    invDEBI_quick_watch_show_fpu_sw     PROC
        movsx   ebx,word ptr ds:[edi+_MO_DATA]
        movzx   edx,word ptr ss:[ebp+ebx]

      ; Show the value in binary
        call    invDEBI_quick_watch_add_divider
        mov     ebx,16
        mov     edi,offset hex_text
        call    invDEBI_quick_watch_add_radix_in_edx
        mov     ebx,2
        mov     edi,offset bin_text
        call    invDEBI_quick_watch_add_radix_in_edx

        test    edx,_SW_BUSY
        .IF (!zero?)
            mov     esi,offset busy
            call    invDEBI_quick_watch_add_item
        .ENDIF

      ; Display the condition codes in binary
        mov     ebx,edx
        and     ebx,_SW_C3
        shr     ebx,11
        mov     ecx,edx
        and     ecx,_SW_C2 or _SW_C1 or _SW_C0
        shr     ecx,_SW_C0-1
        or      ebx,ecx
      ; Right now, ecx contains the value
        push    edx
        mov     edx,ebx
        mov     ebx,2
        mov     edi,offset condition_codes_text
        call    invDEBI_quick_watch_add_radix_in_edx
        pop     edx

      ; Top of stack
        mov     ebx,edx
        and     ebx,_SW_TOS
        shr     ebx,11
        push    edx
        mov     edx,ebx
        mov     ebx,10
        mov     edi,offset top_of_stack_text
        call    invDEBI_quick_watch_add_radix_in_edx
        pop     edx

      ; Add all of the flags
        mov     edi,-1
        test    edx,_SW_ERROR_SUMMARY
        .IF (!zero?)
            mov     esi,offset error_summary
            call    invDEBI_quick_watch_add_item
        .ENDIF

        test    edx,_SW_STACK_FAULT
        .IF (!zero?)
            mov     esi,offset stack_fault
            call    invDEBI_quick_watch_add_item
        .ENDIF

        mov     edi,offset exception_prefix_text
        test    edx,_SW_PE
        .IF (!zero?)
            mov     esi,offset precision_text
            call    invDEBI_quick_watch_add_item
        .ENDIF

        test    edx,_SW_UE
        .IF (!zero?)
            mov     esi,offset underflow_text
            call    invDEBI_quick_watch_add_item
        .ENDIF

        test    edx,_SW_OE
        .IF (!zero?)
            mov     esi,offset overflow_text
            call    invDEBI_quick_watch_add_item
        .ENDIF

        test    edx,_SW_ZE
        .IF (!zero?)
            mov     esi,offset divide_by_zero_text
            call    invDEBI_quick_watch_add_item
        .ENDIF

        test    edx,_SW_DE
        .IF (!zero?)
            mov     esi,offset denormalized_text
            call    invDEBI_quick_watch_add_item
        .ENDIF

        test    edx,_SW_IE
        .IF (!zero?)
            mov     esi,offset invalid_text
            call    invDEBI_quick_watch_add_item
        .ENDIF
        ret
    invDEBI_quick_watch_show_fpu_sw     ENDP




    invDEBI_quick_watch_show_fpu_tw     PROC
        movsx   ebx,word ptr ds:[edi+_MO_DATA]
        movzx   edx,word ptr ss:[ebp+ebx]

        call    invDEBI_quick_watch_add_divider
        mov     ecx,8
        mov     edi,offset stx_text
        mov     byte ptr ds:[edi+2],'7'
      @@:
        mov     bl,dl
        and     bl,11b
        .IF (bl == 00b)
          ; Valid
            mov     esi,offset tag_valid
        .ELSEIF (bl == 01b)
          ; Zero
            mov     esi,offset tag_zero
        .ELSEIF (bl == 10b)
          ; Special
            mov     esi,offset tag_special
        .ELSE
          ; Empty
            mov     esi,offset tag_empty
        .ENDIF
        call    invDEBI_quick_watch_add_item
        dec     byte ptr ds:[edi+2]
        ror     dx,2
        loop    @B
        ret
    invDEBI_quick_watch_show_fpu_tw     ENDP




    invDEBI_quick_watch_stack_32        PROC
    ; This routine displays a 32-bit value that's on the user's stack
        movsx   ebx,word ptr ds:[edi+_MO_DATA]
        mov     edx,dword ptr ss:[ebp-04]
        mov     edx,dword ptr ss:[edx+ebx]
        call    invDEBI_quick_watch_add_divider
        call    invDEBI_quick_watch_common_32
        ret
    invDEBI_quick_watch_stack_32        ENDP




    invDEBI_quick_watch_locals_32       PROC
    ; This routine displays a 32-bit value that's on the user's stack
        movsx   ebx,word ptr ds:[edi+_MO_DATA]
        mov     edx,dword ptr ss:[ebp+00]
        mov     edx,dword ptr ss:[edx+ebx]
        call    invDEBI_quick_watch_add_divider
        call    invDEBI_quick_watch_common_32
        ret
    invDEBI_quick_watch_locals_32       ENDP




    invDEBI_quick_watch_show_fpu_opcode     PROC
    ; This routine displays the 11 bits of an FPU opcode.  It is known that the prefix bits are always 11011.
    ; These 11-bits help to make up the entire opcode.  That opcode is used here and the corresponding FPU command is found.
    ;
        push    ds
        mov     ebx,1101100000000000b
        movsx   edx,word ptr ds:[edi+_MO_DATA]
        movzx   edx,word ptr ss:[ebp+edx]
        and     edx,0000011111111111b
        or      ebx,edx
      ; Right now, ebx - opcode of last FPU instruction
        call    invDEBI_quick_watch_add_divider
        call    fword ptr ds:_X86_fpu_opcode
        mov     edi,offset disasm_text
        call    invDEBI_quick_watch_add_item_ecx
        pop     ds
        ret
    invDEBI_quick_watch_show_fpu_opcode     ENDP




    invDEBI_mem1_window     PROC
        mov     ah,0                                                ; Ul X
        mov     al,1                                                ; Ul Y
        mov     bh,14                                               ; Lr X
        mov     bl,12                                               ; Lr Y
        call    invDEBI_populate_mem_window
        ret
    invDEBI_mem1_window     ENDP




    invDEBI_mem2_window     PROC
        mov     ah,0                                                ; Ul X
        mov     al,1                                                ; Ul Y
        mov     bh,29                                               ; Lr X
        mov     bl,12                                               ; Lr Y
        call    invDEBI_populate_mem_window
        ret
    invDEBI_mem2_window     ENDP




    invDEBI_mem3_window     PROC
        mov     ah,0                                                ; Ul X
        mov     al,1                                                ; Ul Y
        mov     bh,44                                               ; Lr X
        mov     bl,12                                               ; Lr Y
        call    invDEBI_populate_mem_window
        ret
    invDEBI_mem3_window     ENDP




    invDEBI_mem4_window     PROC
        mov     ah,0                                                ; Ul X
        mov     al,1                                                ; Ul Y
        mov     bh,59                                               ; Lr X
        mov     bl,12                                               ; Lr Y
        call    invDEBI_populate_mem_window
        ret
    invDEBI_mem4_window     ENDP




    invDEBI_populate_mem_window     PROC
    ; This routine is called to populate a memory window
    ;
    ; Upon entry:      ah,al - Upper left X,Y
    ;                  bh,bl - Lower right X,Y
    ;               ds:[esi] - far ptr to mem.x window object
    ;
    ; Upon exit:    The window is populated with whatever the current address expression suggests
    ;
        .IF (dword ptr ds:[esi+_ST_MEMVAR_OFFSET] != -1)
            push    es                                              ; Copy data from the MEMVAR memory into local variables
            push    ebx
            push    esi
            mov     ebx,_sDEBI_memory
            mov     es,ebx
            mov     ebx,offset DEBI_exp_memvar_list
            mov     esi,dword ptr ds:[esi+_ST_MEMVAR_OFFSET]
            call    invDEBI_from_object_memvar
            pop     esi
            pop     ebx
            pop     es

          ; See if we need to update the data there
            .IF (ds:live == 'X' || ds:force_func_windows == _YES)
              ; It is a live expression (which means whatever on the screen being displayed right now needs to be overwritten)
                pushfd
                cli
                call    invDEBI_get_mem_window_coords
                mov     esi,offset text_22
                mov     ecx,sizeof text_22 - 1
                call    invDEBI_parse_expression
                jc      quit                                        ; Branch if error in expression
                mov     ds:mem_segment,eax
                mov     ds:mem_offset,ebx

              ; Obtain limit for this selector (to find out when a pointer is going beyond readable memory)
                mov     edx,eax                                     ; Selector
                mov     eax,'get '
                mov     ebx,'limi'
                call    fword ptr ds:_EXODUS_requestor
                mov     ds:mem_limit,ecx

                mov     esi,offset disp_22
                mov     ecx,sizeof disp_22 - 1
                call    invDEBI_parse_expression
                jc      quit                                        ; Branch if error in expressions
                mov     ds:mem_displacement,ebx

              ; Display the top line (if any)
                .IF (ds:show_addresses == 'X')
                    call    invDEBI_pop_line_show_address
                    mov     eax,1
                .ELSE
                    xor     eax,eax
                .ENDIF
                sub     esp,4
              ; [esp+0] - dword, holds current Y value (for each line displayed)

              ; Now, for each line, parse the data
                mov     dword ptr ss:[esp+0],eax
                jmp     @F
                .WHILE (eax <= ds:mem_height)
                  ; Determine the window type and populate a line of data based on that type
                    .IF (ds:ascii_char == 'X')
                      default_window:
                        call    invDEBI_pop_line_mem_window_ascii_char
                    .ELSEIF (ds:_byte == 'X')
                        call    invDEBI_pop_line_mem_window_byte
                    .ELSEIF (ds:_word == 'X')
                        call    invDEBI_pop_line_mem_window_word
                    .ELSEIF (ds:_dword == 'X')
                        call    invDEBI_pop_line_mem_window_dword
                    .ELSEIF (ds:_qword == 'X')
                        call    invDEBI_pop_line_mem_window_qword
                    .ELSEIF (ds:float32 == 'X')
                        call    invDEBI_pop_line_mem_window_float32
                    .ELSEIF (ds:float64 == 'X')
                        call    invDEBI_pop_line_mem_window_float64
                    .ELSEIF (ds:float80 == 'X')
                        call    invDEBI_pop_line_mem_window_float80
                    .ELSE
                        jmp     default_window
                    .ENDIF
                    inc     dword ptr ss:[esp+0]                    ; Move to next logical line
                    add     ds:mem_ul_y,FONT_Y                      ; Move down to next displayable line
                  @@:
                    mov     eax,dword ptr ss:[esp+0]
                .ENDW

                add     esp,4
                popfd
            .ENDIF
        .ENDIF
      quit:
        ret
    invDEBI_populate_mem_window     ENDP




    ; All routines below receive the same input.
    ;
    ; Upon entry:     ds:mem_ul_x - starting X pixel coordinate
    ;                 ds:mem_ul_y - starting Y pixel coordinate
    ;                ds:mem_width - # of characters wide before spilling out of window
    ;               ds:mem_height - # of lines tall before spilling out of window
    ;              ds:mem_segment - segment to use for addresses
    ;               ds:mem_offset - offset to use for addresses
    ;         ds:mem_displacement - displacement to use for address
    ;
    ; Upon exit:    The memory window is populated
    ;
    invDEBI_pop_line_show_address       PROC
    ; This routine is used to show the address
        pushad
        push    ds
        push    es
        enter   16,0

      ; Data gets stored to ss:[esp] converted to es:[edi] (Note, esi is used below for display purposes)
        push    ss
        pop     es
        mov     edi,esp
        mov     esi,esp
        mov     word ptr es:[edi],'x0'
        add     edi,2
      ; Store the segment
        mov     eax,ds:mem_segment
        ror     eax,12
        mov     ecx,4
        call    invDEBI_store_ecx_hexadecimal_in_eax
        mov     al,':'
        stosb

      ; Store the offset
        mov     eax,ds:mem_offset
        rol     eax,4
        mov     ecx,8
        call    invDEBI_store_ecx_hexadecimal_in_eax
        xor     al,al
        stosb

      ; Show the address
        push    ss
        pop     ds
        push    cs:mem_ul_x                                         ; horizontal
        push    cs:mem_ul_y                                         ; vertical
        push    esi                                                 ; start of text we've just created to display
        call    fword ptr cs:_VID_g_mono_display_text               ;

        leave
        pop     es
        pop     ds
        popad

      ; Move down to next displayable line
        add     ds:mem_ul_y,FONT_Y
        ret
    invDEBI_pop_line_show_address       ENDP




    invDEBI_pop_line_mem_window_ascii_char      PROC
    ; This routine is called to display a line of data in an ASCII character format
        call    invDEBI_pop_line_show_displacement
        .IF (ds:show_addresses == 'X')
            add     ds:mem_temp_x,1*FONT_X                          ; Move over one more space between displacement and data
        .ENDIF
        pushad
        push    ds
        push    es
        enter   184,0                                               ; Screen is 90 columns wide, must accomodate a potential max!

      ; Get our temporary destination address
        push    ss
        pop     es
        mov     edi,esp

      ; Get our source address
        mov     ds,ds:mem_segment
        mov     esi,cs:mem_offset
        add     esi,cs:mem_displacement

      ; Now, copy the text to our temp area
        mov     edx,cs:mem_temp_x
        mov     ecx,cs:mem_max_x
        xor     ebx,ebx
        .WHILE (edx < ecx && ebx < 90)                              ; while temp_x < max_x and count < 90)
            add     edx,FONT_X
            .IF (edx < ecx)
                mov     al,168                                      ; Store the ® character (indicating the character to the right
                stosb                                               ;                 should be displayed regardless of what it is)
            .ENDIF
            .IF (esi <= cs:mem_limit)
                lodsb
                or      al,al
                jnz     @F
                mov     al,-1
            .ELSE
                mov     al,'?'
            .ENDIF
          @@:
            .IF (edx < ecx)
                stosb
            .ENDIF
            inc     ebx
        .ENDW
        xor     al,al
        stosb

      ; Now, display what we've just copied
        push    ss
        pop     ds
        mov     esi,esp
        push    cs:mem_temp_x
        push    cs:mem_ul_y
        push    esi
        call    fword ptr cs:_VID_g_mono_display_text

      ; We're finished
        leave
        pop     es
        pop     ds
        add     ds:mem_displacement,ebx
        popad
        ret
    invDEBI_pop_line_mem_window_ascii_char      ENDP




    invDEBI_pop_line_mem_window_byte            PROC
    ; This routine is called to display a line of data in a BYTE format
        call    invDEBI_pop_line_show_displacement
        .IF (ds:show_addresses == 'X')
            add     ds:mem_temp_x,1*FONT_X                          ; Move over one more space between displacement and data
        .ENDIF
        pushad
        push    ds
        push    es
        enter   96,0                                                ; Screen is 90 columns wide, must accomodate a potential max!
      ; [ebp-04], dword - Maximum offset to achieve for the three-byte field used for BYTE data

      ; Get our temporary destination address
        push    ss
        pop     es
        mov     edi,esp

      ; Get our source address
        mov     ds,ds:mem_segment
        mov     esi,cs:mem_offset
        add     esi,cs:mem_displacement

      ; Now, copy the text to our temp area
        mov     edx,cs:mem_temp_x
        mov     ecx,cs:mem_max_x
        mov     dword ptr ss:[ebp-04],ecx
        sub     dword ptr ss:[ebp-04],3*FONT_X
        xor     ebx,ebx
        .WHILE (edx < ecx && edx <= dword ptr ss:[ebp-04] && ebx < 90/3)
          ; The above line basically equates to:  while temp_x < max_x and (enough_space) and count < 30)

          ; Get the character to display in BYTE format
            .IF (esi <= cs:mem_limit)
                lodsb
            .ELSE
                xor     al,al
            .ENDIF

          @@:
            call    invDEBI_store_byte_data_in_al

            add     edx,FONT_X*3
            .IF (edx <= dword ptr ss:[ebp-04])
              ; Store space after
                mov     al,32
                stosb
            .ENDIF

          ; Move to next screen location
            inc     ebx
        .ENDW
        xor     al,al
        stosb

      ; Now, display what we've just copied
        push    ss
        pop     ds
        mov     esi,esp
        push    cs:mem_temp_x
        push    cs:mem_ul_y
        push    esi
        call    fword ptr cs:_VID_g_mono_display_text

      ; We're finished
        leave
        pop     es
        pop     ds
        add     ds:mem_displacement,ebx
        popad
        ret
    invDEBI_pop_line_mem_window_byte            ENDP




    invDEBI_pop_line_mem_window_word            PROC
    ; This routine is called to display a line of data in a WORD format
        call    invDEBI_pop_line_show_displacement
        .IF (ds:show_addresses == 'X')
            add     ds:mem_temp_x,1*FONT_X                          ; Move over one more space between displacement and data
        .ENDIF
        pushad
        push    ds
        push    es
        enter   96,0                                                ; Screen is 90 columns wide, must accomodate a potential max!
      ; [ebp-04], dword - Maximum offset to achieve for the three-byte field used for BYTE data

      ; Get our temporary destination address
        push    ss
        pop     es
        mov     edi,esp

      ; Get our source address
        sub     ds:mem_limit,2
        mov     ds,ds:mem_segment
        mov     esi,cs:mem_offset
        add     esi,cs:mem_displacement

      ; Now, copy the text to our temp area
        mov     edx,cs:mem_temp_x
        mov     ecx,cs:mem_max_x
        mov     dword ptr ss:[ebp-04],ecx
        sub     dword ptr ss:[ebp-04],5*FONT_X
        xor     ebx,ebx
        .WHILE (edx < ecx && edx <= dword ptr ss:[ebp-04] && ebx < 2*90/5)
          ; The above line basically equates to:  while temp_x < max_x and (enough_space) and count < 18)

          ; Get the character to display in WORD format
            .IF (esi <= cs:mem_limit)
                lodsw
            .ELSE
                xor     ax,ax
            .ENDIF

          @@:
          ; Store upper high byte
            push    eax
            shr     eax,8
            call    invDEBI_store_byte_data_in_al
            pop     eax

          ; Store upper low byte
            call    invDEBI_store_byte_data_in_al

            add     edx,FONT_X*5
            .IF (edx <= dword ptr ss:[ebp-04])
              ; Store space after
                mov     al,32
                stosb
            .ENDIF

          ; Move to next screen location
            add     ebx,2
        .ENDW
        xor     al,al
        stosb

      ; Now, display what we've just copied
        push    ss
        pop     ds
        mov     esi,esp
        push    cs:mem_temp_x
        push    cs:mem_ul_y
        push    esi
        call    fword ptr cs:_VID_g_mono_display_text

      ; We're finished
        leave
        pop     es
        pop     ds
        add     ds:mem_displacement,ebx
        add     ds:mem_limit,2
        popad
        ret
    invDEBI_pop_line_mem_window_word            ENDP




    invDEBI_pop_line_mem_window_dword           PROC
    ; This routine is called to display a line of data in a DWORD format
        call    invDEBI_pop_line_show_displacement
        .IF (ds:show_addresses == 'X')
            add     ds:mem_temp_x,1*FONT_X                          ; Move over one more space between displacement and data
        .ENDIF
        pushad
        push    ds
        push    es
        enter   96,0                                                ; Screen is 90 columns wide, must accomodate a potential max!
      ; [ebp-04], dword - Maximum offset to achieve for the three-byte field used for BYTE data

      ; Get our temporary destination address
        push    ss
        pop     es
        mov     edi,esp

      ; Get our source address
        sub     ds:mem_limit,4
        mov     ds,ds:mem_segment
        mov     esi,cs:mem_offset
        add     esi,cs:mem_displacement

      ; Now, copy the text to our temp area
        mov     edx,cs:mem_temp_x
        mov     ecx,cs:mem_max_x
        mov     dword ptr ss:[ebp-04],ecx
        sub     dword ptr ss:[ebp-04],10*FONT_X
        xor     ebx,ebx
        .WHILE (edx < ecx && edx <= dword ptr ss:[ebp-04] && ebx < 4*90/10)
          ; The above line basically equates to:  while temp_x < max_x and (enough_space) and count < whatever:) )

          ; Get the character to display in DWORD format
            .IF (esi <= cs:mem_limit)
                lodsd
            .ELSE
                xor     eax,eax
            .ENDIF

          @@:
          ; Store upper high byte of high word
            push    eax
            shr     eax,24
            call    invDEBI_store_byte_data_in_al
            pop     eax

          ; Store upper low byte of high word
            push    eax
            shr     eax,16
            call    invDEBI_store_byte_data_in_al

          ; Store period between high word and low word
            mov     al,'.'
            stosb
            pop     eax

          ; Store upper high byte of low word
            push    eax
            shr     eax,8
            call    invDEBI_store_byte_data_in_al
            pop     eax

          ; Store upper low byte of low word
            call    invDEBI_store_byte_data_in_al

            add     edx,FONT_X*10
            .IF (edx <= dword ptr ss:[ebp-04])
              ; Store one space after
                mov     al,32
                stosb
            .ENDIF

          ; Move to next screen location
            add     ebx,4
        .ENDW
        xor     al,al
        stosb

      ; Now, display what we've just copied
        push    ss
        pop     ds
        mov     esi,esp
        push    cs:mem_temp_x
        push    cs:mem_ul_y
        push    esi
        call    fword ptr cs:_VID_g_mono_display_text

      ; We're finished
        leave
        pop     es
        pop     ds
        add     ds:mem_displacement,ebx
        add     ds:mem_limit,4
        popad
        ret
    invDEBI_pop_line_mem_window_dword           ENDP




    invDEBI_pop_line_mem_window_qword           PROC
    ; This routine is called to display a line of data in a QWORD format
        call    invDEBI_pop_line_show_displacement
        .IF (ds:show_addresses == 'X')
            add     ds:mem_temp_x,1*FONT_X                          ; Move over one more space between displacement and data
        .ENDIF
        pushad
        push    ds
        push    es
        enter   96,0                                                ; Screen is 90 columns wide, must accomodate a potential max!
      ; [ebp-04], dword - Maximum offset to achieve for the three-byte field used for BYTE data

      ; Get our temporary destination address
        push    ss
        pop     es
        mov     edi,esp

      ; Get our source address
        sub     ds:mem_limit,8
        mov     ds,ds:mem_segment
        mov     esi,cs:mem_offset
        add     esi,cs:mem_displacement

      ; Now, copy the text to our temp area
        mov     edx,cs:mem_temp_x
        mov     ecx,cs:mem_max_x
        mov     dword ptr ss:[ebp-04],ecx
        sub     dword ptr ss:[ebp-04],19*FONT_X
        xor     ebx,ebx
        .WHILE (edx < ecx && edx <= dword ptr ss:[ebp-04] && ebx < 8*90/19)
          ; The above line basically equates to:  while temp_x < max_x and (enough_space) and count < whatever:) )
            push    ecx

            mov     ecx,2
          top_loop:
              ; Get the character to display in QWORD format
                .IF (esi <= cs:mem_limit)
                    .IF (ecx == 2)
                        mov     eax,dword ptr ds:[esi+4]
                    .ELSE
                        mov     eax,dword ptr ds:[esi+0]
                    .ENDIF
                .ELSE
                    xor     eax,eax
                .ENDIF

              @@:
              ; Store upper high byte of high word
                push    eax
                shr     eax,24
                call    invDEBI_store_byte_data_in_al
                pop     eax

              ; Store upper low byte of high word
                push    eax
                shr     eax,16
                call    invDEBI_store_byte_data_in_al

              ; Store period between high word and low word
                mov     al,'.'
                stosb
                pop     eax

              ; Store upper high byte of low word
                push    eax
                shr     eax,8
                call    invDEBI_store_byte_data_in_al
                pop     eax

              ; Store upper low byte of low word
                call    invDEBI_store_byte_data_in_al

              ; Store one space after
                .IF (ecx == 2)
                    mov     al,'.'
                    stosb
                .ELSE
                    add     edx,FONT_X*19
                    .IF (edx <= dword ptr ss:[ebp-04])
                        mov     al,32
                        stosb
                    .ENDIF
                .ENDIF
                loop    top_loop

            pop     ecx
            add     esi,8
          ; Move to next screen location
            add     ebx,8
        .ENDW
        xor     al,al
        stosb

      ; Now, display what we've just copied
        push    ss
        pop     ds
        mov     esi,esp
        push    cs:mem_temp_x
        push    cs:mem_ul_y
        push    esi
        call    fword ptr cs:_VID_g_mono_display_text

      ; We're finished
        leave
        pop     es
        pop     ds
        add     ds:mem_displacement,ebx
        add     ds:mem_limit,8
        popad
        ret
    invDEBI_pop_line_mem_window_qword           ENDP




    invDEBI_pop_line_show_displacement      PROC
    ; This routine is used to show the displacement for the current line
    ;
    ; Upon entry:   ds:show_addresses - set to 'X' if address should be displayed
    ;                     ds:mem_ul_x - X coordinate on-screen to display
    ;                     ds:mem_ul_y - Y coordinate on-screen to display
    ;             ds:mem_displacement - displacement value to display
    ;
    ; Upon exit:    ds:mem_temp_x - set to next available X coordinate (to be compared with ds:mem_max_x)
    ;
        mov     eax,ds:mem_ul_x
        mov     ds:mem_temp_x,eax
        .IF (ds:show_addresses == 'X')
            push    ds
            push    es
            pushad
            enter   8,0
          ; [ebp-16], 16-bytes, string set aside for display

          ; Store the value to ss:[esp] converted to es:[edi]
            mov     edi,esp
            push    ss
            pop     es

          ; Always store 4 characters plus the sign
            mov     eax,ds:mem_displacement
            call    invDEBI_store_eax_sign
            mov     ecx,3
            ror     eax,8
            call    invDEBI_store_ecx_hexadecimal_in_eax_no_sign
            xor     al,al
            stosb

          ; Now, display what we've just created
            push    ss
            pop     ds
            mov     esi,esp
            push    cs:mem_temp_x                                   ; horizontal
            push    cs:mem_ul_y                                     ; vertical
            push    esi                                             ; start of text we've just created to display
            call    fword ptr cs:_VID_g_mono_display_text           ;

            leave
            popad
            pop     es
            pop     ds

          ; Adjust for the data that will display now
            add     ds:mem_temp_x,4*FONT_X                          ; 4 for "+000"
        .ENDIF
        ret
    invDEBI_pop_line_show_displacement      ENDP




    invDEBI_store_eax_sign      PROC
    ; This routine is used to store the sign in EAX
    ;
    ; Upon entry:        eax - value to examine
    ;               es:[edi] - far ptr to where to store the sign
    ;
    ; Upon exit:    The sign is stored
    ;
      ; Store the sign
        .IF (eax > 7fffffffh)
            mov     dl,'-'
        .ELSE
            mov     dl,'+'
        .ENDIF
        mov     byte ptr es:[edi],dl
        inc     edi
        ret
    invDEBI_store_eax_sign      ENDP




    invDEBI_store_ecx_hexadecimal_in_eax_no_sign        PROC
    ; This routine is used to store the data in eax to the output string
    ;
    ; Upon entry:        eax - value to convert to text (without regard to sign, meaning negative values are NEG'd)
    ;                    ecx - # of characters to store
    ;               es:[edi] - far ptr to where to store to
    ;
    ; Upon exit:    The data is stored for each character
    ;
      ; Store the data
        .IF (eax > 7fffffffh)
          ; Convert from - to + for display (the sign has already been displayed)
            neg     eax
        .ENDIF
        ; No return is here because this function will simply flow into the one below to complete the display
        ;ret
    invDEBI_store_ecx_hexadecimal_in_eax_no_sign        ENDP




    invDEBI_store_ecx_hexadecimal_in_eax        PROC
    ; This routine is used to store the data in eax to the output string
    ;
    ; Upon entry:        eax - value to convert to text
    ;                    ecx - # of characters to store
    ;               es:[edi] - far ptr to where to store to
    ;
    ; Upon exit:    The data is stored for each character
    ;
      ; Store the data
        .WHILE (ecx > 0)
            mov     dl,al
            and     dl,0fh
            .IF (dl >= 0 && dl <= 9)
                add     dl,'0'
            .ELSE
                add     dl,'a'-10
            .ENDIF
            mov     byte ptr es:[edi],dl
            inc     edi
            rol     eax,4
            dec     ecx
        .ENDW
        ret
    invDEBI_store_ecx_hexadecimal_in_eax        ENDP




    invDEBI_store_byte_data_in_al       PROC
    ; This routine is used to store the nibbles in al to es:[edi]
    ;
    ; Upon entry:         al - value to store
    ;               es:[edi] - far ptr to where to store
    ;
    ; Upon exit:    data is stored and edi is moved
    ;
      ; Store upper nibble
        push    eax
        shr     al,4
        .IF (al >= 0 && al <= 9)
            add     al,'0'
        .ELSE
            add     al,'a'-10
        .ENDIF
        stosb
        pop     eax

      ; Store lower nibble
        and     al,0fh
        .IF (al >= 0 && al <= 9)
            add     al,'0'
        .ELSE
            add     al,'a'-10
        .ENDIF
        stosb
        ret
    invDEBI_store_byte_data_in_al       ENDP




    invDEBI_get_mem_window_coords       PROC
    ; This routine is used to determine the ul X,Y and lr X,Y coordinates for the current mem window update
    ;
    ; Upon entry:      ah,al - Upper left X,Y
    ;                  bh,bl - Lower right X,Y
    ;               ds:[esi] - far ptr to screen object
    ;
    ; Upon exit:      ds:mem_ul_x - Starting UL X pixel for data
    ;                 ds:mem_ul_y - Starting UL Y pixel for data
    ;                ds:mem_width - How many characters are available horizontally before spilling out of window
    ;               ds:mem_height - How many lines are available vertically before spilling out of window
    ;
        pushad
        enter   4,0
      ; [ebp-04], dword - Ul Y
      ;
      ; Now, calculate the new pixel coordinates
        movzx   ecx,ah
        movzx   edx,al
        mov     dword ptr ss:[ebp-04],edx                           ; Ul y

      ; Determine how wide/high the window is
        sub     bh,ah
        sub     bl,al
      ; Right now, bh - width of usable window
      ;            bl - height of usable window
        movzx   eax,bh                                              ; Width
        movzx   ebx,bl                                              ; Height
        mov     ds:mem_width,eax
        mov     ds:mem_height,ebx

      ; Now, adjust for the current font
        mov     eax,FONT_X
        mul     ecx                                                 ; Ul x
        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        mov     ds:mem_ul_x,eax

        mov     eax,FONT_Y
        mul     dword ptr ss:[ebp-04]                               ; Ul y
        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        mov     ds:mem_ul_y,eax

      ; Determine the maximum X pixel (used in loops)
        mov     eax,ds:mem_width
        inc     eax
        mov     ebx,FONT_X
        mul     ebx
        add     eax,ds:mem_ul_x
        mov     ds:mem_max_x,eax

      ; We're finished
        leave
        popad
        ret
    invDEBI_get_mem_window_coords       ENDP




    invDEBI_logo_window     PROC
    ; This routine is called when updating the screen.  It is called from the @FunctionHandlesObject macro
    ;
    ; Upon entry:   ds:[esi] - far ptr to screen info
    ;               ds:[edi] - far ptr to function handle
    ;
    ; Upon exit:    The logo is redrawn
    ;
;        mov     ebx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
;        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
;
;        push    ebx                                                 ; ul-x
;        push    edx                                                 ; ul-y
;        add     ebx,30*FONT_X
;        push    ebx                                                 ; lr-x
;        add     edx,4*FONT_Y-1
;        push    edx                                                 ; lr-y
;        push    dword ptr 0                                         ; Put this string
;        push    dword ptr offset debi_debugger_logo                 ; Offset to the buffer
;        call    fword ptr cs:_VID_g_mono_window_function
        ret
    invDEBI_logo_window     ENDP




  ; These options all do the same thing, but they're individuall identified in the source code because at some point in
  ; the future it might become advantageous to break them out individually (or to have one menu be different)
    invDEBI_descriptor_right_click:
    invDEBI_fpu_1_right_click:
    invDEBI_fpu_2_right_click:
    invDEBI_fpu_save_state_right_click:
    invDEBI_fpu_summary_right_click:
    invDEBI_locals_right_click:
    invDEBI_mem_1_right_click:
    invDEBI_mem_2_right_click:
    invDEBI_mem_3_right_click:
    invDEBI_mem_4_right_click:
    invDEBI_mmx_right_click:
    invDEBI_query_right_click:
    invDEBI_quick_watch_right_click:
    invDEBI_reg_1_right_click:
    invDEBI_reg_3_right_click:
    invDEBI_reg_right_click:
    invDEBI_stack_right_click:
        jmp     invDEBI_general_menu




    invDEBI_cfsca_1_right_click:
    invDEBI_cfsca_2_right_click:
    invDEBI_cfsca_3_right_click:
        jmp     invDEBI_cfsca_menu




    invDEBI_change_window_cfsca_1   PROC
        push    offset DEBI_t_keyboard_objects
        push    offset DEBI_t_mouse_objects
        push    offset DEBI_t_screen_objects
        jmp     invDEBI_change_window_common_cfsca
    invDEBI_change_window_cfsca_1   ENDP




    invDEBI_change_window_cfsca_2   PROC
        push    offset DEBI_c_keyboard_objects
        push    offset DEBI_c_mouse_objects
        push    offset DEBI_c_screen_objects
        jmp     invDEBI_change_window_common_cfsca
    invDEBI_change_window_cfsca_2   ENDP




    invDEBI_change_window_cfsca_3   PROC
        push    offset DEBI_d_keyboard_objects
        push    offset DEBI_d_mouse_objects
        push    offset DEBI_d_screen_objects
        jmp     invDEBI_change_window_common_cfsca
    invDEBI_change_window_cfsca_3   ENDP




    invDEBI_change_window_common_cfsca      PROC
    ; There can only be one active CFSCA window at a time.  This algorithm will try to replace the existing one
    ;
    ; Upon entry:   The stack is arranged as below
    ;
    ; Upon exit:    The window is either replaced with the new one, or control goes to invDEBI_new_window_common
    ;
      ; [esp+12] - Calling function offset
      ; [esp+08] - Keyboard objects
      ; [esp+04] - Mouse objects
      ; [esp+00] - Screen objects
        mov     esi,offset DEBI_screen_table
        xor     ecx,ecx
        .WHILE (ecx < 15)
            .IF (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _YES)
                mov     eax,dword ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]
                .IF (eax == DEBI_d_screen_objects || eax == DEBI_c_screen_objects || eax == DEBI_t_screen_objects)
                    mov     ds:menu_restore_screen_after,_NO        ; Force the menu cancelation algorithm to not restore screen
                    mov     ds:single_step_top,0                    ; Force the CFSCA window to reposition the current disassembly
                    mov     ds:single_step_end,0                    ;  line to the top line of the CFSCA window

                  ; Let's update the existing CFSCA item
                    mov     edx,dword ptr ss:[esp+08]
                    mov     dword ptr ds:[esi+_ST_OBJECT_KBD_OFFSET],edx
                    mov     edx,dword ptr ss:[esp+04]
                    mov     dword ptr ds:[esi+_ST_OBJECT_MOUSE_OFFSET],edx
                    mov     edx,dword ptr ss:[esp+00]
                    mov     dword ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET],edx

                  ; Redraw the new window
                    pushfd
                    cli
                    call    invDEBI_clear_screen_and_redraw_windows
                    popfd
                    jmp     quit
                .ENDIF
            .ENDIF

          next_one:
            add     esi,_ST_LENGTH
            inc     ecx
        .ENDW
      ; We didn't find one, so we do nothing

      quit:
        add     esp,12
        ret
    invDEBI_change_window_common_cfsca      ENDP




    ; The following invDEBI_new_window_*() functions all receive the same information
    ;
    ; Upon entry:   ds:general_menu_esi - Offset to screen object which created this menu
    ;
    ; Upon exit:    If there is room, a new object is created
    ;
    invDEBI_new_window_descriptor       PROC
        push    offset DEBI_keyboard_objects
        push    offset DEBI_a_mouse_objects
        push    offset DEBI_a_screen_objects
        jmp     invDEBI_new_window_common
    invDEBI_new_window_descriptor       ENDP




    invDEBI_new_window_regs_1       PROC
        push    offset DEBI_keyboard_objects
        push    offset DEBI_p_mouse_objects
        push    offset DEBI_p_screen_objects
        jmp     invDEBI_new_window_common
    invDEBI_new_window_regs_1       ENDP




    invDEBI_new_window_regs_3       PROC
        push    offset DEBI_keyboard_objects
        push    offset DEBI_b_mouse_objects
        push    offset DEBI_b_screen_objects
        jmp     invDEBI_new_window_common
    invDEBI_new_window_regs_3       ENDP




    invDEBI_new_window_mmx      PROC
        push    offset DEBI_keyboard_objects
        push    offset DEBI_s_mouse_objects
        push    offset DEBI_s_screen_objects
        jmp     invDEBI_new_window_common
    invDEBI_new_window_mmx      ENDP




    invDEBI_new_window_fpu_1        PROC
        push    offset DEBI_keyboard_objects
        push    offset DEBI_q_mouse_objects
        push    offset DEBI_q_screen_objects
        jmp     invDEBI_new_window_common
    invDEBI_new_window_fpu_1        ENDP




    invDEBI_new_window_fpu_2        PROC
        push    offset DEBI_keyboard_objects
        push    offset DEBI_r_mouse_objects
        push    offset DEBI_r_screen_objects
        jmp     invDEBI_new_window_common
    invDEBI_new_window_fpu_2        ENDP




    invDEBI_new_window_fpu_summary      PROC
        push    offset DEBI_keyboard_objects
        push    offset DEBI_e_mouse_objects
        push    offset DEBI_e_screen_objects
        jmp     invDEBI_new_window_common
    invDEBI_new_window_fpu_summary      ENDP




    invDEBI_new_window_fpu_savestate        PROC
        push    offset DEBI_keyboard_objects
        push    offset DEBI_f_mouse_objects
        push    offset DEBI_f_screen_objects
        jmp     invDEBI_new_window_common
    invDEBI_new_window_fpu_savestate        ENDP




    invDEBI_new_window_mem_1        PROC
        push    offset DEBI_keyboard_objects
        push    offset DEBI_m_mouse_objects
        push    offset DEBI_m_screen_objects
        jmp     invDEBI_new_window_common
    invDEBI_new_window_mem_1        ENDP




    invDEBI_new_window_mem_2        PROC
        push    offset DEBI_keyboard_objects
        push    offset DEBI_g_mouse_objects
        push    offset DEBI_g_screen_objects
        jmp     invDEBI_new_window_common
    invDEBI_new_window_mem_2        ENDP




    invDEBI_new_window_mem_3        PROC
        push    offset DEBI_keyboard_objects
        push    offset DEBI_n_mouse_objects
        push    offset DEBI_n_screen_objects
        jmp     invDEBI_new_window_common
    invDEBI_new_window_mem_3        ENDP




    invDEBI_new_window_mem_4        PROC
        push    offset DEBI_keyboard_objects
        push    offset DEBI_h_mouse_objects
        push    offset DEBI_h_screen_objects
        jmp     invDEBI_new_window_common
    invDEBI_new_window_mem_4        ENDP




    invDEBI_new_window_locals       PROC
        push    offset DEBI_keyboard_objects
        push    offset DEBI_l_mouse_objects
        push    offset DEBI_l_screen_objects
        jmp     invDEBI_new_window_common
    invDEBI_new_window_locals       ENDP




    invDEBI_new_window_stack        PROC
        push    offset DEBI_keyboard_objects
        push    offset DEBI_i_mouse_objects
        push    offset DEBI_i_screen_objects
        jmp     invDEBI_new_window_common
    invDEBI_new_window_stack        ENDP




    invDEBI_new_window_common       PROC
    ; This routine is used to create a new common window (if there's room for one)
    ;
    ; Upon entry:   The stack is arranged as below
    ;
    ; Upon exit:    The window is either created or not
    ;
      ; [esp+48] - Calling function offset
      ; [esp+44] - Keyboard objects
      ; [esp+40] - Mouse objects
      ; [esp+36] - Screen objects
      ; [esp+32] - eax
      ; [esp+28] - ecx
      ; [esp+24] - edx
      ; [esp+20] - ebx
      ; [esp+16] - esp
      ; [esp+12] - ebp
      ; [esp+08] - esi
      ; [esp+04] - edi
      ; [esp+00] - eflags
        pushad
        pushfd

      ; Determine if there's room
        mov     esi,offset DEBI_screen_table
        xor     ecx,ecx
        .WHILE (ecx < 15)
            .IF (byte ptr ds:[esi+_ST_OBJECT_ACTIVE] == _NO)
              ; We found where we can add it
                cli
                mov     byte ptr ds:[esi+_ST_OBJECT_ALTERABLE],_YES
                mov     byte ptr ds:[esi+_ST_OBJECT_ACTIVE],_YES
                mov     dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL],0       ; Force it in the upper-left corner (they'll move it)
                mov     dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL],0
                mov     dword ptr ds:[esi+_ST_MEMVAR_OFFSET],-1
                mov     edx,dword ptr ss:[esp+44]
                mov     dword ptr ds:[esi+_ST_OBJECT_KBD_OFFSET],edx
                mov     dword ptr ds:[esi+_ST_OBJECT_MEMORY_OFFSET],-1
                mov     edx,dword ptr ss:[esp+40]
                mov     dword ptr ds:[esi+_ST_OBJECT_MOUSE_OFFSET],edx
                mov     edx,dword ptr ss:[esp+36]
                mov     dword ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET],edx

              ; Right now, ds:[esi] - far ptr to this object
                call    invDEBI_clear_screen_and_redraw_windows

                mov     ds:menu_restore_screen_after,_NO
                jmp     quit
            .ENDIF
            add     esi,_ST_LENGTH
            inc     ecx
        .ENDW

      quit:
        popfd
        popad
        add     esp,12
        ret
    invDEBI_new_window_common       ENDP
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; END - 66666 - Actions taken when various menu items are selected
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; 77777 - Menu bar events
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    invDEBI_menu_continue_click     PROC
    ; This routine is called when they click on the continue cask
        mov     ds:debi_ok_to_quit,2
        stc
        ret
    invDEBI_menu_continue_click     ENDP




    invDEBI_menu_break_click        PROC
    ; This routine is called when they click on the break cask
        ret
    invDEBI_menu_break_click        ENDP




    invDEBI_menu_over_click         PROC
    ; This routine is called when they click on the over cask
        ret
    invDEBI_menu_over_click         ENDP




    invDEBI_menu_step_click         PROC
    ; This routine is called when they click on the step cask
        mov     ds:debi_ok_to_quit,1
        stc
        ret
    invDEBI_menu_step_click         ENDP
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; END - 77777 - Menu bar events
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=










;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; 88888 - DRAG and DRAG RELEASE handlers
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    invDEBI_object_drag_start       PROC
    ; This routine is called when an object needs to be dragged
    ;
    ; Upon entry:   ds:[esi] - far ptr to screen object
    ;               ds:[edi] - far ptr to mouse object
    ;
    ; Upon exit:    The object is picked up and dragging begins
    ;
        pushad
        mov     ds:dragging_esi,esi
        mov     ds:dragging_edi,edi
        mov     ds:dragging_object,_YES

      ; Calculate starting coordinates
        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        mov     ds:dragging_x,edx
        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        mov     ds:dragging_y,edx

      ; Grab the height and width
        mov     edx,dword ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]
        movzx   eax,word ptr ds:[edx+_ST_OBJECT_SCREEN_WIDTH]
        mov     ds:dragging_width,eax
        movzx   eax,word ptr ds:[edx+_ST_OBJECT_SCREEN_HEIGHT]
        mov     ds:dragging_height,eax

      ; Calculate the offset (the mouse wasn't at the upper-left corner when it was clicked, this tells how far away we were
        mov     edx,ds:mouse_left_click_x_start
        sub     edx,ds:dragging_x
        mov     ds:dragging_offset_x,edx

        mov     edx,ds:mouse_left_click_y_start
        sub     edx,ds:dragging_y
        mov     ds:dragging_offset_y,edx

      ; Begin the dragging
        mov     ds:dragging_snap_x,8
        mov     ds:dragging_snap_y,6
        mov     dl,1
        call    invDEBI_drag_start
        popad
        ret
    invDEBI_object_drag_start       ENDP




    invDEBI_object_drag_stop        PROC
    ; This routine is called when an object needs to be dragged
    ;
    ; Upon entry:   ds:[esi] - far ptr to screen object
    ;               ds:[edi] - far ptr to mouse object
    ;
    ; Upon exit:    The object is picked up and dragging begins
    ;
      ; Restore the original screen
        mov     ds:dragging_object,_NO
        call    invDEBI_drag_stop
        call    invDEBI_restore_screen2

        pushfd
        cli
        mov     esi,ds:dragging_esi
      ; Drop the window at its new location
        mov     edx,ds:dragging_x
        sub     edx,ds:dragging_offset_x
        push    edx
        call    invDEBI_dragging_snap_x
        pop     edx
        mov     dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL],edx
      ; Now, update the mouse position (we were snapping the values, and may not be exactly where we ended up)
        add     edx,ds:dragging_offset_x
        mov     ds:mouse_current_x,edx

        mov     eax,ds:dragging_y
        sub     eax,ds:dragging_offset_y
        push    eax
        call    invDEBI_dragging_snap_y
        pop     eax
        mov     dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL],eax
      ; Now, update the mouse position
        add     eax,ds:dragging_offset_y
        mov     ds:mouse_current_y,eax

      ; Now, force a redraw
        movzx   eax,ds:force_screen_redraw
        push    eax
        mov     ds:force_screen_redraw,_YES
        call    invDEBI_populate_debug_screen
        pop     eax
        mov     ds:force_screen_redraw,al


        popfd

        ret
    invDEBI_object_drag_stop        ENDP




    invDEBI_stx_drag_start  PROC
    ; This routine is called when a left-drag event is recognized from the various stx regions
      ; Save original information
        pushad
        mov     ds:fpu_esi,esi
        mov     ds:fpu_edi,edi

        mov     eax,ds:mouse_left_click_x_start
        mov     ds:fpu_x,eax
        mov     edx,ds:mouse_left_click_y_start
        mov     ds:fpu_y,edx
        call    invDEBI_determine_stx_variable
        mov     ds:fpu_source,edx
      ; Right now, edx - offset to reach the stx value on the stack
      ;            ecx - x value of st(x)
      ;            eax - position down the screen (0-st7, 1-st6, 7-st0)
        .IF (edx == -1)
            jmp     quit
        .ENDIF

      ; Move down the specified number of stx's
        mov     ebx,FONT_Y
        mul     ebx
        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        add     edx,dword ptr ds:[edi+_MO_X1]
        mov     ds:dragging_x,edx

        mov     ds:fpu_data,eax
        sub     ds:fpu_y,eax
        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        add     eax,dword ptr ds:[edi+_MO_Y1]
        mov     ds:dragging_y,eax

      ; Setup the variables for dragging
        mov     edx,dword ptr ds:[edi+_MO_X2]
        sub     edx,dword ptr ds:[edi+_MO_X1]
        add     edx,8
        and     edx,not 111b                                        ; Round to nearest 8th pixel (so we only load multiples of 8)
        mov     ds:dragging_width,edx
        mov     ds:dragging_height,FONT_Y-1                         ; change base-1 to base-0

      ; Determine the offset
        mov     edx,ds:fpu_x
        sub     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        sub     edx,dword ptr ds:[edi+_MO_X1]
        mov     ds:dragging_offset_x,edx

        mov     edx,ds:fpu_y
        sub     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        sub     edx,dword ptr ds:[edi+_MO_Y1]
        mov     ds:dragging_offset_y,edx

        mov     dl,1
        call    invDEBI_drag_start
      quit:
        popad
        ret
    invDEBI_stx_drag_start  ENDP




    invDEBI_stx_drag_stop   PROC
    ; This routine is called when something is dropped over an stx region
      ; Cancel the dragging
        .IF (ds:dragging_object == _YES)
            jmp     invDEBI_object_drag_stop
        .ENDIF
        call    invDEBI_drag_stop
        call    invDEBI_restore_screen2

      ; Determine where they landed
        mov     edi,ds:fpu_edi
        mov     eax,ds:mouse_left_click_x_stop
        sub     eax,ds:dragging_offset_x
      ; Right now, eax is the upper left corner
      ; But, the way things are dragged in this system we have to average out the location
        mov     ebx,dword ptr ds:[edi+_MO_X2]
        sub     ebx,dword ptr ds:[edi+_MO_X1]
        shr     ebx,1
        add     eax,ebx
      ; Right now, eax is the average (to the nearest pixel) of the left side and right side
        mov     ds:fpu_x,eax

        mov     edx,ds:mouse_left_click_y_stop
        sub     edx,ds:dragging_offset_y
        add     edx,FONT_Y / 2
      ; Right now, edx is the average (to the nearest pixel) of the top and bottom
        mov     ds:fpu_y,edx

        call    invDEBI_determine_stx_variable
        .IF (edx != -1)
            finit
            mov     ebx,ds:fpu_source
            fld     tbyte ptr ss:[ebp+ebx]
            fstp    tbyte ptr ss:[ebp+edx]
            call    invDEBI_FPU_update_display
        .ENDIF
        ret
    invDEBI_stx_drag_stop   ENDP




    invDEBI_determine_stx_variable      PROC
    ; This routine is used to determine which stx variable was clicked on (assuming st7 is at the top, st0 at the bottom)
    ;
    ; Upon entry:   ds:fpu_x - X coord where click was made
    ;               ds:fpu_y - Y coord
    ;               ds:[esi] - far ptr to screen object
    ;               ds:[edi] - far ptr to mouse object
    ;
    ; Upon exit:    edx - offset to get to stx variable on stack
    ;               ecx - x value in stx, -1 if invalid range specified
    ;
        push    ebx

        mov     edx,ds:fpu_y
        sub     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        sub     edx,dword ptr ds:[edi+_MO_Y1]
      ; Right now, edx - pixels down from upper-left coordinate of stx block
        mov     eax,edx
        xor     edx,edx
        mov     ebx,FONT_Y
        div     ebx
      ; Right now, eax - the # of items down
        .IF (al == 0)
          ; st7
            mov     edx,-200+98
            mov     ecx,7
        .ELSEIF (al == 1)
          ; st6
            mov     edx,-200+88
            mov     ecx,6
        .ELSEIF (al == 2)
          ; st5
            mov     edx,-200+78
            mov     ecx,5
        .ELSEIF (al == 3)
          ; st4
            mov     edx,-200+68
            mov     ecx,4
        .ELSEIF (al == 4)
          ; st3
            mov     edx,-200+58
            mov     ecx,3
        .ELSEIF (al == 5)
          ; st2
            mov     edx,-200+48
            mov     ecx,2
        .ELSEIF (al == 6)
          ; st1
            mov     edx,-200+38
            mov     ecx,1
        .ELSEIF (al == 7)
          ; st0
            mov     edx,-200+28
            mov     ecx,0
        .ELSE
            mov     edx,-1
            mov     ecx,-1
        .ENDIF

        pop     ebx
        ret
    invDEBI_determine_stx_variable      ENDP




    invDEBI_mmx_drag_start  PROC
    ; This routine is called when a left-drag event is recognized from the various mmx regions
      ; Save original information
        pushad
        mov     ds:fpu_esi,esi
        mov     ds:fpu_edi,edi

        mov     eax,ds:mouse_left_click_x_start
        mov     ds:fpu_x,eax
        mov     edx,ds:mouse_left_click_y_start
        mov     ds:fpu_y,edx
        call    invDEBI_determine_mmx_variable
        mov     ds:fpu_source,edx
      ; Right now, edx - offset to reach the mmx value on the stack
      ;            eax - position down the screen (0-mm0, 1-mm1, 7-mm7)
        .IF (edx == -1)
            jmp     quit
        .ENDIF

      ; Move down the specified number of mmx's
        mov     ebx,FONT_Y
        mul     ebx
        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        add     edx,dword ptr ds:[edi+_MO_X1]
        mov     ds:dragging_x,edx

        mov     ds:fpu_data,eax
        sub     ds:fpu_y,eax
        add     eax,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        add     eax,dword ptr ds:[edi+_MO_Y1]
        mov     ds:dragging_y,eax

      ; Setup the variables for dragging
        mov     edx,dword ptr ds:[edi+_MO_X2]
        sub     edx,dword ptr ds:[edi+_MO_X1]
        add     edx,8
        and     edx,not 111b                                        ; Round to nearest 8th pixel (so we only load multiples of 8)
        mov     ds:dragging_width,edx
        mov     ds:dragging_height,FONT_Y-1                         ; change base-1 to base-0

      ; Determine the offset
        mov     edx,ds:fpu_x
        sub     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        sub     edx,dword ptr ds:[edi+_MO_X1]
        mov     ds:dragging_offset_x,edx

        mov     edx,ds:fpu_y
        sub     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        sub     edx,dword ptr ds:[edi+_MO_Y1]
        mov     ds:dragging_offset_y,edx

        mov     dl,1
        call    invDEBI_drag_start
      quit:
        popad
        ret
    invDEBI_mmx_drag_start  ENDP




    invDEBI_mmx_drag_stop   PROC
    ; This routine is called when something is dropped over an mmx region
      ; Cancel the dragging
        .IF (ds:dragging_object == _YES)
            jmp     invDEBI_object_drag_stop
        .ENDIF
        call    invDEBI_drag_stop
        call    invDEBI_restore_screen2

      ; Determine where they landed
        mov     edi,ds:fpu_edi
        mov     eax,ds:mouse_left_click_x_stop
        sub     eax,ds:dragging_offset_x
      ; Right now, eax is the upper left corner
      ; But, the way things are dragged in this system we have to average out the location
        mov     ebx,dword ptr ds:[edi+_MO_X2]
        sub     ebx,dword ptr ds:[edi+_MO_X1]
        shr     ebx,1
        add     eax,ebx
      ; Right now, eax is the average (to the nearest pixel) of the left side and right side
        mov     ds:fpu_x,eax

        mov     edx,ds:mouse_left_click_y_stop
        sub     edx,ds:dragging_offset_y
        add     edx,FONT_Y / 2
      ; Right now, edx is the average (to the nearest pixel) of the top and bottom
        mov     ds:fpu_y,edx

        call    invDEBI_determine_mmx_variable
        .IF (edx != -1)
            finit
            mov     ebx,ds:fpu_source
            fild    qword ptr ss:[ebp+ebx]
            fistp   qword ptr ss:[ebp+edx]
            call    invDEBI_FPU_update_display
        .ENDIF
        ret
    invDEBI_mmx_drag_stop   ENDP




    invDEBI_determine_mmx_variable      PROC
    ; This routine is used to determine which mmx variable was clicked on (assuming st7 is at the top, st0 at the bottom)
    ;
    ; Upon entry:   ds:fpu_x - X coord where click was made
    ;               ds:fpu_y - Y coord
    ;               ds:[esi] - far ptr to screen object
    ;               ds:[edi] - far ptr to mouse object
    ;
    ; Upon exit:    edx - offset to get to mmx variable on stack
    ;               ecx - x value in mmx, -1 if invalid range specified
    ;
        push    ebx

        mov     edx,ds:fpu_y
        sub     edx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        sub     edx,dword ptr ds:[edi+_MO_Y1]
      ; Right now, edx - pixels down from upper-left coordinate of mmx block
        mov     eax,edx
        xor     edx,edx
        mov     ebx,FONT_Y
        div     ebx
      ; Right now, eax - the # of items down
        .IF (al == 0)
          ; mm0
            mov     edx,-200+28
        .ELSEIF (al == 1)
          ; mm1
            mov     edx,-200+38
        .ELSEIF (al == 2)
          ; mm2
            mov     edx,-200+48
        .ELSEIF (al == 3)
          ; mm3
            mov     edx,-200+58
        .ELSEIF (al == 4)
          ; mm4
            mov     edx,-200+68
        .ELSEIF (al == 5)
          ; mm5
            mov     edx,-200+78
        .ELSEIF (al == 6)
          ; mm6
            mov     edx,-200+88
        .ELSEIF (al == 7)
          ; mm7
            mov     edx,-200+98
        .ELSE
            mov     edx,-1
            mov     ecx,-1
        .ENDIF

        pop     ebx
        ret
    invDEBI_determine_mmx_variable      ENDP




    invDEBI_drag_start      PROC
    ; This routine is used to begin the process of grabbing something on the screen in preparation for dragging it
    ;
    ; Upon entry:   ds:dragging_* - setup
    ;                          dl - How to grab?  0-grab object as is, 1-grab as NOT image of itself
        push    ds
        pushad
        pushfd

      ; Save this object to the screen buffer (for dragging)
        .IF (dl == 0)
          ; Grab the image as is
            mov     eax,1
        .ELSE
          ; Grab the NOT image of itself
            mov     eax,11
        .ENDIF

        cli
      ; Grab the image to be dragged
        push    dword ptr ds:dragging_x
        push    dword ptr ds:dragging_y
        mov     edx,ds:dragging_x
        add     edx,ds:dragging_width
        push    edx
        mov     edx,ds:dragging_y
        add     edx,ds:dragging_height
        push    edx
        push    eax                                                 ; Get or Get_NOT
        push    dword ptr 4000h
        mov     eax,_sDEBI_screen
        mov     ds,eax
        call    fword ptr cs:_VID_g_mono_window_function

      ; Clear the image of where it was dragged
        push    dword ptr cs:dragging_x
        push    dword ptr cs:dragging_y
        mov     eax,cs:dragging_x
        add     eax,cs:dragging_width
        push    eax
        mov     edx,cs:dragging_y
        add     edx,cs:dragging_height
        push    edx
        push    dword ptr 2                                         ; Clear
        push    dword ptr 0                                         ; Not used here, but required for spacer
        call    fword ptr cs:_VID_g_mono_window_function

      ; Save the screen after the area has been cleared
        call    invDEBI_save_screen2

        popfd
        popad
        pop     ds
        mov     ds:dragging_something,1
        ret
    invDEBI_drag_start      ENDP




    invDEBI_drag_stop       PROC
        .IF (ds:dragging_object == _YES)
          ; We're dragging a window (no release point was specified because it could be released anywhere)
            call    invDEBI_object_drag_stop
        .ELSE
          ; We're just canceling the drag
            mov     ds:dragging_something,0
            mov     ds:dragging_skipped,0
        .ENDIF
        ret
    invDEBI_drag_stop       ENDP
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; END - 88888 - DRAG and DRAG RELEASE handlers
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=










;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; 99999 - Keyboard events
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    invDEBI_clear_text_22        PROC
    ; This routine is called when there is input to process from the keyboard
    ;
    ; Upon entry:   eax - key
    ;               ebx - flags
    ;                ds - Debi's data segment
    ;
    ; Upon exit:    The key is either accepted and processed or ignored
    ;               Note that processing might include moving to another field
    ;
        .IF (ax == tab)
          ; Move to next item (or first one if we're on the last)
            mov     edx,1
            call    invDEBI_next_keyboard_item
        .ELSEIF (ax == shift_tab)
          ; Move to previous item (or last one if we're on the first)
            mov     edx,-1
            call    invDEBI_next_keyboard_item
        .ELSEIF (ax == enter_key || ax == grey_enter)
          ; They've selected this option
            call    invDEBI_lostFocus
            mov     esi,offset text_22
            mov     ecx,22
            call    invDEBI_input_clear_field
            mov     esi,ds:screen_object
            call    invDEBI_screen_refresh
            mov     edi,offset text_22_object
            mov     ds:kbd_object,edi
            call    invDEBI_setFocus
        .ENDIF
        ret
    invDEBI_clear_text_22        ENDP




    invDEBI_input_clear_var_click       PROC
    ; This routine is called when a mouse button is clicked on the "text_22" clear-item option
    ;
    ; Upon entry:   ds:[esi] - far ptr to screen object
    ;               ds:[edi] - far ptr to mouse object
    ;
    ; Upon exit:    The input field is cleared, and the focus is set
    ;
        mov     esi,dword ptr ds:[edi+_MO_DATA1]
        movzx   ecx,word ptr ds:[edi+_MO_DATA2]
        call    invDEBI_input_clear_field
        mov     esi,ds:screen_object
        call    invDEBI_screen_refresh
        ret
    invDEBI_input_clear_var_click       ENDP




    invDEBI_clear_disp_22       PROC
    ; This routine is called when there is input to process from the keyboard
    ;
    ; Upon entry:   eax - key
    ;               ebx - flags
    ;                ds - Debi's data segment
    ;
    ; Upon exit:    The key is either accepted and processed or ignored
    ;               Note that processing might include moving to another field
    ;
        .IF (ax == tab)
          ; Move to next item (or first one if we're on the last)
            mov     edx,1
            call    invDEBI_next_keyboard_item
        .ELSEIF (ax == shift_tab)
          ; Move to previous item (or last one if we're on the first)
            mov     edx,-1
            call    invDEBI_next_keyboard_item
        .ELSEIF (ax == enter_key || ax == grey_enter)
          ; They've selected this option
            call    invDEBI_lostFocus
            mov     esi,offset disp_22
            mov     ecx,22
            call    invDEBI_input_clear_field
            mov     esi,ds:screen_object
            call    invDEBI_screen_refresh
            mov     edi,offset disp_22_object
            mov     ds:kbd_object,edi
            call    invDEBI_setFocus
        .ENDIF
        ret
    invDEBI_clear_disp_22       ENDP




    invDEBI_input_clear_field       PROC
    ; This routine is called to clear the contents of a field
    ;
    ; Upon entry:   ds:[esi] - far ptr to string
    ;                    ecx - length of string
    ;
    ; Upon exit:    String is reset to spaces
        push    ecx
        push    esi
        .WHILE (ecx > 0)
            mov     byte ptr ds:[esi],32
            inc     esi
            dec     ecx
        .ENDW
        pop     esi
        pop     ecx
        ret
    invDEBI_input_clear_field       ENDP




    invDEBI_checkbox_mouse_handler      PROC
    ; This routine is called to toggle a character from "X" to space, and back again
    ;
    ; Upon entry:   ds:[esi] - far ptr to screen objects
    ;               ds:[edi] - far ptr to mouse objects
    ;
    ; Upon exit:    The data item pointed to by the mouse object is toggled
    ;
        mov     ebx,dword ptr ds:[edi+_MO_DATA]
        call    invDEBI_checkbox_toggle
        ret
    invDEBI_checkbox_mouse_handler      ENDP




    invDEBI_checkbox_toggle     PROC
    ; This routine executes a toggle on the data item at ds:[ebx]
    ;
    ; Upon entry:   ds:[ebx] - The byte there is either a space or something else
    ;
    ; Upon exit:    If it's a space, it's changed to an 'X'
    ;               If it's something else, it's changed to a space
    ;               The screen is refreshed
    ;
        mov     al,32
        .IF (byte ptr ds:[ebx] == al)
          ; It's a space
            mov     al,'X'
        .ENDIF
        mov     byte ptr ds:[ebx],al

      ; Refresh the screen with the new data
        mov     esi,ds:screen_object
        call    invDEBI_screen_refresh
        ret
    invDEBI_checkbox_toggle     ENDP




    invDEBI_screen_refresh      PROC
    ; This routine is called when the current screen needs to be redrawn, then all keyboard objects contained within redrawn also
    ;
    ; Upon entry:   ds:[esi] - far ptr to screen objects to refresh
    ;
    ; Upon exit:    The screen is redrawn first, then any and all keyboard objects are redrawn afterwards
    ;               This has the effect of rendering the victim extremely succeptable to ... er, suggestion.
    ;               Oh, sorry.  Uhm, this has the effect of refreshing the current screen
    ;
        pushad
        pushfd
      ; Save current object
        push    ds:kbd_object

      ; Save textbox items
        push    ds:textbox_x
        push    ds:textbox_y
        push    ds:textbox_offset
        push    ds:textbox_sel_end                                  ; Note, only sel_end is used to determine if text is selected

      ; Save checkbox items
        push    ds:checkbox_x
        push    ds:checkbox_y
        push    ds:checkbox_offset

      ; Save button items
        push    ds:button_x
        push    ds:button_y
        push    ds:button_offset

      ; Save function items
        push    ds:function_x
        push    ds:function_y

      ; Turn off the mouse and cursor for this redisplay
        cli
        call    invDEBI_hide_mouse_pointer
        call    invDEBI_turn_cursor_off

      ; Redraw the entire window
        mov     edi,dword ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]
        call    invDEBI_draw_objects

      ; Initialize variables that might alter the appearance of the refresh
        mov     ds:textbox_offset,0
        mov     ds:textbox_sel_end,0

      ; Now, redraw the displayable keyboard objects
        mov     edi,dword ptr ds:[esi+_ST_OBJECT_KBD_OFFSET]
        .WHILE (byte ptr ds:[edi] != _END)
            mov     ds:kbd_object,edi
            mov     edx,ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            add     edx,ds:[edi+_KO_X]
            mov     ebx,ds:[esi+_ST_OBJECT_UL_VERTICAL]
            add     ebx,ds:[edi+_KO_Y]
            mov     al,byte ptr ds:[edi]
            .IF (al == _START)
                inc     edi
                jmp     @F
            .ELSEIF (al == _KO_TEXTBOX)
              ; This needs redrawn
                mov     ds:textbox_x,edx
                mov     ds:textbox_y,ebx
                call    invDEBI_textbox_refresh
            .ELSEIF (al == _KO_CHECKBOX)
              ; This needs redrawn
                movzx   eax,byte ptr ds:[edi+_KO_X_OFFSET]
                mov     ds:checkbox_x,edx
                mov     ds:checkbox_y,ebx
                mov     ds:checkbox_offset,eax
                call    invDEBI_checkbox_refresh
            .ELSEIF (al == _KO_BUTTON)
              ; This does not need to be redrawn
                movzx   eax,byte ptr ds:[edi+_KO_X_OFFSET]
                mov     ds:button_x,edx
                mov     ds:button_y,ebx
                mov     ds:button_offset,eax
                call    invDEBI_button_refresh
            .ELSEIF (al == _KO_FUNCTION)
              ; This might need to be redrawn.
              ; We let the function decide that one. :)
                movzx   edx,word ptr ds:[edi+_KO_X_FUNCTION]
                add     edx,ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                movzx   ebx,word ptr ds:[edi+_KO_Y_FUNCTION]
                add     ebx,ds:[esi+_ST_OBJECT_UL_VERTICAL]
                mov     ds:function_x,edx
                mov     ds:function_y,ebx
                call    dword ptr ds:[edi+_KO_REFRESH_FUNCTION]
            .ENDIF
            add     edi,_KO_LENGTH
          @@:
        .ENDW

      ; Restore function items
        pop     ds:function_y
        pop     ds:function_x

      ; Restore button items
        pop     ds:button_offset
        pop     ds:button_y
        pop     ds:button_x

      ; Restore checkbox items
        pop     ds:checkbox_offset
        pop     ds:button_y
        pop     ds:button_x

      ; Restore textbox items
        pop     ds:textbox_sel_end
        pop     ds:textbox_offset
        pop     ds:textbox_y
        pop     ds:textbox_x

      ; Restore current object
        pop     ds:kbd_object
        popfd
        popad
        ret
    invDEBI_screen_refresh      ENDP




    invDEBI_textbox_kbd_handler     PROC
    ; This routine is called when there is input to process from the keyboard
    ;
    ; Upon entry:   eax - key
    ;               ebx - flags
    ;                ds - Debi's data segment
    ;
    ; Upon exit:    The key is either accepted and processed or ignored
    ;               Note that processing might include moving to another field
    ;
        .IF (ax == 0)
            ret
        .ELSEIF (ax == home || ax == grey_home)
          ; They want to move to the beginning
            mov     ds:textbox_sel_end,0
            mov     ds:textbox_offset,0
        .ELSEIF (ax == end_key || ax == grey_end)
            mov     ds:textbox_sel_end,0
            call    invDEBI_textbox_end
        .ELSEIF (ax == left || ax == grey_left)
            mov     ds:textbox_sel_end,0
            .IF (ds:textbox_offset > 0)
                dec     ds:textbox_offset
            .ENDIF
        .ELSEIF (ax == right || ax == grey_right)
            mov     ds:textbox_sel_end,0
          right_key:
            mov     ecx,ds:textbox_offset
            call    invDEBI_textbox_get_length
            .IF (ds:textbox_offset < ecx)
                inc     ds:textbox_offset
            .ENDIF
        .ELSEIF (ax == escape)
            jmp     invDEBI_kbd_input_cancel
        .ELSEIF (ax == F8)
            not     ds:insert_mode
        .ELSEIF (ax == backspace || ax == f5)
            .IF (ds:textbox_sel_end != 0)
                call    invDEBI_textbox_delete_selected
                mov     ecx,ds:textbox_sel_start
                .IF (ecx > 0)
                    dec     ecx
                .ENDIF
                mov     ds:textbox_offset,ecx
            .ELSE
                .IF (ds:textbox_offset > 0)
                    mov     ecx,ds:textbox_offset
                    mov     ds:textbox_sel_end,ecx
                    dec     ecx
                    mov     ds:textbox_sel_start,ecx
                    call    invDEBI_textbox_delete_selected
                    dec     ds:textbox_offset
                .ENDIF
            .ENDIF
        .ELSEIF (ax == delete || ax == grey_delete)
            .IF (ds:textbox_sel_end != 0)
                call    invDEBI_textbox_delete_selected
                mov     ecx,ds:textbox_sel_start
                mov     ds:textbox_offset,ecx
            .ELSE
                call    invDEBI_textbox_get_length
                .IF (ds:textbox_offset < ecx)
                    mov     ecx,ds:textbox_offset
                    mov     ds:textbox_sel_start,ecx
                    inc     ecx
                    mov     ds:textbox_sel_end,ecx
                    call    invDEBI_textbox_delete_selected
                .ENDIF
            .ENDIF
        .ELSEIF (ax == tab || ax == enter_key || ax == grey_enter)
          ; Move to next item (or first one if we're on the last)
            mov     edx,1
            call    invDEBI_next_keyboard_item
            jmp     do_not_refresh
        .ELSEIF (ax == shift_tab)
          ; Move to previous item (or last one if we're on the first)
            mov     edx,-1
            call    invDEBI_next_keyboard_item
            jmp     do_not_refresh
        .ELSEIF (al >= 32)
            .IF (ds:textbox_sel_end != 0)
                call    invDEBI_textbox_delete_selected
                mov     ecx,ds:textbox_sel_start
                mov     ds:textbox_offset,ecx
            .ENDIF
            call    invDEBI_textbox_get_length
            .IF (ds:textbox_offset < ecx)
                call    invDEBI_textbox_insert
                mov     edi,ds:kbd_object
                mov     edi,dword ptr ds:[edi+_KO_VAR]
                mov     ecx,ds:textbox_offset
                mov     byte ptr ds:[edi+ecx],al
                inc     ds:textbox_offset
            .ENDIF
        .ENDIF
        call    invDEBI_textbox_set_cursor
        call    invDEBI_textbox_refresh
      do_not_refresh:
        ret
    invDEBI_textbox_kbd_handler     ENDP




    invDEBI_checkbox_kbd_handler        PROC
    ; This routine is called when there is input to process from the keyboard
    ;
    ; Upon entry:   eax - key
    ;               ebx - flags
    ;                ds - Debi's data segment
    ;
    ; Upon exit:    The key is either accepted and processed or ignored
    ;               Note that processing might include moving to another field
    ;
      ; Rules:  X or x - Marks the checkbox to positive
      ;         space or return - Toggle the checkbox setting
        mov     esi,ds:screen_object
        mov     edi,ds:kbd_object
        mov     ebx,dword ptr ds:[edi+13]                       ; Refer to DEBI\DEBI_MAC.ASP @DEBI_checkbox macro for offset
        .IF (al == 'X' || al == 'x')
          ; Time to set (we clear it here so it will toggle there)
            mov     byte ptr ds:[ebx],32
            call    invDEBI_checkbox_toggle
        .ELSEIF (al == 32 || al == 13)
          ; Time to toggle whatever it currently is
            call    invDEBI_checkbox_toggle
        .ELSEIF (ax == tab)
          ; Move to next item (or first one if we're on the last)
            mov     edx,1
            call    invDEBI_next_keyboard_item
        .ELSEIF (ax == shift_tab)
          ; Move to previous item (or last one if we're on the first)
            mov     edx,-1
            call    invDEBI_next_keyboard_item
        .ENDIF
        ret
    invDEBI_checkbox_kbd_handler        ENDP




    invDEBI_button_kbd_handler          PROC
    ; This routine is called when there is input to process from the keyboard
    ;
    ; Upon entry:   eax - key
    ;               ebx - flags
    ;                ds - Debi's data segment
    ;
    ; Upon exit:    The key is either accepted and processed or ignored
    ;               Note that processing might include moving to another field
    ;
        .IF (ax == tab)
          ; Move to next item (or first one if we're on the last)
            mov     edx,1
            call    invDEBI_next_keyboard_item
        .ELSEIF (ax == shift_tab)
          ; Move to previous item (or last one if we're on the first)
            mov     edx,-1
            call    invDEBI_next_keyboard_item
        .ELSEIF (ax == enter_key || ax == grey_enter)
          ; They've selected this button
            mov     edi,ds:kbd_object
            call    dword ptr ds:[edi+_KO_FUNC]
        .ENDIF
        ret
    invDEBI_button_kbd_handler          ENDP




    invDEBI_next_keyboard_item      PROC
    ; This routine is used to move to the next or previous item (depending on the value in edx)
    ;
    ; Upon entry:   edx - Direction to move, 1=Next item, -1=Previous item
    ;
    ; Upon exit:    kbd_object - updated
    ;                kbd_focus - updated
        pushad
        .IF (edx == -1)
            mov     edx,-_KO_LENGTH
        .ELSE
            mov     edx,_KO_LENGTH
        .ENDIF
        mov     edi,ds:kbd_object
        mov     ds:save_kbd_object,edi
        mov     esi,ds:screen_object
        mov     ebx,dword ptr ds:[esi+_ST_OBJECT_KBD_OFFSET]
      ; Right now, ds:[esi] - far ptr to the current screen object
      ;            ds:[edi] - far ptr to the current KBD object
      ;            ds:[ebx] - far ptr to the first KBD object
      ;                 edx - direction to go
        call    invDEBI_lostFocus                                   ; Current item loses focus
      @@:
      ; Move to the next object
        .IF (byte ptr ds:[edi] != _START)
            add     edi,edx
        .ELSE
            .IF (edx == -_KO_LENGTH)
              ; Go backwards to previous item
                add     edi,edx
            .ELSE
              ; Go forward to next item (since it's _START, we only move forward 1 byte)
                inc     edi
            .ENDIF
        .ENDIF
      ; Now, see if we've gone too far
        .IF (edi < ebx)
          ; We've gone passed the top, so we start back over at the end
            mov     edi,ebx
            .WHILE (byte ptr ds:[edi] != _END)
                .IF (byte ptr ds:[edi] == _START)
                    inc     edi
                .ELSE
                    add     edi,_KO_LENGTH
                .ENDIF
            .ENDW

            sub     edi,_KO_LENGTH
            jmp     @B
        .ELSEIF (byte ptr ds:[edi] == _END)
          ; We're at the end, so we start back over
            mov     edi,ebx
            jmp     @B
        .ENDIF
      ; We've found the next item
        mov     ds:kbd_object,edi
        call    invDEBI_setFocus
        popad
        ret
    invDEBI_next_keyboard_item      ENDP




    invDEBI_textbox_insert      PROC
    ; This routine is called to insert a space (if we're in insert mode)
    ;
    ; Upon entry:   ecx - Current textbox length
    ;
    ; Upon exit:    A space is inserted at the current location if in insert mode
    ;
        .IF (ds:insert_mode != 0 && ecx != 1)
          ; We're in insert mode
            pushfd
            pushad
            push    es
          ; Copy from ds:[esi] to es:[edi]
          ; We're doing this backwards, so we start at the end of the string
            mov     es,ds:data_segment
            dec     ecx
            mov     esi,ds:kbd_object
            mov     edi,dword ptr ds:[esi+_KO_VAR]
            add     edi,ecx
            mov     esi,edi
            dec     esi
            sub     ecx,ds:textbox_offset
          ; Right now, ds:[esi] - far ptr to character before the last one in the string
          ;            es:[edi] - far ptr to last string
          ;                 ecx - # of characters to copy
            std
            rep     movsb

            pop     es
            popad
            popfd
        .ENDIF
        ret
    invDEBI_textbox_insert      ENDP




    invDEBI_textbox_delete_selected     PROC
    ; This routine is used to delete the selected text from the current textbox string
    ;
    ; Upon entry:   ds:textbox_sel_start - start of selected text
    ;               ds:textbox_sel_end   - end of selected text
    ;
    ; Upon exit:    The string is updated and the
    ;
        .IF (ds:textbox_sel_end == 0)
            ret
        .ENDIF

      ; There is text that's selected, let's delete it
        pushfd
        pushad
        push    es
        mov     es,ds:data_segment
        mov     esi,ds:kbd_object
        mov     edi,dword ptr ds:[esi+_KO_VAR]
        add     edi,ds:textbox_sel_start
        mov     esi,edi
        add     esi,ds:textbox_sel_end
        sub     esi,ds:textbox_sel_start

      ; Right now, ds:[edi] - far ptr to string
      ; Copy the text over the selected portion
        call    invDEBI_textbox_get_length
        sub     ecx,ds:textbox_sel_end
        cld
        rep     movsb

      ; Pad with spaces to the end
        mov     al,32
        .WHILE (byte ptr es:[edi] != 0)
            stosb
        .ENDW

        pop     es
        popad
        popfd
        mov     ds:textbox_sel_end,0
        ret
    invDEBI_textbox_delete_selected     ENDP




    invDEBI_setFocus    PROC
    ; This routine is called to set focus on a particular item
    ;
    ; Upon entry:   ds:kbd_object - far ptr to object that should have kbd focus
    ;            ds:screen_object - far ptr to screen object
    ;
    ; Upon exit:    Cursor is flashing at the appropriate location
    ;               Keyboard input is routed to the appropriate handler
    ;               Other unique-to-type-of-data settings are established
    ;
        mov     esi,ds:screen_object
        mov     edi,ds:kbd_object
        pushfd
        cli
        call    invDEBI_hide_mouse_pointer
        call    invDEBI_turn_cursor_off

      ; Determine where the item will be displayed
        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        add     edx,dword ptr ds:[edi+_KO_X]
        mov     ebx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        add     ebx,dword ptr ds:[edi+_KO_Y]
        mov     al,byte ptr ds:[edi]
        .IF (al == _KO_TEXTBOX)
            mov     ds:textbox_x,edx
            mov     ds:textbox_y,ebx
            call    invDEBI_textbox_end                             ; Position the cursor at the end of the line
            mov     ecx,ds:textbox_offset                           ; Select everything on a setFocus
            mov     ds:textbox_sel_start,0                          ;   (so if they press a key all is replaced)
            mov     ds:textbox_sel_end,ecx
            call    invDEBI_textbox_refresh
            mov     ds:kbd_focus,offset invDEBI_textbox_kbd_handler     ; Set the keyboard focus to the correct handler
            call    invDEBI_textbox_activate
        .ELSEIF (al == _KO_CHECKBOX)
          ; It's a checkbox item
            movzx   eax,byte ptr ds:[edi+_KO_X_OFFSET]
            mov     ds:checkbox_x,edx
            mov     ds:checkbox_y,ebx
            mov     ds:checkbox_offset,eax
            mov     ds:kbd_focus,offset invDEBI_checkbox_kbd_handler    ; Set the keyboard focus to the correct handler
            call    invDEBI_checkbox_activate
        .ELSEIF (al == _KO_BUTTON)
          ; It's a button
            movzx   eax,byte ptr ds:[edi+_KO_X_OFFSET]
            mov     ds:button_x,edx
            mov     ds:button_y,ebx
            mov     ds:button_offset,eax
            mov     ds:kbd_focus,offset invDEBI_button_kbd_handler      ; Set the keyboard focus to the correct handler
            call    invDEBI_button_activate
        .ELSEIF (al == _KO_FUNCTION)
          ; It's a special function
            movzx   edx,word ptr ds:[edi+_KO_X_FUNCTION]
            add     edx,ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
            movzx   ebx,word ptr ds:[edi+_KO_Y_FUNCTION]
            add     ebx,ds:[esi+_ST_OBJECT_UL_VERTICAL]
            mov     ds:function_x,edx
            mov     ds:function_y,ebx
            mov     eax,dword ptr ds:[edi+_KO_KBD_FUNCTION]
            mov     ds:kbd_focus,eax
            call    invDEBI_function_set_cursor
            call    dword ptr ds:[edi+_KO_ACTIVATE_FUNCTION]
        .ENDIF
        mov     ds:force_cursor_off,0
        popfd
        ret
    invDEBI_setFocus    ENDP




    invDEBI_object_setFocus     PROC
    ; This routine is used when any button of a mouse is clicked in an area of a keyboard object (focus needs to be set there)
    ;
    ; Upon entry:   ds:[esi] - far ptr to screen objects
    ;               ds:[edi] - far ptr to mouse object (* Note: The references below relate to offsets for the @AnyClick macro)
    ;
    ; Upon exit:    Whatever item currently has the focus loses it
    ;               Whatever item they clicked on gets the focus (* Note: Could be the same thing)
    ;
        push    eax
        push    ebx

      ; See if we're moving to the same item
        mov     eax,ds:kbd_focus
        mov     ebx,dword ptr ds:[edi+_MO_DATA]
        .IF (ebx != eax)
          ; It's a different one
            call    invDEBI_lostFocus
            mov     ds:kbd_object,ebx
            call    invDEBI_setFocus
        .ENDIF

        pop     ebx
        pop     eax
        ret
    invDEBI_object_setFocus     ENDP




    invDEBI_lostFocus       PROC
    ; This routine is called when the current item is about to lose focus
    ;
    ; Upon entry:   ds:kbd_object - far ptr to object that should have kbd focus
    ;            ds:screen_object - far ptr to screen object
    ;
    ; Upon exit:    Cursor is flashing at the appropriate location
    ;               Keyboard input is routed to the appropriate handler
    ;               Other unique-to-type-of-data settings are established
    ;
        pushad
        pushfd
        mov     esi,ds:screen_object
        mov     edi,ds:kbd_object
        cli
        call    invDEBI_hide_mouse_pointer
        call    invDEBI_turn_cursor_off

      ; Determine where the item will be displayed
        mov     edx,dword ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
        add     edx,dword ptr ds:[edi+_KO_X]
        mov     ebx,dword ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
        add     ebx,dword ptr ds:[edi+_KO_Y]
        mov     al,byte ptr ds:[edi]
        .IF (al == _KO_TEXTBOX && ds:textbox_sel_end != 0)
          ; During a lose focus we basically just un-higlight everything on the current item that's higlighted
            mov     ds:textbox_x,edx
            mov     ds:textbox_y,ebx
            mov     ds:textbox_sel_end,0                            ; Force a deselect of anything on this item
            call    invDEBI_textbox_refresh
        .ENDIF
        popfd
        popad
        ret
    invDEBI_lostFocus       ENDP




    invDEBI_textbox_end     PROC
    ; This routine is called to move to the end of the current textbox
    ;
    ; Upon entry:   Nothing
    ;
    ; Upon exit:    textbox_offset - updated with new position
    ;
        pushad

        call    invDEBI_textbox_get_length
      ; Now, move backwards to the first non-space
        mov     edi,ds:kbd_object
        mov     edx,dword ptr ds:[edi+_KO_VAR]
        .WHILE (byte ptr ds:[edx+ecx-1] == 32 && ecx > 0)
            dec     ecx
        .ENDW
        mov     ds:textbox_offset,ecx

        popad
        ret
    invDEBI_textbox_end     ENDP




    invDEBI_textbox_get_length      PROC
    ; This routine is used to get the length of the curren textbox item
    ;
    ; Upon entry:   ds - data_segment
    ;
    ; Upon exit:    ecx - length
    ;
        push    edi
        push    edx

      ; Move to the end of the variable (to find out how long it is)
        mov     edi,ds:kbd_object
        mov     edx,dword ptr ds:[edi+_KO_VAR]
        xor     ecx,ecx
        .WHILE (byte ptr ds:[edx+ecx] != 0)
            inc     ecx
        .ENDW

        pop     edx
        pop     edi
        ret
    invDEBI_textbox_get_length      ENDP




    invDEBI_force_lowercase_ds_edx      PROC
    ; This routine is used to force the null-terminated string at ds:[edx]
    ;
    ; Upon entry:   ds:[edx] - far ptr to null-terminated string
    ;
    ; Upon exit:    The string is forced to lower-case
    ;
        push    edx
        push    eax

        .WHILE (byte ptr ds:[edx] != 0)
            mov     al,byte ptr ds:[edx]
            .IF (al >= 'A' && al <= 'Z')
              ; It is upper-case, let's lower the bad boy
                sub     byte ptr ds:[edx],20h
            .ENDIF
            inc     edx
        .ENDW

        pop     eax
        pop     edx
        ret
    invDEBI_force_lowercase_ds_edx      ENDP




    invDEBI_textbox_refresh     PROC
    ; This routine is called to refresh the textbox item
    ;
    ; Upon entry:   ds:kbd_object - set to textbox object to refresh
    ;               ds:textbox_* variables
    ;
    ; Upon exit:    The item is refreshed
    ;
        pushad
        pushfd
        cli
        call    invDEBI_hide_mouse_pointer
        call    invDEBI_turn_cursor_off

        mov     edi,ds:kbd_object
        mov     eax,ds:textbox_x
        mov     ebx,ds:textbox_y
        mov     edx,dword ptr ds:[edi+_KO_VAR]
      ; Right now, eax - X coord
      ;            ebx - Y coord
      ;            edx - offset to variable
        push    eax                                                 ; horizontal
        push    ebx                                                 ; vertical
        push    edx                                                 ; offset to variable
        call    fword ptr ds:_VID_g_mono_display_text               ;

        .IF (ds:textbox_sel_end != 0)
          ; Now, re-draw the selected portion only in reverse video
            mov     ecx,ds:textbox_sel_start
            .WHILE (ecx > 0)
                inc     edx
                add     eax,FONT_X
                dec     ecx
            .ENDW
            mov     esi,offset trash_string
            mov     ecx,ds:textbox_sel_end
            sub     ecx,ds:textbox_sel_start
            push    eax
            .WHILE (ecx > 0)
                mov     al,byte ptr ds:[edx]
                mov     byte ptr ds:[esi],al
                inc     edx
                inc     esi
                dec     ecx
            .ENDW
            pop     eax
            mov     byte ptr ds:[esi],0
            push    0                                               ; Write operation (0-overlay)
            push    eax                                             ; horizontal
            push    ebx                                             ; vertical
            push    1                                               ; Display mode (1-reverse)
            push    dword ptr offset trash_string
            call    fword ptr ds:_VID_g_mono_display_text_mode
        .ENDIF

        popfd
        popad
        ret
    invDEBI_textbox_refresh     ENDP




    invDEBI_textbox_activate    PROC
    ; This routine is used to activate a textbox item (basically it puts the cursor where it should be)
    ;
    ; Upon entry:   ds:textbox_offset - set to the offset in the textbox from the current item
    ;                    ds:textbox_x - set based on the current item
    ;                    ds:textbox_y - set based on the current item
    ;
    ; Upon exit:    ds:cursor_x - updated
    ;               ds:cursor_y - updated
    ;
        call    invDEBI_textbox_set_cursor
        ret
    invDEBI_textbox_activate    ENDP




    invDEBI_textbox_set_cursor      PROC
    ; This routine is used to put the cursor at the correction locaiton on the screen
    ;
    ; Upon entry:   ds:textbox_offset - offset into the current textbox item
    ;                    ds:textbox_x - textbox item's X coordinate for left-most character
    ;                    ds:textbox_y - textbox item's Y coordinate for left-most character
    ;
    ; Upon exit:    ds:cursor_x - updated
    ;               ds:cursor_y - updated
    ;
        pushad
        mov     eax,ds:textbox_offset
        mov     ebx,FONT_X
        mul     ebx
        add     eax,ds:textbox_x
        mov     ds:cursor_x,eax
        mov     ebx,ds:textbox_y
        mov     ds:cursor_y,ebx
        popad
        ret
    invDEBI_textbox_set_cursor      ENDP




    invDEBI_checkbox_refresh    PROC
    ; This routine is called to refresh the checkbox item
    ;
    ; Upon entry:   ds:kbd_object - set to checkbox object to refresh
    ;               ds:checkbox_* variables
    ;
    ; Upon exit:    The item is refreshed
    ;
        ret
    invDEBI_checkbox_refresh    ENDP




    invDEBI_checkbox_activate   PROC
    ; This routine is used to activate a checkbox item (basically it puts the cursor where it should be)
    ;
    ; Upon entry:   ds:checkbox_x - set based on the current item
    ;               ds:checkbox_y - set based on the current item
    ;
    ; Upon exit:    ds:cursor_x - updated
    ;               ds:cursor_y - updated
    ;
        pushad
        mov     eax,ds:checkbox_offset
        mov     ebx,FONT_X
        mul     ebx
        add     eax,ds:checkbox_x
        mov     ds:cursor_x,eax
        mov     eax,ds:checkbox_y
        mov     ds:cursor_y,eax
        popad
        ret
    invDEBI_checkbox_activate   ENDP




    invDEBI_button_refresh      PROC
    ; This routine is called to refresh the button item
    ;
    ; Upon entry:   ds:kbd_object - set to button object to refresh
    ;               ds:button_* variables
    ;
    ; Upon exit:    The item is refreshed
    ;
        ret
    invDEBI_button_refresh      ENDP




    invDEBI_button_activate     PROC
    ; This routine is used to activate a button item (basically it puts the cursor where it should be)
    ;
    ; Upon entry:   ds:button_x - set based on the current item
    ;               ds:button_y - set based on the current item
    ;
    ; Upon exit:    ds:cursor_x - updated
    ;               ds:cursor_y - updated
    ;
        pushad
        mov     eax,ds:button_offset
        mov     ebx,FONT_X
        mul     ebx
        add     eax,ds:button_x
        mov     ds:cursor_x,eax
        mov     eax,ds:button_y
        mov     ds:cursor_y,eax
        popad
        ret
    invDEBI_button_activate     ENDP




    invDEBI_function_set_cursor     PROC
    ; This routine is used to position the cursor on an item handled by a function
    ;
    ; Upon entry:   ds:function_x - set based on the current item
    ;               ds:function_y - set based on the current item
    ;
    ; Upon exit:    ds:cursor_x - updated
    ;               ds:cursor_y - updated
    ;
        push    eax
        mov     eax,ds:function_x
        mov     ds:cursor_x,eax
        mov     eax,ds:function_y
        mov     ds:cursor_y,eax
        pop     eax
        ret
    invDEBI_function_set_cursor     ENDP




    invDEBI_kbd_input_cancel        PROC
    ; Note, one flaw in Debi's internal design is that multiple layes of input cannot be nested
    ; There is only the top level (which is the main Debi screen that comes up when debugging)
    ; and then there's the programmable level (which is whatever popup is being used)
    ; That's why you see the "mov ds:object_mode,0" line below.  This puts Debi back into its top level object processing.
        pushfd
        cli

      ; Cancel the focus
        mov     ds:kbd_focus,-1

      ; Turn off the mouse, cursor and restore the screen
        call    invDEBI_hide_mouse_pointer
        call    invDEBI_turn_cursor_off
        mov     ds:force_cursor_off,1
        call    invDEBI_restore_screen2

      ; Cancel the popup mode
        mov     ds:object_mode,0
        popfd
        ret
    invDEBI_kbd_input_cancel        ENDP




    invDEBI_exp_screen_ok       PROC
    ; This routine is used when they click on the address expression window's OK button
    ;
    ; Upon entry:   ds:[esi] - far ptr to screen object
    ;               ds:[edi] - far ptr to mouse object (the OK button object)
    ;
    ; Upon exit:    The address is parsed, if valid then it's encoded into the desired location and input is terminated
    ;               If it's invalid, then they're not allowed to click OK (an invalid message appears in the Quick Watch
    ;                                area and editing continues)
    ;
    ;-----
    ; The allowable formats are:
    ;   1 - exp                     - exp linear memory address
    ;   2 - exp:exp                 - exp relative address in specified reg1 segment
    ; Expressions can be:
    ;   [const/reg] [*-/+] [const/reg] [*-/+] [const/reg]
    ;
        push    es
        pushad
        mov     ebx,_sDEBI_memory
        mov     es,ebx

        mov     esi,offset text_22
        mov     ecx,sizeof text_22 - 1
        call    invDEBI_parse_expression
        .IF (!carry?)
            mov     esi,offset disp_22
            mov     ecx,sizeof disp_22 - 1
            call    invDEBI_parse_expression
            .IF (!carry?)
              ; The expression is parsable
                mov     edi,ds:exp_esi
                mov     edi,dword ptr ds:[edi+_ST_MEMVAR_OFFSET]
                mov     ebx,offset DEBI_exp_memvar_list
                call    invDEBI_into_object_memvar
                call    invDEBI_kbd_input_cancel

              ; Now, refresh the screen with the new changes they've made
                movzx   eax,ds:force_screen_redraw
                push    eax
                movzx   eax,ds:force_func_windows
                push    eax
                mov     ds:force_screen_redraw,_YES
                mov     ds:force_func_windows,_YES
                mov     esi,ds:exp_esi                                          ; Screen
                mov     edi,dword ptr ds:[esi+_ST_OBJECT_SCREEN_OFFSET]         ; Object data
                call    invDEBI_draw_objects
                pop     eax
                mov     ds:force_func_windows,al
                pop     eax
                mov     ds:force_screen_redraw,al
            .ENDIF
        .ENDIF
        popad
        pop     es
        ret
    invDEBI_exp_screen_ok       ENDP




    invDEBI_into_object_memvar      PROC
    ; This routine is used to copy from local variables into an object's MEMVAR location
    ;
    ; Upon entry:   ds:[ebx] - far ptr to variable listing
    ;               es:[edi] - far ptr to destination memory location
    ;
    ; Upon exit:    Data is copied
    ;
        pushfd
        pushad
        cld
        .WHILE (dword ptr ds:[ebx+_MEMVAR_MEMORY_VARIABLE] != -1)
            mov     esi,dword ptr ds:[ebx+_MEMVAR_MEMORY_VARIABLE]
            mov     ecx,dword ptr ds:[ebx+_MEMVAR_LENGTH]
            rep     movsb
            add     ebx,_MEMVAR_STRUCT_LENGTH
        .ENDW
        popad
        popfd
        ret
    invDEBI_into_object_memvar      ENDP




    invDEBI_from_object_memvar      PROC
    ; This routine is used to copy from an object's MEMVAR location to local variables
    ;
    ; Upon entry:   ds:[ebx] - far ptr to variable listing
    ;               es:[esi] - far ptr to source memory location
    ;
    ; Upon exit:    Data is copied
    ;
        pushfd
        pushad
        cld
        .WHILE (dword ptr ds:[ebx+_MEMVAR_MEMORY_VARIABLE] != -1)
            mov     edi,dword ptr ds:[ebx+_MEMVAR_MEMORY_VARIABLE]
            mov     ecx,dword ptr ds:[ebx+_MEMVAR_LENGTH]
          ; Copy from _sDEBI_memory memory location to variable
            .WHILE (ecx > 0)
                mov     al,byte ptr es:[esi]
                mov     byte ptr ds:[edi],al
                inc     esi
                inc     edi
                dec     ecx
            .ENDW
            add     ebx,_MEMVAR_STRUCT_LENGTH
        .ENDW
        popad
        popfd
        ret
    invDEBI_from_object_memvar      ENDP




    invDEBI_parse_expression        PROC
    ; This routine is used to parse the text expression into a segment and offset
    ;
    ; Upon entry:   ds:[esi] - far ptr to address expression (has been lower-cased)
    ;                    ecx - length
    ;
    ; Upon exit:    carry? - SET if error, CLEAR if OK
    ;               ¿¬ƒ SET
    ;                ≥ eax - error code if error
    ;                ¿ƒ CLEAR
    ;                  eax - segment to use
    ;                  ebx - offset if no error
    ;
        .IF (byte ptr ds:[esi] == 32)
          ; Nothing to do, default to ds:0x0
            clc
            mov     eax,dword ptr ss:[ebp+_STACK_DS]
            xor     ebx,ebx
            ret
        .ELSEIF (ecx < 2)
          ; Not enough space to do anything
            stc
            ret
        .ENDIF
        push    fs
        mov     fs,cs:data_segment

      ; Initialize default values (in case they don't specify portions)
      ; Note, that this algorithm assumes a segment override won't be specified and stores the calculation in offset_to_use
      ;       until a ":" is found, at which time it is copied and the seg_specified variable is raised
        mov     fs:seg_specified,_NO                                ; The default condition is "they haven't specified a data seg"
        mov     fs:last_operator,_NONE
        mov     ebx,dword ptr ss:[ebp+_STACK_DS]                    ; The default segment is DS
        mov     fs:seg_to_use,ebx
        mov     fs:offset_to_use,0
        .WHILE (ecx > 0)
            mov     ax,word ptr ds:[esi]
            .IF (al == 32)
                inc     esi
                dec     ecx
            .ELSEIF (al == ':')
              ; It's the end of the segment section
                .IF (fs:seg_specified == _YES)
                  ; It's a syntax error (they've already specified something)
                    stc
                    jmp     quit_in_error
                .ENDIF
                mov     fs:seg_specified,_YES
                mov     ebx,fs:offset_to_use
                mov     fs:seg_to_use,ebx
                inc     esi
                dec     ecx
            .ELSEIF (al == '+')
                mov     al,_ADDITION
                jmp     skip_past_operator_byte
            .ELSEIF (al == '*')
                mov     al,_MULTIPLICATION
                jmp     skip_past_operator_byte
            .ELSEIF (al == '/')
                mov     al,_DIVISION
                jmp     skip_past_operator_byte
            .ELSEIF (al == '-')
                mov     al,_SUBTRACTION
              skip_past_operator_byte:
                .IF (fs:last_operator != _NONE)
                  ; it's a syntax error (they've already specified an operator, but nothing to operate against)
                    stc
                    jmp     quit_in_error
                .ENDIF
                mov     fs:last_operator,al
                inc     esi
                dec     ecx
            .ELSEIF (ecx > 2)
                .IF (ax == '>>')
                    mov     al,_SHIFT_RIGHT
                    jmp     skip_past_operator_word
                .ELSEIF (ax == '<<')
                    mov     al,_SHIFT_LEFT
                  skip_past_operator_word:
                    .IF (fs:last_operator != _NONE)
                      ; It's a syntax error (they've already specified an operator, but nothing to operate against)
                        stc
                        jmp     quit_in_error
                    .ENDIF
                    mov     fs:last_operator,al
                    add     esi,2
                    sub     ecx,2
                .ELSEIF (ax == 'x0')
                  ; It's a hexadecimal constant
                    call    invDEBI_parse_hexadecimal_constant
                    jmp     process_operator
                .ELSEIF (ax == 'y0')
                  ; It's a binary constant
                    call    invDEBI_parse_binary_constant
                    jmp     process_operator
                .ELSEIF (ax == 'd0')
                  ; It's a decimal constant
                    call    invDEBI_parse_decimal_constant
                    jmp     process_operator
                .ELSEIF (ax == 'o0')
                  ; It's an octal constant
                    call    invDEBI_parse_octal_constant
                  process_operator:
                    .IF (fs:last_operator == _NONE)
                      ; Ok, we just store it
                        mov     fs:offset_to_use,ebx
                    .ELSE
                      ; We have to operate on it
                        .IF (fs:last_operator == _ADDITION)
                            add     fs:offset_to_use,ebx
                        .ELSEIF (fs:last_operator == _SUBTRACTION)
                            sub     fs:offset_to_use,ebx
                        .ELSEIF (fs:last_operator == _MULTIPLICATION)
                            mov     eax,fs:offset_to_use
                            mul     ebx
                            mov     fs:offset_to_use,eax
                        .ELSE
                          ; It must be a division
                            .IF (ebx == 0)
                              ; It's division by 0, error
                                stc
                                jmp     quit_in_error
                            .ENDIF
                            mov     eax,fs:offset_to_use
                            xor     edx,edx
                            div     ebx
                            mov     fs:offset_to_use,eax
                        .ENDIF
                        mov     fs:last_operator,_NONE
                    .ENDIF
                .ELSE
                  ; It must be a keyword
                    call    invDEBI_search_regs
                    jnz     process_operator                        ; Branch if found
                    call    invDEBI_search_keywords
                    jnz     process_operator                        ; Branch if found
                    stc
                    jmp     quit_in_error
                .ENDIF
            .ELSE
              ; No idea
                stc
                jmp     quit_in_error
            .ENDIF
          next_part:
        .ENDW

      quit:
        mov     eax,fs:seg_to_use
        mov     ebx,fs:offset_to_use
        clc
      quit_in_error:
        pop     fs
        ret
    invDEBI_parse_expression        ENDP




    invDEBI_parse_hexadecimal_constant      PROC
    ; This routine is used to convert a hexadecimal number
    ;
    ; Upon entry:   ds:[esi] - far ptr to source (known to be lower-cased)
    ;                    ecx - maximum number of chars left
    ;
    ; Upon exit:    ebx - converted value
    ;               ds:[esi] - new ptr to first character after the number
    ;
        add     esi,2                                               ; Skip passed the "0x" part
        sub     ecx,2                                               ; Decrease the count by the number of bytes in the "0x" part
        xor     edx,edx                                             ; Initialize our output variable
        xor     ebx,ebx
        .WHILE (ecx > 0 && edx < 8)                                 ; When edx == 8, we've loaded 8 characters (which account for
            movzx   eax,byte ptr ds:[esi]                           ;                            all nibbles in a 32-bit quantity)
            .IF (al >= '0' && al <= '9')
                sub     al,'0'                                      ; It's 0-9
            .ELSEIF (al >= 'a' && al <= 'f')
                sub     al,'a'                                      ; It's a-f
            .ELSE
              ; We're past the last character, we're done
                jmp     quit                                        ; It's something else
            .ENDIF
            shl     ebx,4                                           ; Make room for the nibble
            or      ebx,eax                                         ; Stick in in there

            dec     ecx                                             ; Decrease count
            inc     esi                                             ; Increase offset
            inc     edx                                             ; Increase # of characters skipped
        .ENDW

      quit:
        ret
    invDEBI_parse_hexadecimal_constant      ENDP




    invDEBI_parse_decimal_constant      PROC
    ; This routine is used to convert a decimal number
    ;
    ; Upon entry:   ds:[esi] - far ptr to source
    ;                    ecx - maximum number of chars left
    ;
    ; Upon exit:    ebx - converted value
    ;               ds:[esi] - new ptr to first character after the number
    ;
        add     esi,2                                               ; Skip passed the "0d" part
        sub     ecx,2                                               ; Decrease the count by the number of bytes in the "0d" part
        xor     edx,edx                                             ; Initialize our output variable
        xor     ebx,ebx
        .WHILE (ecx > 0 && edx < 10)                                ; When edx == 10, we've loaded 10 characters (which account for
            movzx   eax,byte ptr ds:[esi]                           ;                      all base-10 nibbles in a 32-bit quantity)
            .IF (al >= '0' && al <= '9')
                sub     al,'0'                                      ; Convert from ASCII to base-0 numeric
                push    eax
                push    ebx
                push    edx

                mov     eax,ebx                                     ; Multiply by 10
                mov     ebx,10
                mul     ebx

                pop     edx
                pop     ebx
                mov     ebx,eax
                pop     eax
                add     ebx,eax
            .ELSE
              ; We're past the last character, we're done
                jmp     quit                                        ; It's something else
            .ENDIF

            dec     ecx                                             ; Decrease count
            inc     esi                                             ; Increase offset
            inc     edx                                             ; Increase # of characters skipped
        .ENDW

      quit:
        ret
    invDEBI_parse_decimal_constant      ENDP




    invDEBI_parse_octal_constant    PROC
    ; This routine is used to convert an octal number
    ;
    ; Upon entry:   ds:[esi] - far ptr to source
    ;                    ecx - maximum number of chars left
    ;
    ; Upon exit:    ebx - converted value
    ;               ds:[esi] - new ptr to first character after the number
    ;                    edx - chars moved
    ;
        add     esi,2                                               ; Skip passed the "0o" part
        sub     ecx,2                                               ; Decrease the count by the number of bytes in the "0o" part
        xor     edx,edx                                             ; Initialize our output variable
        xor     ebx,ebx
        .WHILE (ecx > 0 && edx < 11)                                ; When edx == 11, we've loaded 11 characters (which account for
            movzx   eax,byte ptr ds:[esi]                           ;                        all octal-nibbles in a 32-bit quantity)
            .IF (al >= '0' && al <= '7')
                sub     al,'0'                                      ; It's 0-7
            .ELSE
              ; We're past the last character, we're done
                jmp     quit                                        ; It's something else
            .ENDIF
            shl     ebx,3                                           ; Make room for the nibble
            or      ebx,eax                                         ; Stick in in there

            dec     ecx                                             ; Decrease count
            inc     esi                                             ; Increase offset
            inc     edx                                             ; Increase # of characters skipped
        .ENDW

      quit:
        ret
    invDEBI_parse_octal_constant    ENDP




    invDEBI_parse_binary_constant       PROC
    ; This routine is used to convert a binary number
    ;
    ; Upon entry:   ds:[esi] - far ptr to source
    ;                    ecx - maximum number of chars left
    ;
    ; Upon exit:    ebx - converted value
    ;               ds:[esi] - new ptr to first character after the number
    ;                    edx - chars moved
    ;
        add     esi,2                                               ; Skip passed the "0y" part
        sub     ecx,2                                               ; Decrease the count by the number of bytes in the "0y" part
        xor     edx,edx                                             ; Initialize our output variable
        xor     ebx,ebx
        .WHILE (ecx > 0 && edx < 32)                                ; When edx == 32, we've loaded 32 characters (which account for
            movzx   eax,byte ptr ds:[esi]                           ;                                 all bits in a 32-bit quantity)
            .IF (al >= '0' && al <= '1')
                sub     al,'0'                                      ; It's 0-1
            .ELSE
              ; We're past the last character, we're done
                jmp     quit                                        ; It's something else
            .ENDIF
            shl     ebx,1                                           ; Make room for the nibble
            or      ebx,eax                                         ; Stick in in there

            dec     ecx                                             ; Decrease count
            inc     esi                                             ; Increase offset
            inc     edx                                             ; Increase # of characters skipped
        .ENDW

      quit:
        ret
    invDEBI_parse_binary_constant       ENDP




    invDEBI_search_regs     PROC
    ; This routine is used to search the registers for a match
    ;
    ; Upon entry:   ds:[esi] - far ptr to source
    ;                    ecx - maximum number of chars left in string
    ;
    ; Upon exit:       zero? - SET if not found, CLEAR if found
    ;                    ebx - converted value (from the derived expression)
    ;               ds:[esi] - new ptr to first character after the found text (if any where found)
    ;                    ecx - new value
    ;
        push    edi
        push    eax
        sub     esp,12
      ; [esp+8], dword, original value of esp
      ; [esp+4], dword, length of current item in reg_list
      ; [esp+0], dword, hold value for reg_list pointer
        mov     dword ptr ss:[esp+8],esp
        add     dword ptr ss:[esp+8],12

        mov     edi,offset reg_list
        .WHILE (byte ptr fs:[edi] != -1)
            mov     dword ptr ss:[esp+0],edi                        ; Save pointer
            movzx   edx,byte ptr fs:[edi]                           ; Load length
            mov     dword ptr ss:[esp+4],edx                        ; Save length
            inc     edi                                             ; Move passed length
            xor     edx,edx                                         ; Reset counter
            .WHILE (edx < dword ptr ss:[esp+4])                     ; Continue for length
                mov     al,byte ptr ds:[esi+edx]                    ; Compare source
                mov     ah,byte ptr fs:[edi+edx]                    ;   to list
                call    invDEBI_force_lowercase_ah_al
                .IF (ah != al)
                    jmp     next                                    ; Branch if they don't match
                .ENDIF
                inc     edx
            .ENDW
          ; We've found a match
            mov     al,byte ptr fs:[edi+edx]                        ; Load the byte immediately after
            movsx   ebx,byte ptr fs:[edi+edx+1]                     ; Load the byte immediately after that
          ; Right now, eax is hte byte after the found item.  It is a pointer into the stack indicating where we should get our value.
            .IF (al >= _CS && al <= _ECODE)
              ; It's a 32-bit reference
                mov     ebx,dword ptr ss:[ebp+ebx]
            .ELSEIF (al >= _AL && al <= _DH)
              ; It's an 8-bit reference
                movzx   ebx,byte ptr ss:[ebp+ebx]
            .ELSE
              ; It's a 16-bit reference
                movzx   ebx,word ptr ss:[ebp+ebx]
            .ENDIF
            add     esi,dword ptr ss:[esp+4]
            sub     ecx,dword ptr ss:[esp+4]
          ; We're done
            or      eax,1                                           ; Lower ZERO?
            jmp     quit

          next:
            mov     edi,dword ptr ss:[esp+0]                        ; get original pointer back
            add     edi,dword ptr ss:[esp+4]                        ; for item
            add     edi,3                                           ; for overhead
        .ENDW
        sub     eax,eax                                             ; Set ZERO?

      quit:
        mov     esp,dword ptr ss:[esp+8]                            ; This doesn't affect the ZERO? flag (as an add esp,12 would)
        pop     eax
        pop     edi
        ret
    invDEBI_search_regs     ENDP




    invDEBI_search_keywords     PROC
    ; This routine is used to search the keywords for a match
    ;
    ; Upon entry:   ds:[esi] - far ptr to source
    ;                    ecx - maximum number of chars left in string
    ;
    ; Upon exit:       zero? - SET if not found, CLEAR if found
    ;                    ebx - converted value
    ;               ds:[esi] - new ptr to first character after the number
    ;                    ecx - new value
    ;
        push    edi
        push    eax
        sub     esp,12
      ; [esp+8], dword, original value of esp
      ; [esp+4], dword, length of current item in reg_list
      ; [esp+0], dword, hold value for reg_list pointer
        mov     dword ptr ss:[esp+8],esp
        add     dword ptr ss:[esp+8],12

        mov     edi,offset keyword_listing
        .WHILE (byte ptr fs:[edi] != -1)
            mov     dword ptr ss:[esp+0],edi                        ; Save pointer
            movzx   edx,byte ptr fs:[edi]                           ; Load length
            mov     dword ptr ss:[esp+4],edx                        ; Save length
            inc     edi                                             ; Move passed length
            xor     edx,edx                                         ; Reset counter
            .WHILE (edx < dword ptr ss:[esp+4])                     ; Continue for length
                mov     al,byte ptr ds:[esi+edx]                    ; Compare source
                mov     ah,byte ptr fs:[edi+edx]                    ;   to list
                call    invDEBI_force_lowercase_ah_al
                .IF (ah != al)
                    jmp     next                                    ; Branch if they don't match
                .ENDIF
                inc     edx
            .ENDW
          ; We've found a match
            movsx   ebx,word ptr fs:[edi+edx+1]                     ; Load the word immediately after the trailing NULL
            add     esi,dword ptr ss:[esp+4]
            sub     ecx,dword ptr ss:[esp+4]
          ; We're done
            or      eax,1                                           ; Lower ZERO?
            jmp     quit

          next:
            mov     edi,dword ptr ss:[esp+0]                        ; get original pointer back
            add     edi,dword ptr ss:[esp+4]                        ; for item
            add     edi,4                                           ; for overhead
        .ENDW
        sub     eax,eax                                             ; Set ZERO?

      quit:
        mov     esp,dword ptr ss:[esp+8]                            ; This doesn't affect the ZERO? flag (as an add esp,12 would)
        pop     eax
        pop     edi
        ret
    invDEBI_search_keywords     ENDP




    invDEBI_force_lowercase_ah_al       PROC
    ; This routine is used to force the characters in ah and al to lower-case
    ;
    ; Upon entry:   ah - character
    ;               al - character
    ;
    ; Upon exit:    ah and al are lower-cased (if they're letters)
    ;
        .IF (ah >= 'A' && ah <= 'Z')
            or      ah,20h
        .ENDIF
        .IF (al >= 'A' && al <= 'Z')
            or      al,20h
        .ENDIF
        ret
    invDEBI_force_lowercase_ah_al       ENDP
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; END - 99999 - Keyboard events
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=










;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; AAAAA - INCLUDE files
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    ; invDEBI_cfsca_1_window()
    ; invDEBI_cfsca_2_window()
    ; invDEBI_cfsca_3_window()
    ; invDEBI_cfsca_1_click()
    ; invDEBI_cfsca_2_click()
    ; invDEBI_cfsca_3_click()
    INCLUDE cfsca.asp


    ; Algorithms still being worked on (or slated to be completed at some point in the future)
    INCLUDE todo.asp


    ; iDEBI_open_file()
    ; iDEBI_close_file()
    ; iDEBI_read_file()
    ; iDEBI_write_file()
    ; iDEBI_search_file()
    INCLUDE disk.asp
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; END - AAAAA - INCLUDE files
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=










;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; BBBBB - Interrupt handlers
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
    invDEBI_int0_handler    PROC
        push    0                                                   ; Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int0_text
        jmp     DEBI_debug

    ; * Note: Each of these handlers never return from these procedure.  They call DEBI which will then execute the
    ;         appropriate action
    invDEBI_int0_handler    ENDP




    invDEBI_int1_handler    PROC
        push    0                                                   ; Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int1_text
        jmp     DEBI_debug
    invDEBI_int1_handler    ENDP




    invDEBI_int2_handler    PROC
        push    0                                                   ; Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int2_text
        jmp     DEBI_debug
    invDEBI_int2_handler    ENDP




    invDEBI_int3_handler    PROC
        push    0                                                   ; Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int3_text
        jmp     DEBI_debug
    invDEBI_int3_handler    ENDP




    invDEBI_int4_handler    PROC
        push    0                                                   ; Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int4_text
        jmp     DEBI_debug
    invDEBI_int4_handler    ENDP




    invDEBI_int5_handler    PROC
        push    0                                                   ; Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int5_text
        jmp     DEBI_debug
    invDEBI_int5_handler    ENDP




    invDEBI_int6_handler    PROC
        push    0                                                   ; Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int6_text
        jmp     DEBI_debug
    invDEBI_int6_handler    ENDP




    invDEBI_int7_handler    PROC
    ; This interrupt should only be called when the user is single-stepping through their code and they go from one task
    ; to another.  Under those circumstances the operating system hasn't yet had a chance to save the contents from what
    ; it thinks is the previous task.  Little does it know that this really is the same task. :)
    ; Still, rather than presenting this as an error we just clear the task-switched flag in CR0 and continue processing.
    ; This could result in errant data, but since they're stepping through with their debugger they'll know this.
        clts
;        push    0
;        push    eax
        push    eax
        mov     al,20h
        out     20h,al
        pop     eax
;        mov     eax,offset int7_text
;        jmp     DEBI_debug
        iretd
    invDEBI_int7_handler    ENDP




    invDEBI_int8_handler    PROC
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int8_text
        jmp     DEBI_debug
    invDEBI_int8_handler    ENDP




    invDEBI_int9_handler    PROC
        push    0                                                   ; Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int9_text
        jmp     DEBI_debug
    invDEBI_int9_handler    ENDP




    invDEBI_int10_handler   PROC
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int10_text
        jmp     DEBI_debug
    invDEBI_int10_handler   ENDP




    invDEBI_int11_handler   PROC
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int11_text
        jmp     DEBI_debug
    invDEBI_int11_handler   ENDP




    invDEBI_int12_handler   PROC
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int12_text
        jmp     DEBI_debug
    invDEBI_int12_handler   ENDP




    invDEBI_int13_handler   PROC
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int13_text
        jmp     DEBI_debug
    invDEBI_int13_handler   ENDP




    invDEBI_int14_handler   PROC
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int14_text
        jmp     DEBI_debug
    invDEBI_int14_handler   ENDP




    invDEBI_int15_handler   PROC
        push    0                                                   ; Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int15_text
        jmp     DEBI_debug
    invDEBI_int15_handler   ENDP




    invDEBI_int16_handler   PROC
        push    0                                                   ; Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int16_text
        jmp     DEBI_debug
    invDEBI_int16_handler   ENDP




    invDEBI_int17_handler   PROC
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int17_text
        jmp     DEBI_debug
    invDEBI_int17_handler   ENDP




    invDEBI_int18_handler   PROC
        push    0                                                   ; Fake out because this one doesn't have an error code
        push    eax
        mov     al,20h
        out     20h,al
        mov     eax,offset int18_text
        jmp     DEBI_debug
    invDEBI_int18_handler   ENDP
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;
; END - BBBBB - Interrupt handlers
;
;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=









    INCLUDE debidata.asp

; DATA
    driver_name                             db  "Low-Level Debi Debugger",255,"(source:debi.dbg)",0
    version                                 db  "10.10.2010 BETA",0
    copyright                               db  "(c) Copyright Beatleworks, Inc.",0
    author                                  db  "Rick C. Hodgin",0
    debi_text                               db  "Debi Debugger",0
    beatleworks_text                        db  "(c) Beatleworks, Inc. 2010",0
    bootup                                  db  1                   ; Changed to 0 after bootup is complete

;    success_my_lord                         db  "DEBI.Success my lord!",0
;    success_my_lord_clear                   db  "                     ",0
    step_over_text                          db  "#˙˙ - step over",0
    int0_text                               db  "#00 - divide error",0
    int1_text                               db  "#01 - single-step",0
    int2_text                               db  "#02 - no description",0
    int3_text                               db  "#03 - breakpoint",0
    int4_text                               db  "#04 - overflow",0
    int5_text                               db  "#05 - bound range exceeded",0
    int6_text                               db  "#06 - invalid opcode",0
    int7_text                               db  "#07 - device not available",0
    int8_text                               db  "#08 - double fault",0
    int9_text                               db  "#09 - coprocessor segment overrun",0
    int10_text                              db  "#10 - invalid tss",0
    int11_text                              db  "#11 - segment not present",0
    int12_text                              db  "#12 - stack fault",0
    int13_text                              db  "#13 - general protection fault",0
    int14_text                              db  "#14 - page fault",0
    int15_text                              db  "#15 - no description",0
    int16_text                              db  "#16 - floating point",0
    int17_text                              db  "#17 - alignment check",0
    int18_text                              db  "#18 - machine check",0

    quick_watch_divider                     db  "ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ",0
    round_to_nearest                        db  "nearest",0
    round_down                              db  "down",0
    round_up                                db  "up",0
    round_truncate                          db  "|chop|",0
    precision_single                        db  "24-bit [w/1]",0
    precision_reserved                      db  "[precision: 01b]",0
    precision_double                        db  "53-bit [w/1]",0
    precision_extended                      db  "64-bit",0
    precision_text                          db  "precision",0
    underflow_text                          db  "underflow",0
    overflow_text                           db  "overflow",0
    divide_by_zero_text                     db  "divide-by-zero",0
    denormalized_text                       db  "denormalized",0
    invalid_text                            db  "invalid operation",0
    error_summary                           db  "error summary",0
    stack_fault                             db  "stack fault",0
    busy                                    db  "busy"
    tag_valid                               db  "valid",0
    tag_zero                                db  "zero",0
    tag_special                             db  "invalid",0
    tag_empty                               db  "empty",0


                                           ; type, number_of_bits
    edit_word                               db  0, 16               ; type=0 indicates hexidecimal editing
    edit_dword                              db  0, 32               ; type=1 indicates binary editing
    edit_binary_32                          db  1, 32               ; number_of_bits indicates how many bits are to be modified
    edit_flags                              db  1,  1

    instruction_offset                      dd  -1
    instruction_length                      dd  -1
    step_over                               db  0
    step_offset                             dd  -1
    step_replaced_byte                      db  0

    break_here_var                          db  0
    data_segment                            dw  0
    disable_mouse                           db  0
    disable_kbd                             db  0
    disable_timer                           db  0
    debug_levels                            db  0
    debug_screen_shown                      db  0
    force_screen_redraw                     db  0
    debi_ok_to_quit                         db  0
    object_mode                             dd  0                   ; 0-root, 1-a popup, menu or dialogue
    kbd_object                              dd  0
    save_kbd_object                         dd  0
    kbd_focus                               dd  -1
    mouse_objects                           dd  0
    screen_object                           dd  0
    draw_menu                               dd  0
    menu_queue                              dd  0
    last_menu_item                          db  0ffh
    dragging_something                      dd  0
    dragging_x                              dd  0
    dragging_y                              dd  0
    dragging_height                         dd  0
    dragging_width                          dd  0
    dragging_offset_x                       dd  0
    dragging_offset_y                       dd  0
    dragging_snap_x                         dd  0
    dragging_snap_y                         dd  0
    dragging_last_x                         dd  0
    dragging_last_y                         dd  0
    dragging_skipped                        dd  0
    dragging_esi                            dd  0
    dragging_edi                            dd  0
    dragging_object                         dd  0
    mouse_current_x                         dd  350
    mouse_current_y                         dd  150
    mouse_hovering_x                        dd  -1
    mouse_hovering_y                        dd  -1
    mouse_hovering_count                    dd  -1
    mouse_clicking_count                    dd  -1
    mouse_immediate_count                   dd  -1
    mouse_last_event                        db  0
    mouse_status                            dd  0                   ; Is mouse displayed?  1-Yes, 0-No
    mouse_processing                        dd  0                   ; Is this program processing?  1-Yes, 0-No
    mouse_last_buttons                      dd  0                   ; Button status from previous packet
    mouse_last_button_left                  dd  0
    mouse_last_button_right                 dd  0
    mouse_button_left                       dd  0
    mouse_button_right                      dd  0
    mouse_left_dragging                     dd  0
    mouse_right_dragging                    dd  0
;    mouse_left_delta_x                      dd  0
;    mouse_left_delta_y                      dd  0
;    mouse_right_delta_x                     dd  0
;    mouse_right_delta_y                     dd  0
    mouse_right_click_x_start               dd  0
    mouse_right_click_y_start               dd  0
    mouse_left_click_x_start                dd  0
    mouse_left_click_y_start                dd  0
    mouse_right_click_x_stop                dd  0
    mouse_right_click_y_stop                dd  0
    mouse_left_click_x_stop                 dd  0
    mouse_left_click_y_stop                 dd  0
    mouse_right_click                       dd  0
    mouse_left_click                        dd  0
    mouse_both_click                        dd  0
    vertical_dragging_threshold             dd  5
    horizontal_dragging_threshold           dd  10
    mouse_allowed                           db  1                   ; Are mouse pointer read/write operations allowed?  1-Yes, 0-No
    mouse_save_area                         dd  16 dup(0)           ; 64 bytes
    timer_interface_count                   dd  0
    screen_saver_count                      dd  0
    screen_saver                            db  0
    cursor_x                                dd  15
    cursor_y                                dd  15
    cursor_count                            dd  0
    cursor                                  db  0
    force_cursor_off                        db  1
    force_func_windows                      db  _NO

    general_menu_esi                        dd  0
    general_menu_edi                        dd  0
    menu_restore_screen_after               db  _YES

    mem_ul_x                                dd  0                   ; Used by the mem.x window algorithms for displaying data
    mem_ul_y                                dd  0
    mem_width                               dd  0
    mem_height                              dd  0
    mem_segment                             dd  0                   ; Seg:Offset+Disp to display
    mem_offset                              dd  0
    mem_displacement                        dd  0
    mem_limit                               dd  0                   ; Limit for Seg
    mem_temp_x                              dd  0
    mem_max_x                               dd  0

    fpu_esi                                 dd  0                   ; esi when this function was called
    fpu_edi                                 dd  0                   ; edi
    fpu_x                                   dd  0                   ; mouse X coord where right-click happened
    fpu_y                                   dd  0                   ; mouse Y coord
    fpu_data                                dd  0                   ; miscellaneous data
    fpu_source                              dd  0
    fpu_dest                                dd  0

    exp_esi                                 dd  0
    exp_edi                                 dd  0

  ; Textbox related items
    textbox_x                               dd  0
    textbox_y                               dd  0
    textbox_offset                          dd  0
    textbox_sel_start                       dd  0
    textbox_sel_end                         dd  0

  ; Checkbox related items
    checkbox_x                              dd  0
    checkbox_y                              dd  0
    checkbox_offset                         dd  0                   ; How far from left-side is the actual checkbox?

  ; Button related items
    button_x                                dd  0
    button_y                                dd  0
    button_offset                           dd  0                   ; How far from left-side is the actual text on the button?

  ; Function related items
    function_x                              dd  0
    function_y                              dd  0

    insert_mode                             dd  ON                  ; Default to insert mode

    ; CFSCA variables
    single_step_history                     dd  -1
    single_step_top                         dd  0
    single_step_end                         dd  0

  ; Variables used for FPU conversion
    FPU_fsave_scratch                       db  104 dup(0)
    trash_string                            db  91 dup(0)           ; Used various places
    trash_dword                             dd  0
    trash_10_bytes                          dd  10 dup(0)
    trash_counter                           dd  0

    FPCtrl                                  dw  0
    FPStat                                  dw  0
    exponent                                dd  0
    signed_digits                           dd  0
    number10                                dd  10
    digit                                   dd  0
    bad_number0                             db  " Æ<unsupported>Ø",0
    bad_number1                             db  " Æ<nan>Ø",0
    bad_number2                             db  " Æ<-unsupported>Ø",0
    bad_number3                             db  " Æ<-nan>Ø",0
;   bad_number4                             db  " Æ<+normal>Ø",0
    bad_number5                             db  " Æ<+infinity>Ø",0
;   bad_number6                             db  " Æ<-normal>Ø",0
    bad_number7                             db  " Æ<-infinity>Ø",0
;   bad_number8                             db  " Æ<+zero>Ø",0
    bad_number9                             db  " Æ<empty>Ø",0
;   bad_number10                            db  " Æ<-zero>Ø",0
    bad_number11                            db  " Æ<-empty>Ø",0
    bad_number12                            db  " Æ<denormals>Ø",0
    bad_number13                            db  " Æ<unknown>Ø",0
    bad_number14                            db  " Æ<-denormals>Ø",0
    number_empty                            db  " Æ<empty>Ø",0

    reg_list                                db  3,"eax", _EAX, _STACK_EAX
                                            db  3,"ebx", _EBX, _STACK_EBX
                                            db  3,"ecx", _ECX, _STACK_ECX
                                            db  3,"edx", _EDX, _STACK_EDX
                                            db  3,"esi", _ESI, _STACK_ESI
                                            db  3,"edi", _EDI, _STACK_EDI
                                            db  3,"ebp", _EBP, _STACK_EBP
                                            db  3,"esp", _ESP, _STACK_ESP
                                            db  3,"eip", _EIP, _STACK_EIP
                                            db  6,"eflags", _EFLAGS, _STACK_EFLAGS
                                            db  5,"ecode", _ECODE, _STACK_ERROR_CODE
                                            db  2,"cs", _CS, _STACK_CS
                                            db  2,"ds", _DS, _STACK_DS
                                            db  2,"es", _ES, _STACK_ES          ; Note, must appear after esi (because of es)
                                            db  2,"fs", _FS, _STACK_FS
                                            db  2,"gs", _GS, _STACK_GS
                                            db  2,"ss", _SS, _STACK_SS
                                            db  2,"al", _AL, _STACK_AL
                                            db  2,"bl", _BL, _STACK_BL
                                            db  2,"cl", _CL, _STACK_CL
                                            db  2,"dl", _DL, _STACK_DL
                                            db  2,"ah", _AH, _STACK_AH
                                            db  2,"bh", _BH, _STACK_BH
                                            db  2,"ch", _CH, _STACK_CH
                                            db  2,"dh", _DH, _STACK_DH
                                            db  2,"ax", _AX, _STACK_AX
                                            db  2,"bx", _BX, _STACK_BX
                                            db  2,"cx", _CX, _STACK_CX
                                            db  2,"dx", _DX, _STACK_DX
                                            db  2,"si", _SI, _STACK_SI
                                            db  2,"di", _DI, _STACK_DI
                                            db  2,"bp", _BP, _STACK_BP
                                            db  2,"sp", _SP, _STACK_SP
                                            db  2,"ip", _IP, _STACK_IP
                                            db  -1

    seg_specified                           db  _NO
    seg_to_use                              dd  0
    offset_to_use                           dd  0
    last_operator                           db  _NONE

  ; Used for displaying the selector information when the mouse hovers over it
  keyword_listing:      ; keyword_listing (the structure) is used by invDEBI_parse_expression().invDEBI_search_keywords()
                                            db  5
    _sIDT_text                              db  "_sIDT",0
                                            dw  _sIDT
                                            db  5
    _sGDT_text                              db  "_sGDT",0
                                            dw  _sGDT
                                            db  7
    _sSTACK_text                            db  "_sSTACK",0
                                            dw  _sSTACK
                                            db  6
    _sCODE_text                             db  "_sCODE",0
                                            dw  _sCODE
                                            db  10
    _sGRAPHICS_text                         db  "_sGRAPHICS",0
                                            dw  _sGRAPHICS
                                            db  6
    _sMONO_text                             db  "_sMONO",0
                                            dw  _sMONO
                                            db  5
    _sVGA_text                              db  "_sVGA",0
                                            dw  _sVGA
                                            db  9
    _sALL_MEM_text                          db  "_sALL_MEM",0
                                            dw  _sALL_MEM
                                            db  6
    _sDATA_text                             db  "_sDATA",0
                                            dw  _sDATA
                                            db  12
    _sEXODUS_MEM_text                       db  "_sEXODUS_MEM",0
                                            dw  _sEXODUS_MEM
                                            db  14
    _sEXODUS_PORTS_text                     db  "_sEXODUS_PORTS",0
                                            dw  _sEXODUS_PORTS
                                            db  13
    _sEXODUS_INTS_text                      db  "_sEXODUS_INTS",0
                                            dw  _sEXODUS_INTS
                                            db  12
    _sEXODUS_TSS_text                       db  "_sEXODUS_TSS",0
                                            dw  _sEXODUS_TSS
                                            db  8
    _sSTACK0_text                           db  "_sSTACK0",0
                                            dw  _sSTACK0
                                            db  8
    _sSTACK1_text                           db  "_sSTACK1",0
                                            dw  _sSTACK1
                                            db  8
    _sSTACK2_text                           db  "_sSTACK2",0
                                            dw  _sSTACK2
                                            db  12
    _sPRIMATIVES_text                       db  "_sPRIMATIVES",0
                                            dw  _sPRIMATIVES
                                            db  8
    _sSYSTEM_text                           db  "_sSYSTEM",0
                                            dw  _sSYSTEM
                                            db  18
    _sEXODUS_REQUESTOR_text                 db  "_sEXODUS_REQUESTOR",0
                                            dw  _sEXODUS_REQUESTOR
                                            db  14
    _sSYSTEM_RING1_text                     db  "_sSYSTEM_RING1",0
                                            dw  _sSYSTEM_RING1
                                            db  14
    _sSYSTEM_RING2_text                     db  "_sSYSTEM_RING2",0
                                            dw  _sSYSTEM_RING2
                                            db  14
    _sSYSTEM_RING3_text                     db  "_sSYSTEM_RING3",0
                                            dw  _sSYSTEM_RING3
                                            db  13
    _sDEBI_screen_text                      db  "_sDEBI_screen",0
                                            dw  _sDEBI_screen
                                            db  14
    _sDEBI_memory_text                      db  "_sDEBI_memory",0
                                            dw  _sDEBI_memory
                                            db  14
    _sFLOPPY_TRACK_text                     db  "_sFLOPPY_TRACK",0
                                            dw  _sFLOPPY_TRACK
                                            db  12
    _sVGA_BACKUP_text                       db  "_sVGA_BACKUP",0
                                            dw  _sVGA_BACKUP
                                            db  12
    _sEXODUS_INI_text                       db  "_sEXODUS_INI",0
                                            dw  _sEXODUS_INI
                                            db  19
    _sEXODUS_INI_ERRORS_text                db  "_sEXODUS_INI_ERRORS",0
                                            dw  _sEXODUS_INI_ERRORS
                                            db  13
    _sTASK_SYSTEM_text                      db  "_sTASK_SYSTEM",0
                                            dw  _sTASK_SYSTEM
                                            db  -1
    _sEXODUS_TSS_GATE_text                  db  "_sEXODUS_TSS_GATE",0
    _sPRIMATIVES_LOAD_INFO_text             db  "_sPRIMATIVES_LOAD_INFO",0
    _selector_text                          db  "selector: ",0

    hex_text                                db  "hex: ",0
    dec_text                                db  "dec: ",0
    bin_text                                db  "bin: ",0
  real32_text:
    real4_text                              db  "r32: ",0
  real64_text:
    real8_text                              db  "r64: ",0
  real80_text:
    real10_text                             db  "r80: ",0
    disasm_text                             db  "disasm: ",0
    rounding_text                           db  "rounding: ",0
    precision_prefix_text                   db  "precision: ",0
    exception_prefix_text                   db  "exception: ",0
    mask_text                               db  "mask: ",0
    condition_codes_text                    db  "C3210: ",0
    top_of_stack_text                       db  "TOS: ",0
    stx_text                                db  "stx: ",0

    empty_byte_text                         db  "˙˙",0
    empty_word_text                         db  "˙˙˙˙",0
    empty_dword_text                        db  "˙˙˙˙˙˙˙˙",0
    empty_16_byte_hex_string_text           db  "˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙",0
    empty_16_byte_string_text               db  "˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙",0

    menu_area                               db  3072 dup(0ffh)      ; Max of 3K for menu items
    menu_mouse_objects                      db  60 * 28 dup(0ffh)   ; 60 = max # of mouse items active at one time
                                                                    ; 28 = width of each mouse object

    _EXODUS_requestor                       dw  0
  primative_call_gates:
    _VID_draw_logo                          dw  0
    _VID_display_string_nr_vga              dw  _sEXODUS_REQUESTOR
    _VID_display_string_mono                dw  0f000h
    _VID_clear_screen_mono                  dw  0f000h
    _VID_g_mono_display_text_mode           dw  0f000h
    _VID_g_mono_display_text                dw  0f000h
    _iKBD_activate_DEBI_intercept           dw  0f000h
    _iKBD_deactivate_DEBI_intercept         dw  0f000h
    _iMOUSE_activate_DEBI_intercept         dw  0f000h
    _iMOUSE_deactivate_DEBI_intercept       dw  0f000h
    _VID_g_mono_mouse_pointer               dw  0f000h
    _VID_g_set_font_8x6                     dw  0f000h
    _VID_g_set_font_8x8                     dw  0f000h
    _VID_g_set_font_8x14                    dw  0f000h
    _VID_g_set_font_16x16                   dw  0f000h
    _iTIMER_activate_DEBI_timer_feed        dw  0f000h
    _iTIMER_deactivate_DEBI_timer_feed      dw  0f000h
    _TASK_release_timeslice                 dw  0f000h
    _VID_g_mono_window_function             dw  0f000h
    _VID_position_cursor_mono               dw  0f000h
    _VID_g_display_radix_in_edx_mono        dw  0f000h
    _VID_g_mono_cursor                      dw  0f000h
    _VID_g_claim_ownership                  dw  0f000h
    _VID_g_release_ownership                dw  0f000h
    _VID_g_mono_enter_graphics_mode         dw  0f000h
    _X86_disassemble                        dw  0f000h
    _X86_simplify_disassembly               dw  0f000h
    _X86_assemble                           dw  0f000h
    _X86_fpu_opcode                         dw  0f000h
    _VID_g_mono_cursor_no_insert            dw  0f000h
    _iMOUSE_bochs_DEBI_intercept            dw  0f000h
                                            dw  0f000h
                                            dw  0f000h

    required_primatives                     db  13, "VID_draw_logo"
                                            db  25, "VID_display_string_nr_vga"
                                            db  23, "VID_display_string_mono"
                                            db  21, "VID_clear_screen_mono"
                                            db  28, "VID_g_mono_display_text_mode"
                                            db  23, "VID_g_mono_display_text"
                                            db  28, "iKBD_activate_DEBI_intercept"
                                            db  30, "iKBD_deactivate_DEBI_intercept"
                                            db  30, "iMOUSE_activate_DEBI_intercept"
                                            db  32, "iMOUSE_deactivate_DEBI_intercept"
                                            db  24, "VID_g_mono_mouse_pointer"
                                            db  18, "VID_g_set_font_8x6"
                                            db  18, "VID_g_set_font_8x8"
                                            db  19, "VID_g_set_font_8x14"
                                            db  20, "VID_g_set_font_16x16"
                                            db  31, "iTIMER_activate_DEBI_timer_feed"
                                            db  33, "iTIMER_deactivate_DEBI_timer_feed"
                                            db  22, "TASK_release_timeslice"
                                            db  26, "VID_g_mono_window_function"
                                            db  24, "VID_position_cursor_mono"
                                            db  31, "VID_g_display_radix_in_edx_mono"
                                            db  17, "VID_g_mono_cursor"
                                            db  21, "VID_g_claim_ownership"
                                            db  23, "VID_g_release_ownership"
                                            db  30, "VID_g_mono_enter_graphics_mode"
                                            db  15, "X86_disassemble"
                                            db  24, "X86_simplify_disassembly"
                                            db  12, "X86_assemble"
                                            db  14, "X86_fpu_opcode"
                                            db  27, "VID_g_mono_cursor_no_insert"
                                            db  27, "iMOUSE_bochs_DEBI_intercept"
                                            db  0ffh

    ; This logo consists of a three-wide image (the +2 portion (the 2 stands for "an extra 2 18x16 images wide"))
    ; It wants a box drawn around it (the +80h portion)
    ; And the color we want to use is 8 (dark grey, the "+(8 SHL 3) portion)
    ; * Refer to
    debi_boot_logo                          db  08ah        ; * Refer to VGA\INF\VGA.INF for information on this byte's format
                                            db  10h,10h,10h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,10h,10h,10h
                                            db  10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h
                                            db  10h,10h,10h,10h,10h,10h,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,10h,10h,10h
                                            db  10h,10h,10h,09h,01h,01h,01h,01h,01h,01h,01h,01h,01h,01h,01h,01h,09h,09h,10h,10h
                                            db  10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h
                                            db  10h,10h,10h,10h,10h,10h,0fh,02h,02h,02h,02h,02h,02h,02h,0fh,10h,10h,10h
                                            db  10h,10h,10h,09h,09h,09h,01h,01h,01h,01h,09h,09h,09h,09h,01h,01h,01h,01h,09h,10h
                                            db  10h,10h,10h,10h,10h,10h,10h,10h,10h,09h,09h,09h,09h,10h,10h,10h,10h,10h,10h,10h
                                            db  09h,09h,09h,09h,10h,10h,0fh,02h,02h,02h,02h,02h,02h,02h,0fh,10h,10h,10h
                                            db  10h,10h,10h,10h,10h,09h,01h,01h,01h,01h,09h,10h,10h,10h,09h,09h,01h,01h,01h,09h
                                            db  10h,10h,10h,10h,10h,10h,10h,10h,09h,01h,01h,01h,01h,09h,10h,10h,10h,10h,10h,09h
                                            db  01h,01h,01h,01h,09h,10h,0fh,02h,02h,02h,02h,02h,02h,02h,0fh,10h,10h,10h
                                            db  10h,10h,10h,10h,10h,09h,01h,01h,01h,0eh,09h,0eh,10h,10h,10h,09h,01h,01h,01h,01h
                                            db  09h,10h,10h,10h,10h,10h,10h,10h,10h,09h,01h,01h,01h,09h,10h,10h,10h,10h,10h,09h
                                            db  01h,01h,01h,01h,09h,10h,0fh,02h,02h,02h,02h,02h,02h,02h,0fh,10h,10h,10h
                                            db  10h,10h,10h,10h,10h,09h,0fh,0fh,01h,04h,0ch,0ch,04h,10h,0fh,0fh,0fh,01h,01h,01h
                                            db  09h,10h,10h,10h,10h,10h,10h,10h,10h,09h,01h,01h,01h,09h,10h,10h,10h,10h,10h,10h
                                            db  09h,09h,09h,09h,10h,10h,0fh,02h,02h,02h,02h,02h,02h,02h,0fh,10h,10h,10h
                                            db  10h,10h,10h,10h,10h,0fh,01h,01h,0fh,04h,0ch,0ch,04h,0fh,10h,10h,09h,0fh,01h,01h
                                            db  09h,10h,10h,09h,09h,09h,09h,09h,09h,09h,01h,01h,01h,09h,10h,10h,10h,10h,10h,10h
                                            db  10h,10h,10h,10h,10h,10h,0fh,0fh,0fh,0fh,0fh,0fh,0dh,0fh,0fh,10h,10h,10h
                                            db  10h,10h,10h,10h,10h,09h,01h,01h,01h,0ch,0ch,0ch,0ch,10h,10h,10h,09h,01h,01h,01h
                                            db  09h,10h,09h,01h,01h,01h,01h,01h,01h,09h,01h,01h,01h,09h,10h,09h,09h,09h,10h,09h
                                            db  09h,09h,10h,10h,10h,10h,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,10h,10h,10h
                                            db  10h,10h,10h,10h,10h,09h,01h,0fh,0fh,0ch,0ch,0ch,0ch,0fh,0fh,10h,09h,01h,01h,01h
                                            db  09h,09h,01h,01h,09h,09h,09h,01h,01h,09h,01h,01h,01h,09h,09h,01h,01h,01h,09h,09h
                                            db  01h,01h,09h,10h,10h,10h,10h,10h,10h,10h,0eh,10h,10h,10h,10h,10h,10h,10h
                                            db  10h,10h,10h,10h,10h,09h,0fh,01h,01h,04h,0ch,0ch,04h,10h,10h,0fh,0fh,01h,01h,01h
                                            db  09h,01h,01h,09h,01h,01h,01h,01h,09h,09h,01h,01h,01h,01h,01h,01h,01h,01h,01h,09h
                                            db  01h,01h,01h,09h,10h,10h,10h,10h,10h,10h,0eh,10h,10h,10h,10h,10h,10h,10h
                                            db  10h,10h,10h,10h,10h,0fh,01h,01h,01h,0fh,0ch,0ch,0fh,10h,10h,09h,01h,0fh,01h,01h
                                            db  09h,01h,01h,01h,01h,01h,09h,09h,10h,09h,01h,01h,01h,01h,01h,09h,01h,01h,01h,09h
                                            db  01h,01h,01h,01h,09h,10h,10h,10h,10h,10h,0eh,10h,10h,10h,10h,10h,10h,10h
                                            db  10h,10h,10h,10h,10h,09h,01h,01h,0fh,01h,09h,10h,10h,0fh,10h,09h,01h,01h,01h,01h
                                            db  09h,01h,01h,01h,09h,09h,10h,10h,10h,09h,01h,01h,01h,01h,01h,01h,09h,01h,01h,09h
                                            db  01h,01h,01h,01h,09h,10h,10h,10h,10h,10h,0eh,10h,10h,10h,10h,10h,10h,10h
                                            db  10h,10h,10h,10h,10h,09h,01h,01h,0fh,01h,09h,10h,10h,10h,0fh,09h,01h,01h,01h,09h
                                            db  09h,01h,01h,01h,09h,09h,09h,09h,09h,09h,01h,01h,01h,01h,01h,01h,09h,01h,01h,09h
                                            db  01h,01h,01h,01h,09h,10h,0eh,0eh,0eh,0eh,0eh,10h,10h,10h,10h,10h,10h,10h
                                            db  10h,10h,10h,09h,09h,09h,01h,0fh,01h,01h,09h,09h,09h,09h,0fh,01h,01h,01h,09h,10h
                                            db  09h,01h,01h,01h,01h,01h,01h,01h,01h,09h,01h,01h,01h,01h,01h,01h,01h,01h,01h,09h
                                            db  01h,01h,01h,01h,09h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h
                                            db  10h,10h,10h,09h,01h,01h,01h,0fh,01h,01h,01h,01h,01h,01h,01h,0fh,09h,09h,10h,10h
                                            db  09h,09h,09h,01h,01h,01h,01h,01h,01h,09h,01h,01h,01h,09h,01h,01h,01h,01h,09h,09h
                                            db  01h,01h,01h,09h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h
                                            db  10h,10h,10h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,10h,10h,10h,10h
                                            db  10h,10h,09h,09h,09h,09h,09h,09h,09h,10h,09h,09h,09h,10h,09h,09h,09h,09h,10h,10h
                                            db  09h,09h,09h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h
                                            db  0,0,15h     ; A dark shade of blue for the background

    INCLUDE debilogo.asp

 end_of_required_data:

    driver_primatives                       db  10, "DEBI_debug"
                                            dd  offset DEBI_debug
                                            dw  0

                                            db  19,"iDEBI_kbd_interface"
                                            dd  offset iDEBI_kbd_interface
                                            dw  0

                                            db  21,"iDEBI_mouse_interface"
                                            dd  offset iDEBI_mouse_interface
                                            dw  0

                                            db  21,"iDEBI_timer_interface"
                                            dd  offset iDEBI_timer_interface
                                            dw  0

                                            db  15,"iDEBI_open_file"
                                            dd  offset iDEBI_open_file
                                            dw  0

                                            db  16,"iDEBI_close_file"
                                            dd  offset iDEBI_close_file
                                            dw  0

                                            db  15,"iDEBI_read_file"
                                            dd  offset iDEBI_read_file
                                            dw  0

                                            db  16,"iDEBI_write_file"
                                            dd  offset iDEBI_write_file
                                            dw  0

                                            db  27,"iDEBI_bochs_mouse_interface"
                                            dd  offset iDEBI_bochs_mouse_interface
                                            dw  0

                                            dw  0ffffh              ; Teriminator

already_here                                db  _NO

_TEXT32 ENDS

END
