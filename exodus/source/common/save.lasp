display_register_name_indirect_sib:
    push    cx
    push    edx
    cmp     al,0100b
    jz      @F
    mov     cx,3
    if (al == 000b)
    {
      // eax
        mov     dx,offset eax_register
    
    } else if (al == 001b) {
        mov     dx,offset ecx_register
    
    } else if (al == 010b) {
        mov     dx,offset edx_register
    
    } else if (al == 011b) {
        mov     dx,offset ebx_register
    
    } else if (al == 101b) {
        mov     dx,offset ebp_register
    
    } else if (al == 110b) {
        mov     dx,offset esi_register
    
    } else {; (al == 111b)
        mov     dx,offset edi_register
    }
    jmp     sib_display_it

  @@:
    // sib byte is present
    xor     edx,edx
    mov     cx,3
    mov     al,CS:sib_byte
    and     al,0111b
    if (al == 000b)
    {
        mov     dx,offset eax_register
    
    } else if (al == 001b) {
        mov     dx,offset ecx_register
    
    } else if (al == 010b) {
        mov     dx,offset edx_register
    
    } else if (al == 011b) {
        mov     dx,offset ebx_register
    
    } else if (al == 100b) {
        mov     dx,offset esp_register
    
    } else if (al == 101b) {
        mov     al,CS:sib_byte
        shr     al,6
        cmp     al,00
        jnz     @F
        jmp     check_index
      @@:
        mov     dx,offset ebp_register
    
    } else if (al == 110b) {
        mov     dx,offset esi_register
    
    } else {
        mov     dx,offset edi_register
    }
    write_screen_cs_edx_no_color()
  check_index:
    mov     cx,3
    mov     al,CS:sib_byte
    shr     al,3
    and     al,0111b
    if (al == 000b)
    {
        mov     dx,offset eax_register
    
    } else if (al == 001b) {
        mov     dx,offset ecx_register
    
    } else if (al == 010b) {
        mov     dx,offset edx_register
    
    } else if (al == 011b) {
        mov     dx,offset ebx_register
    
    } else if (al == 100b) {
        jmp     sib_done
    
    } else if (al == 101b) {
        mov     dx,offset ebp_register
    
    } else if (al == 110b) {
        mov     dx,offset esi_register
    
    } else if (al == 111b) {
        mov     dx,offset edi_register
    }
    display_plus_sign()
    write_screen_cs_edx_no_color()

    mov     al,CS:sib_byte
    shr     al,6
    cmp     al,01b
    jnz     @F
    jmp     sib_mod_01
  @@:
    cmp     al,10b
    jnz     @F
    jmp     sib_mod_10
  @@:
    cmp     al,11b
    jnz     sib_done
    jmp     sib_mod_11

  sib_mod_01:
    display_scale_2()
    jmp     sib_done
  sib_mod_10:
    display_scale_4()
    jmp     sib_done
  sib_mod_11:
    display_scale_8()
    jmp     sib_done

  sib_display_it:
    write_screen_cs_edx_no_color()
  sib_done:
    pop     edx
    pop     cx
    ret


display_register_name_indirect_32:
    push    cx
    push    edx
    xor     edx,edx
    mov     cx,3
    if (al == 000b)
    {
        mov     dx,offset ebx_esi_register
        mov     cx,7
    
    } else if (al == 001b) {
        mov     dx,offset ebx_edi_register
        mov     cx,7
    
    } else if (al == 010b) {
        mov     dx,offset ebp_esi_register
        mov     cx,7
    
    } else if (al == 011b) {
        mov     dx,offset ebp_edi_register
        mov     cx,7
    
    } else if (al == 100b) {
        mov     dx,offset esi_register
    
    } else if (al == 101b) {
        mov     dx,offset edi_register
    
    } else if (al == 110b) {
        mov     dx,offset ebp_register
    
    } else {
        mov     dx,offset ebx_register
    }
    write_screen_cs_edx_no_color()
    pop     edx
    pop     cx
    ret


display_register_name_indirect_16:
    push    cx
    push    edx
    cmp     CS:op_size_override,0
    jnz     @F
    jmp     drni16_cont_1
  @@:
  // It has a SIB byte
    mov     al,CS:sib_byte
    display_register_name_indirect_sib()
    ret
  drni16_cont_1:
    xor     edx,edx
    mov     cx,2
    if (al == 000b)
    {
        mov     dx,offset bx_si_register
        mov     cx,5
    
    } else if (al == 001b) {
        mov     dx,offset bx_di_register
        mov     cx,5
    
    } else if (al == 010b) {
        mov     dx,offset bp_si_register
        mov     cx,5
    
    } else if (al == 011b) {
        mov     dx,offset bp_di_register
        mov     cx,5
    
    } else if (al == 100b) {
        mov     dx,offset si_register
    
    } else if (al == 101b) {
        mov     dx,offset di_register
    
    } else if (al == 110b) {
        mov     dx,offset bp_register
    
    } else {
        mov     dx,offset bx_register
    }
    write_screen_cs_edx_no_color()
    pop     edx
    pop     cx
    ret

display_register_name_op_size_override:
    cmp     CS:op_size_override,0
    jz      small_register
    display_register_name_32()
    ret
  small_register:
    display_register_name_16()
    ret


display_register_name_op_size_override_8_16:
    cmp     CS:op_size_override,0
    jz      small_register_2
    display_register_name_16()
    ret
  small_register_2:
    display_register_name_8()
    ret


display_register_name_indirect_op_size_override:
    cmp     CS:op_size_override,0
    jz      small_index
    display_register_name_indirect_32()
    ret
  small_index:
    display_register_name_indirect_16()
    ret


show_register_adr_size_override_no_color:
    cmp     CS:adr_size_override,0
    jz      small_number
    show_register_32_no_color()
    add     di,8*2
    ret
  small_number:
    show_register_16_no_color()
    add     di,4*2
    ret


;;;;; Load in the debug program
    mov     ax,0203h + 14                                           // Read 3 DT, NP & RP sectors (+14 debug prog sectors)
    mov     bx,0800h                                                // Store at 0800:0000h, or 8000h
    mov     es,bx
    xor     bx,bx
    mov     cx,2h                                                   // track 0/sector 2
    xor     dx,dx                                                   // head 0/drive 0
    int     13h                                                     // Read the bad boy
    jnc     Read_Sectors2
    cmp     ah,6
    jz      Read_Sectors
    jmp     Reboot_With_Message_And_Key
  Read_Sectors2:
    mov     ax,0200h + 18                                           // Read next 18 debug prog sectors
    mov     bx,512 * 17
    dec     cx                                                      // track 0/sector 1
    inc     dh                                                      // head 1/drive 0
    int     13h                                                     // Read the bad boy
    jnc     Read_Sectors3
    cmp     ah,6
    jz      Read_Sectors2
    jmp     Reboot_With_Message_And_Key

  Read_Sectors3:
    mov     ax,0200h + 18                                           // Read next 18 debug prog sectors
    mov     bx,512 * (18+17)
    mov     cx,4f01h                                                // track 79/sector 1
    xor     dx,dx                                                   // head 0/drive 0
    int     13h                                                     // Read the bad boy
    jnc     setup_debugger
    cmp     ah,6
    jz      Read_Sectors3
    jmp     Reboot_With_Message_And_Key
;; Point INT1 and INT3 to the debug routine (loaded from the floppy disk from sectors 5 through 17)
  Setup_Debugger:
    xor     ax,ax
    mov     fs,ax
    mov     eax,08600000h                                           // Segment (860h), Offset (0h), linear = 8600h
    mov     u32 ptr FS:[0*4],eax                                  // INT0, divide by zero or divide is too big for dest
    mov     u32 ptr FS:[1*4],eax                                  // INT1, single-step
    mov     u32 ptr FS:[3*4],eax                                  // INT3, software breakpoint
    mov     u32 ptr FS:[4*4],eax                                  // INT4, overflow
    mov     u32 ptr FS:[6*4],eax                                  // INT6, invalid opcode


// From BOOTUP.COM, initialize_kbd code
        mov     si,offset comma
        display_string_both()
      // Send the command to have the 8042 controller perform a self-diagnostic
        mov     al,0aah
        out     64h,al
      @@:
      // Wait for bit 0 of the status port (64h) to become zero
        in      al,64h
        shr     al,1
        jnc     @F
        jmp     @B
      @@:
        in      al,60h
        if (al == 55h)
        {
            mov     si,offset initialized_ok
        
        } else {
            mov     si,offset initialized_error
        }

//    mov     edx,u32 ptr [eax*4]
//    and     edx,0400h
//    .IF (!zero?)
//        mov     u32 ptr [eax*4],0
//        in      al,060h
//    .ENDIF



_sHIGH_MEM        = 102 * 8     // Pointer to HIGH memory structure (shows what HIGH MEMORY is available (memory between 640k and 1MB))

   // Slot 102, data (high memory mapping area)
    mov     eax,102                                                 // GDT slot
    mov     ebx,082000h                                             // base
    mov     edx,256                                                 // limit
    create_data_descriptor()

function find_high_memory_blocks
{
;; This routine tries to find out how many regions there are above 640k that can be written in the 1st Megabyte
;; * Note:  These memory regions will be used by Exodus for buffers requiring < 20-bit addresses for I/O (DMA transfers, etc)
;; * Note:  We know there is memory at 0a0000h - 0bffffh for video memory, so we start searching at 0c0000h
    mov     si,offset finding_high_memory                           // This makes the screen appear like:
    display_string_next_row_both()                            //   "þ Memory between 640k and 1MB:"

    push    ds
    push    es

    mov     ax,_sHIGH_MEM                                           // We store our findings at es:[edi]
    mov     es,ax
    xor     edi,edi

    mov     ax,_sALL_MEM                                            // We scan from ds:[0c0000h] through ds:[0fffffh]
    mov     ds,ax
    mov     esi,0c0000h

  find_high_memory_next_block:
    if (esi >= 0fffffh)
    {
      // We're to the end
        mov     bx,0
        jmp     find_high_memory_end_of_memory
    }
    mov     al,u8 ptr [esi]                                       // Read the byte there
    not     al                                                      // Reverse all bits
    mov     u8 ptr [esi],al                                       // Write it back
    if (byte ptr [esi] == al)                                      // See if we can read what we just wrote
    {
      // We can write here, it's the start of a block
        not     al                                                  // Put back whatever byte was there originally
        mov     u8 ptr [esi],al
        mov     u32 ptr es:[edi],esi                              // Store the start of this block
        add     edi,4

        push    ds
        push    es
        push    esi

        mov     ax,_sDATA
        mov     ds,ax
        mov     es,ax
        mov     edx,esi
        mov     si,offset option_last                               // Show the "+ " text
        display_string_both()
        display_hexidecimal_in_edx_both()                     // Start of block
        mov     si,offset hyphen
        display_string_both()

        pop     esi
        pop     es
        pop     ds
      @@:
      // Now, continue scanning until we can't write anymore (marking the end of a block)
        if (esi >= 0fffffh)
        {
          // We're to the end
            mov     bx,1
            jmp     find_high_memory_end_of_memory
        }
        mov     al,u8 ptr [esi]                                   // Read the byte there
        not     al                                                  // Reverse all bits
        mov     u8 ptr [esi],al                                   // Write it back
        if (byte ptr [esi] != al)                                  // See if we can read what we just wrote
        {
          // We can't write here, it's the end of a block
            dec     esi                                             // The previous byte was the last writeable byte
            mov     u32 ptr es:[edi],esi                          // Store it
            add     edi,4                                           // Move to our next area in the structure
            mov     edx,esi
            inc     esi                                             // Go back to the first byte that failed

           // Show the users the end of the block we found
            push    ds
            push    es
            push    esi

            mov     ax,_sDATA
            mov     ds,ax
            mov     es,ax
            display_hexidecimal_in_edx_next_row_both()        // End of block

            pop     esi
            pop     es
            pop     ds

            jmp     find_high_memory_next_block
        }
        not     al                                                  // Restore the byte that was there
        mov     u8 ptr [esi],al
        inc     esi                                                 // Move to the next byte to try
        jmp     @B
    }
  // We couldn't write it
    add     esi,1024                                                // Move to the next byte to try
    jmp     find_high_memory_next_block

  find_high_memory_end_of_memory:
  // We're at the end of memory
    mov     u32 ptr es:[edi],0ffffffffh                           // Terminate the listing
    mov     ax,_sDATA
    mov     ds,ax
    mov     es,ax
    if (bx == 0)
    {
      // We couldn't find any memory we could write to
        if (edi == 0)
        {
            mov     si,offset option_last                           //   "  + "
            display_string_both()                             // so we display the memory blocks found
            mov     si,offset not_available
            display_string_next_row_both()
        }
    
    } else {
      // We reached the end of the 1MB in the last block
        mov     edx,esi
        display_hexidecimal_in_edx_next_row_both()
    }

  find_high_memory_finished:
    pop     es
    pop     ds
    ret
}
;; DEBUG DISPLAY, shows the value returned from the mouse
    push    ecx
    mov     si,offset open_parenthesis
    display_string_both()
    mov     edx,ebx
    display_hexidecimal_in_edx_both()
    mov     si,offset close_parenthesis
    display_string_both()
    pop     ecx
_sFLOPPY0_DT                  = 112 * 8
_sFLOPPY0_NP                  = 113 * 8
_sFLOPPY0_RP                  = 114 * 8
_sFLOPPY0_BUFFER_READ         = 115 * 8
_sFLOPPY0_BUFFER_WRITE        = 116 * 8
_sFLOPPY0_RESERVED            = 117 * 8; Floppy drive 1 (drive B:)
_sFLOPPY1_DT                  = 118 * 8     // Pointer to floppy disk 1 (drive B:) memory areas
_sFLOPPY1_NP                  = 119 * 8
_sFLOPPY1_RP                  = 120 * 8
_sFLOPPY1_BUFFER_READ         = 121 * 8
_sFLOPPY1_BUFFER_WRITE        = 122 * 8
_sFLOPPY1_RESERVED            = 123 * 8
      // Try to determine what media is in the drive
        mov     al,"A"                                              // Drive letter
        call    u48 ptr cs:_iFDC_initialize_drive
        if (!carry?)
        {
          // There is media in the drive, so we know what capacity this diskette currently is
            mov     edx,eax
            mov     al,"A"
            call    u48 ptr cs:_iDISK_update_media
        }
      // Try to determine what media is in the drive
        mov     al,"B"                                              // Drive letter
        call    u48 ptr cs:_iFDC_initialize_drive
        if (!carry?)
        {
          // There is media in the drive, so we know what capacity this diskette currently is
            mov     edx,eax
            mov     al,"B"
            call    u48 ptr cs:_iDISK_update_media
        }
    pushad                                                           //
    mov     edx,eax                                                  //
    mov     ax,0b800h                                                //
    mov     es,ax                                                    //
    mov     ecx,8                                                    //
    xor     di,di                                                    //
    repeat;;
    {
        rol     edx,4                                                //
        mov     al,dl                                                //
        and     al,0fh                                               //
        if (al > 9)                                                 //
        {
            add     al,'A'-10                                        //
        
        } else {;;
            add     al,'0'                                           //
        }
        stosb                                                        //
        mov     al,7                                                 //
        stosb                                                        //
    } untilcxz;;
    popad                                                            //
    mov     ecx,21                                                   //
    mov     di,80*2                                                  //
    repeat;;
    {
        lodsb                                                        //
        stosb                                                        //
        mov     al,7                                                 //
        stosb                                                        //
    } untilcxz;;
    xor     ax,ax                                                    //
    int     16h                                                      //


// Initializes the ISR counts
    initialize_isr_counts()                                   // Set all ISR count arrays to zero

;; Gather required system information
    find_above_1MB_memory()                                   // Find memory above 1 MB
    initialize_pic()                                          // Setup PIC (Programmable interrupt controller)
    sti
    initialize_timer()                                        // Setup timer
    initialize_keyboard()                                     // Setup keyboard
    initialize_mouse_ps2()                                    // Setup PS/2 Mouse                     // Can't get it to work!
    initialize_pci()                                          // Identify and flag any PCI devices
    initialize_serial()                                       // Setup serial ports
    initialize_parallel()                                     // Setup parallel ports
    initialize_disk_drives()                                  // Setup floppys and basic IDE/SCSI hard disks

;; Load the base exodus configuration

;;; Load user-defined drivers
//    call    load_drivers

    iVT_clear_screen_mono()
    mov     ax,_sDATA
    mov     ds,ax
    mov     ax,_sSYSTEM_AREA
    mov     es,ax  // Display the hours
    mov     ds:offset_mono,0
    xor     edx,edx
    mov     dl,u8 ptr es:[_SYSTEM_HOURS]
    iVT_display_decimal_in_edx_nr_mono()

  // Display the minutes
    xor     edx,edx
    mov     dl,u8 ptr es:[_SYSTEM_MINUTES]
    iVT_display_decimal_in_edx_nr_mono()

  // Display the seconds
    xor     edx,edx
    mov     dl,u8 ptr es:[_SYSTEM_SECONDS]
    iVT_display_decimal_in_edx_nr_mono()

  // Display the 1/182 of a seconds
    xor     edx,edx
    mov     dl,u8 ptr es:[_SYSTEM_182S_OF_A_SECOND]
    iVT_display_decimal_in_edx_nr_mono()

  // Display the month
    xor     edx,edx
    mov     dl,u8 ptr es:[_SYSTEM_MONTH]
    iVT_display_decimal_in_edx_nr_mono()

  // Display the day
    xor     edx,edx
    mov     dl,u8 ptr es:[_SYSTEM_DAY]
    iVT_display_decimal_in_edx_nr_mono()

  // Display the year
    xor     edx,edx
    mov     dx,u16 ptr es:[_SYSTEM_YEAR]
    iVT_display_decimal_in_edx_nr_mono()

  // Display the keyboard port data
    in      al,64h
    xor     edx,edx
    mov     dl,al
    iVT_display_hexidecimal_in_edx_nr_mono()

  // Display the MSR status bit from the floppy disk controller
    mov     edx,_FDC_PORT_MSR
    xor     eax,eax
    in      al,dx
    xchg    eax,edx
    iVT_display_hexidecimal_in_edx_nr_mono()

  // Display the ISR counts
    push    ds
    mov     ax,_sISR_COUNT
    mov     ds,ax

    xor     eax,eax
    while (eax < 256)
    {
        mov     edx,u32 ptr [eax*4]
        push    eax
        if (edx != 0)
        {
            push    edx
            mov     edx,eax
            iVT_display_decimal_in_edx_mono()

            pushad
            push    ds
            mov     ax,_sDATA
            mov     ds,ax
            mov     esi,offset hyphen
            iVT_display_string_mono()
            pop     ds
            popad

            pop     edx
            iVT_display_hexidecimal_in_edx_nr_mono()
        }
        pop     eax
        inc     eax
    }
    pop     ds


function debug_set_pause
{
    pushad
    push    ds

    mov     cx,_sDATA
    mov     ds,cx
    mov     ds:debug_pause_time,eax

    pop     ds
    popad
    ret
}


debug_vga:
    pushad
    push    gs
    push    fs
    push    es
    push    ds
    mov     ax,_sDATA
    mov     ds,ax

    mov     esi,offset debug_text
    iVT_display_string_nr_vga()
    jmp     debug_pause

debug_mono:
    pushad
    push    gs
    push    fs
    push    es
    push    ds
    mov     ax,_sDATA
    mov     ds,ax

    mov     esi,offset debug_text
    iVT_display_string_nr_mono()
  debug_pause:
    if (ds:debug_pause_time != 0)
    {
        mov     eax,ds:debug_pause_time
        push    eax
        call    u48 ptr cs:_xTIMER_wait_x_ticks
    }

    pop     ds
    pop     es
    pop     fs
    pop     gs
    popad
    ret

    include "pic.lasp"                                                 // Programmable interrupt controller (APIC controller)
    include "dma.lasp"                                                 // Direct memory access
    include "video.lasp"                                               // Graphics and text

    include "debi.lasp"                                                // Debugger! :)


//Û
//Û   // Slot 10, data (xDebug)
//Û    mov     eax,_sxDEBUG / 8                                        // GDT slot
//Û    mov     ebx,070000h                                             // base
//Û    mov     edx,0ffffh                                              // limit
//Û    call    create_data_descriptor
//Û
//Û   // Slot 13, STACK0 ptr
//Û    mov     eax,_sSTACK0 / 8                                        // GDT slot
//Û    mov     ebx,40000h                                              // base
//Û    mov     edx,077ffh                                              // limit
//Û    call    create_data_descriptor
//Û
//Û   // Slot 14, STACK1 ptr
//Û    mov     eax,_sSTACK1 / 8                                        // GDT slot
//Û    mov     ebx,47fffh                                              // base
//Û    mov     edx,077ffh                                              // limit
//Û    call    create_data_descriptor
//Û
//Û   // Slot 15, STACK2 ptr
//Û    mov     eax,_sSTACK2 / 8                                        // GDT slot
//Û    mov     ebx,50000h                                              // base
//Û    mov     edx,077ffh                                              // limit
//Û    call    create_data_descriptor
//Û
//Û   // Slot 98, bogus LDT ptr (used for tasks because they require one, whoopee!)
//Û    mov     eax,_sNULL_LDT / 8                                      // GDT slot
//Û    mov     ebx,0                                                   // base
//Û    mov     edx,0                                                   // limit
//Û    call    create_ldt_descriptor
//Û
//Û   // Slot 99, data (internal memory sub-structure, 08d900-09ffff)
//Û    mov     eax,_sMEMORY / 8                                        // GDT slot
//Û    mov     ebx,08d900h                                             // base
//Û    mov     edx,75520                                               // limit
//Û    call    create_data_descriptor
//Û
//Û   // Slot 100, data (keyboard input buffer)
//Û    mov     eax,_sKEYBOARD / 8                                      // GDT slot
//Û    mov     ebx,080000h                                             // base
//Û    mov     edx,4096                                                // limit
//Û    call    create_data_descriptor
//Û
//Û   // Slot 101, data (mouse input buffer)
//Û    mov     eax,_sMOUSE / 8                                         // GDT slot
//Û    mov     ebx,081000h                                             // base
//Û    mov     edx,4096                                                // limit
//Û    call    create_data_descriptor
//Û
//Û;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; FREE (128 bytes)
//Û;   // Slot 102, unused
//Û;    mov     eax,_sUNUSED_1 / 8                                      // GDT slot
//Û;    mov     ebx,082080h                                             // base
//Û;    mov     edx,128                                                 // limit
//Û;    call    create_data_descriptor
//Û
//Û   // Slot 103, data (ISR count array)
//Û    mov     eax,_sISR_COUNT / 8                                     // GDT slot
//Û    mov     ebx,082100h                                             // base
//Û    mov     edx,1024                                                // limit
//Û    call    create_data_descriptor
//Û
//Û   // Slot 104, data (task-timer structure array)
//Û    mov     eax,_sTIMER / 8                                         // GDT slot
//Û    mov     ebx,082500h                                             // base
//Û    mov     edx,37630                                               // limit
//Û    call    create_data_descriptor
//Û
//Û   // Slot 105, data (task "scratch" space)
//Û    mov     eax,_sTIMER_TMP / 8                                     // GDT slot
//Û    mov     ebx,08b800h                                             // base
//Û    mov     edx,256                                                 // limit
//Û    call    create_data_descriptor
//Û
//Û   // Slot 106, data (system memory area for DPL=00)
//Û    mov     eax,_sSYSTEM_AREA / 8                                   // GDT slot
//Û    mov     ebx,08b900h                                             // base
//Û    mov     edx,3072                                                // limit
//Û    call    create_data_descriptor
//Û
//Û   // Slot 107, data (system memory area for DPL=01)
//Û    mov     eax,_sSYSTEM_AREA1 / 8                                  // GDT slot
//Û    mov     ebx,08b900h                                             // base
//Û    mov     edx,2048                                                // limit
//Û    mov     cx,01b                                                  // PL=01
//Û    call    create_data_descriptor_read_only_dpl
//Û
//Û   // Slot 108, data (system memory area for DPL=10)
//Û    mov     eax,_sSYSTEM_AREA2 / 8                                  // GDT slot
//Û    mov     ebx,08b900h                                             // base
//Û    mov     edx,2048                                                // limit
//Û    mov     cx,10b                                                  // PL=10
//Û    call    create_data_descriptor_read_only_dpl
//Û
//Û   // Slot 109, data (system memory area for DPL=11)
//Û    mov     eax,_sSYSTEM_AREA3 / 8                                  // GDT slot
//Û    mov     ebx,08b900h                                             // base
//Û    mov     edx,2048                                                // limit
//Û    mov     cx,11b                                                  // PL=11
//Û    call    create_data_descriptor_read_only_dpl
//Û
//Û   // Slot 110, data (disk drive structure)
//Û    mov     eax,_sDISK_DRIVES / 8                                   // GDT slot
//Û    mov     ebx,08c500h                                             // base
//Û    mov     edx,1024                                                // limit
//Û    call    create_data_descriptor
//Û
//Û   // Slot 111, data (disk partition structure)
//Û    mov     eax,_sDISK_PARTITIONS / 8                               // GDT slot
//Û    mov     ebx,08c900h                                             // base
//Û    mov     edx,4096                                                // limit
//Û    call    create_data_descriptor
//Û
//Û   // Exodus TSS for this environment
//Û    mov     eax,_sEXODUS_TSS / 8                                    // GDT slot
//Û    mov     ebx,082000h                                             // base
//Û    mov     ecx,offset first_pmode_instruction
//Û    mov     edx,7fh                                                 // limit (128 bytes)
//Û    call    create_exodus_tss_descriptor
//Û
//Û   // Task gate to Exodus TSS
//Û    mov     eax,_sEXODUS_TASK_GATE / 8                              // GDT slot
//Û    mov     ebx,_sEXODUS_TSS                                        // GDT slot of TSS this task gate points to
//Û    call    create_task_gate_descriptor
//Û
//Û   // Task Mgr TSS for this environment
//Û   // * Note:  The Task Mgr TSS gets initialized later from the initialize_timer() in SOURCE\INIT32.ASP
//Û
//Û   // Slot 17, Task Manager stack
//Û    mov     eax,_sTASK_MGR_STACK / 8                                // GDT slot
//Û    mov     ebx,58000h                                              // base
//Û    mov     edx,2000h                                               // limit (8k)
//Û    call    create_data_descriptor


function create_ldt_descriptor
{
// Upon entry, ds:[esi] - far ptr to GDT
//                  eax - slot # to insert
//                  ebx - base
//                  edx - limit
//
    mov     u16 ptr [esi+eax*8+2],bx                           // base 0:15
    shr     ebx,16
    mov     u8 ptr [esi+eax*8+4],bl                           // base 16:23
    shr     ebx,8
    mov     u8 ptr [esi+eax*8+5],10000010b                    // Not accessed, writeable, expand=0, DPL=00
    if (edx > 0fffffh)
    {
      // This is a BIG data descriptor (so, we have to change the granularity to 1)
      // Also, setting the granularity bit makes the limit value be the number of 4k segments
        shr     edx,12                                          // Divide by 4096
        mov     u16 ptr [esi+eax*8+0],dx                       // Store the new limit 0:15
        shr     edx,16                                          // Move over to store the next part of the limit
        and     dl,0fh                                          // Mask off the top nibble (the limit is only 20 bits)
        or      dl,11000000b                                    // make granularity=1, big=1 (high bits in dl)
    
    } else {
      // It's a small data descriptor (leave the granularity at 0)
        mov     u16 ptr [esi+eax*8+0],dx                       // limit 0:15
        shr     edx,16
        and     dl,0fh
    }
    mov     u8 ptr [esi+eax*8+6],dl                           // limit 16:19, Granularity=0/1, big=0/1 (depends on size)
    mov     u8 ptr [esi+eax*8+7],bl                           // base 24:31
    ret
    ret
}


function create_data_descriptor_read_only_dpl    NEAR
{
// Upon entry, ds:[esi] - far ptr to GDT
//                  eax - slot # to insert
//                  ebx - base
//                  edx - limit
//                   cl - DPL
    mov     u16 ptr [esi+eax*8+0],dx                           // limit 0:15
    mov     u16 ptr [esi+eax*8+2],bx                           // base 0:15
    shr     ebx,16
    mov     u8 ptr [esi+eax*8+4],bl                           // base 16:23
    shr     ebx,8
    shl     cl,5                                                // Move DPL over to bits 6,5
    or      cl,10010000b                                        // Not accessed, read-only, expand=0, DPL=00
    mov     u8 ptr [esi+eax*8+5],cl
    if (edx > 0fffffh)
    {
      // This is a BIG data descriptor (so, we have to change the granularity to 1)
        shr     edx,12                                          // Divide by 4096
        mov     u16 ptr [esi+eax*8+0],dx                       // Store the new limit 0:15
        shr     edx,16                                          // Move over to store the next part of the limit
        and     dl,0fh                                          // Mask off the top nibble (the limit is only 20 bits)
        or      dl,11000000b                                    // make granularity=1, big=1 (high bits in dl)
    
    } else {
      // It's a small data descriptor (leave the granularity at 0)
        shr     edx,16
        and     dl,0fh
    }
    mov     u8 ptr [esi+eax*8+6],dl                           // limit 16:19, Granularity=0/1, big=0/1 (0/1 depends on size)
    mov     u8 ptr [esi+eax*8+7],bl                           // base 24:31
    ret
}


function create_data_descriptor_expand_down    NEAR
{
// Upon entry, ds:[esi] - far ptr to GDT
//                  eax - slot # to insert
//                  ebx - base
//                  edx - limit
    neg     edx
    mov     u16 ptr [esi+eax*8+0],dx                           // limit 0:15
    shr     edx,16
    mov     u16 ptr [esi+eax*8+2],bx                           // base 0:15
    shr     ebx,16
    mov     u8 ptr [esi+eax*8+4],bl                           // base 16:23
    shr     ebx,8
    mov     u8 ptr [esi+eax*8+5],10010110b                    // Not accessed, writeable, expand=1, DPL=00
    and     dl,0fh
    mov     u8 ptr [esi+eax*8+6],dl                           // limit 16:19, Granularity=0, big=0
    mov     u8 ptr [esi+eax*8+7],bl                           // base 24:31
    ret
}


function create_interrupt_descriptor_16_bit    NEAR
{
// Upon entry, eax - interrupt # to update (0-based)
//        ds:[esi] - far pointer to start of IDT
//             edx - offset in bx to routine
//              bx - segment selector of routine
    push    ecx
    push    edx

    mov     ecx,edx                                             // Copy 32-bit offset to ecx
    and     edx,00000ffffh                                      // Keep lower 16-bits in edx
    and     ecx,0ffff0000h                                      // Keep upper 16-bits in ecx
    mov     cx,1000011000000000b                                // Add lower 16-bits in ecx, 16-bit, DPL=0, Present
    ror     edx,16                                              // Move edx around so we can access the high word
    mov     dx,bx                                               // Segment selector
    ror     edx,16                                              // Ok, put it back the way it was

    mov     u32 ptr [esi+eax*8+0],edx                         // Store the IDT descriptor
    mov     u32 ptr [esi+eax*8+4],ecx

    pop     edx
    pop     ecx
    ret
}


function create_exodus_tss_descriptor
{
// Upon entry, ds:[esi] - far ptr to memory location for the TSS descriptor
//                  eax - slot # to insert
//                  ebx - base
//                  ecx - offset of first instruction
//                  edx - limit
    push    es
    push    edi
    mov     edi,ebx

  // Create the TSS descriptor
    mov     u16 ptr [esi+eax*8+0],dx                           // limit 0:15
    mov     u16 ptr [esi+eax*8+2],bx                           // base 0:15
    shr     ebx,16
    mov     u8 ptr [esi+eax*8+4],bl                           // base 16:23
    shr     ebx,8
    mov     u8 ptr [esi+eax*8+5],10001001b                    // present=1:dpl=00:010:busy=1:1
    shr     edx,16
    and     dl,0fh                                              // make the top nibble be all 0s
    mov     u8 ptr [esi+eax*8+6],dl                           // Granularity=0:0:0:Available=0:limit 16:19
    mov     u8 ptr [esi+eax*8+7],bl                           // base 24:31

  // Write the Exodus variables there
    mov     ebx,edi
    shr     ebx,4
    mov     es,bx
    and     edi,0fh
  // Right now, es:[edi] - far ptr the memory location for Exodus
  // Code segment register
    mov     eax,_sCODE
    mov     u32 ptr es:[edi+76],eax                           // cs
  // Instruction Pointer
    mov     u32 ptr es:[edi+32],ecx                           // eip
  // Data segment registers
    mov     eax,_sDATA
    mov     u32 ptr es:[edi+84],eax                           // ds
    mov     u32 ptr es:[edi+72],eax                           // es
  // Extra segment registers
    mov     eax,_sVGA
    mov     u32 ptr es:[edi+88],eax                           // fs
    mov     eax,_sMONO
    mov     u32 ptr es:[edi+92],eax                           // gs
  // Stack
    mov     eax,_sSTACK
    mov     u32 ptr es:[edi+80],eax                           // ss
    mov     u32 ptr es:[edi+56],077fch                        // esp
  // Stack 2
    mov     eax,_sSTACK2
    mov     u32 ptr es:[edi+24],eax                           // ss2
    mov     u32 ptr es:[edi+20],077fch                        // esp2
  // Stack 1
    mov     eax,_sSTACK1
    mov     u32 ptr es:[edi+16],eax                           // ss1
    mov     u32 ptr es:[edi+12],077fch                        // esp1
  // Stack 0
    mov     eax,_sSTACK0
    mov     u32 ptr es:[edi+8],eax                            // ss0
    mov     u32 ptr es:[edi+4],077fch                         // esp0
  // General purpose registers
    xor     eax,eax
    mov     u32 ptr es:[edi+40],eax                           // eax
    mov     u32 ptr es:[edi+44],eax                           // ecx
    mov     u32 ptr es:[edi+48],eax                           // edx
    mov     u32 ptr es:[edi+52],eax                           // ebx
    mov     u32 ptr es:[edi+60],eax                           // ebp
    mov     u32 ptr es:[edi+64],eax                           // esi
    mov     u32 ptr es:[edi+68],eax                           // edi
    mov     u32 ptr es:[edi+28],eax                           // CR3, paging (not used in Exodus)
    mov     u32 ptr es:[edi+100],eax                          // IO Map Base Address, Trap bit
    mov     u32 ptr es:[edi+0],eax                            // Previous task link
    mov     eax,_sNULL_LDT
    mov     u32 ptr es:[edi+96],eax                           // LDT segment selector
  // EFLAGS
    pushfd
    pop     eax
    mov     u32 ptr es:[edi+36],eax

  // Finished
    pop     edi
    pop     es
    ret
}


function create_task_gate_descriptor
{
// Upon entry, ds:[esi] - far ptr to memory location for the TSS descriptor
//                  eax - slot # to insert
//                  bx - GDT slot for TSS
    shl     ebx,16                                              // Move bx(TSS selector) to high-order word in ebx
    mov     u32 ptr [esi+eax*8+0],ebx
    xor     ebx,ebx
    mov     bh,10000101b                                        // present=1:dpl=00:00101
    mov     u32 ptr [esi+eax*8+4],ebx
    ret
}


_sEXODUS_TSS                  = 11 * 8      // Exodus kernel TSS
_sEXODUS_TASK_GATE            = 12 * 8      // Exodus kernel task gate
_sSTACK0                      = 13 * 8      // Stack segments for Exodus main task
_sSTACK1                      = 14 * 8      //
_sSTACK2                      = 15 * 8      //
_sTASK_MGR_TSS                = 16 * 8      // Task manager TSS
_sTASK_MGR_STACK              = 17 * 8      // Task manager stack
_sTASK_MGR_RLS_TIMESLICE_TSS   = 18 * 8     // Task manager Release_Timeslice TSS
_sTASK_MGR_RLS_STACK          = 19 * 8      // Task manager Release_Timeslice stack
// Exodus internal memory regions
_sNULL_LDT                    = 98 * 8      // LDT selector (NULL)
_sMEMORY                      = 99 * 8      // Exodus internal memory sub-structure (defines all memory blocks)
// Input buffers
_sKEYBOARD                    = 100 * 8     // Keyboard input buffer selector
_sMOUSE                       = 101 * 8     // Mouse input buffer selector
_sUNUSED_1                    = 102 * 8     // unused
// Indicates how many times an interrupt has been serviced by Exodus
_sISR_COUNT                   = 103 * 8     // Pointer to a 256*4 byte array which indicates how many times each interrupt has been called
// Timer related functions (tasks)
_sTIMER                       = 104 * 8     // Pointer to a 36.75k buffer for task timer processes
_sTIMER_TMP                   = 105 * 8     // Pointer to a 256-byte temp area
// User memory area
_sSYSTEM_AREA                 = 106 * 8     // Pointer to system-memory area (read/write access to Exodus, DPL=00)
_sSYSTEM_AREA1                = 107 * 8     // Pointer to system-memory area (read-only available to all applications at DPL=01)
_sSYSTEM_AREA2                = 108 * 8     // Pointer to system-memory area (read-only available to all applications at DPL=10)
_sSYSTEM_AREA3                = 109 * 8     // Pointer to system-memory area (read-only available to all applications at DPL=11)

// Disk information
_sDISK_DRIVES                 = 110 * 8     // Pointer to disk drive device structure table, refer to INF\DISKS.INF
_sDISK_PARTITIONS             = 111 * 8     // Pointer to disk drive partition structure table, refer to INF\DISKS.INF

// Floppy drives
_sFLOPPY0_BASE_DESC           = 112 * 8     // Pointer to floppy disk 0 (drive A:) memory areas
_sFLOPPY1_BASE_DESC           = 118 * 8     // Pointer to floppy disk 1 (drive B:) memory areas

// Fixed data descriptors
_sTASK_POOL                   = 200 * 8     // Pointer to the task pool structure
_sPCI_DEVICES                 = 201 * 8     // Pointer to all the system identified PCI devices

;; Exodus public function 32-bit call gates, task gates and code segment definitions
;; The "cg" indicates call gates, "tg" indicates task gates
_cgxTIMER_wait_full_tick              = 500 * 8         // Constants used to access these call/task gates
_cgxTIMER_wait_next_tick              = 501 * 8
_cgxTIMER_wait_x_ticks                = 502 * 8
_cgxTIMER_evaluate_interval           = 503 * 8
_cgiTIMER_set_interrupt_interval      = 504 * 8
_cgiFDC_initialize_drive              = 505 * 8
_cgiFDC_determine_media               = 506 * 8
_cgiFDC_send_byte                     = 507 * 8
_cgiFDC_read_byte                     = 508 * 8
_cgiFDC_motor_on                      = 509 * 8
_cgiFDC_motor_off                     = 510 * 8
_cgiFDC_clear_fdc_output              = 511 * 8
_cgiFDC_clear_fdc_input               = 512 * 8
_cgiKBD_ll_wait_key                   = 513 * 8
_cgiFDC_read_sector                   = 514 * 8
_cgiFDC_read_track                    = 515 * 8
_cgiFDC_write_sector                  = 516 * 8
_cgiFDC_write_track                   = 517 * 8
_cgiFDC_format_track                  = 518 * 8
_cgiFDC_seek_track                    = 519 * 8
_cgiFDC_seek_relative                 = 520 * 8
_cgiFDC_sense_interrupt               = 521 * 8
_cgiDISK_requestor                    = 522 * 8
_cgiDISK_update_media                 = 523 * 8
_cgiDMA_setup                         = 524 * 8

_tgxTASK_release_timeslice            = 1000 * 8        // Task gate
_cgiTASK_irq6_prep_wait               = 1001 * 8        // Call gate
_cgiTASK_irq6_wait_for_signal         = 1002 * 8

// EFLAGS register constants to access individual flags
_EFLAGS_CF        = 0
_EFLAGS_PF        = 2
_EFLAGS_ACF       = 4
_EFLAGS_ZF        = 6
_EFLAGS_SF        = 7
_EFLAGS_TF        = 8
_EFLAGS_IF        = 9
_EFLAGS_DF        = 10
_EFLAGS_OF        = 11
_EFLAGS_IOPL      = 12
_EFLAGS_NT        = 14
_EFLAGS_RF        = 16
_EFLAGS_VM        = 17


// CR0 constants to access individual flags
_CR0_PE           = 0
_CR0_MP           = 1
_CR0_EM           = 2
_CR0_TS           = 3
_CR0_NE           = 4


// CR4 constants to access individual flags
_CR4_VME          = 0
_CR4_DE           = 3

//----------------------------------------------------------------------------------------------------------------------------------
// IRQ vectors for the exodus design (the MASTER controller is remapped 70h-77h, the SLAVE to 78h-7fh)
_IRQ0_VECTOR      = 70h         // master
_IRQ1_VECTOR      = 71h
_IRQ2_VECTOR      = 72h
_IRQ3_VECTOR      = 73h
_IRQ4_VECTOR      = 74h
_IRQ5_VECTOR      = 75h
_IRQ6_VECTOR      = 76h
_IRQ7_VECTOR      = 77h

_IRQ8_VECTOR      = 78h         // slave
_IRQ9_VECTOR      = 79h
_IRQ10_VECTOR     = 7ah
_IRQ11_VECTOR     = 7bh
_IRQ12_VECTOR     = 7ch
_IRQ13_VECTOR     = 7dh
_IRQ14_VECTOR     = 7eh
_IRQ15_VECTOR     = 7fh

// These constants are for the _sDISK_DRIVES area
// Types of controller
_DISK_CONTROLLER_NONE             = 0
_DISK_CONTROLLER_FLOPPY           = 1
_DISK_CONTROLLER_IDE              = 2
_DISK_CONTROLLER_SCSI             = 3
_DISK_CONTROLLER_PCMCIA           = 4
// Types of device
_DISK_DEVICE_RAM_DISK             = 0
_DISK_DEVICE_DISK_DRIVE           = 1
_DISK_DEVICE_CDROM_DRIVE          = 2
_DISK_DEVICE_DVD_DRIVE            = 3
_DISK_DEVICE_CDR_DRIVE            = 4
_DISK_DEVICE_CDRW_DRIVE           = 5
// Offsets to access data in this structure
_DISK_CONTROLLER_OFFSET           = 0
_DISK_DEVICE_OFFSET               = 1
_DISK_CAPACITY_OFFSET             = 2
_DISK_NUM_HEADS_OFFSET            = 10
_DISK_NUM_TRACKS_OFFSET           = 14
_DISK_NUM_SECTORS_OFFSET          = 18
_DISK_DEVICE_SPECS_OFFSET         = 22
_DISK_FLOPPY_DRIVE_TYPE_OFFSET    = 23
_DISK_BYTES_PER_SECTOR_OFFSET     = 24
_DISK_FLOPPY_GAP_LENGTH_OFFSET    = 28
_DISK_STRUCTURE_SIZE              = 32
// Device specs constants
_DISK_DEVICE_INTERNAL             =    1b
_DISK_DEVICE_MEDIA_REMOVABLE      =   10b
_DISK_DEVICE_HOT_SWAPPABLE        =  100b
_DISK_DEVICE_POWER_DOWN           = 1000b

// These constants are used for floppy disk references
_FLOPPY_360K                      = 0
_FLOPPY_1_2MB                     = 1
_FLOPPY_720K                      = 2
_FLOPPY_1_44MB                    = 3
_FLOPPY_2_88MB                    = 4

// These constants are for the iDISK_requestor() routines
_RQ_iDISK_FLOPPY_DRIVE_TYPE       = 1000


// These constants are for the _sDISK_PARTITIONS area
// File system types
_PARTITION_FILE_TYPE_NOT_ACCESSED     = 0
_PARTITION_FILE_TYPE_UNKNOWN          = 0ffh
_PARTITION_FILE_TYPE_DOS12            = 1
_PARTITION_FILE_TYPE_DOS16            = 2
_PARTITION_FILE_TYPE_DOS32            = 3
_PARTITION_FILE_TYPE_EXODUS           = 11
// Offsets to access data in this structure
_PARTITION_DISK_NUMBER_OFFSET         = 0
_PARTITION_FILE_SYSTEM_TYPE_OFFSET    = 1
_PARTITION_STARTING_HEAD_OFFSET       = 2
_PARTITION_STARTING_TRACK_OFFSET      = 6
_PARTITION_STARTING_SECTOR_OFFSET     = 10
_PARTITION_ENDING_HEAD_OFFSET         = 14
_PARTITION_ENDING_TRACK_OFFSET        = 18
_PARTITION_ENDING_SECTOR_OFFSET       = 22
_PARTITION_STARTING_GDT_OFFSET        = 26
_PARTITION_ACCESS_WORD_OFFSET         = 28
_PARTITION_DRIVE_LETTER_OFFSET        = 30
_PARTITION_PARTITION_CAPACITY         = 32
_PARTITION_STRUCTURE_SIZE             = 48

// TIMER memory accesses
_TIMER_STRUCT_LENGTH              = 32
_TIMER_GDT_LDT                    = 0
_TIMER_GDT                        = 0
_TIMER_LDT                        = 2
_TIMER_INC_VALUE                  = 4
_TIMER_CURRENT_VALUE              = 12
_TIMER_ORIGINAL_FREQ              = 20
_TIMER_RESERVED                   = 24


// PIC register access (programmable interrupt controller)
_PIC_20h                          = 20h                             // input  = 8259-1 read interrupt request/service registers
                                                                    // output = 8259-1 interrupt command
_PIC_21h                          = 21h                             // input  = 8259-1 interrupt mask register
                                                                    // output = 8259-1 interrupt commands
_PIC_70h                          = 70h                             // output = 8259-1 NMI enable (output only)
_PIC_A0h                          = 0a0h                            // input  = 8259-2 read interrupt request / service registers
                                                                    // output = 8259-2 interrupt command
                                                                    // output = 8259-2 NMI control
_PIC_A1h                          = 0a1h                            // input  = 8259-2 interrupt mask register
                                                                    // output = 8259-2 interrupt commands


// PIT register access (8254 programmable interrupt timer)
_PIT_FREQUENCY                    = 1193181 // Equivelent to 1.193181 Mhz
_PIT_0_BASE                       = 40h     // Timer 0
_PIT_1_BASE                       = 41h     // Timer 1
_PIT_2_BASE                       = 42h     // Timer 2
_PIT_MODE                         = 43h     // Mode control for timer's 0-2


// PCI device registers
_PCI_INDEX                        = 0CF8h                           // Refer to inf\pci.inf for more info
_PCI_DATA                         = 0CFCh


// KEYBOARD memory access
_KBD_NEXT_ENTRY                   = 0
_KBD_BUFFER_START                 = 4
_KBD_BUFFER_END                   = 8


// MOUSE memory access
_MOUSE_NEXT_ENTRY                 = 0
_MOUSE_BUFFER_START               = 4
_MOUSE_BUFFER_END                 = 8
// Mouse types
_MOUSE_NOT_INSTALLED              = 0
_MOUSE_PS_2                       = 1
_MOUSE_SERIAL                     = 2


// SERIAL memory accesses
_SERIAL_STRUCT_SIZE               = 16
_SERIAL_UNINITIALIZED             = 0
_SERIAL_NOT_IN_USE                = 1
_SERIAL_IN_USE                    = 2
// Communications ports to be added to the com port base to derive the correct port
_SERIAL_IER                       = 1                               // Interrupt Enable
_SERIAL_IIR                       = 2                               // Interrupt Identification
_SERIAL_FCR                       = 2                               // FIFO Control
_SERIAL_LCR                       = 3                               // Line Control
_SERIAL_MCR                       = 4                               // Modem Control
_SERIAL_LSR                       = 5                               // Line Status
_SERIAL_MSR                       = 6                               // Modem Status
_SERIAL_DLL                       = 0                               // Divisor Latch Least
_SERIAL_DLM                       = 1                               // Divisor Latch Most
// Communcations values returned from the device
_SERIAL_RX_RDY                    = 1                               // Ready to receive data
_SERIAL_INT_MASK                  = 7                               // Interrupt mask
_SERIAL_RX_ID                     = 4                               // Receive ID (what changed on the serial status line)
_SERIAL_RTS                       = 2                               // Ready to send
_SERIAL_DTR                       = 1                               // Data terminal ready
_SERIAL_XON                       = 11h                             // Xon
_SERIAL_XOFF                      = 13h                             // Xoff


// PARALLEL memory accesses
_PARALLEL_STRUCT_SIZE             = 8
_PARALLEL_UNINITIALIZED           = 0
_PARALLEL_NOT_IN_USE              = 1
_PARALLEL_IN_USE                  = 2


// FDC commands
_FDC_PORT_DOR                     = 03f2h                           // DOR - Digital Output Register
_FDC_PORT_MSR                     = 03f4h                           // MSR - Main Status Register
_FDC_PORT_DR                      = 03f5h                           // DR - Data Register
_FDC_PORT_CCR                     = 03f7h                           // CCR - Configuration Control Register
                                                                    //       (aka DRSR - Data Rate Select Register)
_FDC_PORT_DIR                     = 03f7h                           // DIR - Digital Input Register
_FDC_CMD_SEEK                     = 15
_FDC_CMD_SENSE_INTERRUPT          = 8
_FDC_CMD_READ_TRACK               = 6


// DMA constants
_DMA_mode_demand_transfer         = 00b
_DMA_mode_single_transfer         = 01b
_DMA_mode_block_transfer          = 10b

_DMA_operation_verify             = 0
_DMA_operation_write              = 1
_DMA_operation_read               = 2

_DMA_increment                    = 0                               // Data is moved from low address to high
_DMA_decrement                    = 1                               // Data is moved from high address to low

_DMA_channel_0                    = 0
_DMA_channel_1                    = 1
_DMA_channel_2                    = 2
_DMA_channel_fdc                  = 2                               // alias
_DMA_channel_3                    = 3
_DMA_channel_hdc                  = 3                               // alias
_DMA_channel_4                    = 4
_DMA_channel_5                    = 5
_DMA_channel_6                    = 6
_DMA_channel_7                    = 7

// DMA1 information
_DMA1_port_bca_channel_0          = 00h                             // base and current address
_DMA1_port_bcc_channel_0          = 01h                             // base and current count
_DMA1_port_pr_channel_0           = 87h                             // page registers
_DMA1_port_bca_channel_1          = 02h
_DMA1_port_bcc_channel_1          = 03h
_DMA1_port_pr_channel_1           = 83h
_DMA1_port_bca_channel_2          = 04h
_DMA1_port_bcc_channel_2          = 05h
_DMA1_port_pr_channel_2           = 81h
_DMA1_port_bca_channel_3          = 06h
_DMA1_port_bcc_channel_3          = 07h
_DMA1_port_pr_channel_3           = 82h
//
_DMA1_port_status_register        = 08h
_DMA1_port_command_register       = 08h
_DMA1_port_request_register       = 09h
_DMA1_port_mask_register          = 0ah                             // mask register bit
_DMA1_port_mode_register          = 0bh
_DMA1_port_clear_register         = 0ch                             // clear byte, flip/flop
_DMA1_port_temporary_register     = 0dh
_DMA1_port_master_disable         = 0dh
_DMA1_port_clear_mask_register    = 0eh
_DMA1_port_write_all_register     = 0fh                             // write all mask bits

// DMA2 information
_DMA2_port_bca_channel_4          = 0c0h                            // base and current address
_DMA2_port_bcc_channel_4          = 0c2h                            // base and current count
_DMA2_port_pr_channel_4           = 8fh                             // page register
_DMA2_port_bca_channel_5          = 0c4h
_DMA2_port_bcc_channel_5          = 0c6h
_DMA2_port_pr_channel_5           = 8bh
_DMA2_port_bca_channel_6          = 0c8h
_DMA2_port_bcc_channel_6          = 0cah
_DMA2_port_pr_channel_6           = 89h
_DMA2_port_bca_channel_7          = 0cch
_DMA2_port_bcc_channel_7          = 0ceh
_DMA2_port_pr_channel_7           = 8ah
//
_DMA2_port_status_register        = 0d0h
_DMA2_port_command_register       = 0d0h
_DMA2_port_request_register       = 0d2h
_DMA2_port_mask_register          = 0d4h                            // mask register bit
_DMA2_port_mode_register          = 0d6h
_DMA2_port_clear_register         = 0d8h                            // clear byte, flip/flop
_DMA2_port_temporary_register     = 0dah
_DMA2_port_master_disable         = 0dah
_DMA2_port_clear_mask_register    = 0dch
_DMA2_port_write_all_register     = 0deh                            // write all mask bits


// CMOS register access
_CMOS_70h                         = 70h
_CMOS_71h                         = 71h

// CMOS data registers, write the requested data value (from this list) to port 70h, then read one-byte data from port 71h
// * Note:  All values are returned in one-byte in BCD form
_NO_CONVERT                       = 0                               // Does not convert CMOS value
_BCD_CONVERT                      = 1                               // Converts CMOS BCD value to true value
_CMOS_SECONDS                     = 00h
_CMOS_SECONDS_ALARM               = 01h
_CMOS_MINUTES                     = 02h
_CMOS_MINUTES_ALARM               = 03h
_CMOS_HOURS                       = 04h
_CMOS_HOURS_ALARM                 = 05h
_CMOS_DAY_OF_WEEK                 = 06h
_CMOS_DAY                         = 07h
_CMOS_MONTH                       = 08h
_CMOS_YEAR                        = 09h     // Stored as "00" through "99"
_CMOS_STATUS_REGISTER_A           = 0ah
_CMOS_STATUS_REGISTER_B           = 0bh
_CMOS_STATUS_REGISTER_C           = 0ch
_CMOS_STATUS_REGISTER_D           = 0dh
_CMOS_DIAGNOSTIC_STATUS_BYTE      = 0eh
_CMOS_SHUTDOWN_STATUS_BYTE        = 0fh
_CMOS_DISKETTE_TYPE               = 10h
_CMOS_HARD_DISK_TYPE              = 12h
_CMOS_EQUIPMENT_BYTE              = 14h
_CMOS_HARD_DISK0_EXTENDED_TYPE    = 19h
_CMOS_HARD_DISK1_EXTENDED_TYPE    = 1ah
OFF               = 0   // These constants are used various places, makes it easier to understand
ON                = 1
NO                = 0
YES               = 1
TRUE              = 1
FALSE             = 0
_STOPPER          = 0ffh
_STOPPER_WORD     = 0ffffh
_STOPPER_DWORD    = 0ffffffffh


    finding_high_memory     u8  "þ Memory blocks between 768k and 1MB",0
    total_memory            u8  "þ Total memory: ",0
    initializing_pic        u8  "þ PIC",0
    initializing_timer      u8  "þ PIT",0
    initializing_pci        u8  "þ PCI bus",0
    initializing_kbd        u8  "þ Keyboard, ",0
    initializing_mouse      u8  "þ Mouse, ",0
    initializing_serial     u8  "þ Serial",0
    initializing_parallel   u8  "þ Parallel",0
    initializing_floppy     u8  "þ Floppy",0
    initializing_ide        u8  "þ IDE",0
    initializing_scsi       u8  "þ SCSI",0
    initializing_sound_card u8  "þ Audio",0
    initializing_network    u8  "þ Network",0


    kbd_101_key             u8  "101/104-key",0
    mouse_serial            u8  "Serial",0
    mouse_ps2               u8  "PS/2",0
    drive_letter            u8  "drive ?:, ",0                      // Floppy drives A:, B:
    floppy_288              u8  "3«",34,", 2.88m",0
    floppy_144              u8  "3«",34,", 1.44m",0
    floppy_12               u8  "5¬",34,", 1.2m",0
    floppy_720              u8  "3«",34,", 720k",0
    floppy_360              u8  "3«",34,", 360k",0
    disk_number             u8  "disk ??, ",0                       // Disk drives 00 through ??
    unknown                 u8  "unknown",0
    memory_mb               u8  " MB",0

    colon                   u8  ":",0
    comma                   u8  ",",0
    comma_space             u8  ", ",0
    open_parenthesis        u8  "(",0
    close_parenthesis       u8  ")",0
    hyphen                  u8  " - ",0
    option_blank            u8  "  - ",0
    option_last             u8  "  + ",0
    option_last_ok          u8  "  + ok",0
    option_last_error       u8  "  + error",0
    sub_option_last_ok      u8  "    + ok"
    sub_option_last_error   u8  "    + error"
    option_port_blank       u8  "  - com1 - ",0
    option_port_last        u8  "  + com1 - ",0
    initialized_ok          u8  ", ok",0
    initialized_error       u8  ", error",0
    not_available           u8  ", not available",0




    divide_by_zero_text     u8  "#0 - Divide by zero",0
    single_step_text        u8  "#1 - Single Step",0
    breakpoint_text         u8  "#3 - INT3 Breakpoint",0
    overflow_text           u8  "#4 - Overflow",0
    bound_exception_text    u8  "#5 - Bound",0
    invalid_opcode          u8  "#6 - Invalid opcode",0
    device_na_text          u8  "#7 - Device not available",0
    double_fault            u8  "#8 - Double fault - Haulted",0
    coprocessor_text        u8  "#9 - Coprocessor Segment Overrun",0
    invalid_tss             u8  "#10 - Invalid TSS",0
    not_present_text        u8  "#11 - Segment Not Present",0
    stack_fault_text        u8  "#12 - Stack fault",0
    gp_fault_text           u8  "#13 - GP fault",0
    page_fault_text         u8  "#14 - Page fault",0
    floating_point_text     u8  "#16 - Floating-Point",0
    alignment_check_text    u8  "#17 - Alignment",0
    machine_check_text      u8  "#18 - Machine-check - Haulted",0

    class_codes             u8  00h, 28, "unavailable (PCI spec < 2.0)",0
                            u8  01h, 12, "mass storage",0
                            u8  02h,  7, "network",0
                            u8  03h,  7, "display",0
                            u8  04h, 10, "multimedia",0
                            u8  05h,  6, "memory",0
                            u8  06h,  6, "bridge",0
                            u8  07h, 21, "simple communications",0
                            u8  08h, 22, "base system peripheral",0
                            u8  09h,  5, "input",0
                            u8  0ah, 15, "docking station",0
                            u8  0bh,  9, "processor",0
                            u8  0ch, 10, "serial bus",0
                            u8  0dh,  8, "wireless",0
                            u8  0eh, 15, "intelligent i/o",0
                            u8  0fh, 24, "satellite communications",0
                            u8  10h, 21, "encryption/decryption",0
                            u8  11h, 38, "data acquisition and signal processing",0
    class_stopper           u8  0ffh, 12, "undetermined",0

    sub_class_codes         u8  00h, 00h, 00h,  7, "Non-VGA",0
                            u8  00h, 01h, 00h,  3, "VGA",0
                            u8  01h, 00h, 00h,  4, "SCSI",0
                            u8  01h, 01h, 00h,  3, "IDE",0
                            u8  01h, 02h, 00h,  6, "floppy",0
                            u8  01h, 03h, 00h,  3, "IPI",0
                            u8  01h, 04h, 00h,  4, "RAID",0
                            u8  02h, 00h, 00h,  8, "ethernet",0
                            u8  02h, 01h, 00h, 10, "token ring",0
                            u8  02h, 02h, 00h,  4, "FDDI",0
                            u8  02h, 03h, 00h,  3, "ATM",0
                            u8  02h, 04h, 00h,  4, "ISDN",0
                            u8  03h, 00h, 00h,  3, "VGA",0
                            u8  03h, 00h, 01h,  4, "8514",0
                            u8  03h, 01h, 00h,  3, "XGA",0
                            u8  03h, 02h, 00h,  2, "3D",0
                            u8  04h, 00h, 00h,  5, "video",0
                            u8  04h, 01h, 00h,  5, "audio",0
                            u8  04h, 02h, 00h, 18, "computer telephony",0
                            u8  05h, 00h, 00h,  3, "RAM",0
                            u8  05h, 01h, 00h,  5, "flash",0
                            u8  06h, 00h, 00h,  8, "host/PCI",0
                            u8  06h, 01h, 00h,  7, "PIC/ISA",0
                            u8  06h, 02h, 00h,  8, "PCI/EISA",0
                            u8  06h, 03h, 00h,  7, "PCI/MCA",0
                            u8  06h, 04h, 00h,  7, "PCI/PCI",0
                            u8  06h, 04h, 01h, 10, "PCI/PCI SD",0
                            u8  06h, 05h, 00h, 10, "PCI/PCMCIA",0
                            u8  06h, 06h, 00h,  9, "PCI/NuBus",0
                            u8  06h, 07h, 00h, 11, "PCI/CardBus",0
                            u8  06h, 08h, 00h,  7, "RACEway",0
                            u8  07h, 00h, 00h, 13, "XT-compatible",0
                            u8  07h, 00h, 01h,  5, "16450",0
                            u8  07h, 00h, 02h,  5, "16550",0
                            u8  07h, 00h, 03h,  5, "16650",0
                            u8  07h, 00h, 04h,  5, "16750",0
                            u8  07h, 00h, 05h,  5, "16850",0
                            u8  07h, 00h, 06h,  5, "16950",0
                            u8  07h, 01h, 00h,  3, "std",0
                            u8  07h, 01h, 01h,  2, "bi",0
                            u8  07h, 01h, 02h,  7, "ECP 1.x",0
                            u8  07h, 01h, 03h, 20, "IEEE 1284 controller",0
                            u8  07h, 01h,0feh, 16, "IEEE 1284 device",0
                            u8  07h, 02h, 00h,  9, "multiport",0
                            u8  07h, 03h, 00h,  5, "modem",0
                            u8  07h, 03h, 01h, 11, "16450 modem",0
                            u8  07h, 03h, 02h, 11, "16550 modem",0
                            u8  07h, 03h, 03h, 11, "16650 modem",0
                            u8  07h, 03h, 04h, 11, "16750 modem",0
                            u8  08h, 00h, 00h,  8, "8259 PIC",0
                            u8  08h, 00h, 01h,  7, "ISA PIC",0
                            u8  08h, 00h, 02h,  8, "EISA PIC",0
                            u8  08h, 00h, 10h,  7, "IO APIC",0
                            u8  08h, 00h, 20h, 10, "IO(x) APIC",0
                            u8  08h, 01h, 00h,  8, "8237 DMA",0
                            u8  08h, 01h, 01h,  7, "ISA DMA",0
                            u8  08h, 01h, 02h,  8, "EISA DMA",0
                            u8  08h, 02h, 00h,  8, "8254 PIT",0
                            u8  08h, 02h, 01h,  9, "ISA timer",0
                            u8  08h, 02h, 02h, 10, "EISA timer",0
                            u8  08h, 03h, 00h, 15, "real-time clock",0
                            u8  08h, 03h, 01h, 19, "ISA real-time clock",0
                            u8  08h, 04h, 00h, 23, "PCI hot-plug controller",0
                            u8  09h, 00h, 00h,  8, "keyboard",0
                            u8  09h, 01h, 00h, 15, "digitizer (pen)",0
                            u8  09h, 02h, 00h,  5, "mouse",0
                            u8  09h, 03h, 00h,  7, "scanner",0
                            u8  09h, 04h, 00h,  8, "gameport",0
                            u8  0ah, 00h, 00h,  7, "generic",0
                            u8  0bh, 00h, 00h,  3, "386",0
                            u8  0bh, 01h, 00h,  3, "486",0
                            u8  0bh, 02h, 00h,  7, "pentium",0
                            u8  0bh, 03h, 00h,  5, "alpha",0
                            u8  0bh, 04h, 00h,  7, "powerpc",0
                            u8  0bh, 05h, 00h,  4, "mips",0
                            u8  0bh, 06h, 00h, 12, "co-processor",0
                            u8  0ch, 00h, 00h,  9, "IEEE 1394",0
                            u8  0ch, 00h, 01h, 17, "IEEE 1394 OpenHCI",0
                            u8  0ch, 01h, 00h, 10, "ACCESS.bus",0
                            u8  0ch, 02h, 00h,  3, "SSA",0
                            u8  0ch, 03h, 01h,  3, "USB",0
                            u8  0ch, 03h, 10h, 12, "USB OpenHost",0
                            u8  0ch, 03h, 80h, 28, "USB no programming interface",0
                            u8  0ch, 03h,0feh, 10, "USB device",0
                            u8  0ch, 04h, 00h,  5, "fibre",0
                            u8  0ch, 05h, 00h, 21, "system management bus",0
                            u8  0dh, 00h, 00h, 15, "iRDA controller",0
                            u8  0dh, 01h, 00h, 11, "consumer IR",0
                            u8  0dh, 10h, 00h, 13, "RF controller",0
                            u8  0eh, 00h, 00h,  4, "FIFO",0
                            u8  0eh,0ffh, 00h,  3, "I2O",0
                            u8  0fh, 01h, 00h,  2, "TV",0
                            u8  0fh, 02h, 00h,  5, "audio",0
                            u8  0fh, 03h, 00h,  5, "voice",0
                            u8  0fh, 04h, 00h,  4, "data",0
                            u8  10h, 00h, 00h, 17, "network/computing",0
                            u8  10h, 10h, 00h, 13, "entertainment",0
                            u8  11h, 00h, 00h,  4, "DPIO",0
    sub_class_other         u8  0ffh, 00h, 00h,  5, "other",0

;; DEBUG codes
    debug1_text             u8  " DEBUG1 ",0
    debug2_text             u8  " DEBUG2 ",0
    debug3_text             u8  " DEBUG3 ",0
    debug4_text             u8  " DEBUG4 ",0
    clear_debug_text        u8  "ÛÛÛÛÛÛÛÛ",0

    debug_text              u8  "þ Debug trap",0
    debug_pause_time        u32 182 * 10        // Default to 10 seconds between items

    cmos_conversion_table   u8  _CMOS_SECONDS, _BCD_CONVERT, _SYSTEM_SECONDS      // This table is used to take data from CMOS and store it in
                            u8  _CMOS_MINUTES, _BCD_CONVERT, _SYSTEM_MINUTES      // our SYSTEM memory area.  This is done during the
                            u8  _CMOS_HOURS, _BCD_CONVERT, _SYSTEM_HOURS          // initialize_timer() routine because the timer is responsible
                            u8  _CMOS_DAY, _BCD_CONVERT, _SYSTEM_DAY              // for updating these values.  Refer to SOURCE\INIT.ASP
                            u8  _CMOS_MONTH, _BCD_CONVERT, _SYSTEM_MONTH
                            u8  _CMOS_YEAR, _BCD_CONVERT, _SYSTEM_YEAR
                            u8  _CMOS_DISKETTE_TYPE, _NO_CONVERT, _SYSTEM_FLOPPY_DRIVE_TYPE
                            u8  _CMOS_HARD_DISK_TYPE, _NO_CONVERT, _SYSTEM_HARD_DRIVE_TYPE
                            u8  _CMOS_HARD_DISK0_EXTENDED_TYPE, _NO_CONVERT, _SYSTEM_HARD_DRIVE0_EXTENDED
                            u8  _CMOS_HARD_DISK1_EXTENDED_TYPE, _NO_CONVERT, _SYSTEM_HARD_DRIVE1_EXTENDED
                            u8  0ffh

    timer_max_hz            u32 0
    timer_max_value         u64 0

    installed_memory        u32 0           // Number of bytes found



;; Exodus public functions that are called by Exodus BOOTUP.COM
;; * Note:  The CALL GATE reference requires a value for the EIP, but it doesn't matter what it is.  For that reason all of
;;          the memory variables below are shifted down 4 bytes, this allows the bogus EIP to be there before the valid CALL GATE
    _xTIMER_wait_full_tick              u16 0                       // Bogus EIP DWORD
    _xTIMER_wait_next_tick              u16 0
    _xTIMER_wait_x_ticks                u16 _cgxTIMER_wait_full_tick
    _xTIMER_evaluate_interval           u16 _cgxTIMER_wait_next_tick
    _iTIMER_set_interrupt_interval      u16 _cgxTIMER_wait_x_ticks
    _iFDC_initialize_drive              u16 _cgxTIMER_evaluate_interval
    _iFDC_determine_media               u16 _cgiTIMER_set_interrupt_interval
    _iFDC_send_byte                     u16 _cgiFDC_initialize_drive
    _iFDC_read_byte                     u16 _cgiFDC_determine_media
    _iFDC_motor_on                      u16 _cgiFDC_send_byte
    _iFDC_motor_off                     u16 _cgiFDC_read_byte
    _iFDC_clear_fdc_output              u16 _cgiFDC_motor_on
    _xTASK_release_timeslice            u16 _cgiFDC_motor_off
    _iKBD_ll_wait_key                   u16 _cgiFDC_clear_fdc_output
    _iFDC_clear_fdc_input               u16 _tgxTASK_release_timeslice
    _iTASK_irq6_prep_wait               u16 _cgiKBD_ll_wait_key
    _iTASK_irq6_wait_for_signal         u16 _cgiFDC_clear_fdc_input
    _iFDC_read_sector                   u16 _cgiTASK_irq6_prep_wait
    _iFDC_read_track                    u16 _cgiTASK_irq6_wait_for_signal
    _iFDC_write_sector                  u16 _cgiFDC_read_sector
    _iFDC_write_track                   u16 _cgiFDC_read_track
    _iFDC_format_track                  u16 _cgiFDC_write_sector
    _iFDC_seek_track                    u16 _cgiFDC_write_track
    _iFDC_seek_relative                 u16 _cgiFDC_format_track
    _iFDC_sense_interrupt               u16 _cgiFDC_seek_track
    _iDISK_requestor                    u16 _cgiFDC_seek_relative
    _iDISK_update_media                 u16 _cgiFDC_sense_interrupt
    _iDMA_setup                         u16 _cgiDISK_requestor
                                        u16 _cgiDISK_update_media
                                        u16 _cgiDMA_setup


    reg1                    u16 03d4h
    reg2                    u16 03d5h
    offset_vga              u16 0
    offset_mono             u16 0
    attribute_vga           u8  7
    attribute_mono          u8  7
    freeze_vga              u8  0
    freeze_mono             u8  0
    storage_ptr             u32 offset offset_vga                         // pointer to either offset_vga or offset_mono


interrupt_1_handler:
    push    eax
    mov     eax,1
    debug_exception_handler()
    pop     eax
    iretd
interrupt_2_handler:
    push    eax
    mov     eax,2
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_3_handler:
    push    eax
    mov     eax,3
    breakpoint_exception_handler()
    pop     eax
    iretd
interrupt_4_handler:
    push    eax
    mov     eax,4
    overflow_exception_handler()
    pop     eax
    iretd
interrupt_5_handler:
    push    eax
    mov     eax,5
    bound_range_exceeded_handler()
    pop     eax
    iretd
interrupt_6_handler:
    push    eax
    mov     eax,6
    invalid_opcode_handler()
    pop     eax
    iretd
interrupt_7_handler:
    push    eax
    mov     eax,7
    device_not_available_handler()
    pop     eax
    iretd
interrupt_8_handler:
    push    eax
    mov     eax,8
    double_fault_handler()
    pop     eax
    iretd
interrupt_9_handler:
    push    eax
    mov     eax,9
    coprocessor_segment_overrun_handler()
    pop     eax
    iretd
interrupt_10_handler:
    push    eax
    mov     eax,10
    invalid_tss_handler()
    pop     eax
    iretd
interrupt_11_handler:
    push    eax
    mov     eax,11
segment_not_present_handler()
    pop     eax
    iretd
interrupt_12_handler:
    push    eax
    mov     eax,12
    stack_fault_handler()
    pop     eax
    iretd
interrupt_13_handler:
    push    eax
    mov     eax,13
    gp_fault_handler()
    pop     eax
    iretd
interrupt_14_handler:
    push    eax
    mov     eax,14
    page_fault_handler()
    pop     eax
    iretd
interrupt_15_handler:
    push    eax
    mov     eax,15
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_16_handler:
    push    eax
    mov     eax,16
    floating_point_error_handler()
    pop     eax
    iretd
interrupt_17_handler:
    push    eax
    mov     eax,17
    alignment_check_handler()
    pop     eax
    iretd
interrupt_18_handler:
    push    eax
    mov     eax,18
    machine_check_handler()
    pop     eax
    iretd
interrupt_19_handler:
    push    eax
    mov     eax,19
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_20_handler:
    push    eax
    mov     eax,20
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_21_handler:
    push    eax
    mov     eax,21
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_22_handler:
    push    eax
    mov     eax,22
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_23_handler:
    push    eax
    mov     eax,23
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_24_handler:
    push    eax
    mov     eax,24
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_25_handler:
    push    eax
    mov     eax,25
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_26_handler:
    push    eax
    mov     eax,26
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_27_handler:
    push    eax
    mov     eax,27
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_28_handler:
    push    eax
    mov     eax,28
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_29_handler:
    push    eax
    mov     eax,29
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_30_handler:
    push    eax
    mov     eax,30
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_31_handler:
    push    eax
    mov     eax,31
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_32_handler:
    push    eax
    mov     eax,32
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_33_handler:
    push    eax
    mov     eax,33
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_34_handler:
    push    eax
    mov     eax,34
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_35_handler:
    push    eax
    mov     eax,35
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_36_handler:
    push    eax
    mov     eax,36
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_37_handler:
    push    eax
    mov     eax,37
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_38_handler:
    push    eax
    mov     eax,38
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_39_handler:
    push    eax
    mov     eax,39
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_40_handler:
    push    eax
    mov     eax,40
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_41_handler:
    push    eax
    mov     eax,41
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_42_handler:
    push    eax
    mov     eax,42
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_43_handler:
    push    eax
    mov     eax,43
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_44_handler:
    push    eax
    mov     eax,44
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_45_handler:
    push    eax
    mov     eax,45
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_46_handler:
    push    eax
    mov     eax,46
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_47_handler:
    push    eax
    mov     eax,47
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_48_handler:
    push    eax
    mov     eax,48
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_49_handler:
    push    eax
    mov     eax,49
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_50_handler:
    push    eax
    mov     eax,50
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_51_handler:
    push    eax
    mov     eax,51
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_52_handler:
    push    eax
    mov     eax,52
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_53_handler:
    push    eax
    mov     eax,53
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_54_handler:
    push    eax
    mov     eax,54
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_55_handler:
    push    eax
    mov     eax,55
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_56_handler:
    push    eax
    mov     eax,56
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_57_handler:
    push    eax
    mov     eax,57
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_58_handler:
    push    eax
    mov     eax,58
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_59_handler:
    push    eax
    mov     eax,59
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_60_handler:
    push    eax
    mov     eax,60
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_61_handler:
    push    eax
    mov     eax,61
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_62_handler:
    push    eax
    mov     eax,62
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_63_handler:
    push    eax
    mov     eax,63
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_64_handler:
    push    eax
    mov     eax,64
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_65_handler:
    push    eax
    mov     eax,65
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_66_handler:
    push    eax
    mov     eax,66
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_67_handler:
    push    eax
    mov     eax,67
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_68_handler:
    push    eax
    mov     eax,68
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_69_handler:
    push    eax
    mov     eax,69
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_70_handler:
    push    eax
    mov     eax,70
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_71_handler:
    push    eax
    mov     eax,71
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_72_handler:
    push    eax
    mov     eax,72
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_73_handler:
    push    eax
    mov     eax,73
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_74_handler:
    push    eax
    mov     eax,74
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_75_handler:
    push    eax
    mov     eax,75
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_76_handler:
    push    eax
    mov     eax,76
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_77_handler:
    push    eax
    mov     eax,77
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_78_handler:
    push    eax
    mov     eax,78
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_79_handler:
    push    eax
    mov     eax,79
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_80_handler:
    push    eax
    mov     eax,80
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_81_handler:
    push    eax
    mov     eax,81
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_82_handler:
    push    eax
    mov     eax,82
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_83_handler:
    push    eax
    mov     eax,83
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_84_handler:
    push    eax
    mov     eax,84
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_85_handler:
    push    eax
    mov     eax,85
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_86_handler:
    push    eax
    mov     eax,86
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_87_handler:
    push    eax
    mov     eax,87
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_88_handler:
    push    eax
    mov     eax,88
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_89_handler:
    push    eax
    mov     eax,89
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_90_handler:
    push    eax
    mov     eax,90
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_91_handler:
    push    eax
    mov     eax,91
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_92_handler:
    push    eax
    mov     eax,92
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_93_handler:
    push    eax
    mov     eax,93
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_94_handler:
    push    eax
    mov     eax,94
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_95_handler:
    push    eax
    mov     eax,95
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_96_handler:
    push    eax
    mov     eax,96
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_97_handler:
    push    eax
    mov     eax,97
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_98_handler:
    push    eax
    mov     eax,98
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_99_handler:
    push    eax
    mov     eax,99
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_100_handler:
    push    eax
    mov     eax,100
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_101_handler:
    push    eax
    mov     eax,101
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_102_handler:
    push    eax
    mov     eax,102
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_103_handler:
    push    eax
    mov     eax,103
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_104_handler:
    push    eax
    mov     eax,104
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_105_handler:
    push    eax
    mov     eax,105
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_106_handler:
    push    eax
    mov     eax,106
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_107_handler:
    push    eax
    mov     eax,107
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_108_handler:
    push    eax
    mov     eax,108
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_109_handler:
    push    eax
    mov     eax,109
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_110_handler:
    push    eax
    mov     eax,110
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_111_handler:
    push    eax
    mov     eax,111
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_112_handler:                                              // IRQ 0
    push    eax
    mov     eax,112
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_113_handler:                                              // IRQ 1
    push    eax
    mov     eax,113
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_114_handler:                                              // IRQ 2
    push    eax
    mov     eax,114
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_115_handler:                                              // IRQ 3
    push    eax
    mov     eax,115
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_116_handler:                                              // IRQ 4
    push    eax
    mov     eax,116
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_117_handler:                                              // IRQ 5
    push    eax
    mov     eax,117
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_118_handler:                                              // IRQ 6
    push    eax
    mov     eax,118
//    call    IRQ6_handler
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_119_handler:                                              // IRQ 7
    push    eax
    mov     eax,119
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_120_handler:                                              // IRQ 8
    push    eax
    mov     eax,120
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_121_handler:                                              // IRQ 9
    push    eax
    mov     eax,121
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_122_handler:                                              // IRQ 10
    push    eax
    mov     eax,122
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_123_handler:                                              // IRQ 11
    push    eax
    mov     eax,123
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_124_handler:                                              // IRQ 12
    push    eax
    mov     eax,124
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_125_handler:                                              // IRQ 13
    push    eax
    mov     eax,125
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_126_handler:                                              // IRQ 14
    push    eax
    mov     eax,126
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_127_handler:                                              // IRQ 15
    push    eax
    mov     eax,127
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_128_handler:
    push    eax
    mov     eax,128
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_129_handler:
    push    eax
    mov     eax,129
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_130_handler:
    push    eax
    mov     eax,130
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_131_handler:
    push    eax
    mov     eax,131
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_132_handler:
    push    eax
    mov     eax,132
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_133_handler:
    push    eax
    mov     eax,133
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_134_handler:
    push    eax
    mov     eax,134
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_135_handler:
    push    eax
    mov     eax,135
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_136_handler:
    push    eax
    mov     eax,136
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_137_handler:
    push    eax
    mov     eax,137
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_138_handler:
    push    eax
    mov     eax,138
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_139_handler:
    push    eax
    mov     eax,139
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_140_handler:
    push    eax
    mov     eax,140
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_141_handler:
    push    eax
    mov     eax,141
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_142_handler:
    push    eax
    mov     eax,142
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_143_handler:
    push    eax
    mov     eax,143
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_144_handler:
    push    eax
    mov     eax,144
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_145_handler:
    push    eax
    mov     eax,145
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_146_handler:
    push    eax
    mov     eax,146
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_147_handler:
    push    eax
    mov     eax,147
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_148_handler:
    push    eax
    mov     eax,148
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_149_handler:
    push    eax
    mov     eax,149
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_150_handler:
    push    eax
    mov     eax,150
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_151_handler:
    push    eax
    mov     eax,151
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_152_handler:
    push    eax
    mov     eax,152
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_153_handler:
    push    eax
    mov     eax,153
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_154_handler:
    push    eax
    mov     eax,154
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_155_handler:
    push    eax
    mov     eax,155
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_156_handler:
    push    eax
    mov     eax,156
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_157_handler:
    push    eax
    mov     eax,157
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_158_handler:
    push    eax
    mov     eax,158
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_159_handler:
    push    eax
    mov     eax,159
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_160_handler:
    push    eax
    mov     eax,160
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_161_handler:
    push    eax
    mov     eax,161
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_162_handler:
    push    eax
    mov     eax,162
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_163_handler:
    push    eax
    mov     eax,163
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_164_handler:
    push    eax
    mov     eax,164
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_165_handler:
    push    eax
    mov     eax,165
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_166_handler:
    push    eax
    mov     eax,166
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_167_handler:
    push    eax
    mov     eax,167
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_168_handler:
    push    eax
    mov     eax,168
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_169_handler:
    push    eax
    mov     eax,169
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_170_handler:
    push    eax
    mov     eax,170
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_171_handler:
    push    eax
    mov     eax,171
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_172_handler:
    push    eax
    mov     eax,172
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_173_handler:
    push    eax
    mov     eax,173
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_174_handler:
    push    eax
    mov     eax,174
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_175_handler:
    push    eax
    mov     eax,175
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_176_handler:
    push    eax
    mov     eax,176
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_177_handler:
    push    eax
    mov     eax,177
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_178_handler:
    push    eax
    mov     eax,178
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_179_handler:
    push    eax
    mov     eax,179
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_180_handler:
    push    eax
    mov     eax,180
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_181_handler:
    push    eax
    mov     eax,181
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_182_handler:
    push    eax
    mov     eax,182
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_183_handler:
    push    eax
    mov     eax,183
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_184_handler:
    push    eax
    mov     eax,184
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_185_handler:
    push    eax
    mov     eax,185
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_186_handler:
    push    eax
    mov     eax,186
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_187_handler:
    push    eax
    mov     eax,187
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_188_handler:
    push    eax
    mov     eax,188
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_189_handler:
    push    eax
    mov     eax,189
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_190_handler:
    push    eax
    mov     eax,190
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_191_handler:
    push    eax
    mov     eax,191
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_192_handler:
    push    eax
    mov     eax,192
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_193_handler:
    push    eax
    mov     eax,193
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_194_handler:
    push    eax
    mov     eax,194
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_195_handler:
    push    eax
    mov     eax,195
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_196_handler:
    push    eax
    mov     eax,196
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_197_handler:
    push    eax
    mov     eax,197
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_198_handler:
    push    eax
    mov     eax,198
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_199_handler:
    push    eax
    mov     eax,199
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_200_handler:
    push    eax
    mov     eax,200
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_201_handler:
    push    eax
    mov     eax,201
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_202_handler:
    push    eax
    mov     eax,202
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_203_handler:
    push    eax
    mov     eax,203
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_204_handler:
    push    eax
    mov     eax,204
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_205_handler:
    push    eax
    mov     eax,205
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_206_handler:
    push    eax
    mov     eax,206
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_207_handler:
    push    eax
    mov     eax,207
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_208_handler:
    push    eax
    mov     eax,208
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_209_handler:
    push    eax
    mov     eax,209
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_210_handler:
    push    eax
    mov     eax,210
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_211_handler:
    push    eax
    mov     eax,211
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_212_handler:
    push    eax
    mov     eax,212
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_213_handler:
    push    eax
    mov     eax,213
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_214_handler:
    push    eax
    mov     eax,214
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_215_handler:
    push    eax
    mov     eax,215
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_216_handler:
    push    eax
    mov     eax,216
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_217_handler:
    push    eax
    mov     eax,217
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_218_handler:
    push    eax
    mov     eax,218
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_219_handler:
    push    eax
    mov     eax,219
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_220_handler:
    push    eax
    mov     eax,220
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_221_handler:
    push    eax
    mov     eax,221
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_222_handler:
    push    eax
    mov     eax,222
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_223_handler:
    push    eax
    mov     eax,223
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_224_handler:
    push    eax
    mov     eax,224
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_225_handler:
    push    eax
    mov     eax,225
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_226_handler:
    push    eax
    mov     eax,226
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_227_handler:
    push    eax
    mov     eax,227
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_228_handler:
    push    eax
    mov     eax,228
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_229_handler:
    push    eax
    mov     eax,229
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_230_handler:
    push    eax
    mov     eax,230
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_231_handler:
    push    eax
    mov     eax,231
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_232_handler:
    push    eax
    mov     eax,232
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_233_handler:
    push    eax
    mov     eax,233
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_234_handler:
    push    eax
    mov     eax,234
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_235_handler:
    push    eax
    mov     eax,235
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_236_handler:
    push    eax
    mov     eax,236
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_237_handler:
    push    eax
    mov     eax,237
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_238_handler:
    push    eax
    mov     eax,238
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_239_handler:
    push    eax
    mov     eax,239
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_240_handler:
    push    eax
    mov     eax,240
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_241_handler:
    push    eax
    mov     eax,241
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_242_handler:
    push    eax
    mov     eax,242
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_243_handler:
    push    eax
    mov     eax,243
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_244_handler:
    push    eax
    mov     eax,244
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_245_handler:
    push    eax
    mov     eax,245
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_246_handler:
    push    eax
    mov     eax,246
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_247_handler:
    push    eax
    mov     eax,247
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_248_handler:
    push    eax
    mov     eax,248
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_249_handler:
    push    eax
    mov     eax,249
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_250_handler:
    push    eax
    mov     eax,250
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_251_handler:
    push    eax
    mov     eax,251
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_252_handler:
    push    eax
    mov     eax,252
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_253_handler:
    push    eax
    mov     eax,253
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_254_handler:
    push    eax
    mov     eax,254
    count_interrupt_handler_eoi()
    pop     eax
    iretd
interrupt_255_handler:
    push    eax
    mov     eax,255
    count_interrupt_handler_eoi()
    pop     eax
    iretd

function irq6_handler
{
// IRQ6 (76h) ISR
    count_interrupt_handler_eoi()                             // Update count and signal end of interrupt
    push    esi
    push    ds

    mov     si,_sSYSTEM
    mov     ds,si
    inc     u8 ptr ds:[_SYSTEM_i_IRQ6_INDICATOR]                  // Raise the flag indicating this one is completed

    pop     ds
    pop     esi
    ret
}


function divide_by_zero_handler
{
;; INT 0, Divide by 0
    count_interrupt_handler_eoi()                             // Update count and signal end of interrupt
    exception_handler_fake_error_code()
    push    esi
    mov     esi,offset divide_by_zero_text
    debi_debug()
    pop     esi
//    call    debi_exception
    exception_handler_remove_error_code()
    ret
}

function debug_exception_handler
{
;; INT 1, Single-step exception
    count_interrupt_handler_eoi()                             // Update count and signal end of interrupt
    exception_handler_fake_error_code()
    push    esi
    mov     esi,offset single_step_text
    debi_debug()
//    call    debi_exception
    pop     esi
    exception_handler_remove_error_code()
    ret
}

function breakpoint_exception_handler
{
;; INT 3, Breakpoint exception
    count_interrupt_handler_eoi()                             // Update count and signal end of interrupt
    exception_handler_fake_error_code()
    push    esi
    mov     esi,offset breakpoint_text
    debi_debug()
//    call    debi_exception
    pop     esi
    exception_handler_remove_error_code()
    ret
}

function overflow_exception_handler
{
;; INT 4, Overflow exception
    count_interrupt_handler_eoi()                             // Update count and signal end of interrupt
    exception_handler_fake_error_code()
    push    esi
    mov     esi,offset overflow_text
    debi_debug()
//    call    debi_exception
    pop     esi
    exception_handler_remove_error_code()
    ret
}

function bound_range_exceeded_handler
{
;; INT 5, BOUND range exceeded exception
    count_interrupt_handler_eoi()                             // Update count and signal end of interrupt
    exception_handler_fake_error_code()
    push    esi
    mov     esi,offset bound_exception_text
    debi_debug()
//    call    debi_exception
    pop     esi
    exception_handler_remove_error_code()
    ret
}

function invalid_opcode_handler
{
;; INT 6, Invalid opcode
    count_interrupt_handler_eoi()                             // Update count and signal end of interrupt
    exception_handler_fake_error_code()
    push    esi
    mov     esi,offset invalid_opcode
    debi_debug()
//    call    debi_exception
    pop     esi
    exception_handler_remove_error_code()
    ret
}

function device_not_available_handler
{
;; INT 7, device not available exception
    count_interrupt_handler_eoi()                             // Update count and signal end of interrupt
// REMEMBER
    clts
//    push    esi
//    mov     esi,offset device_na_text
//    call    debi_debug
//    call    debi_exception
    ret
}

function double_fault_handler
{
;; INT 8, Double-fault
    count_interrupt_handler_eoi()                             // Update count and signal end of interrupt
    push    esi
    mov     esi,offset double_fault
    debi_debug()
//    call    debi_exception
    pop     esi
    exception_handler_remove_error_code()
    ret
}

function coprocessor_segment_overrun_handleressor_segment_overrun_handler PROC
{
;; INT 9, coprocessor segment overrun exception
    count_interrupt_handler_eoi()                             // Update count and signal end of interrupt
    exception_handler_fake_error_code()
    push    esi
    mov     esi,offset coprocessor_text
    debi_debug()
//    call    debi_exception
    pop     esi
    exception_handler_remove_error_code()
    ret
}

function invalid_tss_handler
{
;; INT 10, Invalid TSS
    count_interrupt_handler_eoi()                             // Update count and signal end of interrupt
    push    esi
    mov     esi,offset invalid_tss
    debi_debug()
//    call    debi_exception
    pop     esi
    exception_handler_remove_error_code()
    ret
}

function segment_not_present_handler
{
;; INT 11, segment not present exception
    count_interrupt_handler_eoi()                             // Update count and signal end of interrupt
    push    esi
    mov     esi,offset not_present_text
    debi_debug()
//    call    debi_exception
    pop     esi
    exception_handler_remove_error_code()
    ret
}

function stack_fault_handler
{
;; INT 12, Stack fault
    count_interrupt_handler_eoi()                             // Update count and signal end of interrupt
    push    esi
    mov     esi,offset stack_fault_text
    debi_debug()
//    call    debi_exception
    pop     esi
    exception_handler_remove_error_code()
    ret
}

function gp_fault_handler
{
;; INT 13, GP fault
    count_interrupt_handler_eoi()                             // Update count and signal end of interrupt
    push    esi
    mov     esi,offset gp_fault_text
    debi_debug()
//    call    debi_exception
    pop     esi
    exception_handler_remove_error_code()
    ret
}

function page_fault_handler
{
;; INT 14, page fault exception
    count_interrupt_handler_eoi()                             // Update count and signal end of interrupt
    push    esi
    mov     esi,offset page_fault_text
    debi_debug()
//    call    debi_exception
    pop     esi
    exception_handler_remove_error_code()
    ret
}

function floating_point_error_handler
{
;; INT 16, floating point exception
    count_interrupt_handler_eoi()                             // Update count and signal end of interrupt
    exception_handler_fake_error_code()
    push    esi
    mov     esi,offset floating_point_text
    debi_debug()
//    call    debi_exception
    pop     esi
    exception_handler_remove_error_code()
    ret
}

function alignment_check_handler
{
;; INT 17, alignment check exception
    count_interrupt_handler_eoi()                             // Update count and signal end of interrupt
    push    esi
    mov     esi,offset alignment_check_text
    debi_debug()
//    call    debi_exception
    pop     esi
    exception_handler_remove_error_code()
    ret
}

function machine_check_handler
{
;; INT 18, machine check exception
    count_interrupt_handler_eoi()                             // Update count and signal end of interrupt
    exception_handler_fake_error_code()
    push    esi
    mov     esi,offset machine_check_text
    debi_debug()
//    call    debi_exception
    pop     esi
    exception_handler_remove_error_code()
    ret
}




function exception_handler_fake_error_code
{
// This routine compensates for the fact that many faults do not push error codes on the stack.
// In doing so it makes everything nice, neat and tidy
//
    sub     esp,4
    push    eax
//
// Right now:  [esp+28] - eflags - code that caused the fault
//             [esp+24] -  cs - code that cause the fault
//             [esp+20] - eip - code that caused the fault
//             [esp+16] - original eax value from code that originally caused the fault/trap/interrupt handler
//             [esp+12] - return address to original fault/trap/interrupt handler
//             [esp+8] - return address to calling procedure
//             [esp+4] - space reserved for the insertion of the fake error code
//             [esp+0] - eax value saved here

;; Move the return address to calling procedure down the stack
    mov     eax,u32 ptr [esp+8]
    mov     u32 ptr [esp+4],eax

;; Move the return address to the original fault/trap/interrupt handler routine
    mov     eax,u32 ptr [esp+12]
    mov     u32 ptr [esp+8],eax

;; Move the original eax value
    mov     eax,u32 ptr [esp+16]
    mov     u32 ptr [esp+12],eax

;; Stick a value of 0 in where the error # would normally go
    mov     u32 ptr [esp+16],0
//
// And now:  [esp+28] - eflags - code that caused the fault
//           [esp+24] -  cs - code that cause the fault
//           [esp+20] - eip - code that caused the fault
//           [esp+16] - fake error code
//           [esp+12] - original eax value from code that originally caused the fault/trap/interrupt handler
//           [esp+8]  - return address to original fault/trap/interrupt handler
//           [esp+4]  - return address to calling procedure
//           [esp+0]  - eax value saved here

    pop     eax
    ret
}




function exception_handler_remove_error_code
{
// This routine removes the error code from the stack before returning to the interrupted procedure
// In doing so it makes everything nice, neat and tidy
//
    push    eax
//
// Right now:  [esp+28] - eflags - code that caused the fault
//             [esp+24] - cs - code that cause the fault
//             [esp+20] - eip - code that caused the fault
//             [esp+16] - error code
//             [esp+12] - original eax value from code that originally caused the fault/trap/interrupt handler
//             [esp+8]  - return address to original fault/trap/interrupt handler
//             [esp+4]  - return address to calling procedure
//             [esp+0]  - eax value saved here

;; Move the original eax value up one notch on the stack ladder of success
    mov     eax,u32 ptr [esp+12]
    mov     u32 ptr [esp+16],eax

;; Move the return address to original f/t/i handler up one
    mov     eax,u32 ptr [esp+8]
    mov     u32 ptr [esp+12],eax

;; Move the return address to calling procedure up one
    mov     eax,u32 ptr [esp+4]
    mov     u32 ptr [esp+8],eax

;; Move the saved eax value here
    mov     eax,u32 ptr [esp+0]
    mov     u32 ptr [esp+4],eax
    add     esp,4
//
// And now:  [esp+24] - eflags - code that caused the fault
//           [esp+20] - cs - code that cause the fault
//           [esp+16] - eip - code that caused the fault
//           [esp+12] - original eax value from code that originally caused the fault/trap/interrupt handler
//           [esp+8]  - return address to original fault/trap/interrupt handler
//           [esp+4]  - return address to calling procedure
//           [esp+0]  - eax value saved here
//
    pop     eax
    ret
}




function count_interrupt_handler_eoi
{
// This routine signals end-of-interrupt and increments a count for the interrupt handlers
    push    eax
    if (eax >= 78h && eax <= 7fh)
    {
      // It's from the SLAVE PIC, send both commands
        mov     al,20h
        out     0a0h,al
    
    } else {
        mov     al,20h
    }
    out     20h,al
    pop     eax
  // Note, execution continues here in count_interrupt_handler().  This routine was just added as a common entry point to
  //       send out the end-of-interrupt signal for interrupts that do not have a service
}
function count_interrupt_handler
{
  // Now, display a count on the screen which indicates how many keys have been pressed
    push    ds
    push    edx
    push    eax

    mov     dx,_sISR_COUNT
    mov     ds,dx
    and     eax,0ffh
    inc     u32 ptr [eax*4]                                       // We're updating the dword, so multiply by 4

    pop     eax
    pop     edx
    pop     ds
    ret
}




IFNDEF _DEBI
    function debi_debug    NEAR
    {
        ret
    }
}



function initialize_isr_counts
{
// This routine initializes all of the ISR counts to zero
    push    ds
    push    ecx

    mov     ax,_sISR_COUNT
    mov     ds,ax
    mov     ecx,256                                                 // Do it for all 256 interrupt vectors
  @@:
    mov     u32 ptr ds:[ecx*4-4],0                                // ecx*4 = 256*4 = 1024, but we're writing 4 bytes there, so -4
    loope   @B

    pop     ecx
    pop     ds
    ret
}



tss32_offset0           u8  "L16 | +000 |  link:",0
tss32_offset4           u8  " 32 | +004 |  esp0:",0
tss32_offset8           u8  "L16 | +008 |   ss0:",0
tss32_offset12          u8  " 32 | +012 |  esp1:",0
tss32_offset16          u8  "L16 | +016 |   ss1:",0
tss32_offset20          u8  " 32 | +020 |  esp2:",0
tss32_offset24          u8  "L16 | +024 |   ss2:",0
tss32_offset28          u8  " 32 | +028 |   cr3:",0
tss32_offset32          u8  " 32 | +032 |   eip:",0
tss32_offset36          u8  " 32 | +036 |eflags:",0
tss32_offset40          u8  " 32 | +040 |   eax:",0
tss32_offset44          u8  " 32 | +044 |   ecx:",0
tss32_offset48          u8  " 32 | +048 |   edx:",0
tss32_offset52          u8  " 32 | +052 |   ebx:",0
tss32_offset56          u8  " 32 | +056 |   esp:",0
tss32_offset60          u8  " 32 | +060 |   ebp:",0
tss32_offset64          u8  " 32 | +064 |   esi:",0
tss32_offset68          u8  " 32 | +068 |   edi:",0
tss32_offset72          u8  "L16 | +072 |    es:",0
tss32_offset76          u8  "L16 | +076 |    cs:",0
tss32_offset80          u8  "L16 | +080 |    ss:",0
tss32_offset84          u8  "L16 | +084 |    ds:",0
tss32_offset88          u8  "L16 | +088 |    fs:",0
tss32_offset92          u8  "L16 | +092 |    gs:",0
tss32_offset96          u8  "L16 | +096 |   ldt:",0
tss32_offset100         u8  "H16 | +100 |   i/o:",0

function iVT_display_tss32_mono
{
// This procedure is used to display TSS data on the monochrome screen
// Upon entry:   ds:[esi] - far ptr to TSS in memory
    pushad
    push    ds
    push    esi

    mov     ax,_sDATA
    mov     ds,ax

;; Clear the screen
    iVT_clear_screen_mono()                                       // Clear mono screen (the TSS display takes up most of screen)

;; Display all identifiers
    mov     esi,offset tss32_offset0                                // Display each header so the user knows what the data means
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset4
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset8
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset12
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset16
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset20
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset24
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset28
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset32
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset36
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset40
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset44
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset48
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset52
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset56
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset60
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset64
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset68
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset72
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset76
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset80
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset84
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset88
    iVT_display_string_nr_mono()
    mov     esi,offset tss32_offset92
    iVT_display_string_nr_mono()

  // These get displayed in their own column
    mov     dh,00
    mov     dl,40
    iVT_position_cursor_mono()
    mov     esi,offset tss32_offset96
    iVT_display_string_nr_mono()
    mov     dh,1
    mov     dl,40
    iVT_position_cursor_mono()
    mov     esi,offset tss32_offset100
    iVT_display_string_nr_mono()

;; Now, display TSS data
    pop     esi
    pop     ds

  // Save current color
    mov     al,cs:attribute_mono
    push    eax
  // Set new color
    mov     al,112
    iVT_set_attribute_mono()

  // Begin displaying the raw data
    mov     ecx,24                                                  // We repeat for the 24 items in the left-most column
    mov     dh,00                                                   // Start at Y=0, X=21
    mov     dl,21
  @@:
    push    ecx
    push    edx
    iVT_position_cursor_mono()                                // Move cursor there
    mov     ecx,4                                                   // Display 4 bytes
    iVT_display_hex_string_ecx_ro_mono()                      //  in hexidecimal format
    pop     edx
    pop     ecx
    inc     dh                                                      // Move down one line
    add     esi,4                                                   // Move to next item in TSS
    loop    @B

;; Now, display the remaining two items in the other column
    mov     dh,00
    mov     dl,61
    push    edx
    iVT_position_cursor_mono()
    mov     ecx,4
    iVT_display_hex_string_ecx_ro_mono()
    pop     edx
    add     esi,4

    inc     dh
    iVT_position_cursor_mono()
    mov     ecx,4
    iVT_display_hex_string_ecx_ro_mono()

    pop     eax                                                     // Returns saved attribute in al
    iVT_set_attribute_mono()

    popad
    ret
}

    xor     esi,esi
    mov     u32 ptr fs:[esi],'OY'
    mov     u32 ptr gs:[esi],'OY'
@@:
jmp     @B
//pushad
//mov edx,ebx
//mov ebx,16
//mov edi,10*80*2
//call VID_display_radix_in_edx_mono
//popad
//@@:
//jmp @B

   // Now, get ready to update the program structure
    mov     ax,_sPRIMATIVE_LOAD_INFO
    mov     fs,ax
    xor     ebp,ebp
  // Right now, fs:[ebp] - far ptr to the pimative load info memory region

;;;pushad
;;;push ds
;;;mov edx,ebx
;;;mov ebx,16
;;;xor edi,edi
;;;call VID_display_radix_in_edx_mono
;;;pop ds
;;;popad
;;;
;;;mov edx,u32 ptr ds:[esi+_BOOT_PB_size]
;;;mov ebx,16
;;;mov edi,80*2
;;;call VID_display_radix_in_edx_mono
;;;@@:
;;;hlt
;;;jmp @B


pushad
pushfd
if (edx != 0c8h)
{
    mov ebx,16
    xor edi,edi
    VID_display_radix_in_edx_mono()
}
popfd
popad



pushad
mov ax,_sGDT
mov ds,ax
mov esi,830h
mov ecx,8
xor edi,edi
VID_display_hex_string_ecx_mono()
popad
@@:
hlt
jmp @B


//@@:
//hlt
//jmp @B



    function read_8042_64h
    {
    // This routine reads one byte from port 60h into al
        in      al,064h
        call    u48 ptr cs:_xTIMER_wait_full_tick
        ret
    }




    function read_8042_60h
    {
    // This routine reads the byte in from port 60h to al
        push    ecx
        xor     ecx,ecx
      @@:
        read_8042_64h()                                       // Wait for bit 0 of port (64h) to become zero before reading
        shr     al,1
        jc      @F
        loope   @B
      @@:
        call    u48 ptr cs:_xTIMER_wait_full_tick
        in      al,060h
        pop     ecx
        ret
    }




    function write_8042_64h
    {
    // This routine writes a byte to port 64h
        call    u48 ptr cs:_xTIMER_wait_full_tick
        mov     al,ah
        out     064h,al
        ret
    }




    function write_8042_60h
    {
    // This routine writes the byte in ah to port 60h
        push    ecx
        xor     ecx,ecx
      @@:
        read_8042_64h()                                       // Wait for bit 1 of port (64h) to become zero before writing
        shr     al,2
        jnc     @F
        loope   @B
      @@:
        call    u48 ptr cs:_xTIMER_wait_full_tick
        mov     al,ah                                               // Write it
        out     060h,al
        call    u48 ptr cs:_xTIMER_wait_full_tick
        pop     ecx
        ret
    }




    function read_8042_64h_fast
    {
    // This routine reads one byte from port 60h into al
        in      al,064h
        jmp     $+2
        ret
    }




    function read_8042_60h_fast
    {
    // This routine reads the byte in from port 60h to al
        push    ecx
        xor     ecx,ecx
      @@:
        read_8042_64h_fast()                                  // Wait for bit 0 of port (64h) to become zero before reading
        shr     al,1
        jc      @F
        loope   @B
      @@:
        in      al,060h
        jmp     $+2
        pop     ecx
        ret
    }




    function write_8042_64h_fast
    {
    // This routine writes a byte to port 64h
      @@:
        mov     al,ah
        out     064h,al
        jmp     $+2
        ret
    }




    function write_8042_60h_fast
    {
    // This routine writes the byte in ah to port 60h
        push    ecx
        xor     ecx,ecx
      @@:
        read_8042_64h()                                       // Wait for bit 1 of port (64h) to become zero before writing
        shr     al,2
        jnc     @F
        loope   @B
      @@:
        mov     al,ah                                               // Write it
        out     060h,al
        jmp     $+2
        pop     ecx
        ret
    }




    function disable_keyboard
    {
    // Sends the disable keyboard command to port 64h
        push    eax
        mov     ah,0adh                                             // Disable keyboard command
        write_8042_64h()
        call    u48 ptr cs:_xTIMER_wait_full_tick
        pop     eax
        ret
    }




    function enable_keyboard
    {
    // Sends the enable keyboard command to port 64h
        push    eax
        mov     ah,0aeh                                             // Enable keyboard command
        write_8042_64h()
        call    u48 ptr cs:_xTIMER_wait_full_tick
        pop     eax
        ret
    }


//pushad
//mov edx,ebp
//mov ebx,16
//add u32 ptr gs:[_SYSTEM_i_SCRATCH_DWORD1],80
//mov edi,u32 ptr gs:[_SYSTEM_i_SCRATCH_DWORD1]
//call VID_display_radix_in_edx_mono
//popad



//pushad
//mov ax,_sPRIMATIVE_LOAD_INFO
//mov ds,ax
//mov esi,4
//mov ecx,2
//mov edi,80*2*0
//call VID_display_hex_string_ecx_mono
//
//add esi,2
//mov ecx,2
//mov edi,80*2*1
//call VID_display_hex_string_ecx_mono
//add esi,2
//
//mov ecx,1
//mov edi,80*2*2
//call VID_display_hex_string_ecx_mono
//mov cl,u8 ptr [esi]
//inc esi
//call VID_display_hex_string_ecx_mono
//add esi,ecx
//
//mov ecx,1
//mov edi,80*2*3
//call VID_display_hex_string_ecx_mono
//mov cl,u8 ptr [esi]
//inc esi
//call VID_display_hex_string_ecx_mono
//add esi,ecx
//
//mov ecx,1
//mov edi,80*2*4
//call VID_display_hex_string_ecx_mono
//mov cl,u8 ptr [esi]
//inc esi
//call VID_display_hex_string_ecx_mono
//add esi,ecx
//
//mov ecx,1
//mov edi,80*2*5
//call VID_display_hex_string_ecx_mono
//mov cl,u8 ptr [esi]
//inc esi
//call VID_display_hex_string_ecx_mono
//add esi,ecx
//
//mov ecx,4
//mov edi,80*2*6
//call VID_display_hex_string_ecx_mono
//add esi,4
//
//mov ecx,4
//mov edi,80*2*7
//call VID_display_hex_string_ecx_mono
//add esi,4
//
//mov ecx,4
//mov edi,80*2*8
//call VID_display_hex_string_ecx_mono
//add esi,4
//
//mov ecx,4
//mov edi,80*2*9
//call VID_display_hex_string_ecx_mono
//popad
//@@:
//hlt
//jmp @B


//pushad
//mov esi,edi
//mov ecx,16
//mov edi,80*2*14
//call VID_display_hex_string_ecx_mono
//popad
//@@:
//hlt
//jmp @B
//@@:
//hlt
//jmp @B
      // Now, display the palette on the mono monitor so we can determine what the fuck is wrong!!!!
//        xor     eax,eax
//        .WHILE (eax < 14h)
//            push    eax
            mov     edx,RAMDAC_INDEX_READ
            mov     al,6
            out     dx,al
            jmp     $+2
            mov     edx,RAMDAC_DATA
            in      al,dx                                           // Red
            display_al()
            in      al,dx                                           // Green
            display_al()
            in      al,dx                                           // Blue
            display_al()
            VID_move_to_next_line_mono()
//            pop     eax
//            inc     eax
//        .ENDW
      // Now, display the palette on the mono monitor so we can determine what the fuck is wrong!!!!
        xor     eax,eax
        while (eax <= 14h)
        {
            mov     ebx,eax
            display_al()

            mov     edx,STATUS_REG1
            in      al,dx
            jmp     $+2
            mov     edx,ATTRIB_INDEX
            mov     al,bl
            or      al,20h
            out     dx,al
            jmp     $+2
            jmp     $+2
            jmp     $+2
            jmp     $+2
            jmp     $+2
            mov     edx,ATTRIB_DATA_READ
            jmp     $+2
            jmp     $+2
            jmp     $+2
            jmp     $+2
            jmp     $+2
            in      al,dx                                           // Red
            display_al()
            VID_move_to_next_line_mono()

            mov     eax,ebx
            inc     eax
        }


//      // Now, display the palette on the mono monitor so we can determine what the fuck is wrong!!!!
//        xor     eax,eax
//        .WHILE (eax <= 14h)
//            mov     ebx,eax
//            call    display_al
//
//            mov     edx,STATUS_REG1
//            in      al,dx
//            call    invWait_a_bit
//
//            mov     edx,ATTRIB_INDEX
//            mov     al,bl
//            or      al,20h
//            out     dx,al
//            call    invWait_a_bit
//
//            mov     edx,ATTRIB_DATA_READ
//            in      al,dx                                           // Red
//            call    display_al
//            callf   VID_move_to_next_line_mono
//
//            mov     eax,ebx
//            inc     eax
//        .ENDW






    keyboard_logo                           u8  00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh
                                            u8  0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh
                                            u8  0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh
                                            u8  0fh,0fh,0fh,07h,07h,10h,0fh,07h,07h,10h,07h,07h,10h,07h,07h,10h,07h,07h
                                            u8  0fh,0fh,0fh,07h,07h,10h,0fh,07h,07h,10h,07h,07h,10h,07h,07h,10h,07h,07h
                                            u8  0fh,0fh,0fh,10h,10h,10h,0fh,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h
                                            u8  0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh
                                            u8  0fh,0fh,0fh,07h,07h,10h,07h,07h,10h,07h,07h,10h,07h,07h,10h,07h,07h,10h
                                            u8  0fh,0fh,0fh,07h,07h,10h,07h,07h,10h,07h,07h,10h,07h,07h,10h,07h,07h,10h
                                            u8  0fh,0fh,0fh,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h
                                            u8  0fh,0fh,0fh,07h,07h,07h,10h,07h,07h,10h,07h,07h,10h,07h,07h,10h,07h,07h
                                            u8  0fh,0fh,0fh,07h,07h,07h,10h,07h,07h,10h,07h,07h,10h,07h,07h,10h,07h,07h
                                            u8  0fh,0fh,0fh,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h
                                            u8  0fh,0fh,0fh,07h,07h,07h,07h,10h,07h,07h,10h,07h,07h,10h,07h,07h,10h,07h
                                            u8  20h,20h,20h

    mouse_logo                              u8  00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,07h,07h,07h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,00h,07h,07h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,07h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,07h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,0fh,0fh,0fh,00h,0fh,0fh,0fh,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,0fh,10h,10h,10h,00h,10h,10h,10h,0fh,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,0fh,10h,10h,10h,00h,10h,10h,10h,0fh,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,0fh,10h,10h,10h,00h,10h,10h,10h,0fh,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,0fh,00h,00h,00h,00h,00h,00h,00h,0fh,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,11h,0fh,0fh,0fh,0fh,0fh,0fh,0fh,11h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,08h,0fh,0fh,0fh,0fh,0fh,0fh,0fh,08h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,07h,0fh,0fh,0fh,0fh,0fh,07h,00h,00h,00h,00h,00h,00h
                                            u8  35h,35h,35h
                                            u8  30h,30h,30h

    chip_logo                               u8  00h,00h,00h,00h,00h,00h,00h,00h,0fh,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,00h,0fh,00h,00h,00h,0fh,00h,00h,00h,00h,00h
                                            u8  0ch,0ch,00h,00h,00h,0fh,0fh,00h,0fh,0fh,00h,00h,00h,00h,0fh,0fh,00h,00h
                                            u8  0ch,0ch,00h,00h,0fh,00h,00h,00h,0fh,00h,0fh,00h,0fh,00h,0fh,00h,0fh,00h
                                            u8  0ch,0ch,00h,00h,0fh,00h,00h,00h,0fh,00h,0fh,00h,0fh,00h,0fh,00h,0fh,00h
                                            u8  0ch,0ch,00h,00h,00h,0fh,0fh,00h,0fh,00h,0fh,00h,0fh,00h,0fh,0fh,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,0fh,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,0fh,00h,00h,00h
                                            u8  10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h
                                            u8  10h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h
                                            u8  10h,11h,07h,07h,07h,11h,07h,07h,07h,11h,07h,07h,07h,11h,07h,07h,07h,11h
                                            u8  10h,11h,07h,07h,07h,11h,07h,07h,07h,11h,07h,07h,07h,11h,07h,07h,07h,11h
                                            u8  10h,11h,11h,07h,11h,11h,11h,07h,11h,11h,11h,07h,11h,11h,11h,07h,11h,11h
                                            u8  10h,10h,10h,07h,10h,10h,10h,07h,10h,10h,10h,07h,10h,10h,10h,07h,10h,10h
                                            u8  00h,00h,00h,07h,00h,00h,00h,07h,00h,00h,00h,07h,00h,00h,00h,07h,00h,00h
                                            u8  00h,00h,00h,07h,00h,00h,00h,07h,00h,00h,00h,07h,00h,00h,00h,07h,00h,00h
                                            u8  15,15,15
                                            u8  20,20,20

    card_logo                               u8  00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,07h,07h,07h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,07h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,07h,0ah,0ah,0ah,0ah,0ah,0ah,0ah,0ah,0ah,0ah,0ah,0ah,0ah,00h
                                            u8  00h,00h,00h,07h,0ah,0ah,0ah,11h,11h,11h,11h,11h,0ah,0ah,0ah,0ah,0ah,00h
                                            u8  00h,00h,00h,07h,0ah,0ah,11h,0ch,0ch,0ch,0ch,0ch,11h,0ah,0ah,0ah,0ah,00h
                                            u8  00h,00h,00h,07h,0ah,0ah,11h,0ch,0ch,0ch,0ch,0ch,11h,0ah,0ah,0ah,0ah,00h
                                            u8  00h,00h,00h,07h,0ah,0ah,11h,0ch,0ch,0ch,0ch,0ch,11h,0ah,0ah,0ah,0ah,00h
                                            u8  00h,00h,00h,07h,0ah,0ah,11h,0ch,0ch,0ch,0ch,0ch,11h,0ah,0ah,0ah,0ah,00h
                                            u8  00h,00h,00h,07h,0ah,0ah,0ah,11h,11h,11h,11h,11h,0ah,0ah,0ah,0ah,0ah,00h
                                            u8  00h,00h,00h,07h,0ah,0ah,0ah,0ah,0ah,0ah,0ah,0ah,0ah,0ah,0ah,0ah,00h,00h
                                            u8  00h,00h,00h,07h,00h,0eh,10h,0eh,10h,0eh,10h,0eh,10h,0eh,00h,00h,00h,00h
                                            u8  00h,00h,00h,07h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  037h,037h,010h
                                            u8  000h,032h,000h

    com_logo                                u8  0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh
                                            u8  0eh,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,00h,00h,00h,11h,11h,11h,11h,11h,11h,00h,00h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,00h,00h,10h,12h,12h,12h,12h,12h,12h,10h,00h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,00h,00h,10h,12h,12h,12h,12h,12h,12h,10h,00h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,00h,00h,10h,12h,12h,12h,12h,12h,12h,10h,00h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,00h,00h,10h,10h,10h,12h,12h,10h,10h,10h,00h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,00h,00h,00h,00h,10h,10h,10h,10h,00h,00h,00h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,00h,00h,00h,00h,10h,10h,10h,10h,00h,00h,00h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,00h,00h,00h,00h,00h,10h,10h,00h,00h,00h,00h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,00h,00h,00h,00h,00h,10h,10h,00h,00h,00h,00h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,00h,00h,00h,00h,00h,10h,10h,00h,00h,00h,00h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,00h,00h,00h,00h,00h,10h,10h,00h,00h,00h,00h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,00h,00h,00h,00h,00h,10h,10h,00h,00h,00h,00h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,00h,00h,00h,00h,00h,10h,10h,00h,00h,00h,00h,00h,00h,00h,0eh
                                            u8  0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,10h,10h,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh
                                            u8  22h,22h,22h
                                            u8  34h,34h,34h
                                            u8  27h,27h,27h

    lpt_logo                                u8  0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh
                                            u8  0eh,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,00h,00h,0eh
                                            u8  0eh,00h,00h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,00h,00h,0eh
                                            u8  0eh,00h,10h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,10h,00h,0eh
                                            u8  0eh,00h,10h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,10h,00h,0eh
                                            u8  0eh,00h,10h,10h,10h,12h,12h,12h,12h,12h,12h,12h,12h,10h,10h,10h,00h,0eh
                                            u8  0eh,00h,00h,00h,10h,10h,10h,12h,12h,12h,12h,10h,10h,10h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,00h,00h,00h,10h,10h,10h,10h,10h,10h,00h,00h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,00h,00h,00h,00h,10h,10h,10h,10h,00h,00h,00h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,00h,00h,00h,00h,00h,10h,10h,00h,00h,00h,00h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,00h,00h,00h,00h,00h,10h,10h,00h,00h,00h,00h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,00h,00h,00h,00h,00h,10h,10h,00h,00h,00h,00h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,00h,00h,00h,00h,00h,10h,10h,00h,00h,00h,00h,00h,00h,00h,0eh
                                            u8  0eh,00h,00h,00h,00h,00h,00h,00h,10h,10h,00h,00h,00h,00h,00h,00h,00h,0eh
                                            u8  0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh,10h,10h,0eh,0eh,0eh,0eh,0eh,0eh,0eh,0eh
                                            u8  22h,22h,22h
                                            u8  34h,34h,34h
                                            u8  27h,27h,27h

    debi_logo                               u8  09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,00h,00h,00h,00h
                                            u8  09h,01h,01h,01h,01h,01h,01h,01h,01h,01h,01h,01h,01h,09h,09h,00h,00h,00h
                                            u8  09h,09h,09h,01h,01h,01h,01h,09h,09h,09h,09h,01h,01h,01h,01h,09h,00h,00h
                                            u8  00h,00h,09h,01h,01h,01h,01h,09h,00h,00h,00h,09h,09h,01h,01h,01h,09h,00h
                                            u8  00h,00h,09h,01h,01h,01h,0eh,09h,0eh,00h,00h,00h,09h,01h,01h,01h,01h,09h
                                            u8  00h,00h,09h,0fh,0fh,01h,04h,0ch,0ch,04h,00h,0fh,0fh,0fh,01h,01h,01h,09h
                                            u8  00h,00h,0fh,01h,01h,0fh,04h,0ch,0ch,04h,0fh,00h,00h,09h,0fh,01h,01h,09h
                                            u8  00h,00h,09h,01h,01h,01h,0ch,0ch,0ch,0ch,00h,00h,00h,09h,01h,01h,01h,09h
                                            u8  00h,00h,09h,01h,0fh,0fh,0ch,0ch,0ch,0ch,0fh,0fh,00h,09h,01h,01h,01h,09h
                                            u8  00h,00h,09h,0fh,01h,01h,04h,0ch,0ch,04h,00h,00h,0fh,0fh,01h,01h,01h,09h
                                            u8  00h,00h,0fh,01h,01h,01h,0fh,0ch,0ch,0fh,00h,00h,09h,01h,0fh,01h,01h,09h
                                            u8  00h,00h,09h,01h,01h,0fh,01h,09h,00h,00h,0fh,00h,09h,01h,01h,01h,01h,09h
                                            u8  00h,00h,09h,01h,01h,0fh,01h,09h,00h,00h,00h,0fh,09h,01h,01h,01h,09h,00h
                                            u8  09h,09h,09h,01h,0fh,01h,01h,09h,09h,09h,09h,0fh,01h,01h,01h,09h,00h,00h
                                            u8  09h,01h,01h,01h,0fh,01h,01h,01h,01h,01h,01h,01h,0fh,09h,09h,00h,00h,00h
                                            u8  09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,00h,00h,00h,00h,00h

    floppy_35_logo                          u8  00h,11h,10h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,10h,11h,00h
                                            u8  00h,11h,10h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,10h,11h,00h
                                            u8  00h,11h,00h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,10h,11h,00h
                                            u8  00h,11h,10h,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,10h,11h,00h
                                            u8  00h,11h,10h,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,10h,11h,00h
                                            u8  00h,11h,10h,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,10h,11h,00h
                                            u8  00h,11h,10h,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,10h,11h,00h
                                            u8  00h,11h,10h,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,0fh,10h,11h,00h
                                            u8  00h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,00h
                                            u8  00h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,00h
                                            u8  00h,11h,11h,11h,11h,0ch,0ch,0ch,0ch,0ch,0ch,10h,10h,10h,11h,11h,11h,00h
                                            u8  00h,11h,11h,11h,11h,0ch,10h,10h,0ch,0ch,0ch,10h,10h,10h,11h,11h,11h,00h
                                            u8  00h,11h,11h,11h,11h,0ch,10h,10h,0ch,0ch,0ch,10h,10h,10h,11h,11h,11h,00h
                                            u8  00h,11h,11h,11h,11h,0ch,10h,10h,0ch,0ch,0ch,10h,10h,10h,11h,11h,11h,00h
                                            u8  00h,00h,11h,11h,11h,0ch,10h,10h,0ch,0ch,0ch,10h,10h,10h,11h,11h,11h,00h
                                            u8  00h,00h,00h,11h,11h,0ch,0ch,0ch,0ch,0ch,0ch,11h,11h,11h,11h,11h,11h,00h
                                            u8  19h,19h,19h
                                            u8  1fh,1fh,1fh

    floppy_525_logo                         u8  08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h
                                            u8  08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h
                                            u8  08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h
                                            u8  08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,00h
                                            u8  08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h
                                            u8  08h,08h,08h,08h,08h,08h,08h,08h,00h,00h,08h,08h,08h,08h,08h,08h,08h,08h
                                            u8  08h,08h,08h,08h,08h,08h,08h,00h,00h,00h,00h,08h,08h,08h,08h,08h,08h,08h
                                            u8  08h,08h,08h,08h,08h,08h,00h,00h,00h,00h,00h,00h,08h,08h,08h,08h,08h,08h
                                            u8  08h,08h,08h,08h,08h,08h,08h,00h,00h,00h,00h,08h,08h,08h,08h,08h,08h,08h
                                            u8  08h,08h,08h,08h,08h,08h,08h,08h,00h,00h,08h,08h,07h,08h,08h,08h,08h,08h
                                            u8  08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h
                                            u8  08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h
                                            u8  08h,08h,08h,08h,08h,08h,08h,08h,07h,07h,08h,08h,08h,08h,08h,08h,08h,08h
                                            u8  08h,08h,08h,08h,08h,08h,08h,08h,07h,07h,08h,08h,08h,08h,08h,08h,08h,08h
                                            u8  08h,08h,08h,08h,08h,08h,08h,08h,07h,07h,08h,08h,08h,08h,08h,08h,08h,08h
                                            u8  08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h

    hard_drive_logo                         u8  00h,0ch,00h,10h,10h,11h,11h,11h,11h,11h,11h,11h,10h,10h,10h,10h,10h,00h
                                            u8  00h,00h,00h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,10h,10h,00h
                                            u8  00h,10h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,10h,00h
                                            u8  00h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,00h
                                            u8  00h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,00h
                                            u8  00h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,00h
                                            u8  00h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,00h
                                            u8  00h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,00h
                                            u8  00h,10h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,10h,00h
                                            u8  00h,10h,10h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,10h,10h,00h
                                            u8  00h,10h,10h,10h,10h,11h,11h,11h,11h,11h,11h,11h,10h,10h,10h,10h,10h,00h
                                            u8  00h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,10h,00h
                                            u8  00h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,10h,0fh,0fh,0fh,0fh,10h,00h
                                            u8  00h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,10h,0fh,0fh,0fh,0fh,10h,00h
                                            u8  00h,04h,07h,07h,07h,07h,07h,07h,07h,07h,07h,00h,0fh,0fh,0fh,0fh,00h,00h
                                            u8  00h,04h,07h,07h,07h,07h,07h,07h,07h,07h,07h,00h,0ch,08h,12h,0eh,00h,00h
                                            u8  18h,18h,18h
                                            u8  14h,14h,14h
                                            u8  1ah,1ah,1ah

    sound_logo                              u8  00h,00h,00h,00h,00h,00h,12h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,07h,11h,11h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,07h,12h,11h,11h,00h,00h,00h,00h,00h,00h,07h,00h,00h,00h
                                            u8  00h,00h,00h,08h,13h,12h,11h,10h,0eh,00h,00h,00h,00h,07h,00h,00h,00h,00h
                                            u8  00h,00h,08h,0eh,13h,12h,11h,10h,0eh,00h,00h,00h,07h,00h,00h,00h,00h,00h
                                            u8  00h,08h,0eh,0eh,13h,12h,11h,10h,0eh,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  08h,0eh,0eh,0eh,08h,08h,11h,10h,0eh,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  08h,0eh,0eh,0eh,08h,0eh,08h,10h,0eh,00h,00h,00h,07h,07h,07h,07h,07h,00h
                                            u8  08h,0eh,0eh,0eh,08h,0eh,08h,10h,0eh,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  08h,10h,0eh,0eh,08h,08h,11h,10h,0eh,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,08h,10h,0eh,13h,12h,11h,10h,0eh,00h,00h,00h,07h,00h,00h,00h,00h,00h
                                            u8  00h,00h,08h,10h,13h,12h,11h,10h,0eh,00h,00h,00h,00h,07h,00h,00h,00h,00h
                                            u8  00h,00h,00h,08h,13h,12h,11h,10h,0eh,00h,00h,00h,00h,00h,07h,00h,00h,00h
                                            u8  00h,00h,00h,00h,07h,12h,11h,11h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,07h,11h,11h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,12h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  38h,38h,12h
                                            u8  30h,30h,10h
                                            u8  2bh,2bh,08h
                                            u8  24h,24h,07h

    dtnprp_logo                             u8  00h,00h,00h,00h,00h,0fh,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,0fh,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,0fh,0fh,0fh,00h,0fh,0fh,0fh,00h,00h,0fh,0fh,0fh,00h,00h,00h
                                            u8  00h,00h,0fh,00h,00h,0fh,00h,0fh,00h,00h,0fh,00h,0fh,00h,00h,0fh,00h,00h
                                            u8  00h,00h,0fh,00h,00h,0fh,00h,0fh,00h,00h,0fh,00h,0fh,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,0fh,0fh,0fh,00h,0fh,00h,00h,0fh,00h,0fh,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,0fh,0fh,0fh,0fh,0fh,0fh,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,09h,09h,09h,0fh,0fh,0fh,0fh,0fh,0fh,09h,09h,09h,00h,00h,00h
                                            u8  00h,00h,00h,09h,00h,00h,0fh,0fh,0fh,0fh,0fh,0fh,00h,00h,09h,00h,00h,00h
                                            u8  00h,00h,00h,09h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,09h,00h,00h,00h
                                            u8  00h,00h,00h,09h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,09h,00h,00h,00h
                                            u8  00h,0ch,0ch,0ch,0ch,0ch,00h,00h,00h,00h,00h,00h,0ah,0ah,0ah,0ah,0ah,00h
                                            u8  00h,0ch,0ch,0ch,0ch,0ch,00h,00h,00h,00h,00h,00h,0ah,0ah,0ah,0ah,0ah,00h
                                            u8  00h,0ch,0ch,0ch,0ch,0ch,00h,00h,00h,00h,00h,00h,0ah,0ah,0ah,0ah,0ah,00h

    fat_logo                                u8  00h,00h,00h,00h,00h,0fh,0fh,00h,00h,00h,00h,00h,00h,0fh,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,0fh,00h,00h,00h,0fh,0fh,00h,00h,0fh,0fh,0fh,00h,00h,00h
                                            u8  00h,00h,00h,0fh,0fh,0fh,00h,00h,00h,00h,0fh,00h,00h,0fh,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,0fh,00h,00h,00h,0fh,0fh,0fh,00h,00h,0fh,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,0fh,00h,00h,0fh,00h,00h,0fh,00h,00h,0fh,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,0fh,00h,00h,00h,0fh,0fh,0fh,00h,00h,00h,0fh,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  0fh,0fh,0fh,0fh,0fh,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  0fh,0fh,0fh,0fh,0fh,09h,09h,09h,09h,09h,09h,09h,09h,09h,09h,00h,00h,00h
                                            u8  0fh,0fh,0fh,0fh,0fh,00h,00h,00h,09h,00h,00h,00h,00h,00h,09h,00h,00h,00h
                                            u8  00h,00h,09h,00h,00h,00h,00h,00h,09h,00h,00h,00h,00h,00h,09h,00h,00h,00h
                                            u8  00h,00h,09h,00h,00h,00h,00h,00h,09h,00h,00h,00h,00h,00h,09h,00h,00h,00h
                                            u8  00h,0ch,0ch,0ch,0ch,00h,00h,0ah,0ah,0ah,0ah,00h,00h,0eh,0eh,0eh,0eh,00h
                                            u8  00h,0ch,0ch,0ch,0ch,00h,00h,0ah,0ah,0ah,0ah,00h,00h,0eh,0eh,0eh,0eh,00h
                                            u8  00h,0ch,0ch,0ch,0ch,00h,00h,0ah,0ah,0ah,0ah,00h,00h,0eh,0eh,0eh,0eh,00h

    network_logo                            u8  00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,0fh,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,0fh,0fh,0fh,00h,00h
                                            u8  00h,00h,00h,0fh,0fh,0fh,00h,00h,00h,0fh,0fh,00h,00h,00h,0fh,00h,00h,00h
                                            u8  00h,00h,00h,0fh,00h,00h,0fh,00h,0fh,00h,0fh,0fh,00h,00h,0fh,00h,00h,00h
                                            u8  00h,00h,00h,0fh,00h,00h,0fh,00h,0fh,0fh,00h,00h,00h,00h,0fh,00h,00h,00h
                                            u8  00h,00h,00h,0fh,00h,00h,0fh,00h,00h,0fh,0fh,0fh,00h,00h,00h,0fh,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,0fh,0fh,0fh,0fh,0fh,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,0fh,0fh,0fh,0fh,0fh,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,00h,00h,10h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,0fh,0fh,0fh,00h,00h,00h,00h,00h,02h,00h,00h,00h,00h,00h,0fh,0fh,0fh
                                            u8  00h,0fh,0fh,0fh,02h,02h,02h,02h,02h,00h,02h,02h,02h,02h,02h,0fh,0fh,0fh
                                            u8  00h,0fh,0fh,0fh,00h,00h,00h,00h,00h,02h,00h,00h,00h,00h,00h,0fh,0fh,0fh
                                            u8  00h,00h,00h,00h,00h,00h,00h,00h,00h,02h,00h,00h,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,0fh,0fh,0fh,0fh,0fh,00h,00h,00h,00h,00h,00h
                                            u8  00h,00h,00h,00h,00h,00h,00h,0fh,0fh,0fh,0fh,0fh,00h,00h,00h,00h,00h,00h
                                            u8  00h,26h,00

//   grace_logo                              u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//
//   elegance_logo                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú
//                                           u8  úúúúúúúúúúúúúúúúúú

    typeset_logo                            u8  12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,0fh
                                            u8  12h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,0fh
                                            u8  12h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,0fh
                                            u8  12h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,0fh
                                            u8  12h,12h,12h,12h,12h,12h,11h,11h,11h,11h,11h,12h,12h,12h,12h,12h,12h,0fh
                                            u8  12h,10h,10h,10h,10h,10h,11h,11h,11h,11h,11h,10h,10h,10h,10h,10h,12h,0fh
                                            u8  12h,12h,12h,12h,12h,12h,11h,11h,11h,11h,11h,12h,12h,12h,12h,12h,12h,0fh
                                            u8  12h,10h,10h,10h,10h,10h,11h,11h,11h,11h,11h,10h,10h,10h,10h,12h,12h,0fh
                                            u8  12h,12h,12h,12h,12h,12h,11h,11h,11h,11h,11h,12h,12h,12h,12h,12h,12h,0fh
                                            u8  12h,10h,10h,10h,10h,10h,11h,11h,11h,11h,11h,10h,10h,10h,10h,10h,10h,0fh
                                            u8  12h,12h,12h,12h,12h,12h,11h,11h,11h,11h,11h,12h,12h,12h,12h,12h,12h,0fh
                                            u8  12h,10h,10h,10h,10h,12h,11h,11h,11h,11h,11h,12h,12h,12h,12h,12h,12h,0fh
                                            u8  12h,12h,12h,12h,12h,12h,11h,11h,11h,11h,11h,12h,12h,12h,12h,12h,12h,0fh
                                            u8  12h,12h,12h,12h,12h,12h,11h,11h,11h,11h,11h,12h,12h,12h,12h,12h,12h,0fh
                                            u8  12h,10h,10h,10h,10h,12h,11h,11h,11h,11h,11h,12h,12h,12h,12h,12h,12h,0fh
                                            u8  12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,12h,0fh
                                            u8  2dh,2dh,2dh
                                            u8  33h,00h,33h
                                            u8  3ah,3ah,3ah

    numbers_logo                            u8  10h,10h,10h,10h,12h,10h,10h,10h,10h,12h,10h,10h,10h,10h,12h,10h,10h,10h
                                            u8  10h,10h,11h,11h,11h,11h,10h,10h,10h,12h,10h,10h,11h,11h,11h,11h,10h,10h
                                            u8  12h,12h,11h,11h,11h,11h,11h,12h,12h,12h,12h,12h,11h,11h,11h,11h,12h,0fh
                                            u8  10h,10h,11h,11h,11h,11h,11h,11h,10h,12h,10h,10h,11h,11h,11h,11h,10h,10h
                                            u8  10h,10h,11h,11h,11h,11h,11h,11h,11h,12h,10h,10h,11h,11h,11h,11h,10h,10h
                                            u8  12h,12h,11h,11h,11h,11h,11h,11h,11h,11h,12h,12h,11h,11h,11h,11h,12h,0fh
                                            u8  10h,10h,11h,11h,11h,11h,11h,11h,11h,11h,11h,12h,11h,11h,11h,11h,10h,10h
                                            u8  10h,10h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,10h,10h
                                            u8  12h,12h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,12h,0fh
                                            u8  10h,10h,11h,11h,11h,11h,12h,11h,11h,11h,11h,11h,11h,11h,11h,11h,10h,10h
                                            u8  10h,10h,11h,11h,11h,11h,12h,12h,11h,11h,11h,11h,11h,11h,11h,11h,10h,10h
                                            u8  12h,12h,11h,11h,11h,11h,10h,10h,10h,11h,11h,11h,11h,11h,11h,11h,12h,0fh
                                            u8  10h,10h,11h,11h,11h,11h,10h,10h,10h,12h,11h,11h,11h,11h,11h,11h,10h,10h
                                            u8  10h,10h,11h,11h,11h,11h,12h,12h,12h,12h,12h,11h,11h,11h,11h,11h,10h,10h
                                            u8  12h,12h,11h,11h,11h,11h,10h,10h,10h,12h,10h,10h,11h,11h,11h,11h,12h,0fh
                                            u8  10h,10h,10h,10h,12h,10h,10h,10h,10h,12h,10h,10h,10h,10h,12h,10h,10h,10h
                                            u8  2dh,2dh,2dh
                                            u8  33h,00h,33h
                                            u8  3ah,3ah,3ah       // Initialize internal constants
        mov     ds:timer_max_hz,182                                 // timer_max_hz = 182
        mov     u32 ptr ds:timer_max_value[0],0c7e9b820h          // timer_max_value = 119318100000 = 1bc7e9b820h
        mov     u32 ptr ds:timer_max_value[4],01bh

        mov     esi,offset timer_area
        mov     u16 ptr [esi+_TIMER_GDT],0ffffh                    // GDT entry (0ffffh means it's the system time-of-day event)
        mov     u16 ptr [esi+_TIMER_LDT],0                         // LDT (it's the _sTIMER descriptor)
        mov     u32 ptr [esi+_TIMER_INC_VALUE],0c75ed2bah         // We have set the timer to interrupt ~182 times/second.  See
        mov     u32 ptr [esi+_TIMER_INC_VALUE+4],01bh             // the note above about this value.
        mov     u32 ptr [esi+_TIMER_CURRENT_VALUE],0
        mov     u32 ptr [esi+_TIMER_CURRENT_VALUE+4],0
        mov     u32 ptr [esi+_TIMER_ORIGINAL_FREQ],433610A2h      // * Note:  433610A2h = f32 182.064971924 in dword format
      // Terminate the listings entry                                //          MASM won't recognize "mov f32 ptr [si+20],182.0"
        add     esi,_TIMER_STRUCT_LENGTH                            //          even though it's only a 4-byte move.  Oh well!
        mov     u32 ptr [esi],0ffffffffh

       // Wait for CMOS to be ready for us to read
        mov     al,_CMOS_STATUS_REGISTER_A                          // Tell CMOS we want to read the status register A
        out     _CMOS_70h,al                                        // First, wait for it to go high (because we could've been very
        @IO_pause                                                   // lucky and gotten in while it was low, but it could've been

        xor     ecx,ecx                                             // Set a limit as to how long it waits
      wait_high:
        in      al,_CMOS_71h                                        // Read the data
        test    al,80h                                              // We're waiting for it to go high (1)
        loopnzd wait_high                                           // If branch then it's low (0)

        xor     ecx,ecx
      wait_low:
        in      al,_CMOS_71h                                        // Read the data
        test    al,80h                                              // We're waiting for it to go low (0)
        loopzd  wait_low                                            // If branch then it's high (1)

       // Initialize constants
        mov     ax,_sSYSTEM_AREA                                    // We're going to be storing time and date information
        mov     ds,ax
        mov     u8 ptr ds:[_SYSTEM_SECONDS_SINCE_BOOTUP],0        // Initialize the one's that aren't calculation dependent
        mov     u8 ptr ds:[_SYSTEM_182S_OF_A_SECOND],0

       // Read CMOS and store the converted BCD data as integers
        fninit                                                      // Initialize the fpu (we'll be using it shortly)
        xor     eax,eax                                             // Clear off all bits (we'll be loading BCD into fpu)
        xor     ebx,ebx
        mov     edi,offset cmos_conversion_table                    // * Note:  Refer to bootup.com for information
        while (byte ptr cs:[edi] != 0ffh)
        {
            mov     al,u8 ptr cs:[edi]                            // Read the CMOS register to read in
            inc     di
            out     _CMOS_70h,al                                    // Tell CMOS what we'll be reading
            @IO_pause
            in      al,_CMOS_71h                                    // Read it

            mov     ah,u8 ptr cs:[edi]
            inc     di
            if (ah == _BCD_CONVERT)
            {
                push    u32 ptr 0                                 // Stick 6 extra bytes on the stack (fbld loads tbyte ptr)
                push    u16 ptr 0
                and     eax,0ffh
                push    eax                                         // Stick it on the stack (remember eax's other bits are clear)
                mov     ebp,esp
                fbld    tbyte ptr [ebp]                             // Load it as a BCD
                fistp   u32 ptr [ebp]                             // Store it as an integer
                pop     eax                                         // And load it back into eax as an integer
                add     esp,6                                       // Clear the 6 bytes back off the stack
            }

            mov     bl,u8 ptr cs:[edi]                            // Populate bx with the offset in _sSYSTEM_AREA to store this byte
            inc     edi
            mov     u8 ptr [ebx],al                               // And store the integer version of the BCD data
        }
        add     u16 ptr ds:[_SYSTEM_YEAR],2000                     // Adjust the century (CMOS stores xx=00-99, we assume 2000+xx)
        mov     ds,cs:data_segment
       // Setup the TSS in the GDT
        mov     eax,_sTASK_MGR_TSS / 8
        mov     ebx,82080h
        mov     edx,07fh                                            // 128 bytes
        create_tss_descriptor32()

       // Physically create the TSS in memory
        push    ds
        mov     ax,_sALL_MEM
        mov     ds,ax
        mov     esi,82080h
      // Right now, ds:[esi] - far ptr to TSS location in memory
        mov     ebx,_sCODE
        mov     ecx,offset timer_handler
        mov     edx,_sTASK_MGR_STACK
        mov     edi,1ffch                                           // 8k stack
        create_tss32()
        pop     ds


        mov     ebx,u32 ptr ds:timer_max_value[0]
        mov     ecx,u32 ptr ds:timer_max_value[4]

     // Increment all of the timer event counters
        mov     esi,offset timer_area
        jmp     timer_loop                                          // We know there is always at least one event (the system timer)
        while (dword ptr ds:[esi+_TIMER_GDT_LDT] != -1)
        {
          timer_loop:
            if (dword ptr ds:[esi+_TIMER_GDT_LDT] != 0fffffffeh)
            {
              // This is 64-bit math.  Rather than use the FPU we do it in integers because it's faster
              // This routine is called a minimum of 182 times per second, and possible one hell of a lot more!
                mov     eax,u32 ptr ds:[esi+_TIMER_INC_VALUE]                 // Load increment value into edx:eax
                mov     edx,u32 ptr ds:[esi+_TIMER_INC_VALUE+4]
                add     u32 ptr ds:[esi+_TIMER_CURRENT_VALUE],eax             // Increment the current value
                adc     u32 ptr ds:[esi+_TIMER_CURRENT_VALUE+4],edx

                cmp     u32 ptr ds:[esi+_TIMER_CURRENT_VALUE+4],ecx           // Are we beyond the maximum count value in the high dword?
                ja      timer_adjust_counter                                    // Yes if branch, this means we're definately over
                jnz     timer_next_slot                                         // If branch, then it's less than the high dword (not yet)

                cmp     u32 ptr ds:[esi+_TIMER_CURRENT_VALUE],ebx             // Is the low dword >= ebx?
                jb      timer_next_slot                                         // No if branch

              timer_adjust_counter:                                             // Yes, it is!  Process it!
                sub     u32 ptr ds:[esi+_TIMER_CURRENT_VALUE],ebx             // Reset the counter value down (keeping the overflow)
                sbb     u32 ptr ds:[esi+_TIMER_CURRENT_VALUE+4],ecx
              timer_execute_task:
                cmp     u16 ptr ds:[esi+_TIMER_GDT],0ffffh
                jnz     timer_application_event                jmp     timer_next_slot


              timer_application_event:                               // It's an application event
                 // REMEMBER
                jmp     timer_next_slot
            }
          timer_next_slot:
            add     esi,_TIMER_STRUCT_LENGTH
        }



//        dec     esi
//        inc     u8 ptr ds:[esi]
//        cmp     u8 ptr ds:[esi],60
//        jb      timer_system_event_done
//        mov     u8 ptr ds:[esi],al
//
//     // Increment the minutes
//        dec     esi
//        inc     u8 ptr ds:[esi]
//        cmp     u8 ptr ds:[esi],59
//        jb      timer_system_event_done
//        mov     u8 ptr ds:[esi],al
//
//     // Increment the hours
//        dec     esi
//        inc     u8 ptr ds:[esi]
//        cmp     u8 ptr ds:[esi],24
//        jb      timer_system_event_done
//        mov     u8 ptr ds:[esi],0
//
//     // Increment the date (we're into the next day here)
//        call    invTIMER_system_event_next_date


    function invTIMER_system_event_next_date
    {
    // This routine ensures that the date is valid
    // It has to do some more complex math so it was brought into its own algorithm
        push    ax
        push    dx

       // Increment the day of the month
        inc     u8 ptr ds:[_SYSTEM_DAY]

       // See if we're into the next month
        mov     dl,u8 ptr ds:[_SYSTEM_MONTH]
        if (dl == 1 || dl == 3 || dl == 5 || dl == 7 || dl == 8 || dl == 10 || dl == 12)
        {
          // We're in months with 31 days, Jan, Mar, May, Jul, Aug, Oct, Dec
            if (byte ptr ds:[_SYSTEM_DAY] > 31)
            {
                jmp     goto_next_month
            }
        
        } else if (dl == 2) {
          // We're in February, we need to see if it's a leap year
            mov     ax,u16 ptr ds:[_SYSTEM_YEAR]
            shr     ax,1
            if (carry?)
            {
              not_a_leap_year:                                      // It's not a leap year, because it's odd
                if (byte ptr ds:[_SYSTEM_DAY] > 28)                // Is the day > 28?
                {
                    jmp     goto_next_month                         // If branch, yes
                }
            
            } else {
                shr     ax,1
                if (carry?)
                {
                    jmp     not_a_leap_year                         // It's not a leap year, (not evenly divisible by 4)
                
                } else {
;; REMEMBER, have to add an algorithm here to weed out any century not evenly divisble by 400, those aren't leap years
                    if (byte ptr ds:[_SYSTEM_DAY] > 29)            // It's a leap year
                    {
                        jmp     goto_next_month
                    }
                }
            }
        
        } else {
          // We're in months with 30 days, Apr, Jun, Sep, Nov
            if (byte ptr ds:[_SYSTEM_DAY] > 30)
            {
              goto_next_month:
                mov     u8 ptr ds:[_SYSTEM_DAY],1
                inc     u8 ptr ds:[_SYSTEM_MONTH]
                if (byte ptr ds:[_SYSTEM_MONTH] > 12)
                {
                    mov     u8 ptr ds:[_SYSTEM_MONTH],1
                    inc     u16 ptr ds:[_SYSTEM_YEAR]
                }
            }
        }

       // Reset the seconds since midnight
        mov     u32 ptr ds:[_SYSTEM_SECONDS_SINCE_MIDNIGHT],0

        pop     dx
        pop     ax
        ret
    }

                        
                        } else if (al == _16_8_8) {
                            mov     u32 ptr [ebp-092],edx
                          // Do the upper 16-bits
                            shr     edx,16
                          // Right now, edx - lower word contains the upper 16-bits of the value specified
                          //            ebx - 16 (base-16 number, it will be displayed in hexidecimal)
                            mov     eax,u32 ptr ds:[edi+5]        // x
                            add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                            push    eax
                            mov     eax,u32 ptr ds:[edi+9]        // y
                            add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                            push    eax
                            mov     ecx,4                           // number of digits to display
                            invDEBI_add_radix_object()
                            call    u48 ptr ds:_VID_g_display_radix_in_edx_mono

                          // Do the xh byte (bits 8-15)
                            mov     edx,u32 ptr [ebp-092]
                            shr     edx,8
                            and     edx,0ffh
                          // Right now, edx - lower byte contains the bits 8-15
                          //            ebx - 16 (base-16number, it will be displayed in hexidecimal)
                            mov     eax,u32 ptr ds:[edi+5]        // x
                            add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                            add     eax,5*8
                            push    eax
                            mov     eax,u32 ptr ds:[edi+9]        // y
                            add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                            push    eax
                            mov     ecx,2                           // number of digits to display
                            invDEBI_add_radix_object()
                            call    u48 ptr ds:_VID_g_display_radix_in_edx_mono

                          // Do the xl byte (bits 0-7)
                            mov     edx,u32 ptr [ebp-092]
                            and     edx,0ffh
                          // Right now, edx - lower byte contains the bits 0-7
                          //            ebx - 16 (base-16 number, it will be displayed in hexidecimal)
                            mov     eax,u32 ptr ds:[edi+5]        // x
                            add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                            add     eax,8*8
                            push    eax
                            mov     eax,u32 ptr ds:[edi+9]        // y
                            add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                            push    eax
                            mov     ecx,2                           // number of digits to display
                            invDEBI_add_radix_object()
                            call    u48 ptr ds:_VID_g_display_radix_in_edx_mono
                        
                        } else if (al == _16_16) {
                            mov     u32 ptr [ebp-092],edx
                          // Do the upper 16-bits
                            shr     edx,16
                          // Right now, edx - lower word contains the upper 16-bits of the value specified
                          //            ebx - 16 (base-16 number, it will be displayed in hexidecimal)
                            mov     eax,u32 ptr ds:[edi+5]        // x
                            add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                            push    eax
                            mov     eax,u32 ptr ds:[edi+9]        // y
                            add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                            push    eax
                            mov     ecx,4                           // number of digits to display
                            invDEBI_add_radix_object()
                            call    u48 ptr ds:_VID_g_display_radix_in_edx_mono

                          // Do the lower 16-bits
                            mov     edx,u32 ptr [ebp-092]
                            and     edx,0ffffh
                          // Right now, edx - lower word of the value specified
                          //            ebx - 16 (base-16 number, it will be displayed in hexidecimal)
                            mov     eax,u32 ptr ds:[edi+5]        // x
                            add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_HORIZONTAL]
                            add     eax,5*8
                            push    eax
                            mov     eax,u32 ptr ds:[edi+9]        // y
                            add     eax,u32 ptr ds:[esi+_ST_OBJECT_UL_VERTICAL]
                            push    eax
                            mov     ecx,4                           // number of digits to display
                            invDEBI_add_radix_object()
                            call    u48 ptr ds:_VID_g_display_radix_in_edx_mono

//--------------------------
inc     u32 ptr [esp+64]
cmp     u32 ptr [esp+64],6
jnz     skip_halt
   mov edx,[esp+68]
   mov edi,(80*2)*0
   mov ebx,16
   VID_display_radix_in_edx_mono()

   mov edx,[esp+72]
   mov edi,(80*2)*1
   VID_display_radix_in_edx_mono()

   mov edx,[esp+76]
   mov edi,(80*2)*2
   VID_display_radix_in_edx_mono()

   mov edx,[esp+80]
   mov edi,(80*2)*3
   VID_display_radix_in_edx_mono()
   @@:
     hlt
     jmp @B
skip_halt:
//--------------------------



// LOAD_XDEBUG()
ifdef _XDEBUG
{
    mov     ax,0200h + 14                                           // Read 14 debug program sectors
    mov     bx,7000h                                                // Store at 7000:0000h, or 7000h
    mov     es,bx
    xor     bx,bx
    mov     cx,5h                                                   // track 0/sector 5
    xor     dx,dx                                                   // head 0/drive 0
    int     13h                                                     // Read the bad boy
    jnc     Read_Sectors2
    jmp     Read_Sectors1
  Read_Sectors2:
// * Note:  If this is turned on, make sure code in PB.ASM puts XDEBUG.COM in this file area
    mov     ax,0200h + 18                                           // Read next 18 debug prog sectors
    mov     bx,512 * 14
    mov     cx,1                                                    // track 0/sector 1
    mov     dx,100h                                                 // head 1/drive 0
    int     13h                                                     // Read the bad boy
    jnc     Read_Sectors3
    jmp     Read_Sectors2
  Read_Sectors3:
    mov     ax,0200h + 18                                           // Read next 18 debug prog sectors
    mov     bx,512 * (18+14)
    mov     cx,4f01h                                                // track 79/sector 1
    xor     dx,dx                                                   // head 0/drive 0
    int     13h                                                     // Read the bad boy
    jnc     setup_debugger
    jmp     Read_Sectors3
  Setup_Debugger:
    xor     ax,ax
    mov     fs,ax
    mov     eax,70000000h                                           // Segment (7000h), Offset (0h), linear = 70000h
    mov     u32 ptr FS:[1*4],eax                                  // INT1, single-step
    mov     u32 ptr FS:[3*4],eax                                  // INT3, software breakpoint
}; Turn off the floppy drive motor
    mov     al,001100b
    mov     edx,03f2h
    out     dx,al



//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
//
// +------------------------+
// | _TEXT_FIELD PARAMETERS |
// +------------------------+
_TFP_ENABLED                        EQU
_TFP_VISIBLE                        EQU
_TFP_ALIGNMENT                      EQU
_TFP_AUTO_SIZE                      EQU
_TFP_BORDER                         EQU
_TFP_COLOR_DISABLEP_BACKGROUND      EQU
_TFP_COLOR_DISABLEP_FOREGROUND      EQU
_TFP_COLOR_DISABLEP_STYLE           EQU
_TFP_COLOR_ENABLEP_BACKGROUND       EQU
_TFP_COLOR_ENABLEP_FOREGROUND       EQU
_TFP_COLOR_ENABLEP_STYLE            EQU
_TFP_COLOR_SELECTEP_BACKGROUND      EQU
_TFP_COLOR_SELECTEP_FOREGROUND      EQU
_TFP_COLOR_SELECTEP_STYLE           EQU
_TFP_FONT_NAME                      EQU
_TFP_FONT_SIZE                      EQU
_TFP_FONT_TYPEFACE_BOLD             EQU
_TFP_FONT_TYPEFACE_DITHER           EQU
_TFP_FONT_TYPEFACE_ITALICS          EQU
_TFP_FONT_TYPEFACE_REVERSE          EQU
_TFP_FONT_TYPEFACE_STRIKETHROUGH    EQU
_TFP_FONT_TYPEFACE_UNDERLINE        EQU
_TFP_FONT_NAME_ID                   EQU
_TFP_MARGIN_LEFT                    EQU
_TFP_MARGIN_RIGHT                   EQU
_TFP_MARGIN_TOP                     EQU
_TFP_MARGIN_BOTTOM                  EQU
_TFP_MISC_1                         EQU
_TFP_MISC_2                         EQU
_TFP_MISC_3                         EQU
_TFP_MISC_4                         EQU
_TFP_MOUSE_POINTER                  EQU
_TFP_POSITION_HEIGHT                EQU
_TFP_POSITION_LEFT                  EQU
_TFP_POSITION_TOP                   EQU
_TFP_POSITION_WIDTH                 EQU
_TFP_SELECTEP_END                   EQU
_TFP_SELECTEP_START                 EQU
_TFP_SELECT_ALL_AT_GET_FOCUS        EQU
_TFP_MISC_FLAG_1                    EQU
_TFP_MISC_FLAG_2                    EQU
_TFP_MISC_FLAG_3                    EQU
_TFP_SIZEABLE                       EQU
_TFP_SOURCE_INPUT_FORMAT            EQU
_TFP_SOURCE_INPUT_MASK              EQU
_TFP_SOURCE_MAX_LENGTH              EQU
_TFP_SOURCE_OFFSET                  EQU
_TFP_TAB_INDEX                      EQU
_TFP_TAB_STOP                       EQU
_TFP_UNDO                           EQU
_TFP_WRAP_TEXT                      EQU
_TFP_ZERO_CHAR                      EQU
_TFP_ZERO_CONTENTS                  EQU

_TFE_CLICK_BOTH_SINGLE              EQU
_TFE_CLICK_BOTH_DOUBLE              EQU
_TFE_CLICK_LEFT_SINGLE              EQU
_TFE_CLICK_LEFT_DOUBLE              EQU
_TFE_CLICK_LEFT_DOWN                EQU
_TFE_CLICK_LEFT_UP                  EQU
_TFE_CLICK_RIGHT_SINGLE             EQU
_TFE_CLICK_RIGHT_DOUBLE             EQU
_TFE_CLICK_RIGHT_DOWN               EQU
_TFE_CLICK_RIGHT_UP                 EQU
_TFE_DROPPED_INTO_LEFT              EQU
_TFE_DROPPED_INTO_RIGHT             EQU
_TFE_DRAG_LEFT_START                EQU
_TFE_DRAG_LEFT_STOP                 EQU
_TFE_DRAG_RIGHT_START               EQU
_TFE_DRAG_RIGHT_STOP                EQU
_TFE_FOCUS_GOT                      EQU
_TFE_FOCUS_LOST                     EQU
_TFE_FOCUS_SET                      EQU
_TFE_HOVER                          EQU
_TFE_KEYSTROKE_BEFORE               EQU
_TFE_KEYSTROKE_AFTER                EQU
_TFE_WHEN_CREATED                   EQU
_TFE_WHEN_DESTROYED                 EQU
_TFE_REQUESTOR                      EQU
_TFE_RESIZED_AFTER                  EQU
_TFE_RESIZED_BEFORE                 EQU
_TFE_UNDO_BEFORE                    EQU
_TFE_UNDO_AFTER                     EQU
pushad
xor     eax,eax
mov     edx,u32 ptr ds:[_TASK_SYSTEM_CURRENT_TASK_OFFSET]
if (edx != _FIRST_TASK_ENTRY)
{
    mov     ebx,16
    mov     ecx,8
    push    0
    push    0
    call    u48 ptr cs:_VID_g_display_radix_in_edx_mono
}
popad
