BAlive Intermediate Language
by Rick C. Hodgin
----------------------------

Jan.22.2016 -- I've had the idea to create an intermediate language which
possesses limited typing abilities, expressly limited to:

    s8/u8    -- signed, unsigned 8-bit
    s16/u16  -- signed, unsigned 16-bit
    s32/u32  -- signed, unsigned 32-bit
    s64/u64  -- signed, unsigned 64-bit
    f32/f64  -- 32-bit and 64-bit floating point IEEE-754

Local variables and structure members are declared to be either fundamental
types, pointers to fundamental types, or fixed-size array blocks, as in
this structur example (for local variables, simply declared within the
function, or global variables, simply declared outside a function):

    struct SExample
    {
        s8   single_character;
        s8   fixed_size_array[10];
        s8   pointer_to_allocated_block[];
    }

-----
Functions are declared similarly to those in CAlive, but there is no explicit
returns clause, and a new attribute is added to each parameter allowing it to
be flagged as an input-only value (the function will not alter its contents),
an output-only value (the function will replace its contents), or an input-
and-output value (the function will read the input, and may at any time
replace its contents):

    function name
    | params in  s32 a     // Input parameter, unchanged
    | params out s32 b     // Output parameter, overwrites whatever's there
    | params     s32 c     // Input+output parameter, use and overwrite
    {
        // Code goes here
    }

The parameter a is declared as input-only.  Parameter b is declared as
output-only.  And parameter c is declared as input-and-output, and therefore
does not have or need an explicit declaration as this is the default type.
By this form, parameters are either passed by-reference or by-value.

-----
BAlive will impose no forward declaration requirements.  It will look to
the entire compilation to determine what is in-scope and out-of-scope.

BAlive is free to analyze anything it sees and optimize the code, provided
the generated output mimics the behavior of the source code.  Source code
can be flagged in keep {{ }} blocks (which need not be nested properly), to
indicate to the compiler that certain parts are to be literal and cannot
be swapped out with optimized code.  For example:

    keep {{
        function main
        | params out s32 result
        | params     s32 argc
        | params     s8p argv[]
        {
    }}
            // Source code goes here
        }

In this example, the parameters that are passed will be kept as they are,
and will not be changed.

-----
BAlive will be a singe-expression language.  It will only allow one operation
to take place per line.  You cannot do this in BAlive:

    y = a + b + c;
    x = f(g(y));

Instead, you must do this:

    y = a + b;  // Only a single operation per line (result = a op b)
    y += c;     // Conventional operators are allowed
    g(t, y);    // t is output, y is input
    f(x, t);    // x is output, t is input

It is more verbose, but it is the intention to keep it very close to an
assembly language.  As such, these are keywords and syntaxes:

    (a >= b) goto label_name;

In this case, the test acts like a predicate.  If a is greater-than-or-equal-
t b, then it will branch to the label called "label_name".  If not, it will
continue on to the next line of code.  This translates to the following:

In CAlive:
    if (a >= b)    printf("greater than or equal to\n");
    else           printf("less than\n");

...in BAlive:

        (a >= b) goto compare_was_false
        printf("greater than or equal to\n");
        goto continue_on
    :compare_was_false
        printf("less than\n");
    :continue_on

...and it is the intention to ultimately create an AAlive language, which
is an assembly language format which follow a similar progression, allowing
the above, for example, to be translated into these i386 equivalents:

        predicate   instruction   parameters
        ---------   -----------   -------------------
                    mov           eax,a
                    cmp           eax,b
          (!>=)     jmp           compare_was_false
                    push          "greater than or equal to\n\0"
                    jmp           common_function_call
        :compare_was_false
                    push          "less than\n\0"
        :common_function_call
                    call          printf

...which is then assembled down into machine code:

        // Somewhere in header code:
        message1:  "greater than or equal to\n\0"
        message2:  "less than\n\0"

        // In program flow:
            mov     eax,a
            cmp     eax,b
            jl      compare_was_false
            push    offset message1
            jmp     common_function_call
        :compare_was_false
            push    offset message2
        :common_function_call
            call    printf

-----
This will result in a very vertically-heavy language, however, its purpose
is to provide a symbolic way to look at assembly source code.  As such, it
should be very close to the 1:1 nature of most assembly instructions, yet
in symbolic form able to be understood by non-assembly programmers, and
also assembly programmers, to see the translation between CAlive source
code, and assembly, through this intermediate lens.

Best regards,
Rick C. Hodgin

