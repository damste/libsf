LASM -- Intel 80386 Instructions
================================


-----
	2E			CS: override prefix
	36			SS: override prefix
	3E			DS: override prefix
	26			ES: override prefix
	64			FS: override prefix
	65			GS: override prefix
	66			Operand size override prefix
	67			Address size override prefix

-----
	F0			LOCK prefix
	F2			REPne/z prefix
	F3			REP/e/z prefix

-----
	+cc =	0	O
			1	NO
			2	B,NAE
			3	AE,NB
			4	Z,E
			5	NZ,NE
			6	NA,BE
			7	A,NBE
			8	S
			9	NS
			a	P,PE
			b	NP,PO
			c	L,NGE
			d	GE,NL
			e	LE,NG
			f	G,NLE

-----
	37			AAA					-- ASCII adjust al after addition
	D5,0A		AAD					-- ASCII adjust ax before division
	D5,0A		AAD					-- ASCII adjust eax before division
	D5,ib		AAD2				-- ASCII adjust ax before division to base imm8
	D5,ib		AAD2				-- ASCII adjust eax before division to base imm8
	D4,0A		AAM					-- ASCII adjust ax after multiply
	D4,0A		AAM					-- ASCII adjust eax after multiply
	D5,ib		AAM2				-- ASCII adjust ax after multiply to base imm8
	D5,ib		AAM2				-- ASCII adjust eax after multiply to base imm8
	3F			AAS					-- ASCII adjust al after subtraction
	
	14,ib		ADC al,imm8			-- Add with carry imm8 to al
	15,iw		ADC ax,imm16		-- Add with carry imm16 to ax
	15,id		ADC eax,imm32		-- Add with carry imm32 to eax
	80/2,ib		ADC r/m8,imm8		-- Add with carry imm8 to r/m8
	81/2,iw		ADC r/m16,imm16		-- Add with carry imm16 to r/m16
	81/2,iw		ADC r/m32,imm32		-- Add with carry imm32 to r/m32
	83/2,ib		ADC r/m16,imm8		-- Add with carry sign-extended imm8 to r/m16
	83/2,ib		ADC r/m32,imm8		-- Add with carry sign-extended imm8 to r/m32
	10/r		ADC r/m8,r8			-- Add with carry r8 to r/m8
	11/r		ADC r/m16,r16		-- Add with carry r16 to r/m16
	11/r		ADC r/m32,r32		-- Add with carry r32 to r/m32
	12/r		ADC r16,r/m16		-- Add with carry r/m16 to r16
	12/r		ADC r32,r/m32		-- Add with carry r/m32 to r32
	13/r		ADC r16,r/m16		-- Add with carry r/m16 to r16
	13/r		ADC r32,r/m32		-- Add with carry r/m32 to r32
	
	04,ib		ADD al,imm8			-- Add imm8 to al
	05,iw		ADD ax,imm16		-- Add imm16 to ax
	05,id		ADD eax,imm32		-- Add imm32 to eax
	80/0,ib		ADD r/m8,imm8		-- Add imm8 to r/m8
	81/0,iw		ADD r/m16,imm16		-- Add imm16 to r/m16
	81/0,iw		ADD r/m32,imm32		-- Add imm32 to r/m32
	83/0,ib		ADD r/m16,imm8		-- Add sign-extended imm8 to r/m16
	83/0,ib		ADD r/m32,imm8		-- Add sign-extended imm8 to r/m32
	00/r		ADD r/m8,r8			-- Add r8 to r/m8
	01/r		ADD r/m16,r16		-- Add r16 to r/m16
	01/r		ADD r/m32,r32		-- Add r32 to r/m32
	02/r		ADD r16,r/m16		-- Add r/m16 to r16
	02/r		ADD r32,r/m32		-- Add r/m32 to r32
	03/r		ADD r16,r/m16		-- Add r/m16 to r16
	03/r		ADD r32,r/m32		-- Add r/m32 to r32
	
	24,ib		AND al,imm8			-- imm8  al
	25,iw		AND ax,imm16		-- imm16 to ax
	25,id		AND eax,imm32		-- imm32 to eax
	80/4,ib		AND r/m8,imm8		-- imm8 to r/m8
	81/4,iw		AND r/m16,imm16		-- imm16 to r/m16
	81/4,iw		AND r/m32,imm32		-- imm32 to r/m32
	83/4,ib		AND r/m16,imm8		-- sign-extended imm8 to r/m16
	83/4,ib		AND r/m32,imm8		-- sign-extended imm8 to r/m32
	20/r		AND r/m8,r8			-- r8 to r/m8
	21/r		AND r/m16,r16		-- r16 to r/m16
	21/r		AND r/m32,r32		-- r32 to r/m32
	22/r		AND r16,r/m16		-- r/m16 to r16
	22/r		AND r32,r/m32		-- r/m32 to r32
	23/r		AND r16,r/m16		-- r/m16 to r16
	23/r		AND r32,r/m32		-- r/m32 to r32

	63/r		APRL r/m16,r16		-- Adjust RPL of r/m16 to not less than RPL of r16

	62/r		BOUND r16,m16&16	-- Check if r16 (array index) is within bounds specified by m16&16
	62/r		BOUND r32,m32&32	-- Check if r32 (array index) is within bounds specified by m32&32

	0F,BC		BSF r16,r/m16		-- Bit scan forward on r/m16
	0F,BC		BSF r32,r/m32		-- Bit scan forward on r/m32

	0F,BD		BSR r16,r/m16		-- Bit scan reverse on r/m16
	0F,BD		BSR r32,r/m32		-- Bit scan reverse on r/m32

	0F,C8+r		BSWAP r32			-- Swap endian on 32-bit register

	0F,A3		BT r/m16,r16		-- Store selected bit in carry
	0F,A3		BT r/m32,r32		-- Store selected bit in carry
	0F,BA/4,ib	BT r/m16,imm8		-- Store selected bit in carry
	0F,BA/4,ib	BT r/m32,imm8		-- Store selected bit in carry

	0F,BB		BTC r/m16,r16		-- Store selected bit in carry, and complement
	0F,BB		BTC r/m32,r32		-- Store selected bit in carry, and complement
	0F,BA/7,ib	BTC r/m16,imm8		-- Store selected bit in carry, and complement
	0F,BA/7,ib	BTC r/m32,imm8		-- Store selected bit in carry, and complement

	0F,B3		BTR r/m16,r16		-- Store selected bit in carry, and clear
	0F,B3		BTR r/m32,r32		-- Store selected bit in carry, and clear
	0F,BA/6,ib	BTR r/m16,imm8		-- Store selected bit in carry, and clear
	0F,BA/6,ib	BTR r/m32,imm8		-- Store selected bit in carry, and clear

	0F,AB		BTS r/m16,r16		-- Store selected bit in carry, and set
	0F,AB		BTS r/m32,r32		-- Store selected bit in carry, and set
	0F,BA/5,ib	BTS r/m16,imm8		-- Store selected bit in carry, and set
	0F,BA/5,ib	BTS r/m32,imm8		-- Store selected bit in carry, and set

	E8,imm16	CALL rel16			-- Call near, relative to start of next instruction
	E8,imm32	CALL rel32			-- Call near, relative to start of next instruction
	FF/2		CALL r16			-- Call near, absolute address in r16
	FF/2		CALL r32			-- Call near, absolute address in r32
	9A,imm32	CALL ptr16:16		-- Call far, absolute address in imm32
	9A,imm48	CALL ptr16:32		-- Call far, absolute address in imm48
	FF/3		CALL m16:16			-- Call far, absolute indirect address in m16:16
	FF/3		CALL m16:32			-- Call far, absolute indirect address in m16:32

	98			CBW					-- Sign-extend al to ax
	98			CWDE				-- Sign-extend ax to eax

	F8			CLC					-- Clear carry
	FC			CLD					-- Clear direction
	FA			CLI					-- Clear interrupt
	0F,06		CLTS				-- Clear task-switched flag in CR0

	0F,40+cc/r	CMOVcc r16,rm16		-- Move if cc flag condition is true
	0F,40+cc/r	CMOVcc r32,rm32		-- Move if cc flag condition is true
	
	3C,ib		CMP al,imm8			-- imm8  al
	3D,iw		CMP ax,imm16		-- imm16 to ax
	3D,id		CMP eax,imm32		-- imm32 to eax
	80/7,ib		CMP r/m8,imm8		-- imm8 to r/m8
	81/7,iw		CMP r/m16,imm16		-- imm16 to r/m16
	81/7,iw		CMP r/m32,imm32		-- imm32 to r/m32
	83/7,ib		CMP r/m16,imm8		-- sign-extended imm8 to r/m16
	83/7,ib		CMP r/m32,imm8		-- sign-extended imm8 to r/m32
	38/r		CMP r/m8,r8			-- r8 to r/m8
	39/r		CMP r/m16,r16		-- r16 to r/m16
	39/r		CMP r/m32,r32		-- r32 to r/m32
	3A/r		CMP r8,r/m8			-- r/m8 to r8
	3B/r		CMP r16,r/m16		-- r/m16 to r16
	3B/r		CMP r32,r/m32		-- r/m32 to r32

	A6			CMPSB				-- Compare byte in ds:[esi] to es:[edi]
	A7			CMPSW				-- Compare word in ds:[esi] to es:[edi]
	A7			CMPSD				-- Compare dword in ds:[esi] to es:[edi]

	0F,B0/r		CMPXCHG r/m8,r8		-- Compare al with r/m8, if equal set zero and load r8 into r/m8, if not equal clear zero and load r/m8 into al
	0F,B1/r		CMPXCHG r/m16,r16	-- Compare ax with r/m16, if equal set zero and load r16 into r/m16, if not equal clear zero and load r/m16 into ax
	0F,B1/r		CMPXCHG r/m32,r32	-- Compare eax with r/m16, if equal set zero and load r32 into r/m32, if not equal clear zero and load r/m32 into eax

	OF,C7/1		CMPXCHG8B m64		-- Compare edx:eax with m64, if equal set zero and load ECX:EBX into m64, if not equal clear zero and load m64 into edx:eax

	0F,A2		CPUID				-- Based on EAX, load processor information into registers

	99			CDW					-- Sign-extend ax into dx:ax
	99			CDQ					-- Sign-extend eax into edx:eax

	27			DAA					-- Decimal adjust al after addition
	2F			DAS					-- Decimal adjust al after subtraction

	FE/1		DEC r/m8			-- Decrement r/m8 by 1
	FF/1		DEC r/m16			-- Decrement r/m16 by 1
	FF/1		DEC r/m32			-- Decrement r/m32 by 1
	48+r		DEC r16				-- Decrement r16 by 1
	48+r		DEC r32				-- Decrement r32 by 1

	F6/7		DIV r/m8			-- Unsigned divide ax by r/m8, quotient in al, remainder in ah
	F7/6		DIV r/m16			-- Unsigned divide dx:ax by r/m16, quotient in ax, remainder in dx
	F7/6		DIV r/m32			-- Unsigned divide edx:eax by r/m32, quotient in eax, remainder in edx

	0F,77		EMMS				-- Empty the MMX state

	C8,iw,ib	ENTER imm16,imm8	-- Create a stack frame, or nested stack frame

	D9,F0		F2XM1				-- st0 = 2^(st0 - 1) into st0
	D9,E1		FABS				-- st0 = fabs(st0)
	D8/0		FADD f32			-- st0 = st0 + f32
	DC/0		FADD f64			-- st0 = st0 + f64
	D8,C0+r		FADD st0,stN		-- st0 = st0 + stN
	DC,C0+r		FADD stN,st0		-- stN = stN + st0
	DE,C0+r		FADDP stN,st0		-- stN = stN + st0, then pop
	DA/0		FIADD s32			-- st0 = st0 + s32
	DE/0		FIADD s16			-- st0 = st0 + s16
	DF/4		FBLD m80			-- push m80 loaded as binary coded decimal into st0
	DF/6		FBSTP m80			-- Store st0 as binary coded decimal into m80, then pop
	D9,E0		FCHS				-- Complement st0's sign
	9B,DB,E2	FCLEX				-- Clear floating point exceptions after checking for pending unmasked exceptions
	DB,E2		FNCLEX				-- No-wait version of FCLEX
	DA,C0+r		FCMOVB st0,stN		-- Move if carry
	DA,C8+r		FCMOVE st0,stN		-- Move if zero
	DA,D0+r		FCMOVBE st0,stN		-- Move if carry or zero
	DA,D8+r		FCMOVU st0,stN		-- Move if parity
	DB,C0+r		FCMOVNB st0,stN		-- Move if not carry
	DB,C8+r		FCMOVNE st0,stN		-- Move if not zero
	DB,D0+r		FCMOVNBE st0,stN	-- Move if not carry and not zero
	DB,D8+r		FCMOVNU st0,stN		-- Move if not parity
	D8/2		FCOM f32			-- Compare st0 with f32
	DC/2		FCOM f64			-- Compare st0 with f64
	D8,D0+r		FCOM stN			-- Compare st0 with stN
	D8/3		FCOMP f32			-- Compare st0 with f32, then pop
	DC/3		FCOMP f64			-- Compare st0 with f64, then pop
	D8,D8+r		FCOMP stN			-- Compare st0 with stN, then pop
	DE,D9		FCOMPP				-- Compare st0 with st1, then pop, then pop again
	DB,F0+r		FCOMI stN			-- Compare st0 with stN, and set eflags
	DF,F0+r		FCOMIP stN			-- Compare st0 with stN, and set eflags, then pop
	DB,E8+r		FUCOMI stN			-- Compare st0 with stN, check for ordered values, and set eflags
	DF,E8+r		FUCOMIP stN			-- Compare st0 with stN, check for ordered values, and set eflags, then pop
	D9,FF		FCOS				-- st0 = cos(st0)
	D9,F6		FDECSTP				-- Decrement the TOP field in the FPU status word
	D8/6		FDIV f32			-- st0 = st0 / f32
	DC/6		FDIV f64			-- st0 = st0 / f64
	D8,F0+r		FDIV stN			-- st0 = st0 / stN
	DC,F8+r		FDIV stN,st0		-- stN = stN / st0
	DE,F8+r		FDIVP stN,st0		-- stN = stN / st0, then pop
	DA/6		FIDIV s32			-- st0 = st0 / s32
	DE/6		FIDIV s16			-- st0 = st0 / s16
	D8/7		FDIVR f32			-- st0 = f32 / st0
	DC/7		FDIVR f64			-- st0 = f64 / st0
	D8,F8+r		FDIVR stN			-- st0 = stN / st0
	DC,F0+r		FDIVR stN,st0		-- stN = st0 / stN
	DE,F0+r		FDIVRP stN,st0		-- stN = st0 / stN, then pop
	DA/7		FIDIVR s32			-- st0 = s32 / st0
	DE/7		FIDIVR s16			-- st0 = s16 / st0
	DD,C0+r		FFREE stN			-- Set the tag for stN to empty
	DE/2		FICOM s16			-- Compare st0 to s16
	DA/2		FICOM s32			-- Compare st0 to s32
	DE/3		FICOMP s16			-- Compare st0 to s16, then pop
	DA/3		FICOMP s32			-- Compare st0 to s32, then pop
	DF/0		FILD s16			-- Push s16 into st0
	DB/0		FILD s32			-- Push s32 into st0
	DF/5		FILD s64			-- Push s64 into st0
	D9,F7		FINCSTP				-- Increment the TOP field in the FPU status word
	9B,DB,E3	FINIT				-- Initialize the FPU
	DF/2		FIST m16int			-- Store st0 to memory as s16
	DB/2		FIST m32int			-- Store st0 to memory as s32
	DF/3		FISTP m16int		-- Store st0 to memory as s16, then pop
	DB/3		FISTP m32int		-- Store st0 to memory as s32, then pop
	DF/7		FISTP m64int		-- Store st0 to memory as s64, then pop
	D9/0		FLD f32				-- Push f32 into st0
	DD/0		FLD f64				-- Push f64 into st0
	DB/5		FLD f80				-- Push f80 into st0
	D9,C0+r		FLD stN				-- Push stN into st0
	D9,E8		FLD1				-- Push +1.0 into st0
	D9,E9		FLDL2T				-- Push log2(10) into st0
	D9,EA		FLDL2E				-- Push log2(e) into st0
	D9,EB		FLDPI				-- Push pi into st0
	D9,EC		FLDLG2				-- Push log10(2) into st0
	D9,ED		FLDLN2				-- Push loge(2) into st0
	D9,EE		FLDZ				-- Push +0.0 into st0
	D9/5		FLDCW u16			-- Load u16 into FPU control word
	D9/4		FLDENV m14/m28		-- Load 14-byte or 28-byte into environment
	D8/1		FMUL f32			-- st0 = st0 * f32
	DC/1		FMUL f64			-- st0 = st0 * f64
	D8,C8+r		FMUL stN			-- st0 = st0 * stN
	DC,C8+r		FMUL stN,st0		-- stN = stN * st0
	DE,C8+r		FMULP stN,st0		-- stN = stN * st0, then pop
	DA/1		FIMUL m32int		-- st0 = st0 * s32
	DE/1		FIMUL m16int		-- st0 = st0 * s16
	D9,D0		FNOP				-- No operation
	D9,F3		FPATAN				-- st1 = arctan(st1 / st0), then pop
	D9,F8		FPREM				-- st0 = st0 % st1
	D9,F5		FPREM1				-- st0 = IEEE st0 % st1
	D9,F2		FPTAN				-- st0 = tan(st0), then push 1 into st0
	D9,FC		FRNDINT				-- st0 = int(st0)
	DD/4		FRSTOR m94/m108		-- Load FPU state from a 94 or 108 byte block
	9B,DD/6		FSAVE m94/m108		-- Store the FPU state to a 94 or 108 byte block
	D9,FD		FSCALE				-- st0 = 2^stN
	D9,FE		FSIN				-- st0 = sin(st0)
	D9,FB		FSINCOS				-- t = cos(st0), st0 = sin(st0), then push t into st0
	D9,FA		FSQRT				-- st0 = sqrt(st0)
	D9/2		FST f32				-- Copy st0 to f32
	DD/2		FST f64				-- Copy st0 to f64
	DD,D0+r		FST stN				-- Copy st0 to stN
	D9/3		FST f32				-- Copy st0 to f32, then pop
	DD/3		FST f64				-- Copy st0 to f64, then pop
	DB/7		FST f80				-- Copy st0 to f80, then pop
	DD,D8+r		FST stN				-- Copy st0 to stN, then pop
	9B,D9/7		FSTCW m16			-- Copy FPU status word to m16
	9B,D9/6		FSTENV m14/m28		-- Copy FPU environment to 14-byte or 28-byte block
	9B,DD/7		FSTSW m16			-- Copy FPU status word to m16
	9B,DF,E0	FSTSW ax			-- Copy FPU status word to ax
	D8/4		FSUB f32			-- st0 = st0 - f32
	DC/4		FSBU f64			-- st0 = st0 - f64
	D8,E0+r		FSUB stN			-- st0 = st0 - stN
	DC,E8+r		FSUB stN,st0		-- stN = stN - st0
	DE,E8+r		FSUBP stN,st0		-- stN = stN - st0, then pop
	DA/4		FISUB s32			-- st0 = st0 - s32
	DE/4		FISUB s16			-- st0 = st0 - s16
	D8/5		FUSBR f32			-- st0 = f32 - st0
	DC/5		FSUBR f64			-- st0 = f64 - st0
	D8,E8+r		FSUBR st0,stN		-- st0 = stN - st0
	DC,E0+r		FSUBR stN,st0		-- stN = st0 - stN
	DE,E0+r		FSUBRP stN,st0		-- stN = st0 - stN, then pop
	DA/5		FISUBR s32			-- st0 = s32 - st0
	DE/5		FISUBR s16			-- st0 = s16 - st0
	D9,E4		FTST				-- Compare st0 to +0.0
	DD,E0+r		FUCOM stN			-- Compare st0 to stN
	DD,E8+i		FUCOMP stN			-- Compare st0 to stN, then pop
	DA,E9		FUCOMPP				-- Compare st0 to st1, then pop
	D9,E5		FXAM				-- Classify st0
	D9,C8+r		FXCH stN			-- Exchange st0 and stN
	D9,F4		FXTRACT				-- t = st0's exponent, st0 = st0's significand, then push t into st0
	D9,F1		FYL2X				-- st1 = st1 * log2(st0), then pop
	D9,F9		FYL2XP1				-- st1 = st1 * log2(st0 + 1.0), then pop
	
	F4			HLT					-- Halt until interrupt

	F6/7		IDIV r/m8			-- Integer divide ax, al=quotient, ah=remainder
	F7/7		IDIV r/m16			-- Integer divide dx:ax, ax=quotient, dx=remainder
	F7/7		IDIV r/m32			-- Integer divide edx:eax, eax=quotient, edx=remainder

	F6/5		IMUL r/m8			-- ax = al * r/m8
	F7/5		IMUL r/m16			-- dx:ax = ax * r/m16
	F7/5		IMUL r/m16			-- edx:eax = eax * r/m32
	0F,AF/r		IMUL r16,r/m16		-- r16 = r16 * r/m16
	0F,AF/r		IMUL r32,r/m32		-- r32 = r32 * r/m32
	6B/r,ib		IMUL r16,r/m16,imm8	-- r16 = r16 * r/m16 * sign_extend(imm8)
	6B/r,ib		IMUL r32,r/m32,imm8	-- r32 = r32 * r/m32 * sign_extend(imm8)
	69/r,iw		IMUL r16,r/m16,imm16-- r16 = r16 * r/m16 * imm16
	69/r,id		IMUL r32,r/m32,imm32-- r32 = r32 * r/m32 * imm32

	E4,ib		IN al,imm8			-- Read byte from I/O port imm8
	E5,ib		IN ax,imm8			-- Read word from I/O port imm8
	E5,ib		IN eax,imm8			-- Read dword from I/O port imm8
	EC			IN al,dx			-- Read byte from I/o port in dx
	ED			IN ax,dx			-- Read word from I/o port in dx
	ED			IN eax,dx			-- Read dword from I/o port in dx

	FE/0		INC r/m8			-- Increment r/m8 by 1
	FF/0		INC r/m16			-- Increment r/m16 by 1
	FF/0		INC r/m32			-- Increment r/m32 by 1
	40+r		INC r16				-- Increment r16 by 1
	40+r		INC r32				-- Increment r32 by 1

	6C			INS m8,dx			-- Input a byte from I/O port in dx, store to es:[e/di]
	6D			INS m16,dx			-- Input a word from I/O port in dx, store to es:[e/di]
	6D			INS m32,dx			-- Input a dword from I/O port in dx, store to es:[e/di]
	6C			INSB				-- Shorthand for INS m8,dx
	6D			INSW				-- Shorthand for INS m16,dx
	6D			INSD				-- Shorthand for INS m32,dx

	CC			INT3				-- Trap to debugger, one byte
	CD,ib		INT imm8			-- Interrupt vector imm8
	CE			INTO				-- Interrupt on overflow

	0F,08		INVD				-- Invalidate internal caches
	0F,01/7		INVLPG m			-- Invalidate TLB entry for page that contains m

	CF			IRET				-- Interrupt return 16-bit
	CF			IRETD				-- Interrupt return 32-bit

	70+cc,ib	Jcc imm8			-- Conditional jump relative by imm8 offset
	0F,80+cc,iw	Jcc imm16			-- Conditional jump relative by imm16 offset
	0F,80+cc,id	Jcc imm32			-- Conditional jump relative by imm32 offset

	EB,ib		JMP imm8			-- Jump short, imm8 relative to start of next instruction
	E9,iw		JMP imm16			-- Jump near, imm16 relative to start of next instruction
	E9,id		JMP imm32			-- Jump near, imm32 relative to start of next instruction
	FF/4		JMP r/m16			-- Jump near absolute indirect, address in r/m16
	FF/4		JMP r/m32			-- Jump near absolute indirect, address in r/m32
	EA,u32		JMP ptr16:16		-- Jump far, absolute, ptr16:16 in instruction
	EA,u48		JMP ptr16:32		-- Jump far, absolute, ptr16:32 in instruction
	FF/5		JMP m16:16			-- Jump far, absolute indirect, address in m16:16
	FF/5		JMP m16:32			-- Jump far, absolute indirect, address in m16:32

	9F			LAHF				-- ah = eflags.sf:zf:0:af:0:pf:1:cf

	0F,02/r		LAR r16,r/m16		-- r16 = r/m16 &    0ff00h
	0F,02/r		LAR r32,r/m32		-- r32 = r/m32 & 00fxff00h

	C5/r		LDS r16,m16:16		-- Load DS:r16 indirect from far pointer
	C5/r		LDS r32,m16:32		-- Load DS:r32 indirect from far pointer
	0F,B2/r		LSS r16,m16:16		-- Load SS:r16 indirect from far pointer
	0F,B2/r		LSS r32,m16:32		-- Load SS:r32 indirect from far pointer
	C4/r		LES r16,m16:16		-- Load ES:r16 indirect from far pointer
	C4/r		LES r32,m16:32		-- Load ES:r32 indirect from far pointer
	0F,B4/r		LFS r16,m16:16		-- Load FS:r16 indirect from far pointer
	0F,B4/r		LFS r32,m16:32		-- Load FS:r32 indirect from far pointer
	0F,B5/r		LGS r16,m16:16		-- Load GS:r16 indirect from far pointer
	0F,B5/r		LGS r32,m16:32		-- Load GS:r32 indirect from far pointer

	8D/r		LEA r16,m			-- Store effective address for m in r16
	8D/r		LEA r32,m			-- Store effective address for m in r32

	C9			LEAVE				-- sp = bp, then pop bp
	C9			LEAVE				-- esp = ebp, then pop ebp

	0F,01/2		LGDT m16&32			-- Load m into GDTR
	0F,01/3		LIDT m16&32			-- Load m into IDTR
	0F,00/2		LLDT r/m16			-- Load selector into LDTR

	0F,01/6		LMSW r/m16			-- Loads r/m16 into bits cr0

	F0			LOCK				-- Prefix for other instructions, locks system bus

	AC			LODS m8				-- Load byte from ds:[e/si] into al
	AD			LODS m16			-- Load word from ds:[e/si] into ax
	AD			LODS m32			-- Load dword from ds:[e/si] into eax
	AC			LODSB				-- Shorthand for LODS m8
	AD			LODSW				-- Shorthand for LODS m16
	AD			LODSD				-- Shorthand for LODS m32

	E2,ib		LOOP imm8			-- Decrement count, jump short if count != 0
	E1,ib		LOOPE imm8			-- Decrement count, jump short if count != 0 and zero
	E1,ib		LOOPZ imm8			-- Synonym for LOOPE
	E0,ib		LOOPNE imm8			-- Decrement count, jump short if count != 0 and !zero
	E0,ib		LOOPNZ imm8			-- Synonym for LOOPNE

	0F,03/r		LSL r16,r/m16		-- r16 = segment_limit(r/m16)
	0F,03/r		LSL r32,r/m32		-- r32 = segment_limit(r/m32)

	0F,00/3		LTR r/m16			-- Load r/m16 into TR

	88/r		MOV r/m8,r8			-- Move r8 to r/m8
	89/r		MOV r/m16,r16		-- Move r16 to r/m16
	89/r		MOV r/m32,r32		-- Move r32 to r/m32
	8A/r		MOV r8,r/m8			-- Move r/m8 to r8
	8B/r		MOV r16,r/m16		-- Move r/m16 to r16
	8B/r		MOV r32,r/m32		-- Move r/m32 to r32
	8C/r		MOV r/m16,sreg		-- Move segment register to r/m16
	8E/r		MOV sreg,r/m16		-- Move r/m16 to segment register
	A0			MOV al,offset		-- Move byte at Seg:[offset] to al
	A1			MOV ax,offset		-- Move word at Seg:[offset] to ax
	A1			MOV eax,offset		-- Move dword at Seg:[offset] to eax
	A2			MOV offset,al		-- Move al to byte at Seg:[offset]
	A3			MOV offset,ax		-- Move ax to word at Seg:[offset]
	A3			MOV offset,eax		-- Move eax to dword at Seg:[offset]
	B0+r		MOV r8,imm8			-- Move imm8 to r8
	B8+r		MOV r16,imm16		-- Move imm16 to r16
	B8+r		MOV r32,imm32		-- Move imm32 to r32
	C6/0		MOV r/m8,imm8		-- Move imm8 to r/m8
	C7/0		MOV r/m16,imm16		-- Move imm16 to r/m16
	C7/0		MOV r/m32,imm32		-- Move imm32 to r/m32

	0F,22/r		MOV crN,r32			-- Move r32 to crN
	0F,20/r		MOV r32,crN			-- Move crN to r32

	0F,21/r		MOV r32,drN			-- Move drN to r32
	0F,23/r		MOV drN,r32			-- Move r32 to drN

	0F,63/r		MOV mmN,r/m32		-- Move r/m32 to mmN
	0F,7E/r		MOV r/m32,mmN		-- Move mmN to r/m32
	0F,6F/r		MOV mmN,mmN/m64		-- Move mmN/m64 to mmN
	0F,7F/r		MOV mm/m64,mmN		-- Move mmN to mmN/m64
	
	A4			MOVS m8,m8			-- Move byte from ds:[e/si] to es:[e/di]
	A5			MOVS m16,m16		-- Move word from ds:[e/si] to es:[e/di] 
	A5			MOVS m32,m32		-- Move dword from ds:[e/si] to es:[e/di] 
	A4			MOVSB				-- Shorthand for MOVS m8,m8
	A5			MOVSW				-- Shorthand for MOVS m16,m16
	A5			MOVSD				-- Shorthand for MOVS m32,m32

	0F,BE/r		MOVSX r16,r/m8		-- Sign-extend byte to word
	0F,BE/r		MOVSX r32,r/m8		-- Sign-extend byte to dword
	0F,BF/r		MOVSX r32,r/m16		-- Sign-extend word to dword

	0F,B6/r		MOVZX r16,r/m8		-- Zero-extend byte to word
	0F,B6/r		MOVZX r32,r/m8		-- Zero-extend byte to dword
	0F,B7/r		MOVZX r32,r/m16		-- Zero-extend word to dword

	F6/4		MUL r/m8			-- ax = al * r/m8
	F7/4		MUL r/m16			-- dx:ax = ax * r/m16
	F7/4		MUL r/m32			-- edx:eax = eax * r/m32

	F6/3		NEG r/m8			-- Two's complement r/m8
	F7/3		NEG r/m16			-- Two's complement r/m16
	F7/3		NEG r/m32			-- Two's complement r/m32

	90			NOP					-- No operation

	F6/2		NOT r/m8			-- Logical NOT of r/m8
	F7/2		NOT r/m16			-- Logical NOT of r/m16
	F7/2		NOT r/m32			-- Logical NOT of r/m32

	0C,ib		OR al,imm8			-- imm8 to al
	0D,iw		OR AX,imm16			-- imm16 to ax
	0D,id		OR EAX,imm32		-- imm32 to eax
	80/1,ib		OR r/m8,imm8		-- imm8 to r/m8
	81/1,iw		OR r/m16,imm16		-- imm16 to r/m16
	81/1,iw		OR r/m32,imm32		-- imm32 to r/m32
	83/1,ib		OR r/m16,imm8		-- sign-extended imm8 to r/m16
	83/1,ib		OR r/m32,imm8		-- sign-extended imm8 to r/m32
	08/r		OR r/m8,r8			-- r8 to r/m8
	09/r		OR r/m16,r16		-- r16 to r/m16
	09/r		OR r/m32,r32		-- r32 to r/m32
	0A/r		OR r8,r/m8			-- r/m8 to r8
	0B/r		OR r16,r/m16		-- r/m16 to r16
	0B/r		OR r32,r/m32		-- r/m32 to r32

	E6,ib		OUT imm8,al			-- Output al to I/O port imm8
	E7,ib		OUT imm8,ax			-- Output ax to I/O port imm8
	E7,ib		OUT imm8,eax		-- Output eax to I/O port imm8
	EE			OUT dx,al			-- Output al to I/O port dx
	EF			OUT dx,ax			-- Output ax to I/O port dx
	EF			OUT dx,eax			-- Output eax to I/O port dx

	6E			OUTS dx,m8			-- Output byte at ds:[e/si] to I/O port dx
	6F			OUTS dx,m16			-- Output word at ds:[e/si] to I/O port dx
	6F			OUTS dx,m32			-- Output dword at ds:[e/si] to I/O port dx
	6E			OUTSB				-- Shorthand for OUTS dx,m8
	6F			OUTSW				-- Shorthand for OUTS dx,m16
	6F			OUTSD				-- Shorthand for OUTS dx,m32

	8F/0		POP m16				-- Pop stack into m16
	8F/0		POP m32				-- Pop stack into m32
	58+r		POP r16				-- Pop stack into r32
	58+r		POP r32				-- Pop stack into r32
	1F			POP DS				-- Pop stack into DS
	07			POP ES				-- Pop stack into ES
	17			POP SS				-- Pop stack into SS
	0F,A1		POP FS				-- Pop stack into FS
	0F,A9		POP GS				-- Pop stack into GS

	61			POPA				-- Pop all r16 registers
	61			POPAD				-- Pop all r32 registers

	9D			POPF				-- Pop 16-bit flags
	9D			POPFD				-- Pop 32-bit eflags

	0F,18/1		PREFETCHT0 m8		-- Prefetch block around m8 into all caches
	0F,18/1		PREFETCHT1 m8		-- Prefetch block around m8 into l1 and above
	0F,18/1		PREFETCHT2 m8		-- Prefetch block around m8 into l2 and above
	0F,18/1		PREFETCHNTA m8		-- Prefetch block around m8 into non-temporal caches

	FF/6		PUSH r/m16			-- Push r/m16
	FF/6		PUSH r/m32			-- Push r/m32
	50+R		PUSH r16			-- Push r16
	50+R		PUSH r32			-- Push r32
	6A,ib		PUSH imm8			-- Push imm8
	68,iw		PUSH imm16			-- Push imm16
	68,id		PUSH imm32			-- Push imm32
	0E			PUSH cs				-- Push CS
	16			PUSH ss				-- Push SS
	1E			PUSH ds				-- Push DS
	06			PUSH es				-- Push ES
	0F,A0		PUSH fs				-- Push FS
	0F,A8		PUSH gs				-- Push GS

	60			PUSHA				-- Push all 16-bit registers
	60			PUSHAD				-- Push all 32-bit registers

	9C			PUSHF				-- Push 16-bit flags
	9C			PUSHFD				-- Push 32-bit eflags

	D0/2		RCL r/m8			-- Rotate r/m8 through carry by one bit left
	D2/2		RCL r/m8,cl			-- Rotate r/m8 through carry by cl bits left
	C0/2,ib		RCL r/m8,imm8		-- Rotate r/m8 through carry by imm8 bits left
	D1/2		RCL r/m16			-- Rotate r/m16 through carry by one bit left
	D3/2		RCL r/m16,cl		-- Rotate r/m16 through carry by cl bits left
	C1/2,ib		RCL r/m16,imm8		-- Rotate r/m16 through carry by imm8 bits left
	D1/2		RCL r/m32			-- Rotate r/m32 through carry by one bit left
	D3/2		RCL r/m32,cl		-- Rotate r/m32 through carry by cl bits left
	C1/2,ib		RCL r/m32,imm8		-- Rotate r/m32 through carry by imm8 bits left

	D0/3		RCR r/m8			-- Rotate r/m8 through carry by one bit right
	D2/3		RCR r/m8,cl			-- Rotate r/m8 through carry by cl bits right
	C0/3,ib		RCR r/m8,imm8		-- Rotate r/m8 through carry by imm8 bits right
	D1/3		RCR r/m16			-- Rotate r/m16 through carry by one bit right
	D3/3		RCR r/m16,cl		-- Rotate r/m16 through carry by cl bits right
	C1/3,ib		RCR r/m16,imm8		-- Rotate r/m16 through carry by imm8 bits right
	D1/3		RCR r/m32			-- Rotate r/m32 through carry by one bit right
	D3/3		RCR r/m32,cl		-- Rotate r/m32 through carry by cl bits right
	C1/3,ib		RCR r/m32,imm8		-- Rotate r/m32 through carry by imm8 bits right

	D0/0		ROL r/m8			-- Rotate r/m8 by one bit left
	D2/0		ROL r/m8,cl			-- Rotate r/m8 by cl bits left
	C0/0,ib		ROL r/m8,imm8		-- Rotate r/m8 by imm8 bits left
	D1/0		ROL r/m16			-- Rotate r/m16 by one bit left
	D3/0		ROC r/m16,cl		-- Rotate r/m16 by cl bits left
	C1/0,ib		ROL r/m16,imm8		-- Rotate r/m16 by imm8 bits left
	D1/0		ROL r/m32			-- Rotate r/m32 by one bit left
	D3/0		ROL r/m32,cl		-- Rotate r/m32 by cl bits left
	C1/0,ib		ROL r/m32,imm8		-- Rotate r/m32 by imm8 bits left

	D0/1		ROR r/m8			-- Rotate r/m8 by one bit right
	D2/1		ROR r/m8,cl			-- Rotate r/m8 by cl bits right
	C0/1,ib		ROR r/m8,imm8		-- Rotate r/m8 by imm8 bits right
	D1/1		ROR r/m16			-- Rotate r/m16 by one bit right
	D3/1		ROR r/m16,cl		-- Rotate r/m16 by cl bits right
	C1/1,ib		ROR r/m16,imm8		-- Rotate r/m16 by imm8 bits right
	D1/1		ROR r/m32			-- Rotate r/m32 by one bit right
	D3/1		ROR r/m32,cl		-- Rotate r/m32 by cl bits right
	C1/1,ib		ROR r/m32,imm8		-- Rotate r/m32 by imm8 bits right

	0F,32		RDMSR				-- Load MSR specified by ecx into edx:eax
	0F,33		RDPMC				-- Read performance monitoring counter specified by ecx into edx:eax
	0F,31		RDTSC				-- Read time-stamp counter into edx:eax

	C3			RET					-- Near return
	CB			RET					-- Far return
	C2,iw		RET imm16			-- Near return, and pop imm16 bytes from stack
	CA,iw		RET imm16			-- Far return, and pop imm16 bytes from stack

	9E			SAHF				-- Store ah into flags

	D0/3		SAR r/m8			-- Signed divide r/m8 by two once
	D2/3		SAR r/m8,cl			-- Signed divide r/m8 by two cl times
	C0/3,ib		SAR r/m8,imm8		-- Signed divide r/m8 by imm8 times
	D1/3		SAR r/m16			-- Signed divide r/m16 by two once
	D3/3		SAR r/m16,cl		-- Signed divide r/m16 by two cl times
	C1/3,ib		SAR r/m16,imm8		-- Signed divide r/m16 by imm8 times
	D1/3		SAR r/m32			-- Signed divide r/m32 by two once
	D3/3		SAR r/m32,cl		-- Signed divide r/m32 by two cl times
	C1/3,ib		SAR r/m32,imm8		-- Signed divide r/m32 by imm8 times

	D0/0		SHL r/m8			-- Shift left r/m8 once
	D2/0		SHL r/m8,cl			-- Shift left r/m8 cl times
	C0/0,ib		SHL r/m8,imm8		-- Shift left r/m8 imm8 times
	D1/0		SHL r/m16			-- Shift left r/m16 once
	D3/0		SHC r/m16,cl		-- Shift left r/m16 cl times
	C1/0,ib		SHL r/m16,imm8		-- Shift left r/m16 imm8 times
	D1/0		SHL r/m32			-- Shift left r/m32 once
	D3/0		SHL r/m32,cl		-- Shift left r/m32 cl times
	C1/0,ib		SHL r/m32,imm8		-- Shift left r/m32 imm8 times

	D0/1		SHR r/m8			-- Shift right r/m8 once
	D2/1		SHR r/m8,cl			-- Shift right r/m8 cl times
	C0/1,ib		SHR r/m8,imm8		-- Shift right r/m8 imm8 times
	D1/1		SHR r/m16			-- Shift right r/m16 once
	D3/1		SHR r/m16,cl		-- Shift right r/m16 cl times
	C1/1,ib		SHR r/m16,imm8		-- Shift right r/m16 imm8 times
	D1/1		SHR r/m32			-- Shift right r/m32 once
	D3/1		SHR r/m32,cl		-- Shift right r/m32 cl times
	C1/1,ib		SHR r/m32,imm8		-- Shift right r/m32 imm8 times

	1C,ib		SBB al,imm8			-- imm8 from al
	1D,iw		SBB AX,imm16		-- imm16 from ax
	1D,id		SBB EAX,imm32		-- imm32 from eax
	80/3,ib		SBB r/m8,imm8		-- imm8 from r/m8
	81/3,iw		SBB r/m16,imm16		-- imm16 from r/m16
	81/3,iw		SBB r/m32,imm32		-- imm32 from r/m32
	83/3,ib		SBB r/m16,imm8		-- sign-extended imm8 from r/m16
	83/3,ib		SBB r/m32,imm8		-- sign-extended imm8 from r/m32
	18/r		SBB r/m8,r8			-- r8 from r/m8
	19/r		SBB r/m16,r16		-- r16 from r/m16
	19/r		SBB r/m32,r32		-- r32 from r/m32
	1A/r		SBB r8,r/m8			-- r/m8 from r8
	1B/r		SBB r16,r/m16		-- r/m16 from r16
	1B/r		SBB r32,r/m32		-- r/m32 from r32

	AE			SCAS m8				-- Compare al with byte in es:[e/di]
	AF			SCAS m16			-- Compare ax with word in es:[e/di]
	AF			SCAS m32			-- Compare eax with dword in es:[e/di]
	AE			SCASB				-- Shorthand for SCAS m8
	AF			SCASW				-- Shorthand for SCAS m16
	AF			SCASD				-- Shorthand for SCAS m32

	0F,90+cc	SETcc r/m8			-- Set byte if cc condition is met

	0F,01/0		SGDT m48			-- Store GDTR to m48
	0F,01/1		SIDT m48			-- Store IDTR to m48
	0F,00/0		SLDT r/m16			-- Store LDTR to r/m16
	0F,00/0		SLDT r/m32			-- Store LDTR to r/m32

	0F,A4		SHLD r/m16,r16,imm8	-- Shift r/m16 left imm8 places, shifting in bits from r16
	0F,A5		SHLD r/m16,r16,cl	-- Shift r/m16 left cl places, shiting in bits from r16
	0F,A4		SHLD r/m32,r32,imm8	-- Shift r/m32 left imm8 places, shifting in bits from r32
	0F,A5		SHLD r/m32,r32,cl	-- Shift r/m32 left cl places, shiting in bits from r32

	0F,AC		SHRD r/m16,r16,imm8	-- Shift r/m16 right imm8 places, shifting in bits from r16
	0F,AD		SHRD r/m16,r16,cl	-- Shift r/m16 right cl places, shiting in bits from r16
	0F,AC		SHRD r/m32,r32,imm8	-- Shift r/m32 right imm8 places, shifting in bits from r32
	0F,AD		SHRD r/m32,r32,cl	-- Shift r/m32 right cl places, shiting in bits from r32

	0F,01/4		SMSW r/m16			-- Store machine status word to r/m16
	0F,01/4		SMSW r32/m16		-- Store machine status word to r32/m16

	F9			STC					-- Set carry
	FD			STD					-- Set direction
	FB			STI					-- Set interrupt

	AA			STOS m8				-- Store al into es:[e/di]
	AB			STOS m16			-- Store ax into es:[e/di]
	AB			STOS m32			-- Store eax into es:[e/di]
	AA			STOSB				-- Shorthand for STOS m8
	AB			STOSW				-- Shorthand for STOS m16
	AB			STOSD				-- Shorthand for STOS m32

	0F,00/1		STR r/m16			-- Stores segment selector from TR in r/m16

	2C,ib		SUB al,imm8			-- imm8 from al
	2D,iw		SUB AX,imm16		-- imm16 from ax
	2D,id		SUB EAX,imm32		-- imm32 from eax
	80/5,ib		SUB r/m8,imm8		-- imm8 from r/m8
	81/5,iw		SUB r/m16,imm16		-- imm16 from r/m16
	81/5,iw		SUB r/m32,imm32		-- imm32 from r/m32
	83/5,ib		SUB r/m16,imm8		-- sign-extended imm8 from r/m16
	83/5,ib		SUB r/m32,imm8		-- sign-extended imm8 from r/m32
	28/r		SUB r/m8,r8			-- r8 from r/m8
	29/r		SUB r/m16,r16		-- r16 from r/m16
	29/r		SUB r/m32,r32		-- r32 from r/m32
	2A/r		SUB r8,r/m8			-- r/m8 from r8
	2B/r		SUB r16,r/m16		-- r/m16 from r16
	2B/r		SUB r32,r/m32		-- r/m32 from r32

	0F,34		SYSENTER			-- Fast system entry
	0F,35		SYSEXIT				-- Fast system exit

	A8,ib		TEST al,imm8		-- imm8 and al
	A9,iw		TEST AX,imm16		-- imm16 and ax
	A9,id		TEST EAX,imm32		-- imm32 and eax
	F6/0,ib		TEST r/m8,imm8		-- imm8 and r/m8
	F7/0,iw		TEST r/m16,imm16	-- imm16 and r/m16
	F7/0,iw		TEST r/m32,imm32	-- imm32 and r/m32
	84/r		TEST r/m8,r8		-- r8 and r/m8
	85/r		TEST r/m16,r16		-- r16 and r/m16
	85/r		TEST r/m32,r32		-- r32 and r/m32

	0F,0B		UD2					-- Raises invalid opcode exception

	0F,00/4		VERR r/m16			-- Verify segment r/m16 can be read
	0F,00/5		VERW r/m16			-- Verify segment r/m16 can be written to

	9B			FWAIT				-- Check pending unmasked floating-point exceptions

	0F,09		WBINVD				-- Write back and flush internal caches

	0F,30		WRMSR				-- Write the value in edx:eax to MSR specified by ecx

	0F,C0/r		XADD r/m8,r8		-- Exchange r8 and r/m8, and load sum into r/m8
	0F,C1/r		XADD r/m16,r16		-- Exchange r16 and r/m16, and load sum into r/m16
	0F,C1/r		XADD r/m32,r32		-- Exchange r32 and r/m32, and load sum into r/m32

	90+r		XCHG ax,r16			-- Exchange r16 and ax
	90+r		XCHG eax,r32		-- Exchange r32 and eax
	86/r		XCHG r/m8,r8		-- Exchange r8 and r/m8
	87/r		XCHG r/m16,r16		-- Exchange r16 and r/m16
	87/r		XCHG r/m32,r32		-- Exchange r32 and r/m32

	D7			XLAT m8				-- Set al to ds:[e/bx + al]
	D7			XLATB				-- Shorthand for XLAT m8

	34,ib		XOR al,imm8			-- imm8 and al
	35,iw		XOR AX,imm16		-- imm16 and ax
	35,id		XOR EAX,imm32		-- imm32 and eax
	80/6,ib		XOR r/m8,imm8		-- imm8 and r/m8
	81/6,iw		XOR r/m16,imm16		-- imm16 and r/m16
	81/6,iw		XOR r/m32,imm32		-- imm32 and r/m32
	83/6,ib		XOR r/m16,imm8		-- sign-extended imm8 and r/m16
	83/6,ib		XOR r/m32,imm8		-- sign-extended imm8 and r/m32
	30/r		XOR r/m8,r8			-- r8 and r/m8
	31/r		XOR r/m16,r16		-- r16 and r/m16
	31/r		XOR r/m32,r32		-- r32 and r/m32
	32/r		XOR r8,r/m8			-- r/m8 and r8
	33/r		XOR r16,r/m16		-- r/m16 and r16
	33/r		XOR r32,r/m32		-- r/m32 and r32

